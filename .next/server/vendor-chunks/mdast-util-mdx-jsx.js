"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mdast-util-mdx-jsx";
exports.ids = ["vendor-chunks/mdast-util-mdx-jsx"];
exports.modules = {

/***/ "(ssr)/./node_modules/mdast-util-mdx-jsx/lib/index.js":
/*!******************************************************!*\
  !*** ./node_modules/mdast-util-mdx-jsx/lib/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mdxJsxFromMarkdown: () => (/* binding */ mdxJsxFromMarkdown),\n/* harmony export */   mdxJsxToMarkdown: () => (/* binding */ mdxJsxToMarkdown)\n/* harmony export */ });\n/* harmony import */ var ccount__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ccount */ \"(ssr)/./node_modules/ccount/index.js\");\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! devlop */ \"(ssr)/./node_modules/devlop/lib/development.js\");\n/* harmony import */ var parse_entities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! parse-entities */ \"(ssr)/./node_modules/parse-entities/lib/index.js\");\n/* harmony import */ var stringify_entities__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! stringify-entities */ \"(ssr)/./node_modules/stringify-entities/lib/index.js\");\n/* harmony import */ var unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! unist-util-stringify-position */ \"(ssr)/./node_modules/unist-util-stringify-position/lib/index.js\");\n/* harmony import */ var vfile_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vfile-message */ \"(ssr)/./node_modules/vfile-message/lib/index.js\");\n/**\n * @import {CompileContext, Extension as FromMarkdownExtension, Handle as FromMarkdownHandle, OnEnterError, OnExitError, Token} from 'mdast-util-from-markdown'\n * @import {Handle as ToMarkdownHandle, Options as ToMarkdownExtension, State, Tracker} from 'mdast-util-to-markdown'\n * @import {Point} from 'unist'\n * @import {MdxJsxAttribute, MdxJsxAttributeValueExpression, MdxJsxExpressionAttribute, MdxJsxFlowElement, MdxJsxTextElement} from '../index.js'\n */ /**\n * @typedef Tag\n *   Single tag.\n * @property {string | undefined} name\n *   Name of tag, or `undefined` for fragment.\n *\n *   > ðŸ‘‰ **Note**: `null` is used in the AST for fragments, as it serializes in\n *   > JSON.\n * @property {Array<MdxJsxAttribute | MdxJsxExpressionAttribute>} attributes\n *   Attributes.\n * @property {boolean} close\n *   Whether the tag is closing (`</x>`).\n * @property {boolean} selfClosing\n *   Whether the tag is self-closing (`<x/>`).\n * @property {Token['start']} start\n *   Start point.\n * @property {Token['start']} end\n *   End point.\n *\n * @typedef ToMarkdownOptions\n *   Configuration.\n * @property {'\"' | \"'\" | null | undefined} [quote='\"']\n *   Preferred quote to use around attribute values (default: `'\"'`).\n * @property {boolean | null | undefined} [quoteSmart=false]\n *   Use the other quote if that results in less bytes (default: `false`).\n * @property {boolean | null | undefined} [tightSelfClosing=false]\n *   Do not use an extra space when closing self-closing elements: `<img/>`\n *   instead of `<img />` (default: `false`).\n * @property {number | null | undefined} [printWidth=Infinity]\n *   Try and wrap syntax at this width (default: `Infinity`).\n *\n *   When set to a finite number (say, `80`), the formatter will print\n *   attributes on separate lines when a tag doesnâ€™t fit on one line.\n *   The normal behavior is to print attributes with spaces between them\n *   instead of line endings.\n */ \n\n\n\n\n\nconst indent = \"  \";\n/**\n * Create an extension for `mdast-util-from-markdown` to enable MDX JSX.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown` to enable MDX JSX.\n *\n *   When using the syntax extension with `addResult`, nodes will have a\n *   `data.estree` field set to an ESTree `Program` node.\n */ function mdxJsxFromMarkdown() {\n    return {\n        canContainEols: [\n            \"mdxJsxTextElement\"\n        ],\n        enter: {\n            mdxJsxFlowTag: enterMdxJsxTag,\n            mdxJsxFlowTagClosingMarker: enterMdxJsxTagClosingMarker,\n            mdxJsxFlowTagAttribute: enterMdxJsxTagAttribute,\n            mdxJsxFlowTagExpressionAttribute: enterMdxJsxTagExpressionAttribute,\n            mdxJsxFlowTagAttributeValueLiteral: buffer,\n            mdxJsxFlowTagAttributeValueExpression: buffer,\n            mdxJsxFlowTagSelfClosingMarker: enterMdxJsxTagSelfClosingMarker,\n            mdxJsxTextTag: enterMdxJsxTag,\n            mdxJsxTextTagClosingMarker: enterMdxJsxTagClosingMarker,\n            mdxJsxTextTagAttribute: enterMdxJsxTagAttribute,\n            mdxJsxTextTagExpressionAttribute: enterMdxJsxTagExpressionAttribute,\n            mdxJsxTextTagAttributeValueLiteral: buffer,\n            mdxJsxTextTagAttributeValueExpression: buffer,\n            mdxJsxTextTagSelfClosingMarker: enterMdxJsxTagSelfClosingMarker\n        },\n        exit: {\n            mdxJsxFlowTagClosingMarker: exitMdxJsxTagClosingMarker,\n            mdxJsxFlowTagNamePrimary: exitMdxJsxTagNamePrimary,\n            mdxJsxFlowTagNameMember: exitMdxJsxTagNameMember,\n            mdxJsxFlowTagNameLocal: exitMdxJsxTagNameLocal,\n            mdxJsxFlowTagExpressionAttribute: exitMdxJsxTagExpressionAttribute,\n            mdxJsxFlowTagExpressionAttributeValue: data,\n            mdxJsxFlowTagAttributeNamePrimary: exitMdxJsxTagAttributeNamePrimary,\n            mdxJsxFlowTagAttributeNameLocal: exitMdxJsxTagAttributeNameLocal,\n            mdxJsxFlowTagAttributeValueLiteral: exitMdxJsxTagAttributeValueLiteral,\n            mdxJsxFlowTagAttributeValueLiteralValue: data,\n            mdxJsxFlowTagAttributeValueExpression: exitMdxJsxTagAttributeValueExpression,\n            mdxJsxFlowTagAttributeValueExpressionValue: data,\n            mdxJsxFlowTagSelfClosingMarker: exitMdxJsxTagSelfClosingMarker,\n            mdxJsxFlowTag: exitMdxJsxTag,\n            mdxJsxTextTagClosingMarker: exitMdxJsxTagClosingMarker,\n            mdxJsxTextTagNamePrimary: exitMdxJsxTagNamePrimary,\n            mdxJsxTextTagNameMember: exitMdxJsxTagNameMember,\n            mdxJsxTextTagNameLocal: exitMdxJsxTagNameLocal,\n            mdxJsxTextTagExpressionAttribute: exitMdxJsxTagExpressionAttribute,\n            mdxJsxTextTagExpressionAttributeValue: data,\n            mdxJsxTextTagAttributeNamePrimary: exitMdxJsxTagAttributeNamePrimary,\n            mdxJsxTextTagAttributeNameLocal: exitMdxJsxTagAttributeNameLocal,\n            mdxJsxTextTagAttributeValueLiteral: exitMdxJsxTagAttributeValueLiteral,\n            mdxJsxTextTagAttributeValueLiteralValue: data,\n            mdxJsxTextTagAttributeValueExpression: exitMdxJsxTagAttributeValueExpression,\n            mdxJsxTextTagAttributeValueExpressionValue: data,\n            mdxJsxTextTagSelfClosingMarker: exitMdxJsxTagSelfClosingMarker,\n            mdxJsxTextTag: exitMdxJsxTag\n        }\n    };\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function buffer() {\n        this.buffer();\n    }\n    /**\n   * Copy a point-like value.\n   *\n   * @param {Point} d\n   *   Point-like value.\n   * @returns {Point}\n   *   unist point.\n   */ function point(d) {\n        return {\n            line: d.line,\n            column: d.column,\n            offset: d.offset\n        };\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function data(token) {\n        this.config.enter.data.call(this, token);\n        this.config.exit.data.call(this, token);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function enterMdxJsxTag(token) {\n        /** @type {Tag} */ const tag = {\n            name: undefined,\n            attributes: [],\n            close: false,\n            selfClosing: false,\n            start: token.start,\n            end: token.end\n        };\n        if (!this.data.mdxJsxTagStack) this.data.mdxJsxTagStack = [];\n        this.data.mdxJsxTag = tag;\n        this.buffer();\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function enterMdxJsxTagClosingMarker(token) {\n        const stack = this.data.mdxJsxTagStack;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(stack, \"expected `mdxJsxTagStack`\");\n        if (stack.length === 0) {\n            throw new vfile_message__WEBPACK_IMPORTED_MODULE_1__.VFileMessage(\"Unexpected closing slash `/` in tag, expected an open tag first\", {\n                start: token.start,\n                end: token.end\n            }, \"mdast-util-mdx-jsx:unexpected-closing-slash\");\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function enterMdxJsxTagAnyAttribute(token) {\n        const tag = this.data.mdxJsxTag;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, \"expected `mdxJsxTag`\");\n        if (tag.close) {\n            throw new vfile_message__WEBPACK_IMPORTED_MODULE_1__.VFileMessage(\"Unexpected attribute in closing tag, expected the end of the tag\", {\n                start: token.start,\n                end: token.end\n            }, \"mdast-util-mdx-jsx:unexpected-attribute\");\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function enterMdxJsxTagSelfClosingMarker(token) {\n        const tag = this.data.mdxJsxTag;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, \"expected `mdxJsxTag`\");\n        if (tag.close) {\n            throw new vfile_message__WEBPACK_IMPORTED_MODULE_1__.VFileMessage(\"Unexpected self-closing slash `/` in closing tag, expected the end of the tag\", {\n                start: token.start,\n                end: token.end\n            }, \"mdast-util-mdx-jsx:unexpected-self-closing-slash\");\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function exitMdxJsxTagClosingMarker() {\n        const tag = this.data.mdxJsxTag;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, \"expected `mdxJsxTag`\");\n        tag.close = true;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function exitMdxJsxTagNamePrimary(token) {\n        const tag = this.data.mdxJsxTag;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, \"expected `mdxJsxTag`\");\n        tag.name = this.sliceSerialize(token);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function exitMdxJsxTagNameMember(token) {\n        const tag = this.data.mdxJsxTag;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, \"expected `mdxJsxTag`\");\n        tag.name += \".\" + this.sliceSerialize(token);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function exitMdxJsxTagNameLocal(token) {\n        const tag = this.data.mdxJsxTag;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, \"expected `mdxJsxTag`\");\n        tag.name += \":\" + this.sliceSerialize(token);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function enterMdxJsxTagAttribute(token) {\n        const tag = this.data.mdxJsxTag;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, \"expected `mdxJsxTag`\");\n        enterMdxJsxTagAnyAttribute.call(this, token);\n        tag.attributes.push({\n            type: \"mdxJsxAttribute\",\n            name: \"\",\n            value: null,\n            position: {\n                start: point(token.start),\n                // @ts-expect-error: `end` will be patched later.\n                end: undefined\n            }\n        });\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function enterMdxJsxTagExpressionAttribute(token) {\n        const tag = this.data.mdxJsxTag;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, \"expected `mdxJsxTag`\");\n        enterMdxJsxTagAnyAttribute.call(this, token);\n        tag.attributes.push({\n            type: \"mdxJsxExpressionAttribute\",\n            value: \"\",\n            position: {\n                start: point(token.start),\n                // @ts-expect-error: `end` will be patched later.\n                end: undefined\n            }\n        });\n        this.buffer();\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function exitMdxJsxTagExpressionAttribute(token) {\n        const tag = this.data.mdxJsxTag;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, \"expected `mdxJsxTag`\");\n        const tail = tag.attributes[tag.attributes.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tail.type === \"mdxJsxExpressionAttribute\");\n        const estree = token.estree;\n        tail.value = this.resume();\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tail.position !== undefined);\n        tail.position.end = point(token.end);\n        if (estree) {\n            tail.data = {\n                estree\n            };\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function exitMdxJsxTagAttributeNamePrimary(token) {\n        const tag = this.data.mdxJsxTag;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, \"expected `mdxJsxTag`\");\n        const node = tag.attributes[tag.attributes.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"mdxJsxAttribute\");\n        node.name = this.sliceSerialize(token);\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(node.position !== undefined);\n        node.position.end = point(token.end);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function exitMdxJsxTagAttributeNameLocal(token) {\n        const tag = this.data.mdxJsxTag;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, \"expected `mdxJsxTag`\");\n        const node = tag.attributes[tag.attributes.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"mdxJsxAttribute\");\n        node.name += \":\" + this.sliceSerialize(token);\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(node.position !== undefined);\n        node.position.end = point(token.end);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function exitMdxJsxTagAttributeValueLiteral(token) {\n        const tag = this.data.mdxJsxTag;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, \"expected `mdxJsxTag`\");\n        const node = tag.attributes[tag.attributes.length - 1];\n        node.value = (0,parse_entities__WEBPACK_IMPORTED_MODULE_2__.parseEntities)(this.resume(), {\n            nonTerminated: false\n        });\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(node.position !== undefined);\n        node.position.end = point(token.end);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function exitMdxJsxTagAttributeValueExpression(token) {\n        const tag = this.data.mdxJsxTag;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, \"expected `mdxJsxTag`\");\n        const tail = tag.attributes[tag.attributes.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tail.type === \"mdxJsxAttribute\");\n        /** @type {MdxJsxAttributeValueExpression} */ const node = {\n            type: \"mdxJsxAttributeValueExpression\",\n            value: this.resume()\n        };\n        const estree = token.estree;\n        if (estree) {\n            node.data = {\n                estree\n            };\n        }\n        tail.value = node;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tail.position !== undefined);\n        tail.position.end = point(token.end);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function exitMdxJsxTagSelfClosingMarker() {\n        const tag = this.data.mdxJsxTag;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, \"expected `mdxJsxTag`\");\n        tag.selfClosing = true;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function exitMdxJsxTag(token) {\n        const tag = this.data.mdxJsxTag;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, \"expected `mdxJsxTag`\");\n        const stack = this.data.mdxJsxTagStack;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(stack, \"expected `mdxJsxTagStack`\");\n        const tail = stack[stack.length - 1];\n        if (tag.close && tail.name !== tag.name) {\n            throw new vfile_message__WEBPACK_IMPORTED_MODULE_1__.VFileMessage(\"Unexpected closing tag `\" + serializeAbbreviatedTag(tag) + \"`, expected corresponding closing tag for `\" + serializeAbbreviatedTag(tail) + \"` (\" + (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_3__.stringifyPosition)(tail) + \")\", {\n                start: token.start,\n                end: token.end\n            }, \"mdast-util-mdx-jsx:end-tag-mismatch\");\n        }\n        // End of a tag, so drop the buffer.\n        this.resume();\n        if (tag.close) {\n            stack.pop();\n        } else {\n            this.enter({\n                type: token.type === \"mdxJsxTextTag\" ? \"mdxJsxTextElement\" : \"mdxJsxFlowElement\",\n                name: tag.name || null,\n                attributes: tag.attributes,\n                children: []\n            }, token, onErrorRightIsTag);\n        }\n        if (tag.selfClosing || tag.close) {\n            this.exit(token, onErrorLeftIsTag);\n        } else {\n            stack.push(tag);\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {OnEnterError}\n   */ function onErrorRightIsTag(closing, open) {\n        const stack = this.data.mdxJsxTagStack;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(stack, \"expected `mdxJsxTagStack`\");\n        const tag = stack[stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, \"expected `mdxJsxTag`\");\n        const place = closing ? \" before the end of `\" + closing.type + \"`\" : \"\";\n        const position = closing ? {\n            start: closing.start,\n            end: closing.end\n        } : undefined;\n        throw new vfile_message__WEBPACK_IMPORTED_MODULE_1__.VFileMessage(\"Expected a closing tag for `\" + serializeAbbreviatedTag(tag) + \"` (\" + (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_3__.stringifyPosition)({\n            start: open.start,\n            end: open.end\n        }) + \")\" + place, position, \"mdast-util-mdx-jsx:end-tag-mismatch\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {OnExitError}\n   */ function onErrorLeftIsTag(a, b) {\n        const tag = this.data.mdxJsxTag;\n        (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tag, \"expected `mdxJsxTag`\");\n        throw new vfile_message__WEBPACK_IMPORTED_MODULE_1__.VFileMessage(\"Expected the closing tag `\" + serializeAbbreviatedTag(tag) + \"` either after the end of `\" + b.type + \"` (\" + (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_3__.stringifyPosition)(b.end) + \") or another opening tag after the start of `\" + b.type + \"` (\" + (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_3__.stringifyPosition)(b.start) + \")\", {\n            start: a.start,\n            end: a.end\n        }, \"mdast-util-mdx-jsx:end-tag-mismatch\");\n    }\n    /**\n   * Serialize a tag, excluding attributes.\n   * `self-closing` is not supported, because we donâ€™t need it yet.\n   *\n   * @param {Tag} tag\n   * @returns {string}\n   */ function serializeAbbreviatedTag(tag) {\n        return \"<\" + (tag.close ? \"/\" : \"\") + (tag.name || \"\") + \">\";\n    }\n}\n/**\n * Create an extension for `mdast-util-to-markdown` to enable MDX JSX.\n *\n * This extension configures `mdast-util-to-markdown` with\n * `options.fences: true` and `options.resourceLink: true` too, do not\n * overwrite them!\n *\n * @param {ToMarkdownOptions | null | undefined} [options]\n *   Configuration (optional).\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable MDX JSX.\n */ function mdxJsxToMarkdown(options) {\n    const options_ = options || {};\n    const quote = options_.quote || '\"';\n    const quoteSmart = options_.quoteSmart || false;\n    const tightSelfClosing = options_.tightSelfClosing || false;\n    const printWidth = options_.printWidth || Number.POSITIVE_INFINITY;\n    const alternative = quote === '\"' ? \"'\" : '\"';\n    if (quote !== '\"' && quote !== \"'\") {\n        throw new Error(\"Cannot serialize attribute values with `\" + quote + \"` for `options.quote`, expected `\\\"`, or `'`\");\n    }\n    mdxElement.peek = peekElement;\n    return {\n        handlers: {\n            mdxJsxFlowElement: mdxElement,\n            mdxJsxTextElement: mdxElement\n        },\n        unsafe: [\n            {\n                character: \"<\",\n                inConstruct: [\n                    \"phrasing\"\n                ]\n            },\n            {\n                atBreak: true,\n                character: \"<\"\n            }\n        ],\n        // Always generate fenced code (never indented code).\n        fences: true,\n        // Always generate links with resources (never autolinks).\n        resourceLink: true\n    };\n    /**\n   * @type {ToMarkdownHandle}\n   * @param {MdxJsxFlowElement | MdxJsxTextElement} node\n   */ // eslint-disable-next-line complexity\n    function mdxElement(node, _, state, info) {\n        const flow = node.type === \"mdxJsxFlowElement\";\n        const selfClosing = node.name ? !node.children || node.children.length === 0 : false;\n        const depth = inferDepth(state);\n        const currentIndent = createIndent(depth);\n        const trackerOneLine = state.createTracker(info);\n        const trackerMultiLine = state.createTracker(info);\n        /** @type {Array<string>} */ const serializedAttributes = [];\n        const prefix = (flow ? currentIndent : \"\") + \"<\" + (node.name || \"\");\n        const exit = state.enter(node.type);\n        trackerOneLine.move(prefix);\n        trackerMultiLine.move(prefix);\n        // None.\n        if (node.attributes && node.attributes.length > 0) {\n            if (!node.name) {\n                throw new Error(\"Cannot serialize fragment w/ attributes\");\n            }\n            let index = -1;\n            while(++index < node.attributes.length){\n                const attribute = node.attributes[index];\n                /** @type {string} */ let result;\n                if (attribute.type === \"mdxJsxExpressionAttribute\") {\n                    result = \"{\" + (attribute.value || \"\") + \"}\";\n                } else {\n                    if (!attribute.name) {\n                        throw new Error(\"Cannot serialize attribute w/o name\");\n                    }\n                    const value = attribute.value;\n                    const left = attribute.name;\n                    /** @type {string} */ let right = \"\";\n                    if (value === null || value === undefined) {\n                    // Empty.\n                    } else if (typeof value === \"object\") {\n                        right = \"{\" + (value.value || \"\") + \"}\";\n                    } else {\n                        // If the alternative is less common than `quote`, switch.\n                        const appliedQuote = quoteSmart && (0,ccount__WEBPACK_IMPORTED_MODULE_4__.ccount)(value, quote) > (0,ccount__WEBPACK_IMPORTED_MODULE_4__.ccount)(value, alternative) ? alternative : quote;\n                        right = appliedQuote + (0,stringify_entities__WEBPACK_IMPORTED_MODULE_5__.stringifyEntitiesLight)(value, {\n                            subset: [\n                                appliedQuote\n                            ]\n                        }) + appliedQuote;\n                    }\n                    result = left + (right ? \"=\" : \"\") + right;\n                }\n                serializedAttributes.push(result);\n            }\n        }\n        let attributesOnTheirOwnLine = false;\n        const attributesOnOneLine = serializedAttributes.join(\" \");\n        if (// Block:\n        flow && // Including a line ending (expressions).\n        (/\\r?\\n|\\r/.test(attributesOnOneLine) || // Current position (including `<tag`).\n        trackerOneLine.current().now.column + // -1 because columns, +1 for ` ` before attributes.\n        // Attributes joined by spaces.\n        attributesOnOneLine.length + // ` />`.\n        (selfClosing ? tightSelfClosing ? 2 : 3 : 1) > printWidth)) {\n            attributesOnTheirOwnLine = true;\n        }\n        let tracker = trackerOneLine;\n        let value = prefix;\n        if (attributesOnTheirOwnLine) {\n            tracker = trackerMultiLine;\n            let index = -1;\n            while(++index < serializedAttributes.length){\n                // Only indent first line of of attributes, we canâ€™t indent attribute\n                // values.\n                serializedAttributes[index] = currentIndent + indent + serializedAttributes[index];\n            }\n            value += tracker.move(\"\\n\" + serializedAttributes.join(\"\\n\") + \"\\n\" + currentIndent);\n        } else if (attributesOnOneLine) {\n            value += tracker.move(\" \" + attributesOnOneLine);\n        }\n        if (selfClosing) {\n            value += tracker.move((tightSelfClosing || attributesOnTheirOwnLine ? \"\" : \" \") + \"/\");\n        }\n        value += tracker.move(\">\");\n        if (node.children && node.children.length > 0) {\n            if (node.type === \"mdxJsxTextElement\") {\n                value += tracker.move(state.containerPhrasing(node, {\n                    ...tracker.current(),\n                    before: \">\",\n                    after: \"<\"\n                }));\n            } else {\n                tracker.shift(2);\n                value += tracker.move(\"\\n\");\n                value += tracker.move(containerFlow(node, state, tracker.current()));\n                value += tracker.move(\"\\n\");\n            }\n        }\n        if (!selfClosing) {\n            value += tracker.move((flow ? currentIndent : \"\") + \"</\" + (node.name || \"\") + \">\");\n        }\n        exit();\n        return value;\n    }\n}\n// Modified copy of:\n// <https://github.com/syntax-tree/mdast-util-to-markdown/blob/a381cbc/lib/util/container-flow.js>.\n//\n// To do: add `indent` support to `mdast-util-to-markdown`.\n// As indents are only used for JSX, itâ€™s fine for now, but perhaps better\n// there.\n/**\n * @param {MdxJsxFlowElement} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {ReturnType<Tracker['current']>} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined by (blank) lines.\n */ function containerFlow(parent, state, info) {\n    const indexStack = state.indexStack;\n    const children = parent.children;\n    const tracker = state.createTracker(info);\n    const currentIndent = createIndent(inferDepth(state));\n    /** @type {Array<string>} */ const results = [];\n    let index = -1;\n    indexStack.push(-1);\n    while(++index < children.length){\n        const child = children[index];\n        indexStack[indexStack.length - 1] = index;\n        const childInfo = {\n            before: \"\\n\",\n            after: \"\\n\",\n            ...tracker.current()\n        };\n        const result = state.handle(child, parent, state, childInfo);\n        const serializedChild = child.type === \"mdxJsxFlowElement\" ? result : state.indentLines(result, function(line, _, blank) {\n            return (blank ? \"\" : currentIndent) + line;\n        });\n        results.push(tracker.move(serializedChild));\n        if (child.type !== \"list\") {\n            state.bulletLastUsed = undefined;\n        }\n        if (index < children.length - 1) {\n            results.push(tracker.move(\"\\n\\n\"));\n        }\n    }\n    indexStack.pop();\n    return results.join(\"\");\n}\n/**\n * @param {State} state\n * @returns {number}\n */ function inferDepth(state) {\n    let depth = 0;\n    let index = state.stack.length;\n    while(--index > -1){\n        const name = state.stack[index];\n        if (name === \"blockquote\" || name === \"listItem\") break;\n        if (name === \"mdxJsxFlowElement\") depth++;\n    }\n    return depth;\n}\n/**\n * @param {number} depth\n * @returns {string}\n */ function createIndent(depth) {\n    return indent.repeat(depth);\n}\n/**\n * @type {ToMarkdownHandle}\n */ function peekElement() {\n    return \"<\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1tZHgtanN4L2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOzs7OztDQUtDLEdBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUNDLEdBRTRCO0FBQ007QUFDUztBQUNhO0FBQ007QUFDckI7QUFFMUMsTUFBTU8sU0FBUztBQUVmOzs7Ozs7OztDQVFDLEdBQ00sU0FBU0M7SUFDZCxPQUFPO1FBQ0xDLGdCQUFnQjtZQUFDO1NBQW9CO1FBQ3JDQyxPQUFPO1lBQ0xDLGVBQWVDO1lBQ2ZDLDRCQUE0QkM7WUFDNUJDLHdCQUF3QkM7WUFDeEJDLGtDQUFrQ0M7WUFDbENDLG9DQUFvQ0M7WUFDcENDLHVDQUF1Q0Q7WUFDdkNFLGdDQUFnQ0M7WUFFaENDLGVBQWVaO1lBQ2ZhLDRCQUE0Qlg7WUFDNUJZLHdCQUF3QlY7WUFDeEJXLGtDQUFrQ1Q7WUFDbENVLG9DQUFvQ1I7WUFDcENTLHVDQUF1Q1Q7WUFDdkNVLGdDQUFnQ1A7UUFDbEM7UUFDQVEsTUFBTTtZQUNKbEIsNEJBQTRCbUI7WUFDNUJDLDBCQUEwQkM7WUFDMUJDLHlCQUF5QkM7WUFDekJDLHdCQUF3QkM7WUFDeEJyQixrQ0FBa0NzQjtZQUNsQ0MsdUNBQXVDQztZQUN2Q0MsbUNBQW1DQztZQUNuQ0MsaUNBQWlDQztZQUNqQzFCLG9DQUFvQzJCO1lBQ3BDQyx5Q0FBeUNOO1lBQ3pDcEIsdUNBQ0UyQjtZQUNGQyw0Q0FBNENSO1lBQzVDbkIsZ0NBQWdDNEI7WUFDaEN2QyxlQUFld0M7WUFFZjFCLDRCQUE0Qk87WUFDNUJvQiwwQkFBMEJsQjtZQUMxQm1CLHlCQUF5QmpCO1lBQ3pCa0Isd0JBQXdCaEI7WUFDeEJYLGtDQUFrQ1k7WUFDbENnQix1Q0FBdUNkO1lBQ3ZDZSxtQ0FBbUNiO1lBQ25DYyxpQ0FBaUNaO1lBQ2pDakIsb0NBQW9Da0I7WUFDcENZLHlDQUF5Q2pCO1lBQ3pDWix1Q0FDRW1CO1lBQ0ZXLDRDQUE0Q2xCO1lBQzVDWCxnQ0FBZ0NvQjtZQUNoQzFCLGVBQWUyQjtRQUNqQjtJQUNGO0lBRUE7OztHQUdDLEdBQ0QsU0FBUy9CO1FBQ1AsSUFBSSxDQUFDQSxNQUFNO0lBQ2I7SUFFQTs7Ozs7OztHQU9DLEdBQ0QsU0FBU3dDLE1BQU1DLENBQUM7UUFDZCxPQUFPO1lBQUNDLE1BQU1ELEVBQUVDLElBQUk7WUFBRUMsUUFBUUYsRUFBRUUsTUFBTTtZQUFFQyxRQUFRSCxFQUFFRyxNQUFNO1FBQUE7SUFDMUQ7SUFFQTs7O0dBR0MsR0FDRCxTQUFTdkIsS0FBS3dCLEtBQUs7UUFDakIsSUFBSSxDQUFDQyxNQUFNLENBQUN4RCxLQUFLLENBQUMrQixJQUFJLENBQUMwQixJQUFJLENBQUMsSUFBSSxFQUFFRjtRQUNsQyxJQUFJLENBQUNDLE1BQU0sQ0FBQ25DLElBQUksQ0FBQ1UsSUFBSSxDQUFDMEIsSUFBSSxDQUFDLElBQUksRUFBRUY7SUFDbkM7SUFFQTs7O0dBR0MsR0FDRCxTQUFTckQsZUFBZXFELEtBQUs7UUFDM0IsZ0JBQWdCLEdBQ2hCLE1BQU1HLE1BQU07WUFDVkMsTUFBTUM7WUFDTkMsWUFBWSxFQUFFO1lBQ2RDLE9BQU87WUFDUEMsYUFBYTtZQUNiQyxPQUFPVCxNQUFNUyxLQUFLO1lBQ2xCQyxLQUFLVixNQUFNVSxHQUFHO1FBQ2hCO1FBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQ2xDLElBQUksQ0FBQ21DLGNBQWMsRUFBRSxJQUFJLENBQUNuQyxJQUFJLENBQUNtQyxjQUFjLEdBQUcsRUFBRTtRQUM1RCxJQUFJLENBQUNuQyxJQUFJLENBQUNvQyxTQUFTLEdBQUdUO1FBQ3RCLElBQUksQ0FBQ2hELE1BQU07SUFDYjtJQUVBOzs7R0FHQyxHQUNELFNBQVNOLDRCQUE0Qm1ELEtBQUs7UUFDeEMsTUFBTWEsUUFBUSxJQUFJLENBQUNyQyxJQUFJLENBQUNtQyxjQUFjO1FBQ3RDMUUsMENBQU1BLENBQUM0RSxPQUFPO1FBRWQsSUFBSUEsTUFBTUMsTUFBTSxLQUFLLEdBQUc7WUFDdEIsTUFBTSxJQUFJekUsdURBQVlBLENBQ3BCLG1FQUNBO2dCQUFDb0UsT0FBT1QsTUFBTVMsS0FBSztnQkFBRUMsS0FBS1YsTUFBTVUsR0FBRztZQUFBLEdBQ25DO1FBRUo7SUFDRjtJQUVBOzs7R0FHQyxHQUNELFNBQVNLLDJCQUEyQmYsS0FBSztRQUN2QyxNQUFNRyxNQUFNLElBQUksQ0FBQzNCLElBQUksQ0FBQ29DLFNBQVM7UUFDL0IzRSwwQ0FBTUEsQ0FBQ2tFLEtBQUs7UUFFWixJQUFJQSxJQUFJSSxLQUFLLEVBQUU7WUFDYixNQUFNLElBQUlsRSx1REFBWUEsQ0FDcEIsb0VBQ0E7Z0JBQUNvRSxPQUFPVCxNQUFNUyxLQUFLO2dCQUFFQyxLQUFLVixNQUFNVSxHQUFHO1lBQUEsR0FDbkM7UUFFSjtJQUNGO0lBRUE7OztHQUdDLEdBQ0QsU0FBU3BELGdDQUFnQzBDLEtBQUs7UUFDNUMsTUFBTUcsTUFBTSxJQUFJLENBQUMzQixJQUFJLENBQUNvQyxTQUFTO1FBQy9CM0UsMENBQU1BLENBQUNrRSxLQUFLO1FBRVosSUFBSUEsSUFBSUksS0FBSyxFQUFFO1lBQ2IsTUFBTSxJQUFJbEUsdURBQVlBLENBQ3BCLGlGQUNBO2dCQUFDb0UsT0FBT1QsTUFBTVMsS0FBSztnQkFBRUMsS0FBS1YsTUFBTVUsR0FBRztZQUFBLEdBQ25DO1FBRUo7SUFDRjtJQUVBOzs7R0FHQyxHQUNELFNBQVMzQztRQUNQLE1BQU1vQyxNQUFNLElBQUksQ0FBQzNCLElBQUksQ0FBQ29DLFNBQVM7UUFDL0IzRSwwQ0FBTUEsQ0FBQ2tFLEtBQUs7UUFDWkEsSUFBSUksS0FBSyxHQUFHO0lBQ2Q7SUFFQTs7O0dBR0MsR0FDRCxTQUFTdEMseUJBQXlCK0IsS0FBSztRQUNyQyxNQUFNRyxNQUFNLElBQUksQ0FBQzNCLElBQUksQ0FBQ29DLFNBQVM7UUFDL0IzRSwwQ0FBTUEsQ0FBQ2tFLEtBQUs7UUFDWkEsSUFBSUMsSUFBSSxHQUFHLElBQUksQ0FBQ1ksY0FBYyxDQUFDaEI7SUFDakM7SUFFQTs7O0dBR0MsR0FDRCxTQUFTN0Isd0JBQXdCNkIsS0FBSztRQUNwQyxNQUFNRyxNQUFNLElBQUksQ0FBQzNCLElBQUksQ0FBQ29DLFNBQVM7UUFDL0IzRSwwQ0FBTUEsQ0FBQ2tFLEtBQUs7UUFDWkEsSUFBSUMsSUFBSSxJQUFJLE1BQU0sSUFBSSxDQUFDWSxjQUFjLENBQUNoQjtJQUN4QztJQUVBOzs7R0FHQyxHQUNELFNBQVMzQix1QkFBdUIyQixLQUFLO1FBQ25DLE1BQU1HLE1BQU0sSUFBSSxDQUFDM0IsSUFBSSxDQUFDb0MsU0FBUztRQUMvQjNFLDBDQUFNQSxDQUFDa0UsS0FBSztRQUNaQSxJQUFJQyxJQUFJLElBQUksTUFBTSxJQUFJLENBQUNZLGNBQWMsQ0FBQ2hCO0lBQ3hDO0lBRUE7OztHQUdDLEdBQ0QsU0FBU2pELHdCQUF3QmlELEtBQUs7UUFDcEMsTUFBTUcsTUFBTSxJQUFJLENBQUMzQixJQUFJLENBQUNvQyxTQUFTO1FBQy9CM0UsMENBQU1BLENBQUNrRSxLQUFLO1FBQ1pZLDJCQUEyQmIsSUFBSSxDQUFDLElBQUksRUFBRUY7UUFDdENHLElBQUlHLFVBQVUsQ0FBQ1csSUFBSSxDQUFDO1lBQ2xCQyxNQUFNO1lBQ05kLE1BQU07WUFDTmUsT0FBTztZQUNQQyxVQUFVO2dCQUNSWCxPQUFPZCxNQUFNSyxNQUFNUyxLQUFLO2dCQUN4QixpREFBaUQ7Z0JBQ2pEQyxLQUFLTDtZQUNQO1FBQ0Y7SUFDRjtJQUVBOzs7R0FHQyxHQUNELFNBQVNwRCxrQ0FBa0MrQyxLQUFLO1FBQzlDLE1BQU1HLE1BQU0sSUFBSSxDQUFDM0IsSUFBSSxDQUFDb0MsU0FBUztRQUMvQjNFLDBDQUFNQSxDQUFDa0UsS0FBSztRQUNaWSwyQkFBMkJiLElBQUksQ0FBQyxJQUFJLEVBQUVGO1FBQ3RDRyxJQUFJRyxVQUFVLENBQUNXLElBQUksQ0FBQztZQUNsQkMsTUFBTTtZQUNOQyxPQUFPO1lBQ1BDLFVBQVU7Z0JBQ1JYLE9BQU9kLE1BQU1LLE1BQU1TLEtBQUs7Z0JBQ3hCLGlEQUFpRDtnQkFDakRDLEtBQUtMO1lBQ1A7UUFDRjtRQUNBLElBQUksQ0FBQ2xELE1BQU07SUFDYjtJQUVBOzs7R0FHQyxHQUNELFNBQVNtQixpQ0FBaUMwQixLQUFLO1FBQzdDLE1BQU1HLE1BQU0sSUFBSSxDQUFDM0IsSUFBSSxDQUFDb0MsU0FBUztRQUMvQjNFLDBDQUFNQSxDQUFDa0UsS0FBSztRQUNaLE1BQU1rQixPQUFPbEIsSUFBSUcsVUFBVSxDQUFDSCxJQUFJRyxVQUFVLENBQUNRLE1BQU0sR0FBRyxFQUFFO1FBQ3REN0UsMENBQU1BLENBQUNvRixLQUFLSCxJQUFJLEtBQUs7UUFDckIsTUFBTUksU0FBU3RCLE1BQU1zQixNQUFNO1FBRTNCRCxLQUFLRixLQUFLLEdBQUcsSUFBSSxDQUFDSSxNQUFNO1FBQ3hCdEYsMENBQU1BLENBQUNvRixLQUFLRCxRQUFRLEtBQUtmO1FBQ3pCZ0IsS0FBS0QsUUFBUSxDQUFDVixHQUFHLEdBQUdmLE1BQU1LLE1BQU1VLEdBQUc7UUFFbkMsSUFBSVksUUFBUTtZQUNWRCxLQUFLN0MsSUFBSSxHQUFHO2dCQUFDOEM7WUFBTTtRQUNyQjtJQUNGO0lBRUE7OztHQUdDLEdBQ0QsU0FBUzVDLGtDQUFrQ3NCLEtBQUs7UUFDOUMsTUFBTUcsTUFBTSxJQUFJLENBQUMzQixJQUFJLENBQUNvQyxTQUFTO1FBQy9CM0UsMENBQU1BLENBQUNrRSxLQUFLO1FBQ1osTUFBTXFCLE9BQU9yQixJQUFJRyxVQUFVLENBQUNILElBQUlHLFVBQVUsQ0FBQ1EsTUFBTSxHQUFHLEVBQUU7UUFDdEQ3RSwwQ0FBTUEsQ0FBQ3VGLEtBQUtOLElBQUksS0FBSztRQUNyQk0sS0FBS3BCLElBQUksR0FBRyxJQUFJLENBQUNZLGNBQWMsQ0FBQ2hCO1FBQ2hDL0QsMENBQU1BLENBQUN1RixLQUFLSixRQUFRLEtBQUtmO1FBQ3pCbUIsS0FBS0osUUFBUSxDQUFDVixHQUFHLEdBQUdmLE1BQU1LLE1BQU1VLEdBQUc7SUFDckM7SUFFQTs7O0dBR0MsR0FDRCxTQUFTOUIsZ0NBQWdDb0IsS0FBSztRQUM1QyxNQUFNRyxNQUFNLElBQUksQ0FBQzNCLElBQUksQ0FBQ29DLFNBQVM7UUFDL0IzRSwwQ0FBTUEsQ0FBQ2tFLEtBQUs7UUFDWixNQUFNcUIsT0FBT3JCLElBQUlHLFVBQVUsQ0FBQ0gsSUFBSUcsVUFBVSxDQUFDUSxNQUFNLEdBQUcsRUFBRTtRQUN0RDdFLDBDQUFNQSxDQUFDdUYsS0FBS04sSUFBSSxLQUFLO1FBQ3JCTSxLQUFLcEIsSUFBSSxJQUFJLE1BQU0sSUFBSSxDQUFDWSxjQUFjLENBQUNoQjtRQUN2Qy9ELDBDQUFNQSxDQUFDdUYsS0FBS0osUUFBUSxLQUFLZjtRQUN6Qm1CLEtBQUtKLFFBQVEsQ0FBQ1YsR0FBRyxHQUFHZixNQUFNSyxNQUFNVSxHQUFHO0lBQ3JDO0lBRUE7OztHQUdDLEdBQ0QsU0FBUzdCLG1DQUFtQ21CLEtBQUs7UUFDL0MsTUFBTUcsTUFBTSxJQUFJLENBQUMzQixJQUFJLENBQUNvQyxTQUFTO1FBQy9CM0UsMENBQU1BLENBQUNrRSxLQUFLO1FBQ1osTUFBTXFCLE9BQU9yQixJQUFJRyxVQUFVLENBQUNILElBQUlHLFVBQVUsQ0FBQ1EsTUFBTSxHQUFHLEVBQUU7UUFDdERVLEtBQUtMLEtBQUssR0FBR2pGLDZEQUFhQSxDQUFDLElBQUksQ0FBQ3FGLE1BQU0sSUFBSTtZQUFDRSxlQUFlO1FBQUs7UUFDL0R4RiwwQ0FBTUEsQ0FBQ3VGLEtBQUtKLFFBQVEsS0FBS2Y7UUFDekJtQixLQUFLSixRQUFRLENBQUNWLEdBQUcsR0FBR2YsTUFBTUssTUFBTVUsR0FBRztJQUNyQztJQUVBOzs7R0FHQyxHQUNELFNBQVMzQixzQ0FBc0NpQixLQUFLO1FBQ2xELE1BQU1HLE1BQU0sSUFBSSxDQUFDM0IsSUFBSSxDQUFDb0MsU0FBUztRQUMvQjNFLDBDQUFNQSxDQUFDa0UsS0FBSztRQUNaLE1BQU1rQixPQUFPbEIsSUFBSUcsVUFBVSxDQUFDSCxJQUFJRyxVQUFVLENBQUNRLE1BQU0sR0FBRyxFQUFFO1FBQ3REN0UsMENBQU1BLENBQUNvRixLQUFLSCxJQUFJLEtBQUs7UUFDckIsMkNBQTJDLEdBQzNDLE1BQU1NLE9BQU87WUFBQ04sTUFBTTtZQUFrQ0MsT0FBTyxJQUFJLENBQUNJLE1BQU07UUFBRTtRQUMxRSxNQUFNRCxTQUFTdEIsTUFBTXNCLE1BQU07UUFFM0IsSUFBSUEsUUFBUTtZQUNWRSxLQUFLaEQsSUFBSSxHQUFHO2dCQUFDOEM7WUFBTTtRQUNyQjtRQUVBRCxLQUFLRixLQUFLLEdBQUdLO1FBQ2J2RiwwQ0FBTUEsQ0FBQ29GLEtBQUtELFFBQVEsS0FBS2Y7UUFDekJnQixLQUFLRCxRQUFRLENBQUNWLEdBQUcsR0FBR2YsTUFBTUssTUFBTVUsR0FBRztJQUNyQztJQUVBOzs7R0FHQyxHQUNELFNBQVN6QjtRQUNQLE1BQU1rQixNQUFNLElBQUksQ0FBQzNCLElBQUksQ0FBQ29DLFNBQVM7UUFDL0IzRSwwQ0FBTUEsQ0FBQ2tFLEtBQUs7UUFFWkEsSUFBSUssV0FBVyxHQUFHO0lBQ3BCO0lBRUE7OztHQUdDLEdBQ0QsU0FBU3RCLGNBQWNjLEtBQUs7UUFDMUIsTUFBTUcsTUFBTSxJQUFJLENBQUMzQixJQUFJLENBQUNvQyxTQUFTO1FBQy9CM0UsMENBQU1BLENBQUNrRSxLQUFLO1FBQ1osTUFBTVUsUUFBUSxJQUFJLENBQUNyQyxJQUFJLENBQUNtQyxjQUFjO1FBQ3RDMUUsMENBQU1BLENBQUM0RSxPQUFPO1FBQ2QsTUFBTVEsT0FBT1IsS0FBSyxDQUFDQSxNQUFNQyxNQUFNLEdBQUcsRUFBRTtRQUVwQyxJQUFJWCxJQUFJSSxLQUFLLElBQUljLEtBQUtqQixJQUFJLEtBQUtELElBQUlDLElBQUksRUFBRTtZQUN2QyxNQUFNLElBQUkvRCx1REFBWUEsQ0FDcEIsNkJBQ0VxRix3QkFBd0J2QixPQUN4QixnREFDQXVCLHdCQUF3QkwsUUFDeEIsUUFDQWpGLGdGQUFpQkEsQ0FBQ2lGLFFBQ2xCLEtBQ0Y7Z0JBQUNaLE9BQU9ULE1BQU1TLEtBQUs7Z0JBQUVDLEtBQUtWLE1BQU1VLEdBQUc7WUFBQSxHQUNuQztRQUVKO1FBRUEsb0NBQW9DO1FBQ3BDLElBQUksQ0FBQ2EsTUFBTTtRQUVYLElBQUlwQixJQUFJSSxLQUFLLEVBQUU7WUFDYk0sTUFBTWMsR0FBRztRQUNYLE9BQU87WUFDTCxJQUFJLENBQUNsRixLQUFLLENBQ1I7Z0JBQ0V5RSxNQUNFbEIsTUFBTWtCLElBQUksS0FBSyxrQkFDWCxzQkFDQTtnQkFDTmQsTUFBTUQsSUFBSUMsSUFBSSxJQUFJO2dCQUNsQkUsWUFBWUgsSUFBSUcsVUFBVTtnQkFDMUJzQixVQUFVLEVBQUU7WUFDZCxHQUNBNUIsT0FDQTZCO1FBRUo7UUFFQSxJQUFJMUIsSUFBSUssV0FBVyxJQUFJTCxJQUFJSSxLQUFLLEVBQUU7WUFDaEMsSUFBSSxDQUFDekMsSUFBSSxDQUFDa0MsT0FBTzhCO1FBQ25CLE9BQU87WUFDTGpCLE1BQU1JLElBQUksQ0FBQ2Q7UUFDYjtJQUNGO0lBRUE7OztHQUdDLEdBQ0QsU0FBUzBCLGtCQUFrQkUsT0FBTyxFQUFFQyxJQUFJO1FBQ3RDLE1BQU1uQixRQUFRLElBQUksQ0FBQ3JDLElBQUksQ0FBQ21DLGNBQWM7UUFDdEMxRSwwQ0FBTUEsQ0FBQzRFLE9BQU87UUFDZCxNQUFNVixNQUFNVSxLQUFLLENBQUNBLE1BQU1DLE1BQU0sR0FBRyxFQUFFO1FBQ25DN0UsMENBQU1BLENBQUNrRSxLQUFLO1FBQ1osTUFBTThCLFFBQVFGLFVBQVUseUJBQXlCQSxRQUFRYixJQUFJLEdBQUcsTUFBTTtRQUN0RSxNQUFNRSxXQUFXVyxVQUNiO1lBQUN0QixPQUFPc0IsUUFBUXRCLEtBQUs7WUFBRUMsS0FBS3FCLFFBQVFyQixHQUFHO1FBQUEsSUFDdkNMO1FBRUosTUFBTSxJQUFJaEUsdURBQVlBLENBQ3BCLGlDQUNFcUYsd0JBQXdCdkIsT0FDeEIsUUFDQS9ELGdGQUFpQkEsQ0FBQztZQUFDcUUsT0FBT3VCLEtBQUt2QixLQUFLO1lBQUVDLEtBQUtzQixLQUFLdEIsR0FBRztRQUFBLEtBQ25ELE1BQ0F1QixPQUNGYixVQUNBO0lBRUo7SUFFQTs7O0dBR0MsR0FDRCxTQUFTVSxpQkFBaUJJLENBQUMsRUFBRUMsQ0FBQztRQUM1QixNQUFNaEMsTUFBTSxJQUFJLENBQUMzQixJQUFJLENBQUNvQyxTQUFTO1FBQy9CM0UsMENBQU1BLENBQUNrRSxLQUFLO1FBRVosTUFBTSxJQUFJOUQsdURBQVlBLENBQ3BCLCtCQUNFcUYsd0JBQXdCdkIsT0FDeEIsZ0NBQ0FnQyxFQUFFakIsSUFBSSxHQUNOLFFBQ0E5RSxnRkFBaUJBLENBQUMrRixFQUFFekIsR0FBRyxJQUN2QixrREFDQXlCLEVBQUVqQixJQUFJLEdBQ04sUUFDQTlFLGdGQUFpQkEsQ0FBQytGLEVBQUUxQixLQUFLLElBQ3pCLEtBQ0Y7WUFBQ0EsT0FBT3lCLEVBQUV6QixLQUFLO1lBQUVDLEtBQUt3QixFQUFFeEIsR0FBRztRQUFBLEdBQzNCO0lBRUo7SUFFQTs7Ozs7O0dBTUMsR0FDRCxTQUFTZ0Isd0JBQXdCdkIsR0FBRztRQUNsQyxPQUFPLE1BQU9BLENBQUFBLElBQUlJLEtBQUssR0FBRyxNQUFNLEVBQUMsSUFBTUosQ0FBQUEsSUFBSUMsSUFBSSxJQUFJLEVBQUMsSUFBSztJQUMzRDtBQUNGO0FBRUE7Ozs7Ozs7Ozs7O0NBV0MsR0FDTSxTQUFTZ0MsaUJBQWlCQyxPQUFPO0lBQ3RDLE1BQU1DLFdBQVdELFdBQVcsQ0FBQztJQUM3QixNQUFNRSxRQUFRRCxTQUFTQyxLQUFLLElBQUk7SUFDaEMsTUFBTUMsYUFBYUYsU0FBU0UsVUFBVSxJQUFJO0lBQzFDLE1BQU1DLG1CQUFtQkgsU0FBU0csZ0JBQWdCLElBQUk7SUFDdEQsTUFBTUMsYUFBYUosU0FBU0ksVUFBVSxJQUFJQyxPQUFPQyxpQkFBaUI7SUFDbEUsTUFBTUMsY0FBY04sVUFBVSxNQUFNLE1BQU07SUFFMUMsSUFBSUEsVUFBVSxPQUFPQSxVQUFVLEtBQUs7UUFDbEMsTUFBTSxJQUFJTyxNQUNSLDZDQUNFUCxRQUNBO0lBRU47SUFFQVEsV0FBV0MsSUFBSSxHQUFHQztJQUVsQixPQUFPO1FBQ0xDLFVBQVU7WUFDUkMsbUJBQW1CSjtZQUNuQkssbUJBQW1CTDtRQUNyQjtRQUNBTSxRQUFRO1lBQ047Z0JBQUNDLFdBQVc7Z0JBQUtDLGFBQWE7b0JBQUM7aUJBQVc7WUFBQTtZQUMxQztnQkFBQ0MsU0FBUztnQkFBTUYsV0FBVztZQUFHO1NBQy9CO1FBQ0QscURBQXFEO1FBQ3JERyxRQUFRO1FBQ1IsMERBQTBEO1FBQzFEQyxjQUFjO0lBQ2hCO0lBRUE7OztHQUdDLEdBQ0Qsc0NBQXNDO0lBQ3RDLFNBQVNYLFdBQVd2QixJQUFJLEVBQUVtQyxDQUFDLEVBQUVDLEtBQUssRUFBRUMsSUFBSTtRQUN0QyxNQUFNQyxPQUFPdEMsS0FBS04sSUFBSSxLQUFLO1FBQzNCLE1BQU1WLGNBQWNnQixLQUFLcEIsSUFBSSxHQUN6QixDQUFDb0IsS0FBS0ksUUFBUSxJQUFJSixLQUFLSSxRQUFRLENBQUNkLE1BQU0sS0FBSyxJQUMzQztRQUNKLE1BQU1pRCxRQUFRQyxXQUFXSjtRQUN6QixNQUFNSyxnQkFBZ0JDLGFBQWFIO1FBQ25DLE1BQU1JLGlCQUFpQlAsTUFBTVEsYUFBYSxDQUFDUDtRQUMzQyxNQUFNUSxtQkFBbUJULE1BQU1RLGFBQWEsQ0FBQ1A7UUFDN0MsMEJBQTBCLEdBQzFCLE1BQU1TLHVCQUF1QixFQUFFO1FBQy9CLE1BQU1DLFNBQVMsQ0FBQ1QsT0FBT0csZ0JBQWdCLEVBQUMsSUFBSyxNQUFPekMsQ0FBQUEsS0FBS3BCLElBQUksSUFBSSxFQUFDO1FBQ2xFLE1BQU10QyxPQUFPOEYsTUFBTW5ILEtBQUssQ0FBQytFLEtBQUtOLElBQUk7UUFFbENpRCxlQUFlSyxJQUFJLENBQUNEO1FBQ3BCRixpQkFBaUJHLElBQUksQ0FBQ0Q7UUFFdEIsUUFBUTtRQUNSLElBQUkvQyxLQUFLbEIsVUFBVSxJQUFJa0IsS0FBS2xCLFVBQVUsQ0FBQ1EsTUFBTSxHQUFHLEdBQUc7WUFDakQsSUFBSSxDQUFDVSxLQUFLcEIsSUFBSSxFQUFFO2dCQUNkLE1BQU0sSUFBSTBDLE1BQU07WUFDbEI7WUFFQSxJQUFJMkIsUUFBUSxDQUFDO1lBQ2IsTUFBTyxFQUFFQSxRQUFRakQsS0FBS2xCLFVBQVUsQ0FBQ1EsTUFBTSxDQUFFO2dCQUN2QyxNQUFNNEQsWUFBWWxELEtBQUtsQixVQUFVLENBQUNtRSxNQUFNO2dCQUN4QyxtQkFBbUIsR0FDbkIsSUFBSUU7Z0JBRUosSUFBSUQsVUFBVXhELElBQUksS0FBSyw2QkFBNkI7b0JBQ2xEeUQsU0FBUyxNQUFPRCxDQUFBQSxVQUFVdkQsS0FBSyxJQUFJLEVBQUMsSUFBSztnQkFDM0MsT0FBTztvQkFDTCxJQUFJLENBQUN1RCxVQUFVdEUsSUFBSSxFQUFFO3dCQUNuQixNQUFNLElBQUkwQyxNQUFNO29CQUNsQjtvQkFFQSxNQUFNM0IsUUFBUXVELFVBQVV2RCxLQUFLO29CQUM3QixNQUFNeUQsT0FBT0YsVUFBVXRFLElBQUk7b0JBQzNCLG1CQUFtQixHQUNuQixJQUFJeUUsUUFBUTtvQkFFWixJQUFJMUQsVUFBVSxRQUFRQSxVQUFVZCxXQUFXO29CQUN6QyxTQUFTO29CQUNYLE9BQU8sSUFBSSxPQUFPYyxVQUFVLFVBQVU7d0JBQ3BDMEQsUUFBUSxNQUFPMUQsQ0FBQUEsTUFBTUEsS0FBSyxJQUFJLEVBQUMsSUFBSztvQkFDdEMsT0FBTzt3QkFDTCwwREFBMEQ7d0JBQzFELE1BQU0yRCxlQUNKdEMsY0FBY3pHLDhDQUFNQSxDQUFDb0YsT0FBT29CLFNBQVN4Ryw4Q0FBTUEsQ0FBQ29GLE9BQU8wQixlQUMvQ0EsY0FDQU47d0JBQ05zQyxRQUNFQyxlQUNBM0ksMEVBQXNCQSxDQUFDZ0YsT0FBTzs0QkFBQzRELFFBQVE7Z0NBQUNEOzZCQUFhO3dCQUFBLEtBQ3JEQTtvQkFDSjtvQkFFQUgsU0FBU0MsT0FBUUMsQ0FBQUEsUUFBUSxNQUFNLEVBQUMsSUFBS0E7Z0JBQ3ZDO2dCQUVBUCxxQkFBcUJyRCxJQUFJLENBQUMwRDtZQUM1QjtRQUNGO1FBRUEsSUFBSUssMkJBQTJCO1FBQy9CLE1BQU1DLHNCQUFzQlgscUJBQXFCWSxJQUFJLENBQUM7UUFFdEQsSUFDRSxTQUFTO1FBQ1RwQixRQUNBLHlDQUF5QztRQUN4QyxZQUFXcUIsSUFBSSxDQUFDRix3QkFDZix1Q0FBdUM7UUFDdkNkLGVBQWVpQixPQUFPLEdBQUdDLEdBQUcsQ0FBQ3ZGLE1BQU0sR0FDakMsb0RBQW9EO1FBQ3BELCtCQUErQjtRQUMvQm1GLG9CQUFvQm5FLE1BQU0sR0FDMUIsU0FBUztRQUNSTixDQUFBQSxjQUFlaUMsbUJBQW1CLElBQUksSUFBSyxLQUM1Q0MsVUFBUyxHQUNiO1lBQ0FzQywyQkFBMkI7UUFDN0I7UUFFQSxJQUFJTSxVQUFVbkI7UUFDZCxJQUFJaEQsUUFBUW9EO1FBRVosSUFBSVMsMEJBQTBCO1lBQzVCTSxVQUFVakI7WUFFVixJQUFJSSxRQUFRLENBQUM7WUFFYixNQUFPLEVBQUVBLFFBQVFILHFCQUFxQnhELE1BQU0sQ0FBRTtnQkFDNUMscUVBQXFFO2dCQUNyRSxVQUFVO2dCQUNWd0Qsb0JBQW9CLENBQUNHLE1BQU0sR0FDekJSLGdCQUFnQjNILFNBQVNnSSxvQkFBb0IsQ0FBQ0csTUFBTTtZQUN4RDtZQUVBdEQsU0FBU21FLFFBQVFkLElBQUksQ0FDbkIsT0FBT0YscUJBQXFCWSxJQUFJLENBQUMsUUFBUSxPQUFPakI7UUFFcEQsT0FBTyxJQUFJZ0IscUJBQXFCO1lBQzlCOUQsU0FBU21FLFFBQVFkLElBQUksQ0FBQyxNQUFNUztRQUM5QjtRQUVBLElBQUl6RSxhQUFhO1lBQ2ZXLFNBQVNtRSxRQUFRZCxJQUFJLENBQ25CLENBQUMvQixvQkFBb0J1QywyQkFBMkIsS0FBSyxHQUFFLElBQUs7UUFFaEU7UUFFQTdELFNBQVNtRSxRQUFRZCxJQUFJLENBQUM7UUFFdEIsSUFBSWhELEtBQUtJLFFBQVEsSUFBSUosS0FBS0ksUUFBUSxDQUFDZCxNQUFNLEdBQUcsR0FBRztZQUM3QyxJQUFJVSxLQUFLTixJQUFJLEtBQUsscUJBQXFCO2dCQUNyQ0MsU0FBU21FLFFBQVFkLElBQUksQ0FDbkJaLE1BQU0yQixpQkFBaUIsQ0FBQy9ELE1BQU07b0JBQzVCLEdBQUc4RCxRQUFRRixPQUFPLEVBQUU7b0JBQ3BCSSxRQUFRO29CQUNSQyxPQUFPO2dCQUNUO1lBRUosT0FBTztnQkFDTEgsUUFBUUksS0FBSyxDQUFDO2dCQUNkdkUsU0FBU21FLFFBQVFkLElBQUksQ0FBQztnQkFDdEJyRCxTQUFTbUUsUUFBUWQsSUFBSSxDQUFDbUIsY0FBY25FLE1BQU1vQyxPQUFPMEIsUUFBUUYsT0FBTztnQkFDaEVqRSxTQUFTbUUsUUFBUWQsSUFBSSxDQUFDO1lBQ3hCO1FBQ0Y7UUFFQSxJQUFJLENBQUNoRSxhQUFhO1lBQ2hCVyxTQUFTbUUsUUFBUWQsSUFBSSxDQUNuQixDQUFDVixPQUFPRyxnQkFBZ0IsRUFBQyxJQUFLLE9BQVF6QyxDQUFBQSxLQUFLcEIsSUFBSSxJQUFJLEVBQUMsSUFBSztRQUU3RDtRQUVBdEM7UUFDQSxPQUFPcUQ7SUFDVDtBQUNGO0FBRUEsb0JBQW9CO0FBQ3BCLG1HQUFtRztBQUNuRyxFQUFFO0FBQ0YsMkRBQTJEO0FBQzNELDBFQUEwRTtBQUMxRSxTQUFTO0FBQ1Q7Ozs7Ozs7OztDQVNDLEdBQ0QsU0FBU3dFLGNBQWNDLE1BQU0sRUFBRWhDLEtBQUssRUFBRUMsSUFBSTtJQUN4QyxNQUFNZ0MsYUFBYWpDLE1BQU1pQyxVQUFVO0lBQ25DLE1BQU1qRSxXQUFXZ0UsT0FBT2hFLFFBQVE7SUFDaEMsTUFBTTBELFVBQVUxQixNQUFNUSxhQUFhLENBQUNQO0lBQ3BDLE1BQU1JLGdCQUFnQkMsYUFBYUYsV0FBV0o7SUFDOUMsMEJBQTBCLEdBQzFCLE1BQU1rQyxVQUFVLEVBQUU7SUFDbEIsSUFBSXJCLFFBQVEsQ0FBQztJQUVib0IsV0FBVzVFLElBQUksQ0FBQyxDQUFDO0lBRWpCLE1BQU8sRUFBRXdELFFBQVE3QyxTQUFTZCxNQUFNLENBQUU7UUFDaEMsTUFBTWlGLFFBQVFuRSxRQUFRLENBQUM2QyxNQUFNO1FBRTdCb0IsVUFBVSxDQUFDQSxXQUFXL0UsTUFBTSxHQUFHLEVBQUUsR0FBRzJEO1FBRXBDLE1BQU11QixZQUFZO1lBQUNSLFFBQVE7WUFBTUMsT0FBTztZQUFNLEdBQUdILFFBQVFGLE9BQU8sRUFBRTtRQUFBO1FBRWxFLE1BQU1ULFNBQVNmLE1BQU1xQyxNQUFNLENBQUNGLE9BQU9ILFFBQVFoQyxPQUFPb0M7UUFFbEQsTUFBTUUsa0JBQ0pILE1BQU03RSxJQUFJLEtBQUssc0JBQ1h5RCxTQUNBZixNQUFNdUMsV0FBVyxDQUFDeEIsUUFBUSxTQUFVOUUsSUFBSSxFQUFFOEQsQ0FBQyxFQUFFeUMsS0FBSztZQUNoRCxPQUFPLENBQUNBLFFBQVEsS0FBS25DLGFBQVksSUFBS3BFO1FBQ3hDO1FBRU5pRyxRQUFRN0UsSUFBSSxDQUFDcUUsUUFBUWQsSUFBSSxDQUFDMEI7UUFFMUIsSUFBSUgsTUFBTTdFLElBQUksS0FBSyxRQUFRO1lBQ3pCMEMsTUFBTXlDLGNBQWMsR0FBR2hHO1FBQ3pCO1FBRUEsSUFBSW9FLFFBQVE3QyxTQUFTZCxNQUFNLEdBQUcsR0FBRztZQUMvQmdGLFFBQVE3RSxJQUFJLENBQUNxRSxRQUFRZCxJQUFJLENBQUM7UUFDNUI7SUFDRjtJQUVBcUIsV0FBV2xFLEdBQUc7SUFFZCxPQUFPbUUsUUFBUVosSUFBSSxDQUFDO0FBQ3RCO0FBRUE7OztDQUdDLEdBQ0QsU0FBU2xCLFdBQVdKLEtBQUs7SUFDdkIsSUFBSUcsUUFBUTtJQUNaLElBQUlVLFFBQVFiLE1BQU0vQyxLQUFLLENBQUNDLE1BQU07SUFFOUIsTUFBTyxFQUFFMkQsUUFBUSxDQUFDLEVBQUc7UUFDbkIsTUFBTXJFLE9BQU93RCxNQUFNL0MsS0FBSyxDQUFDNEQsTUFBTTtRQUUvQixJQUFJckUsU0FBUyxnQkFBZ0JBLFNBQVMsWUFBWTtRQUNsRCxJQUFJQSxTQUFTLHFCQUFxQjJEO0lBQ3BDO0lBRUEsT0FBT0E7QUFDVDtBQUVBOzs7Q0FHQyxHQUNELFNBQVNHLGFBQWFILEtBQUs7SUFDekIsT0FBT3pILE9BQU9nSyxNQUFNLENBQUN2QztBQUN2QjtBQUVBOztDQUVDLEdBQ0QsU0FBU2Q7SUFDUCxPQUFPO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zb2xhbmEtbGlxdWlkaXR5LXBvb2wvLi9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1tZHgtanN4L2xpYi9pbmRleC5qcz85NzUxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGltcG9ydCB7Q29tcGlsZUNvbnRleHQsIEV4dGVuc2lvbiBhcyBGcm9tTWFya2Rvd25FeHRlbnNpb24sIEhhbmRsZSBhcyBGcm9tTWFya2Rvd25IYW5kbGUsIE9uRW50ZXJFcnJvciwgT25FeGl0RXJyb3IsIFRva2VufSBmcm9tICdtZGFzdC11dGlsLWZyb20tbWFya2Rvd24nXG4gKiBAaW1wb3J0IHtIYW5kbGUgYXMgVG9NYXJrZG93bkhhbmRsZSwgT3B0aW9ucyBhcyBUb01hcmtkb3duRXh0ZW5zaW9uLCBTdGF0ZSwgVHJhY2tlcn0gZnJvbSAnbWRhc3QtdXRpbC10by1tYXJrZG93bidcbiAqIEBpbXBvcnQge1BvaW50fSBmcm9tICd1bmlzdCdcbiAqIEBpbXBvcnQge01keEpzeEF0dHJpYnV0ZSwgTWR4SnN4QXR0cmlidXRlVmFsdWVFeHByZXNzaW9uLCBNZHhKc3hFeHByZXNzaW9uQXR0cmlidXRlLCBNZHhKc3hGbG93RWxlbWVudCwgTWR4SnN4VGV4dEVsZW1lbnR9IGZyb20gJy4uL2luZGV4LmpzJ1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYgVGFnXG4gKiAgIFNpbmdsZSB0YWcuXG4gKiBAcHJvcGVydHkge3N0cmluZyB8IHVuZGVmaW5lZH0gbmFtZVxuICogICBOYW1lIG9mIHRhZywgb3IgYHVuZGVmaW5lZGAgZm9yIGZyYWdtZW50LlxuICpcbiAqICAgPiDwn5GJICoqTm90ZSoqOiBgbnVsbGAgaXMgdXNlZCBpbiB0aGUgQVNUIGZvciBmcmFnbWVudHMsIGFzIGl0IHNlcmlhbGl6ZXMgaW5cbiAqICAgPiBKU09OLlxuICogQHByb3BlcnR5IHtBcnJheTxNZHhKc3hBdHRyaWJ1dGUgfCBNZHhKc3hFeHByZXNzaW9uQXR0cmlidXRlPn0gYXR0cmlidXRlc1xuICogICBBdHRyaWJ1dGVzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBjbG9zZVxuICogICBXaGV0aGVyIHRoZSB0YWcgaXMgY2xvc2luZyAoYDwveD5gKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc2VsZkNsb3NpbmdcbiAqICAgV2hldGhlciB0aGUgdGFnIGlzIHNlbGYtY2xvc2luZyAoYDx4Lz5gKS5cbiAqIEBwcm9wZXJ0eSB7VG9rZW5bJ3N0YXJ0J119IHN0YXJ0XG4gKiAgIFN0YXJ0IHBvaW50LlxuICogQHByb3BlcnR5IHtUb2tlblsnc3RhcnQnXX0gZW5kXG4gKiAgIEVuZCBwb2ludC5cbiAqXG4gKiBAdHlwZWRlZiBUb01hcmtkb3duT3B0aW9uc1xuICogICBDb25maWd1cmF0aW9uLlxuICogQHByb3BlcnR5IHsnXCInIHwgXCInXCIgfCBudWxsIHwgdW5kZWZpbmVkfSBbcXVvdGU9J1wiJ11cbiAqICAgUHJlZmVycmVkIHF1b3RlIHRvIHVzZSBhcm91bmQgYXR0cmlidXRlIHZhbHVlcyAoZGVmYXVsdDogYCdcIidgKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWR9IFtxdW90ZVNtYXJ0PWZhbHNlXVxuICogICBVc2UgdGhlIG90aGVyIHF1b3RlIGlmIHRoYXQgcmVzdWx0cyBpbiBsZXNzIGJ5dGVzIChkZWZhdWx0OiBgZmFsc2VgKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWR9IFt0aWdodFNlbGZDbG9zaW5nPWZhbHNlXVxuICogICBEbyBub3QgdXNlIGFuIGV4dHJhIHNwYWNlIHdoZW4gY2xvc2luZyBzZWxmLWNsb3NpbmcgZWxlbWVudHM6IGA8aW1nLz5gXG4gKiAgIGluc3RlYWQgb2YgYDxpbWcgLz5gIChkZWZhdWx0OiBgZmFsc2VgKS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3ByaW50V2lkdGg9SW5maW5pdHldXG4gKiAgIFRyeSBhbmQgd3JhcCBzeW50YXggYXQgdGhpcyB3aWR0aCAoZGVmYXVsdDogYEluZmluaXR5YCkuXG4gKlxuICogICBXaGVuIHNldCB0byBhIGZpbml0ZSBudW1iZXIgKHNheSwgYDgwYCksIHRoZSBmb3JtYXR0ZXIgd2lsbCBwcmludFxuICogICBhdHRyaWJ1dGVzIG9uIHNlcGFyYXRlIGxpbmVzIHdoZW4gYSB0YWcgZG9lc27igJl0IGZpdCBvbiBvbmUgbGluZS5cbiAqICAgVGhlIG5vcm1hbCBiZWhhdmlvciBpcyB0byBwcmludCBhdHRyaWJ1dGVzIHdpdGggc3BhY2VzIGJldHdlZW4gdGhlbVxuICogICBpbnN0ZWFkIG9mIGxpbmUgZW5kaW5ncy5cbiAqL1xuXG5pbXBvcnQge2Njb3VudH0gZnJvbSAnY2NvdW50J1xuaW1wb3J0IHtvayBhcyBhc3NlcnR9IGZyb20gJ2RldmxvcCdcbmltcG9ydCB7cGFyc2VFbnRpdGllc30gZnJvbSAncGFyc2UtZW50aXRpZXMnXG5pbXBvcnQge3N0cmluZ2lmeUVudGl0aWVzTGlnaHR9IGZyb20gJ3N0cmluZ2lmeS1lbnRpdGllcydcbmltcG9ydCB7c3RyaW5naWZ5UG9zaXRpb259IGZyb20gJ3VuaXN0LXV0aWwtc3RyaW5naWZ5LXBvc2l0aW9uJ1xuaW1wb3J0IHtWRmlsZU1lc3NhZ2V9IGZyb20gJ3ZmaWxlLW1lc3NhZ2UnXG5cbmNvbnN0IGluZGVudCA9ICcgICdcblxuLyoqXG4gKiBDcmVhdGUgYW4gZXh0ZW5zaW9uIGZvciBgbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duYCB0byBlbmFibGUgTURYIEpTWC5cbiAqXG4gKiBAcmV0dXJucyB7RnJvbU1hcmtkb3duRXh0ZW5zaW9ufVxuICogICBFeHRlbnNpb24gZm9yIGBtZGFzdC11dGlsLWZyb20tbWFya2Rvd25gIHRvIGVuYWJsZSBNRFggSlNYLlxuICpcbiAqICAgV2hlbiB1c2luZyB0aGUgc3ludGF4IGV4dGVuc2lvbiB3aXRoIGBhZGRSZXN1bHRgLCBub2RlcyB3aWxsIGhhdmUgYVxuICogICBgZGF0YS5lc3RyZWVgIGZpZWxkIHNldCB0byBhbiBFU1RyZWUgYFByb2dyYW1gIG5vZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZHhKc3hGcm9tTWFya2Rvd24oKSB7XG4gIHJldHVybiB7XG4gICAgY2FuQ29udGFpbkVvbHM6IFsnbWR4SnN4VGV4dEVsZW1lbnQnXSxcbiAgICBlbnRlcjoge1xuICAgICAgbWR4SnN4Rmxvd1RhZzogZW50ZXJNZHhKc3hUYWcsXG4gICAgICBtZHhKc3hGbG93VGFnQ2xvc2luZ01hcmtlcjogZW50ZXJNZHhKc3hUYWdDbG9zaW5nTWFya2VyLFxuICAgICAgbWR4SnN4Rmxvd1RhZ0F0dHJpYnV0ZTogZW50ZXJNZHhKc3hUYWdBdHRyaWJ1dGUsXG4gICAgICBtZHhKc3hGbG93VGFnRXhwcmVzc2lvbkF0dHJpYnV0ZTogZW50ZXJNZHhKc3hUYWdFeHByZXNzaW9uQXR0cmlidXRlLFxuICAgICAgbWR4SnN4Rmxvd1RhZ0F0dHJpYnV0ZVZhbHVlTGl0ZXJhbDogYnVmZmVyLFxuICAgICAgbWR4SnN4Rmxvd1RhZ0F0dHJpYnV0ZVZhbHVlRXhwcmVzc2lvbjogYnVmZmVyLFxuICAgICAgbWR4SnN4Rmxvd1RhZ1NlbGZDbG9zaW5nTWFya2VyOiBlbnRlck1keEpzeFRhZ1NlbGZDbG9zaW5nTWFya2VyLFxuXG4gICAgICBtZHhKc3hUZXh0VGFnOiBlbnRlck1keEpzeFRhZyxcbiAgICAgIG1keEpzeFRleHRUYWdDbG9zaW5nTWFya2VyOiBlbnRlck1keEpzeFRhZ0Nsb3NpbmdNYXJrZXIsXG4gICAgICBtZHhKc3hUZXh0VGFnQXR0cmlidXRlOiBlbnRlck1keEpzeFRhZ0F0dHJpYnV0ZSxcbiAgICAgIG1keEpzeFRleHRUYWdFeHByZXNzaW9uQXR0cmlidXRlOiBlbnRlck1keEpzeFRhZ0V4cHJlc3Npb25BdHRyaWJ1dGUsXG4gICAgICBtZHhKc3hUZXh0VGFnQXR0cmlidXRlVmFsdWVMaXRlcmFsOiBidWZmZXIsXG4gICAgICBtZHhKc3hUZXh0VGFnQXR0cmlidXRlVmFsdWVFeHByZXNzaW9uOiBidWZmZXIsXG4gICAgICBtZHhKc3hUZXh0VGFnU2VsZkNsb3NpbmdNYXJrZXI6IGVudGVyTWR4SnN4VGFnU2VsZkNsb3NpbmdNYXJrZXJcbiAgICB9LFxuICAgIGV4aXQ6IHtcbiAgICAgIG1keEpzeEZsb3dUYWdDbG9zaW5nTWFya2VyOiBleGl0TWR4SnN4VGFnQ2xvc2luZ01hcmtlcixcbiAgICAgIG1keEpzeEZsb3dUYWdOYW1lUHJpbWFyeTogZXhpdE1keEpzeFRhZ05hbWVQcmltYXJ5LFxuICAgICAgbWR4SnN4Rmxvd1RhZ05hbWVNZW1iZXI6IGV4aXRNZHhKc3hUYWdOYW1lTWVtYmVyLFxuICAgICAgbWR4SnN4Rmxvd1RhZ05hbWVMb2NhbDogZXhpdE1keEpzeFRhZ05hbWVMb2NhbCxcbiAgICAgIG1keEpzeEZsb3dUYWdFeHByZXNzaW9uQXR0cmlidXRlOiBleGl0TWR4SnN4VGFnRXhwcmVzc2lvbkF0dHJpYnV0ZSxcbiAgICAgIG1keEpzeEZsb3dUYWdFeHByZXNzaW9uQXR0cmlidXRlVmFsdWU6IGRhdGEsXG4gICAgICBtZHhKc3hGbG93VGFnQXR0cmlidXRlTmFtZVByaW1hcnk6IGV4aXRNZHhKc3hUYWdBdHRyaWJ1dGVOYW1lUHJpbWFyeSxcbiAgICAgIG1keEpzeEZsb3dUYWdBdHRyaWJ1dGVOYW1lTG9jYWw6IGV4aXRNZHhKc3hUYWdBdHRyaWJ1dGVOYW1lTG9jYWwsXG4gICAgICBtZHhKc3hGbG93VGFnQXR0cmlidXRlVmFsdWVMaXRlcmFsOiBleGl0TWR4SnN4VGFnQXR0cmlidXRlVmFsdWVMaXRlcmFsLFxuICAgICAgbWR4SnN4Rmxvd1RhZ0F0dHJpYnV0ZVZhbHVlTGl0ZXJhbFZhbHVlOiBkYXRhLFxuICAgICAgbWR4SnN4Rmxvd1RhZ0F0dHJpYnV0ZVZhbHVlRXhwcmVzc2lvbjpcbiAgICAgICAgZXhpdE1keEpzeFRhZ0F0dHJpYnV0ZVZhbHVlRXhwcmVzc2lvbixcbiAgICAgIG1keEpzeEZsb3dUYWdBdHRyaWJ1dGVWYWx1ZUV4cHJlc3Npb25WYWx1ZTogZGF0YSxcbiAgICAgIG1keEpzeEZsb3dUYWdTZWxmQ2xvc2luZ01hcmtlcjogZXhpdE1keEpzeFRhZ1NlbGZDbG9zaW5nTWFya2VyLFxuICAgICAgbWR4SnN4Rmxvd1RhZzogZXhpdE1keEpzeFRhZyxcblxuICAgICAgbWR4SnN4VGV4dFRhZ0Nsb3NpbmdNYXJrZXI6IGV4aXRNZHhKc3hUYWdDbG9zaW5nTWFya2VyLFxuICAgICAgbWR4SnN4VGV4dFRhZ05hbWVQcmltYXJ5OiBleGl0TWR4SnN4VGFnTmFtZVByaW1hcnksXG4gICAgICBtZHhKc3hUZXh0VGFnTmFtZU1lbWJlcjogZXhpdE1keEpzeFRhZ05hbWVNZW1iZXIsXG4gICAgICBtZHhKc3hUZXh0VGFnTmFtZUxvY2FsOiBleGl0TWR4SnN4VGFnTmFtZUxvY2FsLFxuICAgICAgbWR4SnN4VGV4dFRhZ0V4cHJlc3Npb25BdHRyaWJ1dGU6IGV4aXRNZHhKc3hUYWdFeHByZXNzaW9uQXR0cmlidXRlLFxuICAgICAgbWR4SnN4VGV4dFRhZ0V4cHJlc3Npb25BdHRyaWJ1dGVWYWx1ZTogZGF0YSxcbiAgICAgIG1keEpzeFRleHRUYWdBdHRyaWJ1dGVOYW1lUHJpbWFyeTogZXhpdE1keEpzeFRhZ0F0dHJpYnV0ZU5hbWVQcmltYXJ5LFxuICAgICAgbWR4SnN4VGV4dFRhZ0F0dHJpYnV0ZU5hbWVMb2NhbDogZXhpdE1keEpzeFRhZ0F0dHJpYnV0ZU5hbWVMb2NhbCxcbiAgICAgIG1keEpzeFRleHRUYWdBdHRyaWJ1dGVWYWx1ZUxpdGVyYWw6IGV4aXRNZHhKc3hUYWdBdHRyaWJ1dGVWYWx1ZUxpdGVyYWwsXG4gICAgICBtZHhKc3hUZXh0VGFnQXR0cmlidXRlVmFsdWVMaXRlcmFsVmFsdWU6IGRhdGEsXG4gICAgICBtZHhKc3hUZXh0VGFnQXR0cmlidXRlVmFsdWVFeHByZXNzaW9uOlxuICAgICAgICBleGl0TWR4SnN4VGFnQXR0cmlidXRlVmFsdWVFeHByZXNzaW9uLFxuICAgICAgbWR4SnN4VGV4dFRhZ0F0dHJpYnV0ZVZhbHVlRXhwcmVzc2lvblZhbHVlOiBkYXRhLFxuICAgICAgbWR4SnN4VGV4dFRhZ1NlbGZDbG9zaW5nTWFya2VyOiBleGl0TWR4SnN4VGFnU2VsZkNsb3NpbmdNYXJrZXIsXG4gICAgICBtZHhKc3hUZXh0VGFnOiBleGl0TWR4SnN4VGFnXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIGJ1ZmZlcigpIHtcbiAgICB0aGlzLmJ1ZmZlcigpXG4gIH1cblxuICAvKipcbiAgICogQ29weSBhIHBvaW50LWxpa2UgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UG9pbnR9IGRcbiAgICogICBQb2ludC1saWtlIHZhbHVlLlxuICAgKiBAcmV0dXJucyB7UG9pbnR9XG4gICAqICAgdW5pc3QgcG9pbnQuXG4gICAqL1xuICBmdW5jdGlvbiBwb2ludChkKSB7XG4gICAgcmV0dXJuIHtsaW5lOiBkLmxpbmUsIGNvbHVtbjogZC5jb2x1bW4sIG9mZnNldDogZC5vZmZzZXR9XG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gZGF0YSh0b2tlbikge1xuICAgIHRoaXMuY29uZmlnLmVudGVyLmRhdGEuY2FsbCh0aGlzLCB0b2tlbilcbiAgICB0aGlzLmNvbmZpZy5leGl0LmRhdGEuY2FsbCh0aGlzLCB0b2tlbilcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBlbnRlck1keEpzeFRhZyh0b2tlbikge1xuICAgIC8qKiBAdHlwZSB7VGFnfSAqL1xuICAgIGNvbnN0IHRhZyA9IHtcbiAgICAgIG5hbWU6IHVuZGVmaW5lZCxcbiAgICAgIGF0dHJpYnV0ZXM6IFtdLFxuICAgICAgY2xvc2U6IGZhbHNlLFxuICAgICAgc2VsZkNsb3Npbmc6IGZhbHNlLFxuICAgICAgc3RhcnQ6IHRva2VuLnN0YXJ0LFxuICAgICAgZW5kOiB0b2tlbi5lbmRcbiAgICB9XG4gICAgaWYgKCF0aGlzLmRhdGEubWR4SnN4VGFnU3RhY2spIHRoaXMuZGF0YS5tZHhKc3hUYWdTdGFjayA9IFtdXG4gICAgdGhpcy5kYXRhLm1keEpzeFRhZyA9IHRhZ1xuICAgIHRoaXMuYnVmZmVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBlbnRlck1keEpzeFRhZ0Nsb3NpbmdNYXJrZXIodG9rZW4pIHtcbiAgICBjb25zdCBzdGFjayA9IHRoaXMuZGF0YS5tZHhKc3hUYWdTdGFja1xuICAgIGFzc2VydChzdGFjaywgJ2V4cGVjdGVkIGBtZHhKc3hUYWdTdGFja2AnKVxuXG4gICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFZGaWxlTWVzc2FnZShcbiAgICAgICAgJ1VuZXhwZWN0ZWQgY2xvc2luZyBzbGFzaCBgL2AgaW4gdGFnLCBleHBlY3RlZCBhbiBvcGVuIHRhZyBmaXJzdCcsXG4gICAgICAgIHtzdGFydDogdG9rZW4uc3RhcnQsIGVuZDogdG9rZW4uZW5kfSxcbiAgICAgICAgJ21kYXN0LXV0aWwtbWR4LWpzeDp1bmV4cGVjdGVkLWNsb3Npbmctc2xhc2gnXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIGVudGVyTWR4SnN4VGFnQW55QXR0cmlidXRlKHRva2VuKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy5kYXRhLm1keEpzeFRhZ1xuICAgIGFzc2VydCh0YWcsICdleHBlY3RlZCBgbWR4SnN4VGFnYCcpXG5cbiAgICBpZiAodGFnLmNsb3NlKSB7XG4gICAgICB0aHJvdyBuZXcgVkZpbGVNZXNzYWdlKFxuICAgICAgICAnVW5leHBlY3RlZCBhdHRyaWJ1dGUgaW4gY2xvc2luZyB0YWcsIGV4cGVjdGVkIHRoZSBlbmQgb2YgdGhlIHRhZycsXG4gICAgICAgIHtzdGFydDogdG9rZW4uc3RhcnQsIGVuZDogdG9rZW4uZW5kfSxcbiAgICAgICAgJ21kYXN0LXV0aWwtbWR4LWpzeDp1bmV4cGVjdGVkLWF0dHJpYnV0ZSdcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gZW50ZXJNZHhKc3hUYWdTZWxmQ2xvc2luZ01hcmtlcih0b2tlbikge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMuZGF0YS5tZHhKc3hUYWdcbiAgICBhc3NlcnQodGFnLCAnZXhwZWN0ZWQgYG1keEpzeFRhZ2AnKVxuXG4gICAgaWYgKHRhZy5jbG9zZSkge1xuICAgICAgdGhyb3cgbmV3IFZGaWxlTWVzc2FnZShcbiAgICAgICAgJ1VuZXhwZWN0ZWQgc2VsZi1jbG9zaW5nIHNsYXNoIGAvYCBpbiBjbG9zaW5nIHRhZywgZXhwZWN0ZWQgdGhlIGVuZCBvZiB0aGUgdGFnJyxcbiAgICAgICAge3N0YXJ0OiB0b2tlbi5zdGFydCwgZW5kOiB0b2tlbi5lbmR9LFxuICAgICAgICAnbWRhc3QtdXRpbC1tZHgtanN4OnVuZXhwZWN0ZWQtc2VsZi1jbG9zaW5nLXNsYXNoJ1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBleGl0TWR4SnN4VGFnQ2xvc2luZ01hcmtlcigpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLmRhdGEubWR4SnN4VGFnXG4gICAgYXNzZXJ0KHRhZywgJ2V4cGVjdGVkIGBtZHhKc3hUYWdgJylcbiAgICB0YWcuY2xvc2UgPSB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gZXhpdE1keEpzeFRhZ05hbWVQcmltYXJ5KHRva2VuKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy5kYXRhLm1keEpzeFRhZ1xuICAgIGFzc2VydCh0YWcsICdleHBlY3RlZCBgbWR4SnN4VGFnYCcpXG4gICAgdGFnLm5hbWUgPSB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIGV4aXRNZHhKc3hUYWdOYW1lTWVtYmVyKHRva2VuKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy5kYXRhLm1keEpzeFRhZ1xuICAgIGFzc2VydCh0YWcsICdleHBlY3RlZCBgbWR4SnN4VGFnYCcpXG4gICAgdGFnLm5hbWUgKz0gJy4nICsgdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbilcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBleGl0TWR4SnN4VGFnTmFtZUxvY2FsKHRva2VuKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy5kYXRhLm1keEpzeFRhZ1xuICAgIGFzc2VydCh0YWcsICdleHBlY3RlZCBgbWR4SnN4VGFnYCcpXG4gICAgdGFnLm5hbWUgKz0gJzonICsgdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbilcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBlbnRlck1keEpzeFRhZ0F0dHJpYnV0ZSh0b2tlbikge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMuZGF0YS5tZHhKc3hUYWdcbiAgICBhc3NlcnQodGFnLCAnZXhwZWN0ZWQgYG1keEpzeFRhZ2AnKVxuICAgIGVudGVyTWR4SnN4VGFnQW55QXR0cmlidXRlLmNhbGwodGhpcywgdG9rZW4pXG4gICAgdGFnLmF0dHJpYnV0ZXMucHVzaCh7XG4gICAgICB0eXBlOiAnbWR4SnN4QXR0cmlidXRlJyxcbiAgICAgIG5hbWU6ICcnLFxuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBwb3NpdGlvbjoge1xuICAgICAgICBzdGFydDogcG9pbnQodG9rZW4uc3RhcnQpLFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBgZW5kYCB3aWxsIGJlIHBhdGNoZWQgbGF0ZXIuXG4gICAgICAgIGVuZDogdW5kZWZpbmVkXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBlbnRlck1keEpzeFRhZ0V4cHJlc3Npb25BdHRyaWJ1dGUodG9rZW4pIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLmRhdGEubWR4SnN4VGFnXG4gICAgYXNzZXJ0KHRhZywgJ2V4cGVjdGVkIGBtZHhKc3hUYWdgJylcbiAgICBlbnRlck1keEpzeFRhZ0FueUF0dHJpYnV0ZS5jYWxsKHRoaXMsIHRva2VuKVxuICAgIHRhZy5hdHRyaWJ1dGVzLnB1c2goe1xuICAgICAgdHlwZTogJ21keEpzeEV4cHJlc3Npb25BdHRyaWJ1dGUnLFxuICAgICAgdmFsdWU6ICcnLFxuICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgc3RhcnQ6IHBvaW50KHRva2VuLnN0YXJ0KSxcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogYGVuZGAgd2lsbCBiZSBwYXRjaGVkIGxhdGVyLlxuICAgICAgICBlbmQ6IHVuZGVmaW5lZFxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5idWZmZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIGV4aXRNZHhKc3hUYWdFeHByZXNzaW9uQXR0cmlidXRlKHRva2VuKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy5kYXRhLm1keEpzeFRhZ1xuICAgIGFzc2VydCh0YWcsICdleHBlY3RlZCBgbWR4SnN4VGFnYCcpXG4gICAgY29uc3QgdGFpbCA9IHRhZy5hdHRyaWJ1dGVzW3RhZy5hdHRyaWJ1dGVzLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KHRhaWwudHlwZSA9PT0gJ21keEpzeEV4cHJlc3Npb25BdHRyaWJ1dGUnKVxuICAgIGNvbnN0IGVzdHJlZSA9IHRva2VuLmVzdHJlZVxuXG4gICAgdGFpbC52YWx1ZSA9IHRoaXMucmVzdW1lKClcbiAgICBhc3NlcnQodGFpbC5wb3NpdGlvbiAhPT0gdW5kZWZpbmVkKVxuICAgIHRhaWwucG9zaXRpb24uZW5kID0gcG9pbnQodG9rZW4uZW5kKVxuXG4gICAgaWYgKGVzdHJlZSkge1xuICAgICAgdGFpbC5kYXRhID0ge2VzdHJlZX1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gZXhpdE1keEpzeFRhZ0F0dHJpYnV0ZU5hbWVQcmltYXJ5KHRva2VuKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy5kYXRhLm1keEpzeFRhZ1xuICAgIGFzc2VydCh0YWcsICdleHBlY3RlZCBgbWR4SnN4VGFnYCcpXG4gICAgY29uc3Qgbm9kZSA9IHRhZy5hdHRyaWJ1dGVzW3RhZy5hdHRyaWJ1dGVzLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ21keEpzeEF0dHJpYnV0ZScpXG4gICAgbm9kZS5uYW1lID0gdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbilcbiAgICBhc3NlcnQobm9kZS5wb3NpdGlvbiAhPT0gdW5kZWZpbmVkKVxuICAgIG5vZGUucG9zaXRpb24uZW5kID0gcG9pbnQodG9rZW4uZW5kKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIGV4aXRNZHhKc3hUYWdBdHRyaWJ1dGVOYW1lTG9jYWwodG9rZW4pIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLmRhdGEubWR4SnN4VGFnXG4gICAgYXNzZXJ0KHRhZywgJ2V4cGVjdGVkIGBtZHhKc3hUYWdgJylcbiAgICBjb25zdCBub2RlID0gdGFnLmF0dHJpYnV0ZXNbdGFnLmF0dHJpYnV0ZXMubGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZS50eXBlID09PSAnbWR4SnN4QXR0cmlidXRlJylcbiAgICBub2RlLm5hbWUgKz0gJzonICsgdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbilcbiAgICBhc3NlcnQobm9kZS5wb3NpdGlvbiAhPT0gdW5kZWZpbmVkKVxuICAgIG5vZGUucG9zaXRpb24uZW5kID0gcG9pbnQodG9rZW4uZW5kKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIGV4aXRNZHhKc3hUYWdBdHRyaWJ1dGVWYWx1ZUxpdGVyYWwodG9rZW4pIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLmRhdGEubWR4SnN4VGFnXG4gICAgYXNzZXJ0KHRhZywgJ2V4cGVjdGVkIGBtZHhKc3hUYWdgJylcbiAgICBjb25zdCBub2RlID0gdGFnLmF0dHJpYnV0ZXNbdGFnLmF0dHJpYnV0ZXMubGVuZ3RoIC0gMV1cbiAgICBub2RlLnZhbHVlID0gcGFyc2VFbnRpdGllcyh0aGlzLnJlc3VtZSgpLCB7bm9uVGVybWluYXRlZDogZmFsc2V9KVxuICAgIGFzc2VydChub2RlLnBvc2l0aW9uICE9PSB1bmRlZmluZWQpXG4gICAgbm9kZS5wb3NpdGlvbi5lbmQgPSBwb2ludCh0b2tlbi5lbmQpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gZXhpdE1keEpzeFRhZ0F0dHJpYnV0ZVZhbHVlRXhwcmVzc2lvbih0b2tlbikge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMuZGF0YS5tZHhKc3hUYWdcbiAgICBhc3NlcnQodGFnLCAnZXhwZWN0ZWQgYG1keEpzeFRhZ2AnKVxuICAgIGNvbnN0IHRhaWwgPSB0YWcuYXR0cmlidXRlc1t0YWcuYXR0cmlidXRlcy5sZW5ndGggLSAxXVxuICAgIGFzc2VydCh0YWlsLnR5cGUgPT09ICdtZHhKc3hBdHRyaWJ1dGUnKVxuICAgIC8qKiBAdHlwZSB7TWR4SnN4QXR0cmlidXRlVmFsdWVFeHByZXNzaW9ufSAqL1xuICAgIGNvbnN0IG5vZGUgPSB7dHlwZTogJ21keEpzeEF0dHJpYnV0ZVZhbHVlRXhwcmVzc2lvbicsIHZhbHVlOiB0aGlzLnJlc3VtZSgpfVxuICAgIGNvbnN0IGVzdHJlZSA9IHRva2VuLmVzdHJlZVxuXG4gICAgaWYgKGVzdHJlZSkge1xuICAgICAgbm9kZS5kYXRhID0ge2VzdHJlZX1cbiAgICB9XG5cbiAgICB0YWlsLnZhbHVlID0gbm9kZVxuICAgIGFzc2VydCh0YWlsLnBvc2l0aW9uICE9PSB1bmRlZmluZWQpXG4gICAgdGFpbC5wb3NpdGlvbi5lbmQgPSBwb2ludCh0b2tlbi5lbmQpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gZXhpdE1keEpzeFRhZ1NlbGZDbG9zaW5nTWFya2VyKCkge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMuZGF0YS5tZHhKc3hUYWdcbiAgICBhc3NlcnQodGFnLCAnZXhwZWN0ZWQgYG1keEpzeFRhZ2AnKVxuXG4gICAgdGFnLnNlbGZDbG9zaW5nID0gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIGV4aXRNZHhKc3hUYWcodG9rZW4pIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLmRhdGEubWR4SnN4VGFnXG4gICAgYXNzZXJ0KHRhZywgJ2V4cGVjdGVkIGBtZHhKc3hUYWdgJylcbiAgICBjb25zdCBzdGFjayA9IHRoaXMuZGF0YS5tZHhKc3hUYWdTdGFja1xuICAgIGFzc2VydChzdGFjaywgJ2V4cGVjdGVkIGBtZHhKc3hUYWdTdGFja2AnKVxuICAgIGNvbnN0IHRhaWwgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXVxuXG4gICAgaWYgKHRhZy5jbG9zZSAmJiB0YWlsLm5hbWUgIT09IHRhZy5uYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgVkZpbGVNZXNzYWdlKFxuICAgICAgICAnVW5leHBlY3RlZCBjbG9zaW5nIHRhZyBgJyArXG4gICAgICAgICAgc2VyaWFsaXplQWJicmV2aWF0ZWRUYWcodGFnKSArXG4gICAgICAgICAgJ2AsIGV4cGVjdGVkIGNvcnJlc3BvbmRpbmcgY2xvc2luZyB0YWcgZm9yIGAnICtcbiAgICAgICAgICBzZXJpYWxpemVBYmJyZXZpYXRlZFRhZyh0YWlsKSArXG4gICAgICAgICAgJ2AgKCcgK1xuICAgICAgICAgIHN0cmluZ2lmeVBvc2l0aW9uKHRhaWwpICtcbiAgICAgICAgICAnKScsXG4gICAgICAgIHtzdGFydDogdG9rZW4uc3RhcnQsIGVuZDogdG9rZW4uZW5kfSxcbiAgICAgICAgJ21kYXN0LXV0aWwtbWR4LWpzeDplbmQtdGFnLW1pc21hdGNoJ1xuICAgICAgKVxuICAgIH1cblxuICAgIC8vIEVuZCBvZiBhIHRhZywgc28gZHJvcCB0aGUgYnVmZmVyLlxuICAgIHRoaXMucmVzdW1lKClcblxuICAgIGlmICh0YWcuY2xvc2UpIHtcbiAgICAgIHN0YWNrLnBvcCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW50ZXIoXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOlxuICAgICAgICAgICAgdG9rZW4udHlwZSA9PT0gJ21keEpzeFRleHRUYWcnXG4gICAgICAgICAgICAgID8gJ21keEpzeFRleHRFbGVtZW50J1xuICAgICAgICAgICAgICA6ICdtZHhKc3hGbG93RWxlbWVudCcsXG4gICAgICAgICAgbmFtZTogdGFnLm5hbWUgfHwgbnVsbCxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB0YWcuYXR0cmlidXRlcyxcbiAgICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgICAgfSxcbiAgICAgICAgdG9rZW4sXG4gICAgICAgIG9uRXJyb3JSaWdodElzVGFnXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKHRhZy5zZWxmQ2xvc2luZyB8fCB0YWcuY2xvc2UpIHtcbiAgICAgIHRoaXMuZXhpdCh0b2tlbiwgb25FcnJvckxlZnRJc1RhZylcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhY2sucHVzaCh0YWcpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge09uRW50ZXJFcnJvcn1cbiAgICovXG4gIGZ1bmN0aW9uIG9uRXJyb3JSaWdodElzVGFnKGNsb3NpbmcsIG9wZW4pIHtcbiAgICBjb25zdCBzdGFjayA9IHRoaXMuZGF0YS5tZHhKc3hUYWdTdGFja1xuICAgIGFzc2VydChzdGFjaywgJ2V4cGVjdGVkIGBtZHhKc3hUYWdTdGFja2AnKVxuICAgIGNvbnN0IHRhZyA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KHRhZywgJ2V4cGVjdGVkIGBtZHhKc3hUYWdgJylcbiAgICBjb25zdCBwbGFjZSA9IGNsb3NpbmcgPyAnIGJlZm9yZSB0aGUgZW5kIG9mIGAnICsgY2xvc2luZy50eXBlICsgJ2AnIDogJydcbiAgICBjb25zdCBwb3NpdGlvbiA9IGNsb3NpbmdcbiAgICAgID8ge3N0YXJ0OiBjbG9zaW5nLnN0YXJ0LCBlbmQ6IGNsb3NpbmcuZW5kfVxuICAgICAgOiB1bmRlZmluZWRcblxuICAgIHRocm93IG5ldyBWRmlsZU1lc3NhZ2UoXG4gICAgICAnRXhwZWN0ZWQgYSBjbG9zaW5nIHRhZyBmb3IgYCcgK1xuICAgICAgICBzZXJpYWxpemVBYmJyZXZpYXRlZFRhZyh0YWcpICtcbiAgICAgICAgJ2AgKCcgK1xuICAgICAgICBzdHJpbmdpZnlQb3NpdGlvbih7c3RhcnQ6IG9wZW4uc3RhcnQsIGVuZDogb3Blbi5lbmR9KSArXG4gICAgICAgICcpJyArXG4gICAgICAgIHBsYWNlLFxuICAgICAgcG9zaXRpb24sXG4gICAgICAnbWRhc3QtdXRpbC1tZHgtanN4OmVuZC10YWctbWlzbWF0Y2gnXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge09uRXhpdEVycm9yfVxuICAgKi9cbiAgZnVuY3Rpb24gb25FcnJvckxlZnRJc1RhZyhhLCBiKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy5kYXRhLm1keEpzeFRhZ1xuICAgIGFzc2VydCh0YWcsICdleHBlY3RlZCBgbWR4SnN4VGFnYCcpXG5cbiAgICB0aHJvdyBuZXcgVkZpbGVNZXNzYWdlKFxuICAgICAgJ0V4cGVjdGVkIHRoZSBjbG9zaW5nIHRhZyBgJyArXG4gICAgICAgIHNlcmlhbGl6ZUFiYnJldmlhdGVkVGFnKHRhZykgK1xuICAgICAgICAnYCBlaXRoZXIgYWZ0ZXIgdGhlIGVuZCBvZiBgJyArXG4gICAgICAgIGIudHlwZSArXG4gICAgICAgICdgICgnICtcbiAgICAgICAgc3RyaW5naWZ5UG9zaXRpb24oYi5lbmQpICtcbiAgICAgICAgJykgb3IgYW5vdGhlciBvcGVuaW5nIHRhZyBhZnRlciB0aGUgc3RhcnQgb2YgYCcgK1xuICAgICAgICBiLnR5cGUgK1xuICAgICAgICAnYCAoJyArXG4gICAgICAgIHN0cmluZ2lmeVBvc2l0aW9uKGIuc3RhcnQpICtcbiAgICAgICAgJyknLFxuICAgICAge3N0YXJ0OiBhLnN0YXJ0LCBlbmQ6IGEuZW5kfSxcbiAgICAgICdtZGFzdC11dGlsLW1keC1qc3g6ZW5kLXRhZy1taXNtYXRjaCdcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplIGEgdGFnLCBleGNsdWRpbmcgYXR0cmlidXRlcy5cbiAgICogYHNlbGYtY2xvc2luZ2AgaXMgbm90IHN1cHBvcnRlZCwgYmVjYXVzZSB3ZSBkb27igJl0IG5lZWQgaXQgeWV0LlxuICAgKlxuICAgKiBAcGFyYW0ge1RhZ30gdGFnXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBmdW5jdGlvbiBzZXJpYWxpemVBYmJyZXZpYXRlZFRhZyh0YWcpIHtcbiAgICByZXR1cm4gJzwnICsgKHRhZy5jbG9zZSA/ICcvJyA6ICcnKSArICh0YWcubmFtZSB8fCAnJykgKyAnPidcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBleHRlbnNpb24gZm9yIGBtZGFzdC11dGlsLXRvLW1hcmtkb3duYCB0byBlbmFibGUgTURYIEpTWC5cbiAqXG4gKiBUaGlzIGV4dGVuc2lvbiBjb25maWd1cmVzIGBtZGFzdC11dGlsLXRvLW1hcmtkb3duYCB3aXRoXG4gKiBgb3B0aW9ucy5mZW5jZXM6IHRydWVgIGFuZCBgb3B0aW9ucy5yZXNvdXJjZUxpbms6IHRydWVgIHRvbywgZG8gbm90XG4gKiBvdmVyd3JpdGUgdGhlbSFcbiAqXG4gKiBAcGFyYW0ge1RvTWFya2Rvd25PcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdGlvbnNdXG4gKiAgIENvbmZpZ3VyYXRpb24gKG9wdGlvbmFsKS5cbiAqIEByZXR1cm5zIHtUb01hcmtkb3duRXh0ZW5zaW9ufVxuICogICBFeHRlbnNpb24gZm9yIGBtZGFzdC11dGlsLXRvLW1hcmtkb3duYCB0byBlbmFibGUgTURYIEpTWC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1keEpzeFRvTWFya2Rvd24ob3B0aW9ucykge1xuICBjb25zdCBvcHRpb25zXyA9IG9wdGlvbnMgfHwge31cbiAgY29uc3QgcXVvdGUgPSBvcHRpb25zXy5xdW90ZSB8fCAnXCInXG4gIGNvbnN0IHF1b3RlU21hcnQgPSBvcHRpb25zXy5xdW90ZVNtYXJ0IHx8IGZhbHNlXG4gIGNvbnN0IHRpZ2h0U2VsZkNsb3NpbmcgPSBvcHRpb25zXy50aWdodFNlbGZDbG9zaW5nIHx8IGZhbHNlXG4gIGNvbnN0IHByaW50V2lkdGggPSBvcHRpb25zXy5wcmludFdpZHRoIHx8IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxuICBjb25zdCBhbHRlcm5hdGl2ZSA9IHF1b3RlID09PSAnXCInID8gXCInXCIgOiAnXCInXG5cbiAgaWYgKHF1b3RlICE9PSAnXCInICYmIHF1b3RlICE9PSBcIidcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdDYW5ub3Qgc2VyaWFsaXplIGF0dHJpYnV0ZSB2YWx1ZXMgd2l0aCBgJyArXG4gICAgICAgIHF1b3RlICtcbiAgICAgICAgJ2AgZm9yIGBvcHRpb25zLnF1b3RlYCwgZXhwZWN0ZWQgYFwiYCwgb3IgYFxcJ2AnXG4gICAgKVxuICB9XG5cbiAgbWR4RWxlbWVudC5wZWVrID0gcGVla0VsZW1lbnRcblxuICByZXR1cm4ge1xuICAgIGhhbmRsZXJzOiB7XG4gICAgICBtZHhKc3hGbG93RWxlbWVudDogbWR4RWxlbWVudCxcbiAgICAgIG1keEpzeFRleHRFbGVtZW50OiBtZHhFbGVtZW50XG4gICAgfSxcbiAgICB1bnNhZmU6IFtcbiAgICAgIHtjaGFyYWN0ZXI6ICc8JywgaW5Db25zdHJ1Y3Q6IFsncGhyYXNpbmcnXX0sXG4gICAgICB7YXRCcmVhazogdHJ1ZSwgY2hhcmFjdGVyOiAnPCd9XG4gICAgXSxcbiAgICAvLyBBbHdheXMgZ2VuZXJhdGUgZmVuY2VkIGNvZGUgKG5ldmVyIGluZGVudGVkIGNvZGUpLlxuICAgIGZlbmNlczogdHJ1ZSxcbiAgICAvLyBBbHdheXMgZ2VuZXJhdGUgbGlua3Mgd2l0aCByZXNvdXJjZXMgKG5ldmVyIGF1dG9saW5rcykuXG4gICAgcmVzb3VyY2VMaW5rOiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1RvTWFya2Rvd25IYW5kbGV9XG4gICAqIEBwYXJhbSB7TWR4SnN4Rmxvd0VsZW1lbnQgfCBNZHhKc3hUZXh0RWxlbWVudH0gbm9kZVxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgZnVuY3Rpb24gbWR4RWxlbWVudChub2RlLCBfLCBzdGF0ZSwgaW5mbykge1xuICAgIGNvbnN0IGZsb3cgPSBub2RlLnR5cGUgPT09ICdtZHhKc3hGbG93RWxlbWVudCdcbiAgICBjb25zdCBzZWxmQ2xvc2luZyA9IG5vZGUubmFtZVxuICAgICAgPyAhbm9kZS5jaGlsZHJlbiB8fCBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMFxuICAgICAgOiBmYWxzZVxuICAgIGNvbnN0IGRlcHRoID0gaW5mZXJEZXB0aChzdGF0ZSlcbiAgICBjb25zdCBjdXJyZW50SW5kZW50ID0gY3JlYXRlSW5kZW50KGRlcHRoKVxuICAgIGNvbnN0IHRyYWNrZXJPbmVMaW5lID0gc3RhdGUuY3JlYXRlVHJhY2tlcihpbmZvKVxuICAgIGNvbnN0IHRyYWNrZXJNdWx0aUxpbmUgPSBzdGF0ZS5jcmVhdGVUcmFja2VyKGluZm8pXG4gICAgLyoqIEB0eXBlIHtBcnJheTxzdHJpbmc+fSAqL1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRBdHRyaWJ1dGVzID0gW11cbiAgICBjb25zdCBwcmVmaXggPSAoZmxvdyA/IGN1cnJlbnRJbmRlbnQgOiAnJykgKyAnPCcgKyAobm9kZS5uYW1lIHx8ICcnKVxuICAgIGNvbnN0IGV4aXQgPSBzdGF0ZS5lbnRlcihub2RlLnR5cGUpXG5cbiAgICB0cmFja2VyT25lTGluZS5tb3ZlKHByZWZpeClcbiAgICB0cmFja2VyTXVsdGlMaW5lLm1vdmUocHJlZml4KVxuXG4gICAgLy8gTm9uZS5cbiAgICBpZiAobm9kZS5hdHRyaWJ1dGVzICYmIG5vZGUuYXR0cmlidXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoIW5vZGUubmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzZXJpYWxpemUgZnJhZ21lbnQgdy8gYXR0cmlidXRlcycpXG4gICAgICB9XG5cbiAgICAgIGxldCBpbmRleCA9IC0xXG4gICAgICB3aGlsZSAoKytpbmRleCA8IG5vZGUuYXR0cmlidXRlcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlID0gbm9kZS5hdHRyaWJ1dGVzW2luZGV4XVxuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgICAgbGV0IHJlc3VsdFxuXG4gICAgICAgIGlmIChhdHRyaWJ1dGUudHlwZSA9PT0gJ21keEpzeEV4cHJlc3Npb25BdHRyaWJ1dGUnKSB7XG4gICAgICAgICAgcmVzdWx0ID0gJ3snICsgKGF0dHJpYnV0ZS52YWx1ZSB8fCAnJykgKyAnfSdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWF0dHJpYnV0ZS5uYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzZXJpYWxpemUgYXR0cmlidXRlIHcvbyBuYW1lJylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF0dHJpYnV0ZS52YWx1ZVxuICAgICAgICAgIGNvbnN0IGxlZnQgPSBhdHRyaWJ1dGUubmFtZVxuICAgICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICAgIGxldCByaWdodCA9ICcnXG5cbiAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gRW1wdHkuXG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByaWdodCA9ICd7JyArICh2YWx1ZS52YWx1ZSB8fCAnJykgKyAnfSdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGFsdGVybmF0aXZlIGlzIGxlc3MgY29tbW9uIHRoYW4gYHF1b3RlYCwgc3dpdGNoLlxuICAgICAgICAgICAgY29uc3QgYXBwbGllZFF1b3RlID1cbiAgICAgICAgICAgICAgcXVvdGVTbWFydCAmJiBjY291bnQodmFsdWUsIHF1b3RlKSA+IGNjb3VudCh2YWx1ZSwgYWx0ZXJuYXRpdmUpXG4gICAgICAgICAgICAgICAgPyBhbHRlcm5hdGl2ZVxuICAgICAgICAgICAgICAgIDogcXVvdGVcbiAgICAgICAgICAgIHJpZ2h0ID1cbiAgICAgICAgICAgICAgYXBwbGllZFF1b3RlICtcbiAgICAgICAgICAgICAgc3RyaW5naWZ5RW50aXRpZXNMaWdodCh2YWx1ZSwge3N1YnNldDogW2FwcGxpZWRRdW90ZV19KSArXG4gICAgICAgICAgICAgIGFwcGxpZWRRdW90ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3VsdCA9IGxlZnQgKyAocmlnaHQgPyAnPScgOiAnJykgKyByaWdodFxuICAgICAgICB9XG5cbiAgICAgICAgc2VyaWFsaXplZEF0dHJpYnV0ZXMucHVzaChyZXN1bHQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGF0dHJpYnV0ZXNPblRoZWlyT3duTGluZSA9IGZhbHNlXG4gICAgY29uc3QgYXR0cmlidXRlc09uT25lTGluZSA9IHNlcmlhbGl6ZWRBdHRyaWJ1dGVzLmpvaW4oJyAnKVxuXG4gICAgaWYgKFxuICAgICAgLy8gQmxvY2s6XG4gICAgICBmbG93ICYmXG4gICAgICAvLyBJbmNsdWRpbmcgYSBsaW5lIGVuZGluZyAoZXhwcmVzc2lvbnMpLlxuICAgICAgKC9cXHI/XFxufFxcci8udGVzdChhdHRyaWJ1dGVzT25PbmVMaW5lKSB8fFxuICAgICAgICAvLyBDdXJyZW50IHBvc2l0aW9uIChpbmNsdWRpbmcgYDx0YWdgKS5cbiAgICAgICAgdHJhY2tlck9uZUxpbmUuY3VycmVudCgpLm5vdy5jb2x1bW4gK1xuICAgICAgICAgIC8vIC0xIGJlY2F1c2UgY29sdW1ucywgKzEgZm9yIGAgYCBiZWZvcmUgYXR0cmlidXRlcy5cbiAgICAgICAgICAvLyBBdHRyaWJ1dGVzIGpvaW5lZCBieSBzcGFjZXMuXG4gICAgICAgICAgYXR0cmlidXRlc09uT25lTGluZS5sZW5ndGggK1xuICAgICAgICAgIC8vIGAgLz5gLlxuICAgICAgICAgIChzZWxmQ2xvc2luZyA/ICh0aWdodFNlbGZDbG9zaW5nID8gMiA6IDMpIDogMSkgPlxuICAgICAgICAgIHByaW50V2lkdGgpXG4gICAgKSB7XG4gICAgICBhdHRyaWJ1dGVzT25UaGVpck93bkxpbmUgPSB0cnVlXG4gICAgfVxuXG4gICAgbGV0IHRyYWNrZXIgPSB0cmFja2VyT25lTGluZVxuICAgIGxldCB2YWx1ZSA9IHByZWZpeFxuXG4gICAgaWYgKGF0dHJpYnV0ZXNPblRoZWlyT3duTGluZSkge1xuICAgICAgdHJhY2tlciA9IHRyYWNrZXJNdWx0aUxpbmVcblxuICAgICAgbGV0IGluZGV4ID0gLTFcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBzZXJpYWxpemVkQXR0cmlidXRlcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gT25seSBpbmRlbnQgZmlyc3QgbGluZSBvZiBvZiBhdHRyaWJ1dGVzLCB3ZSBjYW7igJl0IGluZGVudCBhdHRyaWJ1dGVcbiAgICAgICAgLy8gdmFsdWVzLlxuICAgICAgICBzZXJpYWxpemVkQXR0cmlidXRlc1tpbmRleF0gPVxuICAgICAgICAgIGN1cnJlbnRJbmRlbnQgKyBpbmRlbnQgKyBzZXJpYWxpemVkQXR0cmlidXRlc1tpbmRleF1cbiAgICAgIH1cblxuICAgICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKFxuICAgICAgICAnXFxuJyArIHNlcmlhbGl6ZWRBdHRyaWJ1dGVzLmpvaW4oJ1xcbicpICsgJ1xcbicgKyBjdXJyZW50SW5kZW50XG4gICAgICApXG4gICAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzT25PbmVMaW5lKSB7XG4gICAgICB2YWx1ZSArPSB0cmFja2VyLm1vdmUoJyAnICsgYXR0cmlidXRlc09uT25lTGluZSlcbiAgICB9XG5cbiAgICBpZiAoc2VsZkNsb3NpbmcpIHtcbiAgICAgIHZhbHVlICs9IHRyYWNrZXIubW92ZShcbiAgICAgICAgKHRpZ2h0U2VsZkNsb3NpbmcgfHwgYXR0cmlidXRlc09uVGhlaXJPd25MaW5lID8gJycgOiAnICcpICsgJy8nXG4gICAgICApXG4gICAgfVxuXG4gICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKCc+JylcblxuICAgIGlmIChub2RlLmNoaWxkcmVuICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ21keEpzeFRleHRFbGVtZW50Jykge1xuICAgICAgICB2YWx1ZSArPSB0cmFja2VyLm1vdmUoXG4gICAgICAgICAgc3RhdGUuY29udGFpbmVyUGhyYXNpbmcobm9kZSwge1xuICAgICAgICAgICAgLi4udHJhY2tlci5jdXJyZW50KCksXG4gICAgICAgICAgICBiZWZvcmU6ICc+JyxcbiAgICAgICAgICAgIGFmdGVyOiAnPCdcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFja2VyLnNoaWZ0KDIpXG4gICAgICAgIHZhbHVlICs9IHRyYWNrZXIubW92ZSgnXFxuJylcbiAgICAgICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKGNvbnRhaW5lckZsb3cobm9kZSwgc3RhdGUsIHRyYWNrZXIuY3VycmVudCgpKSlcbiAgICAgICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKCdcXG4nKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghc2VsZkNsb3NpbmcpIHtcbiAgICAgIHZhbHVlICs9IHRyYWNrZXIubW92ZShcbiAgICAgICAgKGZsb3cgPyBjdXJyZW50SW5kZW50IDogJycpICsgJzwvJyArIChub2RlLm5hbWUgfHwgJycpICsgJz4nXG4gICAgICApXG4gICAgfVxuXG4gICAgZXhpdCgpXG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbn1cblxuLy8gTW9kaWZpZWQgY29weSBvZjpcbi8vIDxodHRwczovL2dpdGh1Yi5jb20vc3ludGF4LXRyZWUvbWRhc3QtdXRpbC10by1tYXJrZG93bi9ibG9iL2EzODFjYmMvbGliL3V0aWwvY29udGFpbmVyLWZsb3cuanM+LlxuLy9cbi8vIFRvIGRvOiBhZGQgYGluZGVudGAgc3VwcG9ydCB0byBgbWRhc3QtdXRpbC10by1tYXJrZG93bmAuXG4vLyBBcyBpbmRlbnRzIGFyZSBvbmx5IHVzZWQgZm9yIEpTWCwgaXTigJlzIGZpbmUgZm9yIG5vdywgYnV0IHBlcmhhcHMgYmV0dGVyXG4vLyB0aGVyZS5cbi8qKlxuICogQHBhcmFtIHtNZHhKc3hGbG93RWxlbWVudH0gcGFyZW50XG4gKiAgIFBhcmVudCBvZiBmbG93IG5vZGVzLlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqICAgSW5mbyBwYXNzZWQgYXJvdW5kIGFib3V0IHRoZSBjdXJyZW50IHN0YXRlLlxuICogQHBhcmFtIHtSZXR1cm5UeXBlPFRyYWNrZXJbJ2N1cnJlbnQnXT59IGluZm9cbiAqICAgSW5mbyBvbiB3aGVyZSB3ZSBhcmUgaW4gdGhlIGRvY3VtZW50IHdlIGFyZSBnZW5lcmF0aW5nLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqICAgU2VyaWFsaXplZCBjaGlsZHJlbiwgam9pbmVkIGJ5IChibGFuaykgbGluZXMuXG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5lckZsb3cocGFyZW50LCBzdGF0ZSwgaW5mbykge1xuICBjb25zdCBpbmRleFN0YWNrID0gc3RhdGUuaW5kZXhTdGFja1xuICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudC5jaGlsZHJlblxuICBjb25zdCB0cmFja2VyID0gc3RhdGUuY3JlYXRlVHJhY2tlcihpbmZvKVxuICBjb25zdCBjdXJyZW50SW5kZW50ID0gY3JlYXRlSW5kZW50KGluZmVyRGVwdGgoc3RhdGUpKVxuICAvKiogQHR5cGUge0FycmF5PHN0cmluZz59ICovXG4gIGNvbnN0IHJlc3VsdHMgPSBbXVxuICBsZXQgaW5kZXggPSAtMVxuXG4gIGluZGV4U3RhY2sucHVzaCgtMSlcblxuICB3aGlsZSAoKytpbmRleCA8IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baW5kZXhdXG5cbiAgICBpbmRleFN0YWNrW2luZGV4U3RhY2subGVuZ3RoIC0gMV0gPSBpbmRleFxuXG4gICAgY29uc3QgY2hpbGRJbmZvID0ge2JlZm9yZTogJ1xcbicsIGFmdGVyOiAnXFxuJywgLi4udHJhY2tlci5jdXJyZW50KCl9XG5cbiAgICBjb25zdCByZXN1bHQgPSBzdGF0ZS5oYW5kbGUoY2hpbGQsIHBhcmVudCwgc3RhdGUsIGNoaWxkSW5mbylcblxuICAgIGNvbnN0IHNlcmlhbGl6ZWRDaGlsZCA9XG4gICAgICBjaGlsZC50eXBlID09PSAnbWR4SnN4Rmxvd0VsZW1lbnQnXG4gICAgICAgID8gcmVzdWx0XG4gICAgICAgIDogc3RhdGUuaW5kZW50TGluZXMocmVzdWx0LCBmdW5jdGlvbiAobGluZSwgXywgYmxhbmspIHtcbiAgICAgICAgICAgIHJldHVybiAoYmxhbmsgPyAnJyA6IGN1cnJlbnRJbmRlbnQpICsgbGluZVxuICAgICAgICAgIH0pXG5cbiAgICByZXN1bHRzLnB1c2godHJhY2tlci5tb3ZlKHNlcmlhbGl6ZWRDaGlsZCkpXG5cbiAgICBpZiAoY2hpbGQudHlwZSAhPT0gJ2xpc3QnKSB7XG4gICAgICBzdGF0ZS5idWxsZXRMYXN0VXNlZCA9IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGlmIChpbmRleCA8IGNoaWxkcmVuLmxlbmd0aCAtIDEpIHtcbiAgICAgIHJlc3VsdHMucHVzaCh0cmFja2VyLm1vdmUoJ1xcblxcbicpKVxuICAgIH1cbiAgfVxuXG4gIGluZGV4U3RhY2sucG9wKClcblxuICByZXR1cm4gcmVzdWx0cy5qb2luKCcnKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBpbmZlckRlcHRoKHN0YXRlKSB7XG4gIGxldCBkZXB0aCA9IDBcbiAgbGV0IGluZGV4ID0gc3RhdGUuc3RhY2subGVuZ3RoXG5cbiAgd2hpbGUgKC0taW5kZXggPiAtMSkge1xuICAgIGNvbnN0IG5hbWUgPSBzdGF0ZS5zdGFja1tpbmRleF1cblxuICAgIGlmIChuYW1lID09PSAnYmxvY2txdW90ZScgfHwgbmFtZSA9PT0gJ2xpc3RJdGVtJykgYnJlYWtcbiAgICBpZiAobmFtZSA9PT0gJ21keEpzeEZsb3dFbGVtZW50JykgZGVwdGgrK1xuICB9XG5cbiAgcmV0dXJuIGRlcHRoXG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbmRlbnQoZGVwdGgpIHtcbiAgcmV0dXJuIGluZGVudC5yZXBlYXQoZGVwdGgpXG59XG5cbi8qKlxuICogQHR5cGUge1RvTWFya2Rvd25IYW5kbGV9XG4gKi9cbmZ1bmN0aW9uIHBlZWtFbGVtZW50KCkge1xuICByZXR1cm4gJzwnXG59XG4iXSwibmFtZXMiOlsiY2NvdW50Iiwib2siLCJhc3NlcnQiLCJwYXJzZUVudGl0aWVzIiwic3RyaW5naWZ5RW50aXRpZXNMaWdodCIsInN0cmluZ2lmeVBvc2l0aW9uIiwiVkZpbGVNZXNzYWdlIiwiaW5kZW50IiwibWR4SnN4RnJvbU1hcmtkb3duIiwiY2FuQ29udGFpbkVvbHMiLCJlbnRlciIsIm1keEpzeEZsb3dUYWciLCJlbnRlck1keEpzeFRhZyIsIm1keEpzeEZsb3dUYWdDbG9zaW5nTWFya2VyIiwiZW50ZXJNZHhKc3hUYWdDbG9zaW5nTWFya2VyIiwibWR4SnN4Rmxvd1RhZ0F0dHJpYnV0ZSIsImVudGVyTWR4SnN4VGFnQXR0cmlidXRlIiwibWR4SnN4Rmxvd1RhZ0V4cHJlc3Npb25BdHRyaWJ1dGUiLCJlbnRlck1keEpzeFRhZ0V4cHJlc3Npb25BdHRyaWJ1dGUiLCJtZHhKc3hGbG93VGFnQXR0cmlidXRlVmFsdWVMaXRlcmFsIiwiYnVmZmVyIiwibWR4SnN4Rmxvd1RhZ0F0dHJpYnV0ZVZhbHVlRXhwcmVzc2lvbiIsIm1keEpzeEZsb3dUYWdTZWxmQ2xvc2luZ01hcmtlciIsImVudGVyTWR4SnN4VGFnU2VsZkNsb3NpbmdNYXJrZXIiLCJtZHhKc3hUZXh0VGFnIiwibWR4SnN4VGV4dFRhZ0Nsb3NpbmdNYXJrZXIiLCJtZHhKc3hUZXh0VGFnQXR0cmlidXRlIiwibWR4SnN4VGV4dFRhZ0V4cHJlc3Npb25BdHRyaWJ1dGUiLCJtZHhKc3hUZXh0VGFnQXR0cmlidXRlVmFsdWVMaXRlcmFsIiwibWR4SnN4VGV4dFRhZ0F0dHJpYnV0ZVZhbHVlRXhwcmVzc2lvbiIsIm1keEpzeFRleHRUYWdTZWxmQ2xvc2luZ01hcmtlciIsImV4aXQiLCJleGl0TWR4SnN4VGFnQ2xvc2luZ01hcmtlciIsIm1keEpzeEZsb3dUYWdOYW1lUHJpbWFyeSIsImV4aXRNZHhKc3hUYWdOYW1lUHJpbWFyeSIsIm1keEpzeEZsb3dUYWdOYW1lTWVtYmVyIiwiZXhpdE1keEpzeFRhZ05hbWVNZW1iZXIiLCJtZHhKc3hGbG93VGFnTmFtZUxvY2FsIiwiZXhpdE1keEpzeFRhZ05hbWVMb2NhbCIsImV4aXRNZHhKc3hUYWdFeHByZXNzaW9uQXR0cmlidXRlIiwibWR4SnN4Rmxvd1RhZ0V4cHJlc3Npb25BdHRyaWJ1dGVWYWx1ZSIsImRhdGEiLCJtZHhKc3hGbG93VGFnQXR0cmlidXRlTmFtZVByaW1hcnkiLCJleGl0TWR4SnN4VGFnQXR0cmlidXRlTmFtZVByaW1hcnkiLCJtZHhKc3hGbG93VGFnQXR0cmlidXRlTmFtZUxvY2FsIiwiZXhpdE1keEpzeFRhZ0F0dHJpYnV0ZU5hbWVMb2NhbCIsImV4aXRNZHhKc3hUYWdBdHRyaWJ1dGVWYWx1ZUxpdGVyYWwiLCJtZHhKc3hGbG93VGFnQXR0cmlidXRlVmFsdWVMaXRlcmFsVmFsdWUiLCJleGl0TWR4SnN4VGFnQXR0cmlidXRlVmFsdWVFeHByZXNzaW9uIiwibWR4SnN4Rmxvd1RhZ0F0dHJpYnV0ZVZhbHVlRXhwcmVzc2lvblZhbHVlIiwiZXhpdE1keEpzeFRhZ1NlbGZDbG9zaW5nTWFya2VyIiwiZXhpdE1keEpzeFRhZyIsIm1keEpzeFRleHRUYWdOYW1lUHJpbWFyeSIsIm1keEpzeFRleHRUYWdOYW1lTWVtYmVyIiwibWR4SnN4VGV4dFRhZ05hbWVMb2NhbCIsIm1keEpzeFRleHRUYWdFeHByZXNzaW9uQXR0cmlidXRlVmFsdWUiLCJtZHhKc3hUZXh0VGFnQXR0cmlidXRlTmFtZVByaW1hcnkiLCJtZHhKc3hUZXh0VGFnQXR0cmlidXRlTmFtZUxvY2FsIiwibWR4SnN4VGV4dFRhZ0F0dHJpYnV0ZVZhbHVlTGl0ZXJhbFZhbHVlIiwibWR4SnN4VGV4dFRhZ0F0dHJpYnV0ZVZhbHVlRXhwcmVzc2lvblZhbHVlIiwicG9pbnQiLCJkIiwibGluZSIsImNvbHVtbiIsIm9mZnNldCIsInRva2VuIiwiY29uZmlnIiwiY2FsbCIsInRhZyIsIm5hbWUiLCJ1bmRlZmluZWQiLCJhdHRyaWJ1dGVzIiwiY2xvc2UiLCJzZWxmQ2xvc2luZyIsInN0YXJ0IiwiZW5kIiwibWR4SnN4VGFnU3RhY2siLCJtZHhKc3hUYWciLCJzdGFjayIsImxlbmd0aCIsImVudGVyTWR4SnN4VGFnQW55QXR0cmlidXRlIiwic2xpY2VTZXJpYWxpemUiLCJwdXNoIiwidHlwZSIsInZhbHVlIiwicG9zaXRpb24iLCJ0YWlsIiwiZXN0cmVlIiwicmVzdW1lIiwibm9kZSIsIm5vblRlcm1pbmF0ZWQiLCJzZXJpYWxpemVBYmJyZXZpYXRlZFRhZyIsInBvcCIsImNoaWxkcmVuIiwib25FcnJvclJpZ2h0SXNUYWciLCJvbkVycm9yTGVmdElzVGFnIiwiY2xvc2luZyIsIm9wZW4iLCJwbGFjZSIsImEiLCJiIiwibWR4SnN4VG9NYXJrZG93biIsIm9wdGlvbnMiLCJvcHRpb25zXyIsInF1b3RlIiwicXVvdGVTbWFydCIsInRpZ2h0U2VsZkNsb3NpbmciLCJwcmludFdpZHRoIiwiTnVtYmVyIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJhbHRlcm5hdGl2ZSIsIkVycm9yIiwibWR4RWxlbWVudCIsInBlZWsiLCJwZWVrRWxlbWVudCIsImhhbmRsZXJzIiwibWR4SnN4Rmxvd0VsZW1lbnQiLCJtZHhKc3hUZXh0RWxlbWVudCIsInVuc2FmZSIsImNoYXJhY3RlciIsImluQ29uc3RydWN0IiwiYXRCcmVhayIsImZlbmNlcyIsInJlc291cmNlTGluayIsIl8iLCJzdGF0ZSIsImluZm8iLCJmbG93IiwiZGVwdGgiLCJpbmZlckRlcHRoIiwiY3VycmVudEluZGVudCIsImNyZWF0ZUluZGVudCIsInRyYWNrZXJPbmVMaW5lIiwiY3JlYXRlVHJhY2tlciIsInRyYWNrZXJNdWx0aUxpbmUiLCJzZXJpYWxpemVkQXR0cmlidXRlcyIsInByZWZpeCIsIm1vdmUiLCJpbmRleCIsImF0dHJpYnV0ZSIsInJlc3VsdCIsImxlZnQiLCJyaWdodCIsImFwcGxpZWRRdW90ZSIsInN1YnNldCIsImF0dHJpYnV0ZXNPblRoZWlyT3duTGluZSIsImF0dHJpYnV0ZXNPbk9uZUxpbmUiLCJqb2luIiwidGVzdCIsImN1cnJlbnQiLCJub3ciLCJ0cmFja2VyIiwiY29udGFpbmVyUGhyYXNpbmciLCJiZWZvcmUiLCJhZnRlciIsInNoaWZ0IiwiY29udGFpbmVyRmxvdyIsInBhcmVudCIsImluZGV4U3RhY2siLCJyZXN1bHRzIiwiY2hpbGQiLCJjaGlsZEluZm8iLCJoYW5kbGUiLCJzZXJpYWxpemVkQ2hpbGQiLCJpbmRlbnRMaW5lcyIsImJsYW5rIiwiYnVsbGV0TGFzdFVzZWQiLCJyZXBlYXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mdast-util-mdx-jsx/lib/index.js\n");

/***/ })

};
;