"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/estree-util-build-jsx";
exports.ids = ["vendor-chunks/estree-util-build-jsx"];
exports.modules = {

/***/ "(ssr)/./node_modules/estree-util-build-jsx/lib/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/estree-util-build-jsx/lib/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildJsx: () => (/* binding */ buildJsx)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! devlop */ \"(ssr)/./node_modules/devlop/lib/development.js\");\n/* harmony import */ var estree_util_is_identifier_name__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! estree-util-is-identifier-name */ \"(ssr)/./node_modules/estree-util-is-identifier-name/lib/index.js\");\n/* harmony import */ var estree_walker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! estree-walker */ \"(ssr)/./node_modules/estree-walker/src/index.js\");\n/**\n * @typedef {import('estree-jsx').Expression} Expression\n * @typedef {import('estree-jsx').Identifier} Identifier\n * @typedef {import('estree-jsx').ImportSpecifier} ImportSpecifier\n * @typedef {import('estree-jsx').JSXAttribute} JSXAttribute\n * @typedef {import('estree-jsx').JSXIdentifier} JSXIdentifier\n * @typedef {import('estree-jsx').JSXMemberExpression} JSXMemberExpression\n * @typedef {import('estree-jsx').JSXNamespacedName} JSXNamespacedName\n * @typedef {import('estree-jsx').Literal} Literal\n * @typedef {import('estree-jsx').MemberExpression} MemberExpression\n * @typedef {import('estree-jsx').Node} Node\n * @typedef {import('estree-jsx').ObjectExpression} ObjectExpression\n * @typedef {import('estree-jsx').Property} Property\n * @typedef {import('estree-jsx').SpreadElement} SpreadElement\n *\n * @typedef {'automatic' | 'classic'} Runtime\n *   How to transform JSX.\n *\n * @typedef Options\n *   Configuration.\n *\n *   > ðŸ‘‰ **Note**: you can also configure `runtime`, `importSource`, `pragma`,\n *   > and `pragmaFrag` from within files through comments.\n * @property {Runtime | null | undefined} [runtime='classic']\n *   Choose the runtime (default: `'classic'`).\n *\n *   Comment form: `@jsxRuntime theRuntime`.\n * @property {string | null | undefined} [importSource='react']\n *   Place to import `jsx`, `jsxs`, `jsxDEV`, and `Fragment` from, when the\n *   effective runtime is automatic (default: `'react'`).\n *\n *   Comment form: `@jsxImportSource theSource`.\n *\n *   > ðŸ‘‰ **Note**: `/jsx-runtime` or `/jsx-dev-runtime` is appended to this\n *   > provided source.\n *   > In CJS, that can resolve to a file (as in `theSource/jsx-runtime.js`),\n *   > but for ESM an export map needs to be set up to point to files:\n *   >\n *   > ```js\n *   > // â€¦\n *   > \"exports\": {\n *   >   // â€¦\n *   >   \"./jsx-runtime\": \"./path/to/jsx-runtime.js\",\n *   >   \"./jsx-dev-runtime\": \"./path/to/jsx-runtime.js\"\n *   >   // â€¦\n *   > ```\n * @property {string | null | undefined} [pragma='React.createElement']\n *   Identifier or member expression to call when the effective runtime is\n *   classic (default: `'React.createElement'`).\n *\n *   Comment form: `@jsx identifier`.\n * @property {string | null | undefined} [pragmaFrag='React.Fragment']\n *   Identifier or member expression to use as a symbol for fragments when the\n *   effective runtime is classic (default: `'React.Fragment'`).\n *\n *   Comment form: `@jsxFrag identifier`.\n * @property {boolean | null | undefined} [development=false]\n *   When in the automatic runtime, whether to import\n *   `theSource/jsx-dev-runtime.js`, use `jsxDEV`, and pass location info when\n *   available (default: `false`).\n *\n *   This helps debugging but adds a lot of code that you donâ€™t want in\n *   production.\n * @property {string | null | undefined} [filePath]\n *   File path to the original source file (optional).\n *\n *   Passed in location info to `jsxDEV` when using the automatic runtime with\n *   `development: true`.\n *\n * @typedef Annotations\n *   State where info from comments is gathered.\n * @property {string | undefined} [jsx]\n *   JSX identifier (`pragma`).\n * @property {string | undefined} [jsxFrag]\n *   JSX identifier of fragment (`pragmaFrag`).\n * @property {string | undefined} [jsxImportSource]\n *   Where to import an automatic JSX runtime from.\n * @property {Runtime | undefined} [jsxRuntime]\n *   Runtime.\n *\n * @typedef Imports\n *   State of used identifiers from the automatic runtime.\n * @property {boolean | undefined} [fragment]\n *   Symbol of `Fragment`.\n * @property {boolean | undefined} [jsx]\n *   Symbol of `jsx`.\n * @property {boolean | undefined} [jsxs]\n *   Symbol of `jsxs`.\n * @property {boolean | undefined} [jsxDEV]\n *   Symbol of `jsxDEV`.\n */ \n\n\nconst regex = /@(jsx|jsxFrag|jsxImportSource|jsxRuntime)\\s+(\\S+)/g;\n/**\n * Turn JSX in `tree` into function calls: `<x />` -> `h('x')`!\n *\n * ###### Algorithm\n *\n * In almost all cases, this utility is the same as the Babel plugin, except that\n * they work on slightly different syntax trees.\n *\n * Some differences:\n *\n * *   no pure annotations things\n * *   `this` is not a component: `<this>` -> `h('this')`, not `h(this)`\n * *   namespaces are supported: `<a:b c:d>` -> `h('a:b', {'c:d': true})`,\n *     which throws by default in Babel or can be turned on with `throwIfNamespace`\n * *   no `useSpread`, `useBuiltIns`, or `filter` options\n *\n * @param {Node} tree\n *   Tree to transform (typically `Program`).\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {undefined}\n *   Nothing.\n */ function buildJsx(tree, options) {\n    const config = options || {};\n    let automatic = config.runtime === \"automatic\";\n    /** @type {Annotations} */ const annotations = {};\n    /** @type {Imports} */ const imports = {};\n    (0,estree_walker__WEBPACK_IMPORTED_MODULE_0__.walk)(tree, {\n        enter (node) {\n            if (node.type === \"Program\") {\n                const comments = node.comments || [];\n                let index = -1;\n                while(++index < comments.length){\n                    regex.lastIndex = 0;\n                    let match = regex.exec(comments[index].value);\n                    while(match){\n                        // @ts-expect-error: `match[1]` is always a key, `match[2]` when\n                        // runtime is checked later.\n                        annotations[match[1]] = match[2];\n                        match = regex.exec(comments[index].value);\n                    }\n                }\n                if (annotations.jsxRuntime) {\n                    if (annotations.jsxRuntime === \"automatic\") {\n                        automatic = true;\n                        if (annotations.jsx) {\n                            throw new Error(\"Unexpected `@jsx` pragma w/ automatic runtime\");\n                        }\n                        if (annotations.jsxFrag) {\n                            throw new Error(\"Unexpected `@jsxFrag` pragma w/ automatic runtime\");\n                        }\n                    } else if (annotations.jsxRuntime === \"classic\") {\n                        automatic = false;\n                        if (annotations.jsxImportSource) {\n                            throw new Error(\"Unexpected `@jsxImportSource` w/ classic runtime\");\n                        }\n                    } else {\n                        throw new Error(\"Unexpected `jsxRuntime` `\" + annotations.jsxRuntime + \"`, expected `automatic` or `classic`\");\n                    }\n                }\n            }\n        },\n        // eslint-disable-next-line complexity\n        leave (node) {\n            if (node.type === \"Program\") {\n                /** @type {Array<ImportSpecifier>} */ const specifiers = [];\n                if (imports.fragment) {\n                    specifiers.push({\n                        type: \"ImportSpecifier\",\n                        imported: {\n                            type: \"Identifier\",\n                            name: \"Fragment\"\n                        },\n                        local: {\n                            type: \"Identifier\",\n                            name: \"_Fragment\"\n                        }\n                    });\n                }\n                if (imports.jsx) {\n                    specifiers.push({\n                        type: \"ImportSpecifier\",\n                        imported: {\n                            type: \"Identifier\",\n                            name: \"jsx\"\n                        },\n                        local: {\n                            type: \"Identifier\",\n                            name: \"_jsx\"\n                        }\n                    });\n                }\n                if (imports.jsxs) {\n                    specifiers.push({\n                        type: \"ImportSpecifier\",\n                        imported: {\n                            type: \"Identifier\",\n                            name: \"jsxs\"\n                        },\n                        local: {\n                            type: \"Identifier\",\n                            name: \"_jsxs\"\n                        }\n                    });\n                }\n                if (imports.jsxDEV) {\n                    specifiers.push({\n                        type: \"ImportSpecifier\",\n                        imported: {\n                            type: \"Identifier\",\n                            name: \"jsxDEV\"\n                        },\n                        local: {\n                            type: \"Identifier\",\n                            name: \"_jsxDEV\"\n                        }\n                    });\n                }\n                if (specifiers.length > 0) {\n                    let injectIndex = 0;\n                    while(injectIndex < node.body.length){\n                        const child = node.body[injectIndex];\n                        if (\"directive\" in child && child.directive) {\n                            injectIndex++;\n                        } else {\n                            break;\n                        }\n                    }\n                    node.body.splice(injectIndex, 0, {\n                        type: \"ImportDeclaration\",\n                        specifiers,\n                        source: {\n                            type: \"Literal\",\n                            value: (annotations.jsxImportSource || config.importSource || \"react\") + (config.development ? \"/jsx-dev-runtime\" : \"/jsx-runtime\")\n                        }\n                    });\n                }\n            }\n            if (node.type !== \"JSXElement\" && node.type !== \"JSXFragment\") {\n                return;\n            }\n            /** @type {Array<Expression>} */ const children = [];\n            let index = -1;\n            // Figure out `children`.\n            while(++index < node.children.length){\n                const child = node.children[index];\n                if (child.type === \"JSXExpressionContainer\") {\n                    // Ignore empty expressions.\n                    if (child.expression.type !== \"JSXEmptyExpression\") {\n                        children.push(child.expression);\n                    }\n                } else if (child.type === \"JSXText\") {\n                    const value = child.value// Replace tabs w/ spaces.\n                    .replace(/\\t/g, \" \")// Use line feeds, drop spaces around them.\n                    .replace(/ *(\\r?\\n|\\r) */g, \"\\n\")// Collapse multiple line feeds.\n                    .replace(/\\n+/g, \"\\n\")// Drop final line feeds.\n                    .replace(/\\n+$/, \"\")// Drop first line feeds.\n                    .replace(/^\\n+/, \"\")// Replace line feeds with spaces.\n                    .replace(/\\n/g, \" \");\n                    // Ignore collapsible text.\n                    if (value) {\n                        /** @type {Node} */ const text = {\n                            type: \"Literal\",\n                            value\n                        };\n                        create(child, text);\n                        children.push(text);\n                    }\n                } else {\n                    (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(child.type !== \"JSXElement\" && child.type !== \"JSXFragment\" && child.type !== \"JSXSpreadChild\");\n                    children.push(child);\n                }\n            }\n            /** @type {Identifier | Literal | MemberExpression} */ let name;\n            /** @type {Array<Property | SpreadElement>} */ const fields = [];\n            /** @type {Array<Expression>} */ let parameters = [];\n            /** @type {Expression | undefined} */ let key;\n            // Do the stuff needed for elements.\n            if (node.type === \"JSXElement\") {\n                name = toIdentifier(node.openingElement.name);\n                // If the name could be an identifier, but start with a lowercase letter,\n                // itâ€™s not a component.\n                if (name.type === \"Identifier\" && /^[a-z]/.test(name.name)) {\n                    /** @type {Node} */ const next = {\n                        type: \"Literal\",\n                        value: name.name\n                    };\n                    create(name, next);\n                    name = next;\n                }\n                /** @type {boolean | undefined} */ let spread;\n                const attributes = node.openingElement.attributes;\n                let index = -1;\n                // Place props in the right order, because we might have duplicates\n                // in them and whatâ€™s spread in.\n                while(++index < attributes.length){\n                    const attribute = attributes[index];\n                    if (attribute.type === \"JSXSpreadAttribute\") {\n                        if (attribute.argument.type === \"ObjectExpression\") {\n                            fields.push(...attribute.argument.properties);\n                        } else {\n                            fields.push({\n                                type: \"SpreadElement\",\n                                argument: attribute.argument\n                            });\n                        }\n                        spread = true;\n                    } else {\n                        const prop = toProperty(attribute);\n                        if (automatic && prop.key.type === \"Identifier\" && prop.key.name === \"key\") {\n                            if (spread) {\n                                throw new Error(\"Expected `key` to come before any spread expressions\");\n                            }\n                            const value = prop.value;\n                            (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(value.type !== \"AssignmentPattern\" && value.type !== \"ArrayPattern\" && value.type !== \"ObjectPattern\" && value.type !== \"RestElement\");\n                            key = value;\n                        } else {\n                            fields.push(prop);\n                        }\n                    }\n                }\n            } else if (automatic) {\n                imports.fragment = true;\n                name = {\n                    type: \"Identifier\",\n                    name: \"_Fragment\"\n                };\n            } else {\n                name = toMemberExpression(annotations.jsxFrag || config.pragmaFrag || \"React.Fragment\");\n            }\n            if (automatic) {\n                if (children.length > 0) {\n                    fields.push({\n                        type: \"Property\",\n                        key: {\n                            type: \"Identifier\",\n                            name: \"children\"\n                        },\n                        value: children.length > 1 ? {\n                            type: \"ArrayExpression\",\n                            elements: children\n                        } : children[0],\n                        kind: \"init\",\n                        method: false,\n                        shorthand: false,\n                        computed: false\n                    });\n                }\n            } else {\n                parameters = children;\n            }\n            /** @type {Identifier | Literal | MemberExpression} */ let callee;\n            if (automatic) {\n                parameters.push({\n                    type: \"ObjectExpression\",\n                    properties: fields\n                });\n                if (key) {\n                    parameters.push(key);\n                } else if (config.development) {\n                    parameters.push({\n                        type: \"Identifier\",\n                        name: \"undefined\"\n                    });\n                }\n                const isStaticChildren = children.length > 1;\n                if (config.development) {\n                    imports.jsxDEV = true;\n                    callee = {\n                        type: \"Identifier\",\n                        name: \"_jsxDEV\"\n                    };\n                    parameters.push({\n                        type: \"Literal\",\n                        value: isStaticChildren\n                    });\n                    /** @type {ObjectExpression} */ const source = {\n                        type: \"ObjectExpression\",\n                        properties: [\n                            {\n                                type: \"Property\",\n                                method: false,\n                                shorthand: false,\n                                computed: false,\n                                kind: \"init\",\n                                key: {\n                                    type: \"Identifier\",\n                                    name: \"fileName\"\n                                },\n                                value: {\n                                    type: \"Literal\",\n                                    value: config.filePath || \"<source.js>\"\n                                }\n                            }\n                        ]\n                    };\n                    if (node.loc) {\n                        source.properties.push({\n                            type: \"Property\",\n                            method: false,\n                            shorthand: false,\n                            computed: false,\n                            kind: \"init\",\n                            key: {\n                                type: \"Identifier\",\n                                name: \"lineNumber\"\n                            },\n                            value: {\n                                type: \"Literal\",\n                                value: node.loc.start.line\n                            }\n                        }, {\n                            type: \"Property\",\n                            method: false,\n                            shorthand: false,\n                            computed: false,\n                            kind: \"init\",\n                            key: {\n                                type: \"Identifier\",\n                                name: \"columnNumber\"\n                            },\n                            value: {\n                                type: \"Literal\",\n                                value: node.loc.start.column + 1\n                            }\n                        });\n                    }\n                    parameters.push(source, {\n                        type: \"ThisExpression\"\n                    });\n                } else if (isStaticChildren) {\n                    imports.jsxs = true;\n                    callee = {\n                        type: \"Identifier\",\n                        name: \"_jsxs\"\n                    };\n                } else {\n                    imports.jsx = true;\n                    callee = {\n                        type: \"Identifier\",\n                        name: \"_jsx\"\n                    };\n                }\n            } else {\n                if (fields.length > 0) {\n                    parameters.unshift({\n                        type: \"ObjectExpression\",\n                        properties: fields\n                    });\n                } else if (parameters.length > 0) {\n                    parameters.unshift({\n                        type: \"Literal\",\n                        value: null\n                    });\n                }\n                callee = toMemberExpression(annotations.jsx || config.pragma || \"React.createElement\");\n            }\n            parameters.unshift(name);\n            /** @type {Node} */ const call = {\n                type: \"CallExpression\",\n                callee,\n                arguments: parameters,\n                optional: false\n            };\n            create(node, call);\n            this.replace(call);\n        }\n    });\n}\n/**\n * Turn a JSX attribute into a JavaScript property.\n *\n * @param {JSXAttribute} node\n *   JSX attribute.\n * @returns {Property}\n *   JS property.\n */ function toProperty(node) {\n    /** @type {Expression} */ let value;\n    if (node.value) {\n        if (node.value.type === \"JSXExpressionContainer\") {\n            const valueExpression = node.value.expression;\n            (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(valueExpression.type !== \"JSXEmptyExpression\", \"`JSXEmptyExpression` is not allowed in props.\");\n            value = valueExpression;\n        } else {\n            const nodeValue = node.value;\n            (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(nodeValue.type !== \"JSXElement\" && nodeValue.type !== \"JSXFragment\", \"JSX{Element,Fragment} are already compiled to `CallExpression`\");\n            value = nodeValue;\n            delete value.raw;\n        }\n    } else {\n        value = {\n            type: \"Literal\",\n            value: true\n        };\n    }\n    /** @type {Property} */ const replacement = {\n        type: \"Property\",\n        key: toIdentifier(node.name),\n        value,\n        kind: \"init\",\n        method: false,\n        shorthand: false,\n        computed: false\n    };\n    create(node, replacement);\n    return replacement;\n}\n/**\n * Turn a JSX identifier into a normal JS identifier.\n *\n * @param {JSXIdentifier | JSXMemberExpression | JSXNamespacedName} node\n *   JSX identifier.\n * @returns {Identifier | Literal | MemberExpression}\n *   JS identifier.\n */ function toIdentifier(node) {\n    /** @type {Identifier | Literal | MemberExpression} */ let replace;\n    if (node.type === \"JSXMemberExpression\") {\n        // `property` is always a `JSXIdentifier`, but it could be something that\n        // isnâ€™t an ES identifier name.\n        const id = toIdentifier(node.property);\n        replace = {\n            type: \"MemberExpression\",\n            object: toIdentifier(node.object),\n            property: id,\n            computed: id.type === \"Literal\",\n            optional: false\n        };\n    } else if (node.type === \"JSXNamespacedName\") {\n        replace = {\n            type: \"Literal\",\n            value: node.namespace.name + \":\" + node.name.name\n        };\n    } else {\n        replace = (0,estree_util_is_identifier_name__WEBPACK_IMPORTED_MODULE_2__.name)(node.name) ? {\n            type: \"Identifier\",\n            name: node.name\n        } : {\n            type: \"Literal\",\n            value: node.name\n        };\n    }\n    create(node, replace);\n    return replace;\n}\n/**\n * Turn a dotted string into a member expression.\n *\n * @param {string} id\n *   Identifiers.\n * @returns {Identifier | Literal | MemberExpression}\n *   Expression.\n */ function toMemberExpression(id) {\n    const identifiers = id.split(\".\");\n    let index = -1;\n    /** @type {Identifier | Literal | MemberExpression | undefined} */ let result;\n    while(++index < identifiers.length){\n        /** @type {Identifier | Literal} */ const prop = (0,estree_util_is_identifier_name__WEBPACK_IMPORTED_MODULE_2__.name)(identifiers[index]) ? {\n            type: \"Identifier\",\n            name: identifiers[index]\n        } : {\n            type: \"Literal\",\n            value: identifiers[index]\n        };\n        result = result ? {\n            type: \"MemberExpression\",\n            object: result,\n            property: prop,\n            computed: Boolean(index && prop.type === \"Literal\"),\n            optional: false\n        } : prop;\n    }\n    (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(result, \"always a result\");\n    return result;\n}\n/**\n * Inherit some fields from `from` into `to`.\n *\n * @param {Node} from\n *   Node to inherit from.\n * @param {Node} to\n *   Node to add to.\n * @returns {undefined}\n *   Nothing.\n */ function create(from, to) {\n    const fields = [\n        \"start\",\n        \"end\",\n        \"loc\",\n        \"range\",\n        \"comments\"\n    ];\n    let index = -1;\n    while(++index < fields.length){\n        const field = fields[index];\n        if (field in from) {\n            // @ts-expect-error: indexable.\n            to[field] = from[field];\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXN0cmVlLXV0aWwtYnVpbGQtanN4L2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTBGQyxHQUVrQztBQUNvQztBQUNyQztBQUVsQyxNQUFNSyxRQUFRO0FBRWQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FzQkMsR0FDTSxTQUFTQyxTQUFTQyxJQUFJLEVBQUVDLE9BQU87SUFDcEMsTUFBTUMsU0FBU0QsV0FBVyxDQUFDO0lBQzNCLElBQUlFLFlBQVlELE9BQU9FLE9BQU8sS0FBSztJQUNuQyx3QkFBd0IsR0FDeEIsTUFBTUMsY0FBYyxDQUFDO0lBQ3JCLG9CQUFvQixHQUNwQixNQUFNQyxVQUFVLENBQUM7SUFFakJULG1EQUFJQSxDQUFDRyxNQUFNO1FBQ1RPLE9BQU1DLElBQUk7WUFDUixJQUFJQSxLQUFLQyxJQUFJLEtBQUssV0FBVztnQkFDM0IsTUFBTUMsV0FBV0YsS0FBS0UsUUFBUSxJQUFJLEVBQUU7Z0JBQ3BDLElBQUlDLFFBQVEsQ0FBQztnQkFFYixNQUFPLEVBQUVBLFFBQVFELFNBQVNFLE1BQU0sQ0FBRTtvQkFDaENkLE1BQU1lLFNBQVMsR0FBRztvQkFFbEIsSUFBSUMsUUFBUWhCLE1BQU1pQixJQUFJLENBQUNMLFFBQVEsQ0FBQ0MsTUFBTSxDQUFDSyxLQUFLO29CQUU1QyxNQUFPRixNQUFPO3dCQUNaLGdFQUFnRTt3QkFDaEUsNEJBQTRCO3dCQUM1QlQsV0FBVyxDQUFDUyxLQUFLLENBQUMsRUFBRSxDQUFDLEdBQUdBLEtBQUssQ0FBQyxFQUFFO3dCQUNoQ0EsUUFBUWhCLE1BQU1pQixJQUFJLENBQUNMLFFBQVEsQ0FBQ0MsTUFBTSxDQUFDSyxLQUFLO29CQUMxQztnQkFDRjtnQkFFQSxJQUFJWCxZQUFZWSxVQUFVLEVBQUU7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UUFDekI7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc29sYW5hLWxpcXVpZGl0eS1wb29sLy4vbm9kZV9tb2R1bGVzL2VzdHJlZS11dGlsLWJ1aWxkLWpzeC9saWIvaW5kZXguanM/M2Q0MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2VzdHJlZS1qc3gnKS5FeHByZXNzaW9ufSBFeHByZXNzaW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdlc3RyZWUtanN4JykuSWRlbnRpZmllcn0gSWRlbnRpZmllclxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlLWpzeCcpLkltcG9ydFNwZWNpZmllcn0gSW1wb3J0U3BlY2lmaWVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdlc3RyZWUtanN4JykuSlNYQXR0cmlidXRlfSBKU1hBdHRyaWJ1dGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2VzdHJlZS1qc3gnKS5KU1hJZGVudGlmaWVyfSBKU1hJZGVudGlmaWVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdlc3RyZWUtanN4JykuSlNYTWVtYmVyRXhwcmVzc2lvbn0gSlNYTWVtYmVyRXhwcmVzc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlLWpzeCcpLkpTWE5hbWVzcGFjZWROYW1lfSBKU1hOYW1lc3BhY2VkTmFtZVxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlLWpzeCcpLkxpdGVyYWx9IExpdGVyYWxcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2VzdHJlZS1qc3gnKS5NZW1iZXJFeHByZXNzaW9ufSBNZW1iZXJFeHByZXNzaW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdlc3RyZWUtanN4JykuTm9kZX0gTm9kZVxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlLWpzeCcpLk9iamVjdEV4cHJlc3Npb259IE9iamVjdEV4cHJlc3Npb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2VzdHJlZS1qc3gnKS5Qcm9wZXJ0eX0gUHJvcGVydHlcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2VzdHJlZS1qc3gnKS5TcHJlYWRFbGVtZW50fSBTcHJlYWRFbGVtZW50XG4gKlxuICogQHR5cGVkZWYgeydhdXRvbWF0aWMnIHwgJ2NsYXNzaWMnfSBSdW50aW1lXG4gKiAgIEhvdyB0byB0cmFuc2Zvcm0gSlNYLlxuICpcbiAqIEB0eXBlZGVmIE9wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbi5cbiAqXG4gKiAgID4g8J+RiSAqKk5vdGUqKjogeW91IGNhbiBhbHNvIGNvbmZpZ3VyZSBgcnVudGltZWAsIGBpbXBvcnRTb3VyY2VgLCBgcHJhZ21hYCxcbiAqICAgPiBhbmQgYHByYWdtYUZyYWdgIGZyb20gd2l0aGluIGZpbGVzIHRocm91Z2ggY29tbWVudHMuXG4gKiBAcHJvcGVydHkge1J1bnRpbWUgfCBudWxsIHwgdW5kZWZpbmVkfSBbcnVudGltZT0nY2xhc3NpYyddXG4gKiAgIENob29zZSB0aGUgcnVudGltZSAoZGVmYXVsdDogYCdjbGFzc2ljJ2ApLlxuICpcbiAqICAgQ29tbWVudCBmb3JtOiBgQGpzeFJ1bnRpbWUgdGhlUnVudGltZWAuXG4gKiBAcHJvcGVydHkge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtpbXBvcnRTb3VyY2U9J3JlYWN0J11cbiAqICAgUGxhY2UgdG8gaW1wb3J0IGBqc3hgLCBganN4c2AsIGBqc3hERVZgLCBhbmQgYEZyYWdtZW50YCBmcm9tLCB3aGVuIHRoZVxuICogICBlZmZlY3RpdmUgcnVudGltZSBpcyBhdXRvbWF0aWMgKGRlZmF1bHQ6IGAncmVhY3QnYCkuXG4gKlxuICogICBDb21tZW50IGZvcm06IGBAanN4SW1wb3J0U291cmNlIHRoZVNvdXJjZWAuXG4gKlxuICogICA+IPCfkYkgKipOb3RlKio6IGAvanN4LXJ1bnRpbWVgIG9yIGAvanN4LWRldi1ydW50aW1lYCBpcyBhcHBlbmRlZCB0byB0aGlzXG4gKiAgID4gcHJvdmlkZWQgc291cmNlLlxuICogICA+IEluIENKUywgdGhhdCBjYW4gcmVzb2x2ZSB0byBhIGZpbGUgKGFzIGluIGB0aGVTb3VyY2UvanN4LXJ1bnRpbWUuanNgKSxcbiAqICAgPiBidXQgZm9yIEVTTSBhbiBleHBvcnQgbWFwIG5lZWRzIHRvIGJlIHNldCB1cCB0byBwb2ludCB0byBmaWxlczpcbiAqICAgPlxuICogICA+IGBgYGpzXG4gKiAgID4gLy8g4oCmXG4gKiAgID4gXCJleHBvcnRzXCI6IHtcbiAqICAgPiAgIC8vIOKAplxuICogICA+ICAgXCIuL2pzeC1ydW50aW1lXCI6IFwiLi9wYXRoL3RvL2pzeC1ydW50aW1lLmpzXCIsXG4gKiAgID4gICBcIi4vanN4LWRldi1ydW50aW1lXCI6IFwiLi9wYXRoL3RvL2pzeC1ydW50aW1lLmpzXCJcbiAqICAgPiAgIC8vIOKAplxuICogICA+IGBgYFxuICogQHByb3BlcnR5IHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbcHJhZ21hPSdSZWFjdC5jcmVhdGVFbGVtZW50J11cbiAqICAgSWRlbnRpZmllciBvciBtZW1iZXIgZXhwcmVzc2lvbiB0byBjYWxsIHdoZW4gdGhlIGVmZmVjdGl2ZSBydW50aW1lIGlzXG4gKiAgIGNsYXNzaWMgKGRlZmF1bHQ6IGAnUmVhY3QuY3JlYXRlRWxlbWVudCdgKS5cbiAqXG4gKiAgIENvbW1lbnQgZm9ybTogYEBqc3ggaWRlbnRpZmllcmAuXG4gKiBAcHJvcGVydHkge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtwcmFnbWFGcmFnPSdSZWFjdC5GcmFnbWVudCddXG4gKiAgIElkZW50aWZpZXIgb3IgbWVtYmVyIGV4cHJlc3Npb24gdG8gdXNlIGFzIGEgc3ltYm9sIGZvciBmcmFnbWVudHMgd2hlbiB0aGVcbiAqICAgZWZmZWN0aXZlIHJ1bnRpbWUgaXMgY2xhc3NpYyAoZGVmYXVsdDogYCdSZWFjdC5GcmFnbWVudCdgKS5cbiAqXG4gKiAgIENvbW1lbnQgZm9ybTogYEBqc3hGcmFnIGlkZW50aWZpZXJgLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2RldmVsb3BtZW50PWZhbHNlXVxuICogICBXaGVuIGluIHRoZSBhdXRvbWF0aWMgcnVudGltZSwgd2hldGhlciB0byBpbXBvcnRcbiAqICAgYHRoZVNvdXJjZS9qc3gtZGV2LXJ1bnRpbWUuanNgLCB1c2UgYGpzeERFVmAsIGFuZCBwYXNzIGxvY2F0aW9uIGluZm8gd2hlblxuICogICBhdmFpbGFibGUgKGRlZmF1bHQ6IGBmYWxzZWApLlxuICpcbiAqICAgVGhpcyBoZWxwcyBkZWJ1Z2dpbmcgYnV0IGFkZHMgYSBsb3Qgb2YgY29kZSB0aGF0IHlvdSBkb27igJl0IHdhbnQgaW5cbiAqICAgcHJvZHVjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2ZpbGVQYXRoXVxuICogICBGaWxlIHBhdGggdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIChvcHRpb25hbCkuXG4gKlxuICogICBQYXNzZWQgaW4gbG9jYXRpb24gaW5mbyB0byBganN4REVWYCB3aGVuIHVzaW5nIHRoZSBhdXRvbWF0aWMgcnVudGltZSB3aXRoXG4gKiAgIGBkZXZlbG9wbWVudDogdHJ1ZWAuXG4gKlxuICogQHR5cGVkZWYgQW5ub3RhdGlvbnNcbiAqICAgU3RhdGUgd2hlcmUgaW5mbyBmcm9tIGNvbW1lbnRzIGlzIGdhdGhlcmVkLlxuICogQHByb3BlcnR5IHtzdHJpbmcgfCB1bmRlZmluZWR9IFtqc3hdXG4gKiAgIEpTWCBpZGVudGlmaWVyIChgcHJhZ21hYCkuXG4gKiBAcHJvcGVydHkge3N0cmluZyB8IHVuZGVmaW5lZH0gW2pzeEZyYWddXG4gKiAgIEpTWCBpZGVudGlmaWVyIG9mIGZyYWdtZW50IChgcHJhZ21hRnJhZ2ApLlxuICogQHByb3BlcnR5IHtzdHJpbmcgfCB1bmRlZmluZWR9IFtqc3hJbXBvcnRTb3VyY2VdXG4gKiAgIFdoZXJlIHRvIGltcG9ydCBhbiBhdXRvbWF0aWMgSlNYIHJ1bnRpbWUgZnJvbS5cbiAqIEBwcm9wZXJ0eSB7UnVudGltZSB8IHVuZGVmaW5lZH0gW2pzeFJ1bnRpbWVdXG4gKiAgIFJ1bnRpbWUuXG4gKlxuICogQHR5cGVkZWYgSW1wb3J0c1xuICogICBTdGF0ZSBvZiB1c2VkIGlkZW50aWZpZXJzIGZyb20gdGhlIGF1dG9tYXRpYyBydW50aW1lLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgdW5kZWZpbmVkfSBbZnJhZ21lbnRdXG4gKiAgIFN5bWJvbCBvZiBgRnJhZ21lbnRgLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgdW5kZWZpbmVkfSBbanN4XVxuICogICBTeW1ib2wgb2YgYGpzeGAuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW4gfCB1bmRlZmluZWR9IFtqc3hzXVxuICogICBTeW1ib2wgb2YgYGpzeHNgLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgdW5kZWZpbmVkfSBbanN4REVWXVxuICogICBTeW1ib2wgb2YgYGpzeERFVmAuXG4gKi9cblxuaW1wb3J0IHtvayBhcyBhc3NlcnR9IGZyb20gJ2RldmxvcCdcbmltcG9ydCB7bmFtZSBhcyBpc0lkZW50aWZpZXJOYW1lfSBmcm9tICdlc3RyZWUtdXRpbC1pcy1pZGVudGlmaWVyLW5hbWUnXG5pbXBvcnQge3dhbGt9IGZyb20gJ2VzdHJlZS13YWxrZXInXG5cbmNvbnN0IHJlZ2V4ID0gL0AoanN4fGpzeEZyYWd8anN4SW1wb3J0U291cmNlfGpzeFJ1bnRpbWUpXFxzKyhcXFMrKS9nXG5cbi8qKlxuICogVHVybiBKU1ggaW4gYHRyZWVgIGludG8gZnVuY3Rpb24gY2FsbHM6IGA8eCAvPmAgLT4gYGgoJ3gnKWAhXG4gKlxuICogIyMjIyMjIEFsZ29yaXRobVxuICpcbiAqIEluIGFsbW9zdCBhbGwgY2FzZXMsIHRoaXMgdXRpbGl0eSBpcyB0aGUgc2FtZSBhcyB0aGUgQmFiZWwgcGx1Z2luLCBleGNlcHQgdGhhdFxuICogdGhleSB3b3JrIG9uIHNsaWdodGx5IGRpZmZlcmVudCBzeW50YXggdHJlZXMuXG4gKlxuICogU29tZSBkaWZmZXJlbmNlczpcbiAqXG4gKiAqICAgbm8gcHVyZSBhbm5vdGF0aW9ucyB0aGluZ3NcbiAqICogICBgdGhpc2AgaXMgbm90IGEgY29tcG9uZW50OiBgPHRoaXM+YCAtPiBgaCgndGhpcycpYCwgbm90IGBoKHRoaXMpYFxuICogKiAgIG5hbWVzcGFjZXMgYXJlIHN1cHBvcnRlZDogYDxhOmIgYzpkPmAgLT4gYGgoJ2E6YicsIHsnYzpkJzogdHJ1ZX0pYCxcbiAqICAgICB3aGljaCB0aHJvd3MgYnkgZGVmYXVsdCBpbiBCYWJlbCBvciBjYW4gYmUgdHVybmVkIG9uIHdpdGggYHRocm93SWZOYW1lc3BhY2VgXG4gKiAqICAgbm8gYHVzZVNwcmVhZGAsIGB1c2VCdWlsdEluc2AsIG9yIGBmaWx0ZXJgIG9wdGlvbnNcbiAqXG4gKiBAcGFyYW0ge05vZGV9IHRyZWVcbiAqICAgVHJlZSB0byB0cmFuc2Zvcm0gKHR5cGljYWxseSBgUHJvZ3JhbWApLlxuICogQHBhcmFtIHtPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdGlvbnNdXG4gKiAgIENvbmZpZ3VyYXRpb24gKG9wdGlvbmFsKS5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiAgIE5vdGhpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEpzeCh0cmVlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNvbmZpZyA9IG9wdGlvbnMgfHwge31cbiAgbGV0IGF1dG9tYXRpYyA9IGNvbmZpZy5ydW50aW1lID09PSAnYXV0b21hdGljJ1xuICAvKiogQHR5cGUge0Fubm90YXRpb25zfSAqL1xuICBjb25zdCBhbm5vdGF0aW9ucyA9IHt9XG4gIC8qKiBAdHlwZSB7SW1wb3J0c30gKi9cbiAgY29uc3QgaW1wb3J0cyA9IHt9XG5cbiAgd2Fsayh0cmVlLCB7XG4gICAgZW50ZXIobm9kZSkge1xuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ1Byb2dyYW0nKSB7XG4gICAgICAgIGNvbnN0IGNvbW1lbnRzID0gbm9kZS5jb21tZW50cyB8fCBbXVxuICAgICAgICBsZXQgaW5kZXggPSAtMVxuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgY29tbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmVnZXgubGFzdEluZGV4ID0gMFxuXG4gICAgICAgICAgbGV0IG1hdGNoID0gcmVnZXguZXhlYyhjb21tZW50c1tpbmRleF0udmFsdWUpXG5cbiAgICAgICAgICB3aGlsZSAobWF0Y2gpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGBtYXRjaFsxXWAgaXMgYWx3YXlzIGEga2V5LCBgbWF0Y2hbMl1gIHdoZW5cbiAgICAgICAgICAgIC8vIHJ1bnRpbWUgaXMgY2hlY2tlZCBsYXRlci5cbiAgICAgICAgICAgIGFubm90YXRpb25zW21hdGNoWzFdXSA9IG1hdGNoWzJdXG4gICAgICAgICAgICBtYXRjaCA9IHJlZ2V4LmV4ZWMoY29tbWVudHNbaW5kZXhdLnZhbHVlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbm5vdGF0aW9ucy5qc3hSdW50aW1lKSB7XG4gICAgICAgICAgaWYgKGFubm90YXRpb25zLmpzeFJ1bnRpbWUgPT09ICdhdXRvbWF0aWMnKSB7XG4gICAgICAgICAgICBhdXRvbWF0aWMgPSB0cnVlXG5cbiAgICAgICAgICAgIGlmIChhbm5vdGF0aW9ucy5qc3gpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGBAanN4YCBwcmFnbWEgdy8gYXV0b21hdGljIHJ1bnRpbWUnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYW5ub3RhdGlvbnMuanN4RnJhZykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgJ1VuZXhwZWN0ZWQgYEBqc3hGcmFnYCBwcmFnbWEgdy8gYXV0b21hdGljIHJ1bnRpbWUnXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGFubm90YXRpb25zLmpzeFJ1bnRpbWUgPT09ICdjbGFzc2ljJykge1xuICAgICAgICAgICAgYXV0b21hdGljID0gZmFsc2VcblxuICAgICAgICAgICAgaWYgKGFubm90YXRpb25zLmpzeEltcG9ydFNvdXJjZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgJ1VuZXhwZWN0ZWQgYEBqc3hJbXBvcnRTb3VyY2VgIHcvIGNsYXNzaWMgcnVudGltZSdcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICdVbmV4cGVjdGVkIGBqc3hSdW50aW1lYCBgJyArXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbnMuanN4UnVudGltZSArXG4gICAgICAgICAgICAgICAgJ2AsIGV4cGVjdGVkIGBhdXRvbWF0aWNgIG9yIGBjbGFzc2ljYCdcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gICAgbGVhdmUobm9kZSkge1xuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ1Byb2dyYW0nKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXk8SW1wb3J0U3BlY2lmaWVyPn0gKi9cbiAgICAgICAgY29uc3Qgc3BlY2lmaWVycyA9IFtdXG5cbiAgICAgICAgaWYgKGltcG9ydHMuZnJhZ21lbnQpIHtcbiAgICAgICAgICBzcGVjaWZpZXJzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ0ltcG9ydFNwZWNpZmllcicsXG4gICAgICAgICAgICBpbXBvcnRlZDoge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ0ZyYWdtZW50J30sXG4gICAgICAgICAgICBsb2NhbDoge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ19GcmFnbWVudCd9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbXBvcnRzLmpzeCkge1xuICAgICAgICAgIHNwZWNpZmllcnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnSW1wb3J0U3BlY2lmaWVyJyxcbiAgICAgICAgICAgIGltcG9ydGVkOiB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiAnanN4J30sXG4gICAgICAgICAgICBsb2NhbDoge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ19qc3gnfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW1wb3J0cy5qc3hzKSB7XG4gICAgICAgICAgc3BlY2lmaWVycy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdJbXBvcnRTcGVjaWZpZXInLFxuICAgICAgICAgICAgaW1wb3J0ZWQ6IHt0eXBlOiAnSWRlbnRpZmllcicsIG5hbWU6ICdqc3hzJ30sXG4gICAgICAgICAgICBsb2NhbDoge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ19qc3hzJ31cbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGltcG9ydHMuanN4REVWKSB7XG4gICAgICAgICAgc3BlY2lmaWVycy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdJbXBvcnRTcGVjaWZpZXInLFxuICAgICAgICAgICAgaW1wb3J0ZWQ6IHt0eXBlOiAnSWRlbnRpZmllcicsIG5hbWU6ICdqc3hERVYnfSxcbiAgICAgICAgICAgIGxvY2FsOiB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiAnX2pzeERFVid9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzcGVjaWZpZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBsZXQgaW5qZWN0SW5kZXggPSAwXG5cbiAgICAgICAgICB3aGlsZSAoaW5qZWN0SW5kZXggPCBub2RlLmJvZHkubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuYm9keVtpbmplY3RJbmRleF1cblxuICAgICAgICAgICAgaWYgKCdkaXJlY3RpdmUnIGluIGNoaWxkICYmIGNoaWxkLmRpcmVjdGl2ZSkge1xuICAgICAgICAgICAgICBpbmplY3RJbmRleCsrXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5vZGUuYm9keS5zcGxpY2UoaW5qZWN0SW5kZXgsIDAsIHtcbiAgICAgICAgICAgIHR5cGU6ICdJbXBvcnREZWNsYXJhdGlvbicsXG4gICAgICAgICAgICBzcGVjaWZpZXJzLFxuICAgICAgICAgICAgc291cmNlOiB7XG4gICAgICAgICAgICAgIHR5cGU6ICdMaXRlcmFsJyxcbiAgICAgICAgICAgICAgdmFsdWU6XG4gICAgICAgICAgICAgICAgKGFubm90YXRpb25zLmpzeEltcG9ydFNvdXJjZSB8fFxuICAgICAgICAgICAgICAgICAgY29uZmlnLmltcG9ydFNvdXJjZSB8fFxuICAgICAgICAgICAgICAgICAgJ3JlYWN0JykgK1xuICAgICAgICAgICAgICAgIChjb25maWcuZGV2ZWxvcG1lbnQgPyAnL2pzeC1kZXYtcnVudGltZScgOiAnL2pzeC1ydW50aW1lJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLnR5cGUgIT09ICdKU1hFbGVtZW50JyAmJiBub2RlLnR5cGUgIT09ICdKU1hGcmFnbWVudCcpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8RXhwcmVzc2lvbj59ICovXG4gICAgICBjb25zdCBjaGlsZHJlbiA9IFtdXG4gICAgICBsZXQgaW5kZXggPSAtMVxuXG4gICAgICAvLyBGaWd1cmUgb3V0IGBjaGlsZHJlbmAuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpbmRleF1cblxuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ0pTWEV4cHJlc3Npb25Db250YWluZXInKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGVtcHR5IGV4cHJlc3Npb25zLlxuICAgICAgICAgIGlmIChjaGlsZC5leHByZXNzaW9uLnR5cGUgIT09ICdKU1hFbXB0eUV4cHJlc3Npb24nKSB7XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkLmV4cHJlc3Npb24pXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNoaWxkLnR5cGUgPT09ICdKU1hUZXh0Jykge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gY2hpbGQudmFsdWVcbiAgICAgICAgICAgIC8vIFJlcGxhY2UgdGFicyB3LyBzcGFjZXMuXG4gICAgICAgICAgICAucmVwbGFjZSgvXFx0L2csICcgJylcbiAgICAgICAgICAgIC8vIFVzZSBsaW5lIGZlZWRzLCBkcm9wIHNwYWNlcyBhcm91bmQgdGhlbS5cbiAgICAgICAgICAgIC5yZXBsYWNlKC8gKihcXHI/XFxufFxccikgKi9nLCAnXFxuJylcbiAgICAgICAgICAgIC8vIENvbGxhcHNlIG11bHRpcGxlIGxpbmUgZmVlZHMuXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxuKy9nLCAnXFxuJylcbiAgICAgICAgICAgIC8vIERyb3AgZmluYWwgbGluZSBmZWVkcy5cbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXG4rJC8sICcnKVxuICAgICAgICAgICAgLy8gRHJvcCBmaXJzdCBsaW5lIGZlZWRzLlxuICAgICAgICAgICAgLnJlcGxhY2UoL15cXG4rLywgJycpXG4gICAgICAgICAgICAvLyBSZXBsYWNlIGxpbmUgZmVlZHMgd2l0aCBzcGFjZXMuXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxuL2csICcgJylcblxuICAgICAgICAgIC8vIElnbm9yZSBjb2xsYXBzaWJsZSB0ZXh0LlxuICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgLyoqIEB0eXBlIHtOb2RlfSAqL1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IHt0eXBlOiAnTGl0ZXJhbCcsIHZhbHVlfVxuICAgICAgICAgICAgY3JlYXRlKGNoaWxkLCB0ZXh0KVxuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0ZXh0KVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhc3NlcnQoXG4gICAgICAgICAgICBjaGlsZC50eXBlICE9PSAnSlNYRWxlbWVudCcgJiZcbiAgICAgICAgICAgICAgY2hpbGQudHlwZSAhPT0gJ0pTWEZyYWdtZW50JyAmJlxuICAgICAgICAgICAgICBjaGlsZC50eXBlICE9PSAnSlNYU3ByZWFkQ2hpbGQnXG4gICAgICAgICAgKVxuICAgICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqIEB0eXBlIHtJZGVudGlmaWVyIHwgTGl0ZXJhbCB8IE1lbWJlckV4cHJlc3Npb259ICovXG4gICAgICBsZXQgbmFtZVxuICAgICAgLyoqIEB0eXBlIHtBcnJheTxQcm9wZXJ0eSB8IFNwcmVhZEVsZW1lbnQ+fSAqL1xuICAgICAgY29uc3QgZmllbGRzID0gW11cbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8RXhwcmVzc2lvbj59ICovXG4gICAgICBsZXQgcGFyYW1ldGVycyA9IFtdXG4gICAgICAvKiogQHR5cGUge0V4cHJlc3Npb24gfCB1bmRlZmluZWR9ICovXG4gICAgICBsZXQga2V5XG5cbiAgICAgIC8vIERvIHRoZSBzdHVmZiBuZWVkZWQgZm9yIGVsZW1lbnRzLlxuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ0pTWEVsZW1lbnQnKSB7XG4gICAgICAgIG5hbWUgPSB0b0lkZW50aWZpZXIobm9kZS5vcGVuaW5nRWxlbWVudC5uYW1lKVxuXG4gICAgICAgIC8vIElmIHRoZSBuYW1lIGNvdWxkIGJlIGFuIGlkZW50aWZpZXIsIGJ1dCBzdGFydCB3aXRoIGEgbG93ZXJjYXNlIGxldHRlcixcbiAgICAgICAgLy8gaXTigJlzIG5vdCBhIGNvbXBvbmVudC5cbiAgICAgICAgaWYgKG5hbWUudHlwZSA9PT0gJ0lkZW50aWZpZXInICYmIC9eW2Etel0vLnRlc3QobmFtZS5uYW1lKSkge1xuICAgICAgICAgIC8qKiBAdHlwZSB7Tm9kZX0gKi9cbiAgICAgICAgICBjb25zdCBuZXh0ID0ge3R5cGU6ICdMaXRlcmFsJywgdmFsdWU6IG5hbWUubmFtZX1cbiAgICAgICAgICBjcmVhdGUobmFtZSwgbmV4dClcbiAgICAgICAgICBuYW1lID0gbmV4dFxuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFuIHwgdW5kZWZpbmVkfSAqL1xuICAgICAgICBsZXQgc3ByZWFkXG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBub2RlLm9wZW5pbmdFbGVtZW50LmF0dHJpYnV0ZXNcbiAgICAgICAgbGV0IGluZGV4ID0gLTFcblxuICAgICAgICAvLyBQbGFjZSBwcm9wcyBpbiB0aGUgcmlnaHQgb3JkZXIsIGJlY2F1c2Ugd2UgbWlnaHQgaGF2ZSBkdXBsaWNhdGVzXG4gICAgICAgIC8vIGluIHRoZW0gYW5kIHdoYXTigJlzIHNwcmVhZCBpbi5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBhdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbaW5kZXhdXG5cbiAgICAgICAgICBpZiAoYXR0cmlidXRlLnR5cGUgPT09ICdKU1hTcHJlYWRBdHRyaWJ1dGUnKSB7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlLmFyZ3VtZW50LnR5cGUgPT09ICdPYmplY3RFeHByZXNzaW9uJykge1xuICAgICAgICAgICAgICBmaWVsZHMucHVzaCguLi5hdHRyaWJ1dGUuYXJndW1lbnQucHJvcGVydGllcylcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZpZWxkcy5wdXNoKHt0eXBlOiAnU3ByZWFkRWxlbWVudCcsIGFyZ3VtZW50OiBhdHRyaWJ1dGUuYXJndW1lbnR9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzcHJlYWQgPSB0cnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3AgPSB0b1Byb3BlcnR5KGF0dHJpYnV0ZSlcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBhdXRvbWF0aWMgJiZcbiAgICAgICAgICAgICAgcHJvcC5rZXkudHlwZSA9PT0gJ0lkZW50aWZpZXInICYmXG4gICAgICAgICAgICAgIHByb3Aua2V5Lm5hbWUgPT09ICdrZXknXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKHNwcmVhZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICdFeHBlY3RlZCBga2V5YCB0byBjb21lIGJlZm9yZSBhbnkgc3ByZWFkIGV4cHJlc3Npb25zJ1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcHJvcC52YWx1ZVxuXG4gICAgICAgICAgICAgIGFzc2VydChcbiAgICAgICAgICAgICAgICB2YWx1ZS50eXBlICE9PSAnQXNzaWdubWVudFBhdHRlcm4nICYmXG4gICAgICAgICAgICAgICAgICB2YWx1ZS50eXBlICE9PSAnQXJyYXlQYXR0ZXJuJyAmJlxuICAgICAgICAgICAgICAgICAgdmFsdWUudHlwZSAhPT0gJ09iamVjdFBhdHRlcm4nICYmXG4gICAgICAgICAgICAgICAgICB2YWx1ZS50eXBlICE9PSAnUmVzdEVsZW1lbnQnXG4gICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICBrZXkgPSB2YWx1ZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZmllbGRzLnB1c2gocHJvcClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIOKApmFuZCBmcmFnbWVudHMuXG4gICAgICBlbHNlIGlmIChhdXRvbWF0aWMpIHtcbiAgICAgICAgaW1wb3J0cy5mcmFnbWVudCA9IHRydWVcbiAgICAgICAgbmFtZSA9IHt0eXBlOiAnSWRlbnRpZmllcicsIG5hbWU6ICdfRnJhZ21lbnQnfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmFtZSA9IHRvTWVtYmVyRXhwcmVzc2lvbihcbiAgICAgICAgICBhbm5vdGF0aW9ucy5qc3hGcmFnIHx8IGNvbmZpZy5wcmFnbWFGcmFnIHx8ICdSZWFjdC5GcmFnbWVudCdcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBpZiAoYXV0b21hdGljKSB7XG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZmllbGRzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ1Byb3BlcnR5JyxcbiAgICAgICAgICAgIGtleToge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ2NoaWxkcmVuJ30sXG4gICAgICAgICAgICB2YWx1ZTpcbiAgICAgICAgICAgICAgY2hpbGRyZW4ubGVuZ3RoID4gMVxuICAgICAgICAgICAgICAgID8ge3R5cGU6ICdBcnJheUV4cHJlc3Npb24nLCBlbGVtZW50czogY2hpbGRyZW59XG4gICAgICAgICAgICAgICAgOiBjaGlsZHJlblswXSxcbiAgICAgICAgICAgIGtpbmQ6ICdpbml0JyxcbiAgICAgICAgICAgIG1ldGhvZDogZmFsc2UsXG4gICAgICAgICAgICBzaG9ydGhhbmQ6IGZhbHNlLFxuICAgICAgICAgICAgY29tcHV0ZWQ6IGZhbHNlXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1ldGVycyA9IGNoaWxkcmVuXG4gICAgICB9XG5cbiAgICAgIC8qKiBAdHlwZSB7SWRlbnRpZmllciB8IExpdGVyYWwgfCBNZW1iZXJFeHByZXNzaW9ufSAqL1xuICAgICAgbGV0IGNhbGxlZVxuXG4gICAgICBpZiAoYXV0b21hdGljKSB7XG4gICAgICAgIHBhcmFtZXRlcnMucHVzaCh7dHlwZTogJ09iamVjdEV4cHJlc3Npb24nLCBwcm9wZXJ0aWVzOiBmaWVsZHN9KVxuXG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICBwYXJhbWV0ZXJzLnB1c2goa2V5KVxuICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5kZXZlbG9wbWVudCkge1xuICAgICAgICAgIHBhcmFtZXRlcnMucHVzaCh7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiAndW5kZWZpbmVkJ30pXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpc1N0YXRpY0NoaWxkcmVuID0gY2hpbGRyZW4ubGVuZ3RoID4gMVxuXG4gICAgICAgIGlmIChjb25maWcuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICBpbXBvcnRzLmpzeERFViA9IHRydWVcbiAgICAgICAgICBjYWxsZWUgPSB7XG4gICAgICAgICAgICB0eXBlOiAnSWRlbnRpZmllcicsXG4gICAgICAgICAgICBuYW1lOiAnX2pzeERFVidcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyYW1ldGVycy5wdXNoKHt0eXBlOiAnTGl0ZXJhbCcsIHZhbHVlOiBpc1N0YXRpY0NoaWxkcmVufSlcblxuICAgICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0RXhwcmVzc2lvbn0gKi9cbiAgICAgICAgICBjb25zdCBzb3VyY2UgPSB7XG4gICAgICAgICAgICB0eXBlOiAnT2JqZWN0RXhwcmVzc2lvbicsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnUHJvcGVydHknLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvcnRoYW5kOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb21wdXRlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAga2luZDogJ2luaXQnLFxuICAgICAgICAgICAgICAgIGtleToge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ2ZpbGVOYW1lJ30sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdMaXRlcmFsJyxcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb25maWcuZmlsZVBhdGggfHwgJzxzb3VyY2UuanM+J1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChub2RlLmxvYykge1xuICAgICAgICAgICAgc291cmNlLnByb3BlcnRpZXMucHVzaChcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdQcm9wZXJ0eScsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG9ydGhhbmQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbXB1dGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBraW5kOiAnaW5pdCcsXG4gICAgICAgICAgICAgICAga2V5OiB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiAnbGluZU51bWJlcid9LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB7dHlwZTogJ0xpdGVyYWwnLCB2YWx1ZTogbm9kZS5sb2Muc3RhcnQubGluZX1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdQcm9wZXJ0eScsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG9ydGhhbmQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbXB1dGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBraW5kOiAnaW5pdCcsXG4gICAgICAgICAgICAgICAga2V5OiB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiAnY29sdW1uTnVtYmVyJ30sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHt0eXBlOiAnTGl0ZXJhbCcsIHZhbHVlOiBub2RlLmxvYy5zdGFydC5jb2x1bW4gKyAxfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFyYW1ldGVycy5wdXNoKHNvdXJjZSwge3R5cGU6ICdUaGlzRXhwcmVzc2lvbid9KVxuICAgICAgICB9IGVsc2UgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpbXBvcnRzLmpzeHMgPSB0cnVlXG4gICAgICAgICAgY2FsbGVlID0ge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ19qc3hzJ31cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbXBvcnRzLmpzeCA9IHRydWVcbiAgICAgICAgICBjYWxsZWUgPSB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiAnX2pzeCd9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENsYXNzaWMuXG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGZpZWxkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcGFyYW1ldGVycy51bnNoaWZ0KHt0eXBlOiAnT2JqZWN0RXhwcmVzc2lvbicsIHByb3BlcnRpZXM6IGZpZWxkc30pXG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1ldGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcGFyYW1ldGVycy51bnNoaWZ0KHt0eXBlOiAnTGl0ZXJhbCcsIHZhbHVlOiBudWxsfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxlZSA9IHRvTWVtYmVyRXhwcmVzc2lvbihcbiAgICAgICAgICBhbm5vdGF0aW9ucy5qc3ggfHwgY29uZmlnLnByYWdtYSB8fCAnUmVhY3QuY3JlYXRlRWxlbWVudCdcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBwYXJhbWV0ZXJzLnVuc2hpZnQobmFtZSlcbiAgICAgIC8qKiBAdHlwZSB7Tm9kZX0gKi9cbiAgICAgIGNvbnN0IGNhbGwgPSB7XG4gICAgICAgIHR5cGU6ICdDYWxsRXhwcmVzc2lvbicsXG4gICAgICAgIGNhbGxlZSxcbiAgICAgICAgYXJndW1lbnRzOiBwYXJhbWV0ZXJzLFxuICAgICAgICBvcHRpb25hbDogZmFsc2VcbiAgICAgIH1cbiAgICAgIGNyZWF0ZShub2RlLCBjYWxsKVxuICAgICAgdGhpcy5yZXBsYWNlKGNhbGwpXG4gICAgfVxuICB9KVxufVxuXG4vKipcbiAqIFR1cm4gYSBKU1ggYXR0cmlidXRlIGludG8gYSBKYXZhU2NyaXB0IHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7SlNYQXR0cmlidXRlfSBub2RlXG4gKiAgIEpTWCBhdHRyaWJ1dGUuXG4gKiBAcmV0dXJucyB7UHJvcGVydHl9XG4gKiAgIEpTIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiB0b1Byb3BlcnR5KG5vZGUpIHtcbiAgLyoqIEB0eXBlIHtFeHByZXNzaW9ufSAqL1xuICBsZXQgdmFsdWVcblxuICBpZiAobm9kZS52YWx1ZSkge1xuICAgIGlmIChub2RlLnZhbHVlLnR5cGUgPT09ICdKU1hFeHByZXNzaW9uQ29udGFpbmVyJykge1xuICAgICAgY29uc3QgdmFsdWVFeHByZXNzaW9uID0gbm9kZS52YWx1ZS5leHByZXNzaW9uXG4gICAgICBhc3NlcnQoXG4gICAgICAgIHZhbHVlRXhwcmVzc2lvbi50eXBlICE9PSAnSlNYRW1wdHlFeHByZXNzaW9uJyxcbiAgICAgICAgJ2BKU1hFbXB0eUV4cHJlc3Npb25gIGlzIG5vdCBhbGxvd2VkIGluIHByb3BzLidcbiAgICAgIClcbiAgICAgIHZhbHVlID0gdmFsdWVFeHByZXNzaW9uXG4gICAgfVxuICAgIC8vIExpdGVyYWwgb3IgY2FsbCBleHByZXNzaW9uLlxuICAgIGVsc2Uge1xuICAgICAgY29uc3Qgbm9kZVZhbHVlID0gbm9kZS52YWx1ZVxuICAgICAgYXNzZXJ0KFxuICAgICAgICBub2RlVmFsdWUudHlwZSAhPT0gJ0pTWEVsZW1lbnQnICYmIG5vZGVWYWx1ZS50eXBlICE9PSAnSlNYRnJhZ21lbnQnLFxuICAgICAgICAnSlNYe0VsZW1lbnQsRnJhZ21lbnR9IGFyZSBhbHJlYWR5IGNvbXBpbGVkIHRvIGBDYWxsRXhwcmVzc2lvbmAnXG4gICAgICApXG4gICAgICB2YWx1ZSA9IG5vZGVWYWx1ZVxuICAgICAgZGVsZXRlIHZhbHVlLnJhd1xuICAgIH1cbiAgfVxuICAvLyBCb29sZWFuIHByb3AuXG4gIGVsc2Uge1xuICAgIHZhbHVlID0ge3R5cGU6ICdMaXRlcmFsJywgdmFsdWU6IHRydWV9XG4gIH1cblxuICAvKiogQHR5cGUge1Byb3BlcnR5fSAqL1xuICBjb25zdCByZXBsYWNlbWVudCA9IHtcbiAgICB0eXBlOiAnUHJvcGVydHknLFxuICAgIGtleTogdG9JZGVudGlmaWVyKG5vZGUubmFtZSksXG4gICAgdmFsdWUsXG4gICAga2luZDogJ2luaXQnLFxuICAgIG1ldGhvZDogZmFsc2UsXG4gICAgc2hvcnRoYW5kOiBmYWxzZSxcbiAgICBjb21wdXRlZDogZmFsc2VcbiAgfVxuICBjcmVhdGUobm9kZSwgcmVwbGFjZW1lbnQpXG4gIHJldHVybiByZXBsYWNlbWVudFxufVxuXG4vKipcbiAqIFR1cm4gYSBKU1ggaWRlbnRpZmllciBpbnRvIGEgbm9ybWFsIEpTIGlkZW50aWZpZXIuXG4gKlxuICogQHBhcmFtIHtKU1hJZGVudGlmaWVyIHwgSlNYTWVtYmVyRXhwcmVzc2lvbiB8IEpTWE5hbWVzcGFjZWROYW1lfSBub2RlXG4gKiAgIEpTWCBpZGVudGlmaWVyLlxuICogQHJldHVybnMge0lkZW50aWZpZXIgfCBMaXRlcmFsIHwgTWVtYmVyRXhwcmVzc2lvbn1cbiAqICAgSlMgaWRlbnRpZmllci5cbiAqL1xuZnVuY3Rpb24gdG9JZGVudGlmaWVyKG5vZGUpIHtcbiAgLyoqIEB0eXBlIHtJZGVudGlmaWVyIHwgTGl0ZXJhbCB8IE1lbWJlckV4cHJlc3Npb259ICovXG4gIGxldCByZXBsYWNlXG5cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ0pTWE1lbWJlckV4cHJlc3Npb24nKSB7XG4gICAgLy8gYHByb3BlcnR5YCBpcyBhbHdheXMgYSBgSlNYSWRlbnRpZmllcmAsIGJ1dCBpdCBjb3VsZCBiZSBzb21ldGhpbmcgdGhhdFxuICAgIC8vIGlzbuKAmXQgYW4gRVMgaWRlbnRpZmllciBuYW1lLlxuICAgIGNvbnN0IGlkID0gdG9JZGVudGlmaWVyKG5vZGUucHJvcGVydHkpXG4gICAgcmVwbGFjZSA9IHtcbiAgICAgIHR5cGU6ICdNZW1iZXJFeHByZXNzaW9uJyxcbiAgICAgIG9iamVjdDogdG9JZGVudGlmaWVyKG5vZGUub2JqZWN0KSxcbiAgICAgIHByb3BlcnR5OiBpZCxcbiAgICAgIGNvbXB1dGVkOiBpZC50eXBlID09PSAnTGl0ZXJhbCcsXG4gICAgICBvcHRpb25hbDogZmFsc2VcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAnSlNYTmFtZXNwYWNlZE5hbWUnKSB7XG4gICAgcmVwbGFjZSA9IHtcbiAgICAgIHR5cGU6ICdMaXRlcmFsJyxcbiAgICAgIHZhbHVlOiBub2RlLm5hbWVzcGFjZS5uYW1lICsgJzonICsgbm9kZS5uYW1lLm5hbWVcbiAgICB9XG4gIH1cbiAgLy8gTXVzdCBiZSBgSlNYSWRlbnRpZmllcmAuXG4gIGVsc2Uge1xuICAgIHJlcGxhY2UgPSBpc0lkZW50aWZpZXJOYW1lKG5vZGUubmFtZSlcbiAgICAgID8ge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogbm9kZS5uYW1lfVxuICAgICAgOiB7dHlwZTogJ0xpdGVyYWwnLCB2YWx1ZTogbm9kZS5uYW1lfVxuICB9XG5cbiAgY3JlYXRlKG5vZGUsIHJlcGxhY2UpXG4gIHJldHVybiByZXBsYWNlXG59XG5cbi8qKlxuICogVHVybiBhIGRvdHRlZCBzdHJpbmcgaW50byBhIG1lbWJlciBleHByZXNzaW9uLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICogICBJZGVudGlmaWVycy5cbiAqIEByZXR1cm5zIHtJZGVudGlmaWVyIHwgTGl0ZXJhbCB8IE1lbWJlckV4cHJlc3Npb259XG4gKiAgIEV4cHJlc3Npb24uXG4gKi9cbmZ1bmN0aW9uIHRvTWVtYmVyRXhwcmVzc2lvbihpZCkge1xuICBjb25zdCBpZGVudGlmaWVycyA9IGlkLnNwbGl0KCcuJylcbiAgbGV0IGluZGV4ID0gLTFcbiAgLyoqIEB0eXBlIHtJZGVudGlmaWVyIHwgTGl0ZXJhbCB8IE1lbWJlckV4cHJlc3Npb24gfCB1bmRlZmluZWR9ICovXG4gIGxldCByZXN1bHRcblxuICB3aGlsZSAoKytpbmRleCA8IGlkZW50aWZpZXJzLmxlbmd0aCkge1xuICAgIC8qKiBAdHlwZSB7SWRlbnRpZmllciB8IExpdGVyYWx9ICovXG4gICAgY29uc3QgcHJvcCA9IGlzSWRlbnRpZmllck5hbWUoaWRlbnRpZmllcnNbaW5kZXhdKVxuICAgICAgPyB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiBpZGVudGlmaWVyc1tpbmRleF19XG4gICAgICA6IHt0eXBlOiAnTGl0ZXJhbCcsIHZhbHVlOiBpZGVudGlmaWVyc1tpbmRleF19XG4gICAgcmVzdWx0ID0gcmVzdWx0XG4gICAgICA/IHtcbiAgICAgICAgICB0eXBlOiAnTWVtYmVyRXhwcmVzc2lvbicsXG4gICAgICAgICAgb2JqZWN0OiByZXN1bHQsXG4gICAgICAgICAgcHJvcGVydHk6IHByb3AsXG4gICAgICAgICAgY29tcHV0ZWQ6IEJvb2xlYW4oaW5kZXggJiYgcHJvcC50eXBlID09PSAnTGl0ZXJhbCcpLFxuICAgICAgICAgIG9wdGlvbmFsOiBmYWxzZVxuICAgICAgICB9XG4gICAgICA6IHByb3BcbiAgfVxuXG4gIGFzc2VydChyZXN1bHQsICdhbHdheXMgYSByZXN1bHQnKVxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qKlxuICogSW5oZXJpdCBzb21lIGZpZWxkcyBmcm9tIGBmcm9tYCBpbnRvIGB0b2AuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBmcm9tXG4gKiAgIE5vZGUgdG8gaW5oZXJpdCBmcm9tLlxuICogQHBhcmFtIHtOb2RlfSB0b1xuICogICBOb2RlIHRvIGFkZCB0by5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiAgIE5vdGhpbmcuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZShmcm9tLCB0bykge1xuICBjb25zdCBmaWVsZHMgPSBbJ3N0YXJ0JywgJ2VuZCcsICdsb2MnLCAncmFuZ2UnLCAnY29tbWVudHMnXVxuICBsZXQgaW5kZXggPSAtMVxuXG4gIHdoaWxlICgrK2luZGV4IDwgZmllbGRzLmxlbmd0aCkge1xuICAgIGNvbnN0IGZpZWxkID0gZmllbGRzW2luZGV4XVxuICAgIGlmIChmaWVsZCBpbiBmcm9tKSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbmRleGFibGUuXG4gICAgICB0b1tmaWVsZF0gPSBmcm9tW2ZpZWxkXVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbIm9rIiwiYXNzZXJ0IiwibmFtZSIsImlzSWRlbnRpZmllck5hbWUiLCJ3YWxrIiwicmVnZXgiLCJidWlsZEpzeCIsInRyZWUiLCJvcHRpb25zIiwiY29uZmlnIiwiYXV0b21hdGljIiwicnVudGltZSIsImFubm90YXRpb25zIiwiaW1wb3J0cyIsImVudGVyIiwibm9kZSIsInR5cGUiLCJjb21tZW50cyIsImluZGV4IiwibGVuZ3RoIiwibGFzdEluZGV4IiwibWF0Y2giLCJleGVjIiwidmFsdWUiLCJqc3hSdW50aW1lIiwianN4IiwiRXJyb3IiLCJqc3hGcmFnIiwianN4SW1wb3J0U291cmNlIiwibGVhdmUiLCJzcGVjaWZpZXJzIiwiZnJhZ21lbnQiLCJwdXNoIiwiaW1wb3J0ZWQiLCJsb2NhbCIsImpzeHMiLCJqc3hERVYiLCJpbmplY3RJbmRleCIsImJvZHkiLCJjaGlsZCIsImRpcmVjdGl2ZSIsInNwbGljZSIsInNvdXJjZSIsImltcG9ydFNvdXJjZSIsImRldmVsb3BtZW50IiwiY2hpbGRyZW4iLCJleHByZXNzaW9uIiwicmVwbGFjZSIsInRleHQiLCJjcmVhdGUiLCJmaWVsZHMiLCJwYXJhbWV0ZXJzIiwia2V5IiwidG9JZGVudGlmaWVyIiwib3BlbmluZ0VsZW1lbnQiLCJ0ZXN0IiwibmV4dCIsInNwcmVhZCIsImF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGUiLCJhcmd1bWVudCIsInByb3BlcnRpZXMiLCJwcm9wIiwidG9Qcm9wZXJ0eSIsInRvTWVtYmVyRXhwcmVzc2lvbiIsInByYWdtYUZyYWciLCJlbGVtZW50cyIsImtpbmQiLCJtZXRob2QiLCJzaG9ydGhhbmQiLCJjb21wdXRlZCIsImNhbGxlZSIsImlzU3RhdGljQ2hpbGRyZW4iLCJmaWxlUGF0aCIsImxvYyIsInN0YXJ0IiwibGluZSIsImNvbHVtbiIsInVuc2hpZnQiLCJwcmFnbWEiLCJjYWxsIiwiYXJndW1lbnRzIiwib3B0aW9uYWwiLCJ2YWx1ZUV4cHJlc3Npb24iLCJub2RlVmFsdWUiLCJyYXciLCJyZXBsYWNlbWVudCIsImlkIiwicHJvcGVydHkiLCJvYmplY3QiLCJuYW1lc3BhY2UiLCJpZGVudGlmaWVycyIsInNwbGl0IiwicmVzdWx0IiwiQm9vbGVhbiIsImZyb20iLCJ0byIsImZpZWxkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/estree-util-build-jsx/lib/index.js\n");

/***/ })

};
;