/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/acorn";
exports.ids = ["vendor-chunks/acorn"];
exports.modules = {

/***/ "(ssr)/./node_modules/acorn/dist/acorn.js":
/*!******************************************!*\
  !*** ./node_modules/acorn/dist/acorn.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("(function(global, factory) {\n     true ? factory(exports) : 0;\n})(this, function(exports1) {\n    \"use strict\";\n    // This file was generated. Do not modify manually!\n    var astralIdentifierCodes = [\n        509,\n        0,\n        227,\n        0,\n        150,\n        4,\n        294,\n        9,\n        1368,\n        2,\n        2,\n        1,\n        6,\n        3,\n        41,\n        2,\n        5,\n        0,\n        166,\n        1,\n        574,\n        3,\n        9,\n        9,\n        7,\n        9,\n        32,\n        4,\n        318,\n        1,\n        80,\n        3,\n        71,\n        10,\n        50,\n        3,\n        123,\n        2,\n        54,\n        14,\n        32,\n        10,\n        3,\n        1,\n        11,\n        3,\n        46,\n        10,\n        8,\n        0,\n        46,\n        9,\n        7,\n        2,\n        37,\n        13,\n        2,\n        9,\n        6,\n        1,\n        45,\n        0,\n        13,\n        2,\n        49,\n        13,\n        9,\n        3,\n        2,\n        11,\n        83,\n        11,\n        7,\n        0,\n        3,\n        0,\n        158,\n        11,\n        6,\n        9,\n        7,\n        3,\n        56,\n        1,\n        2,\n        6,\n        3,\n        1,\n        3,\n        2,\n        10,\n        0,\n        11,\n        1,\n        3,\n        6,\n        4,\n        4,\n        68,\n        8,\n        2,\n        0,\n        3,\n        0,\n        2,\n        3,\n        2,\n        4,\n        2,\n        0,\n        15,\n        1,\n        83,\n        17,\n        10,\n        9,\n        5,\n        0,\n        82,\n        19,\n        13,\n        9,\n        214,\n        6,\n        3,\n        8,\n        28,\n        1,\n        83,\n        16,\n        16,\n        9,\n        82,\n        12,\n        9,\n        9,\n        7,\n        19,\n        58,\n        14,\n        5,\n        9,\n        243,\n        14,\n        166,\n        9,\n        71,\n        5,\n        2,\n        1,\n        3,\n        3,\n        2,\n        0,\n        2,\n        1,\n        13,\n        9,\n        120,\n        6,\n        3,\n        6,\n        4,\n        0,\n        29,\n        9,\n        41,\n        6,\n        2,\n        3,\n        9,\n        0,\n        10,\n        10,\n        47,\n        15,\n        343,\n        9,\n        54,\n        7,\n        2,\n        7,\n        17,\n        9,\n        57,\n        21,\n        2,\n        13,\n        123,\n        5,\n        4,\n        0,\n        2,\n        1,\n        2,\n        6,\n        2,\n        0,\n        9,\n        9,\n        49,\n        4,\n        2,\n        1,\n        2,\n        4,\n        9,\n        9,\n        330,\n        3,\n        10,\n        1,\n        2,\n        0,\n        49,\n        6,\n        4,\n        4,\n        14,\n        10,\n        5350,\n        0,\n        7,\n        14,\n        11465,\n        27,\n        2343,\n        9,\n        87,\n        9,\n        39,\n        4,\n        60,\n        6,\n        26,\n        9,\n        535,\n        9,\n        470,\n        0,\n        2,\n        54,\n        8,\n        3,\n        82,\n        0,\n        12,\n        1,\n        19628,\n        1,\n        4178,\n        9,\n        519,\n        45,\n        3,\n        22,\n        543,\n        4,\n        4,\n        5,\n        9,\n        7,\n        3,\n        6,\n        31,\n        3,\n        149,\n        2,\n        1418,\n        49,\n        513,\n        54,\n        5,\n        49,\n        9,\n        0,\n        15,\n        0,\n        23,\n        4,\n        2,\n        14,\n        1361,\n        6,\n        2,\n        16,\n        3,\n        6,\n        2,\n        1,\n        2,\n        4,\n        101,\n        0,\n        161,\n        6,\n        10,\n        9,\n        357,\n        0,\n        62,\n        13,\n        499,\n        13,\n        245,\n        1,\n        2,\n        9,\n        726,\n        6,\n        110,\n        6,\n        6,\n        9,\n        4759,\n        9,\n        787719,\n        239\n    ];\n    // This file was generated. Do not modify manually!\n    var astralIdentifierStartCodes = [\n        0,\n        11,\n        2,\n        25,\n        2,\n        18,\n        2,\n        1,\n        2,\n        14,\n        3,\n        13,\n        35,\n        122,\n        70,\n        52,\n        268,\n        28,\n        4,\n        48,\n        48,\n        31,\n        14,\n        29,\n        6,\n        37,\n        11,\n        29,\n        3,\n        35,\n        5,\n        7,\n        2,\n        4,\n        43,\n        157,\n        19,\n        35,\n        5,\n        35,\n        5,\n        39,\n        9,\n        51,\n        13,\n        10,\n        2,\n        14,\n        2,\n        6,\n        2,\n        1,\n        2,\n        10,\n        2,\n        14,\n        2,\n        6,\n        2,\n        1,\n        4,\n        51,\n        13,\n        310,\n        10,\n        21,\n        11,\n        7,\n        25,\n        5,\n        2,\n        41,\n        2,\n        8,\n        70,\n        5,\n        3,\n        0,\n        2,\n        43,\n        2,\n        1,\n        4,\n        0,\n        3,\n        22,\n        11,\n        22,\n        10,\n        30,\n        66,\n        18,\n        2,\n        1,\n        11,\n        21,\n        11,\n        25,\n        71,\n        55,\n        7,\n        1,\n        65,\n        0,\n        16,\n        3,\n        2,\n        2,\n        2,\n        28,\n        43,\n        28,\n        4,\n        28,\n        36,\n        7,\n        2,\n        27,\n        28,\n        53,\n        11,\n        21,\n        11,\n        18,\n        14,\n        17,\n        111,\n        72,\n        56,\n        50,\n        14,\n        50,\n        14,\n        35,\n        39,\n        27,\n        10,\n        22,\n        251,\n        41,\n        7,\n        1,\n        17,\n        2,\n        60,\n        28,\n        11,\n        0,\n        9,\n        21,\n        43,\n        17,\n        47,\n        20,\n        28,\n        22,\n        13,\n        52,\n        58,\n        1,\n        3,\n        0,\n        14,\n        44,\n        33,\n        24,\n        27,\n        35,\n        30,\n        0,\n        3,\n        0,\n        9,\n        34,\n        4,\n        0,\n        13,\n        47,\n        15,\n        3,\n        22,\n        0,\n        2,\n        0,\n        36,\n        17,\n        2,\n        24,\n        20,\n        1,\n        64,\n        6,\n        2,\n        0,\n        2,\n        3,\n        2,\n        14,\n        2,\n        9,\n        8,\n        46,\n        39,\n        7,\n        3,\n        1,\n        3,\n        21,\n        2,\n        6,\n        2,\n        1,\n        2,\n        4,\n        4,\n        0,\n        19,\n        0,\n        13,\n        4,\n        31,\n        9,\n        2,\n        0,\n        3,\n        0,\n        2,\n        37,\n        2,\n        0,\n        26,\n        0,\n        2,\n        0,\n        45,\n        52,\n        19,\n        3,\n        21,\n        2,\n        31,\n        47,\n        21,\n        1,\n        2,\n        0,\n        185,\n        46,\n        42,\n        3,\n        37,\n        47,\n        21,\n        0,\n        60,\n        42,\n        14,\n        0,\n        72,\n        26,\n        38,\n        6,\n        186,\n        43,\n        117,\n        63,\n        32,\n        7,\n        3,\n        0,\n        3,\n        7,\n        2,\n        1,\n        2,\n        23,\n        16,\n        0,\n        2,\n        0,\n        95,\n        7,\n        3,\n        38,\n        17,\n        0,\n        2,\n        0,\n        29,\n        0,\n        11,\n        39,\n        8,\n        0,\n        22,\n        0,\n        12,\n        45,\n        20,\n        0,\n        19,\n        72,\n        200,\n        32,\n        32,\n        8,\n        2,\n        36,\n        18,\n        0,\n        50,\n        29,\n        113,\n        6,\n        2,\n        1,\n        2,\n        37,\n        22,\n        0,\n        26,\n        5,\n        2,\n        1,\n        2,\n        31,\n        15,\n        0,\n        328,\n        18,\n        16,\n        0,\n        2,\n        12,\n        2,\n        33,\n        125,\n        0,\n        80,\n        921,\n        103,\n        110,\n        18,\n        195,\n        2637,\n        96,\n        16,\n        1071,\n        18,\n        5,\n        26,\n        3994,\n        6,\n        582,\n        6842,\n        29,\n        1763,\n        568,\n        8,\n        30,\n        18,\n        78,\n        18,\n        29,\n        19,\n        47,\n        17,\n        3,\n        32,\n        20,\n        6,\n        18,\n        433,\n        44,\n        212,\n        63,\n        129,\n        74,\n        6,\n        0,\n        67,\n        12,\n        65,\n        1,\n        2,\n        0,\n        29,\n        6135,\n        9,\n        1237,\n        42,\n        9,\n        8936,\n        3,\n        2,\n        6,\n        2,\n        1,\n        2,\n        290,\n        16,\n        0,\n        30,\n        2,\n        3,\n        0,\n        15,\n        3,\n        9,\n        395,\n        2309,\n        106,\n        6,\n        12,\n        4,\n        8,\n        8,\n        9,\n        5991,\n        84,\n        2,\n        70,\n        2,\n        1,\n        3,\n        0,\n        3,\n        1,\n        3,\n        3,\n        2,\n        11,\n        2,\n        0,\n        2,\n        6,\n        2,\n        64,\n        2,\n        3,\n        3,\n        7,\n        2,\n        6,\n        2,\n        27,\n        2,\n        3,\n        2,\n        4,\n        2,\n        0,\n        4,\n        6,\n        2,\n        339,\n        3,\n        24,\n        2,\n        24,\n        2,\n        30,\n        2,\n        24,\n        2,\n        30,\n        2,\n        24,\n        2,\n        30,\n        2,\n        24,\n        2,\n        30,\n        2,\n        24,\n        2,\n        7,\n        1845,\n        30,\n        7,\n        5,\n        262,\n        61,\n        147,\n        44,\n        11,\n        6,\n        17,\n        0,\n        322,\n        29,\n        19,\n        43,\n        485,\n        27,\n        229,\n        29,\n        3,\n        0,\n        496,\n        6,\n        2,\n        3,\n        2,\n        1,\n        2,\n        14,\n        2,\n        196,\n        60,\n        67,\n        8,\n        0,\n        1205,\n        3,\n        2,\n        26,\n        2,\n        1,\n        2,\n        0,\n        3,\n        0,\n        2,\n        9,\n        2,\n        3,\n        2,\n        0,\n        2,\n        0,\n        7,\n        0,\n        5,\n        0,\n        2,\n        0,\n        2,\n        0,\n        2,\n        2,\n        2,\n        1,\n        2,\n        0,\n        3,\n        0,\n        2,\n        0,\n        2,\n        0,\n        2,\n        0,\n        2,\n        0,\n        2,\n        1,\n        2,\n        0,\n        3,\n        3,\n        2,\n        6,\n        2,\n        3,\n        2,\n        3,\n        2,\n        0,\n        2,\n        9,\n        2,\n        16,\n        6,\n        2,\n        2,\n        4,\n        2,\n        16,\n        4421,\n        42719,\n        33,\n        4153,\n        7,\n        221,\n        3,\n        5761,\n        15,\n        7472,\n        16,\n        621,\n        2467,\n        541,\n        1507,\n        4938,\n        6,\n        4191\n    ];\n    // This file was generated. Do not modify manually!\n    var nonASCIIidentifierChars = \"‌‍\\xb7̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࢗ-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･\";\n    // This file was generated. Do not modify manually!\n    var nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲊᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟍꟐꟑꟓꟕ-Ƛꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ\";\n    // These are a run-length and offset encoded representation of the\n    // >0xffff code points that are a valid part of identifiers. The\n    // offset starts at 0x10000, and each pair of numbers represents an\n    // offset to the next range, and then a size of the range.\n    // Reserved word lists for various dialects of the language\n    var reservedWords = {\n        3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n        5: \"class enum extends super const export import\",\n        6: \"enum\",\n        strict: \"implements interface let package private protected public static yield\",\n        strictBind: \"eval arguments\"\n    };\n    // And the keywords\n    var ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\n    var keywords$1 = {\n        5: ecma5AndLessKeywords,\n        \"5module\": ecma5AndLessKeywords + \" export import\",\n        6: ecma5AndLessKeywords + \" const class extends export import super\"\n    };\n    var keywordRelationalOperator = /^in(stanceof)?$/;\n    // ## Character categories\n    var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\n    var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n    // This has a complexity linear to the value of the code. The\n    // assumption is that looking up astral identifier characters is\n    // rare.\n    function isInAstralSet(code, set) {\n        var pos = 0x10000;\n        for(var i = 0; i < set.length; i += 2){\n            pos += set[i];\n            if (pos > code) {\n                return false;\n            }\n            pos += set[i + 1];\n            if (pos >= code) {\n                return true;\n            }\n        }\n        return false;\n    }\n    // Test whether a given character code starts an identifier.\n    function isIdentifierStart(code, astral) {\n        if (code < 65) {\n            return code === 36;\n        }\n        if (code < 91) {\n            return true;\n        }\n        if (code < 97) {\n            return code === 95;\n        }\n        if (code < 123) {\n            return true;\n        }\n        if (code <= 0xffff) {\n            return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n        }\n        if (astral === false) {\n            return false;\n        }\n        return isInAstralSet(code, astralIdentifierStartCodes);\n    }\n    // Test whether a given character is part of an identifier.\n    function isIdentifierChar(code, astral) {\n        if (code < 48) {\n            return code === 36;\n        }\n        if (code < 58) {\n            return true;\n        }\n        if (code < 65) {\n            return false;\n        }\n        if (code < 91) {\n            return true;\n        }\n        if (code < 97) {\n            return code === 95;\n        }\n        if (code < 123) {\n            return true;\n        }\n        if (code <= 0xffff) {\n            return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n        }\n        if (astral === false) {\n            return false;\n        }\n        return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n    }\n    // ## Token types\n    // The assignment of fine-grained, information-carrying type objects\n    // allows the tokenizer to store the information it has about a\n    // token in a way that is very cheap for the parser to look up.\n    // All token type variables start with an underscore, to make them\n    // easy to recognize.\n    // The `beforeExpr` property is used to disambiguate between regular\n    // expressions and divisions. It is set on all token types that can\n    // be followed by an expression (thus, a slash after them would be a\n    // regular expression).\n    //\n    // The `startsExpr` property is used to check if the token ends a\n    // `yield` expression. It is set on all token types that either can\n    // directly start an expression (like a quotation mark) or can\n    // continue an expression (like the body of a string).\n    //\n    // `isLoop` marks a keyword as starting a loop, which is important\n    // to know when parsing a label, in order to allow or disallow\n    // continue jumps to that label.\n    var TokenType = function TokenType(label, conf) {\n        if (conf === void 0) conf = {};\n        this.label = label;\n        this.keyword = conf.keyword;\n        this.beforeExpr = !!conf.beforeExpr;\n        this.startsExpr = !!conf.startsExpr;\n        this.isLoop = !!conf.isLoop;\n        this.isAssign = !!conf.isAssign;\n        this.prefix = !!conf.prefix;\n        this.postfix = !!conf.postfix;\n        this.binop = conf.binop || null;\n        this.updateContext = null;\n    };\n    function binop(name, prec) {\n        return new TokenType(name, {\n            beforeExpr: true,\n            binop: prec\n        });\n    }\n    var beforeExpr = {\n        beforeExpr: true\n    }, startsExpr = {\n        startsExpr: true\n    };\n    // Map keyword names to token types.\n    var keywords = {};\n    // Succinct definitions of keyword token types\n    function kw(name, options) {\n        if (options === void 0) options = {};\n        options.keyword = name;\n        return keywords[name] = new TokenType(name, options);\n    }\n    var types$1 = {\n        num: new TokenType(\"num\", startsExpr),\n        regexp: new TokenType(\"regexp\", startsExpr),\n        string: new TokenType(\"string\", startsExpr),\n        name: new TokenType(\"name\", startsExpr),\n        privateId: new TokenType(\"privateId\", startsExpr),\n        eof: new TokenType(\"eof\"),\n        // Punctuation token types.\n        bracketL: new TokenType(\"[\", {\n            beforeExpr: true,\n            startsExpr: true\n        }),\n        bracketR: new TokenType(\"]\"),\n        braceL: new TokenType(\"{\", {\n            beforeExpr: true,\n            startsExpr: true\n        }),\n        braceR: new TokenType(\"}\"),\n        parenL: new TokenType(\"(\", {\n            beforeExpr: true,\n            startsExpr: true\n        }),\n        parenR: new TokenType(\")\"),\n        comma: new TokenType(\",\", beforeExpr),\n        semi: new TokenType(\";\", beforeExpr),\n        colon: new TokenType(\":\", beforeExpr),\n        dot: new TokenType(\".\"),\n        question: new TokenType(\"?\", beforeExpr),\n        questionDot: new TokenType(\"?.\"),\n        arrow: new TokenType(\"=>\", beforeExpr),\n        template: new TokenType(\"template\"),\n        invalidTemplate: new TokenType(\"invalidTemplate\"),\n        ellipsis: new TokenType(\"...\", beforeExpr),\n        backQuote: new TokenType(\"`\", startsExpr),\n        dollarBraceL: new TokenType(\"${\", {\n            beforeExpr: true,\n            startsExpr: true\n        }),\n        // Operators. These carry several kinds of properties to help the\n        // parser use them properly (the presence of these properties is\n        // what categorizes them as operators).\n        //\n        // `binop`, when present, specifies that this operator is a binary\n        // operator, and will refer to its precedence.\n        //\n        // `prefix` and `postfix` mark the operator as a prefix or postfix\n        // unary operator.\n        //\n        // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n        // binary operators with a very low precedence, that should result\n        // in AssignmentExpression nodes.\n        eq: new TokenType(\"=\", {\n            beforeExpr: true,\n            isAssign: true\n        }),\n        assign: new TokenType(\"_=\", {\n            beforeExpr: true,\n            isAssign: true\n        }),\n        incDec: new TokenType(\"++/--\", {\n            prefix: true,\n            postfix: true,\n            startsExpr: true\n        }),\n        prefix: new TokenType(\"!/~\", {\n            beforeExpr: true,\n            prefix: true,\n            startsExpr: true\n        }),\n        logicalOR: binop(\"||\", 1),\n        logicalAND: binop(\"&&\", 2),\n        bitwiseOR: binop(\"|\", 3),\n        bitwiseXOR: binop(\"^\", 4),\n        bitwiseAND: binop(\"&\", 5),\n        equality: binop(\"==/!=/===/!==\", 6),\n        relational: binop(\"</>/<=/>=\", 7),\n        bitShift: binop(\"<</>>/>>>\", 8),\n        plusMin: new TokenType(\"+/-\", {\n            beforeExpr: true,\n            binop: 9,\n            prefix: true,\n            startsExpr: true\n        }),\n        modulo: binop(\"%\", 10),\n        star: binop(\"*\", 10),\n        slash: binop(\"/\", 10),\n        starstar: new TokenType(\"**\", {\n            beforeExpr: true\n        }),\n        coalesce: binop(\"??\", 1),\n        // Keyword token types.\n        _break: kw(\"break\"),\n        _case: kw(\"case\", beforeExpr),\n        _catch: kw(\"catch\"),\n        _continue: kw(\"continue\"),\n        _debugger: kw(\"debugger\"),\n        _default: kw(\"default\", beforeExpr),\n        _do: kw(\"do\", {\n            isLoop: true,\n            beforeExpr: true\n        }),\n        _else: kw(\"else\", beforeExpr),\n        _finally: kw(\"finally\"),\n        _for: kw(\"for\", {\n            isLoop: true\n        }),\n        _function: kw(\"function\", startsExpr),\n        _if: kw(\"if\"),\n        _return: kw(\"return\", beforeExpr),\n        _switch: kw(\"switch\"),\n        _throw: kw(\"throw\", beforeExpr),\n        _try: kw(\"try\"),\n        _var: kw(\"var\"),\n        _const: kw(\"const\"),\n        _while: kw(\"while\", {\n            isLoop: true\n        }),\n        _with: kw(\"with\"),\n        _new: kw(\"new\", {\n            beforeExpr: true,\n            startsExpr: true\n        }),\n        _this: kw(\"this\", startsExpr),\n        _super: kw(\"super\", startsExpr),\n        _class: kw(\"class\", startsExpr),\n        _extends: kw(\"extends\", beforeExpr),\n        _export: kw(\"export\"),\n        _import: kw(\"import\", startsExpr),\n        _null: kw(\"null\", startsExpr),\n        _true: kw(\"true\", startsExpr),\n        _false: kw(\"false\", startsExpr),\n        _in: kw(\"in\", {\n            beforeExpr: true,\n            binop: 7\n        }),\n        _instanceof: kw(\"instanceof\", {\n            beforeExpr: true,\n            binop: 7\n        }),\n        _typeof: kw(\"typeof\", {\n            beforeExpr: true,\n            prefix: true,\n            startsExpr: true\n        }),\n        _void: kw(\"void\", {\n            beforeExpr: true,\n            prefix: true,\n            startsExpr: true\n        }),\n        _delete: kw(\"delete\", {\n            beforeExpr: true,\n            prefix: true,\n            startsExpr: true\n        })\n    };\n    // Matches a whole line break (where CRLF is considered a single\n    // line break). Used to count lines.\n    var lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\n    var lineBreakG = new RegExp(lineBreak.source, \"g\");\n    function isNewLine(code) {\n        return code === 10 || code === 13 || code === 0x2028 || code === 0x2029;\n    }\n    function nextLineBreak(code, from, end) {\n        if (end === void 0) end = code.length;\n        for(var i = from; i < end; i++){\n            var next = code.charCodeAt(i);\n            if (isNewLine(next)) {\n                return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;\n            }\n        }\n        return -1;\n    }\n    var nonASCIIwhitespace = /[\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n    var skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n    var ref = Object.prototype;\n    var hasOwnProperty = ref.hasOwnProperty;\n    var toString = ref.toString;\n    var hasOwn = Object.hasOwn || function(obj, propName) {\n        return hasOwnProperty.call(obj, propName);\n    };\n    var isArray = Array.isArray || function(obj) {\n        return toString.call(obj) === \"[object Array]\";\n    };\n    var regexpCache = Object.create(null);\n    function wordsRegexp(words) {\n        return regexpCache[words] || (regexpCache[words] = new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\"));\n    }\n    function codePointToString(code) {\n        // UTF-16 Decoding\n        if (code <= 0xFFFF) {\n            return String.fromCharCode(code);\n        }\n        code -= 0x10000;\n        return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);\n    }\n    var loneSurrogate = /(?:[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])/;\n    // These are used when `options.locations` is on, for the\n    // `startLoc` and `endLoc` properties.\n    var Position = function Position(line, col) {\n        this.line = line;\n        this.column = col;\n    };\n    Position.prototype.offset = function offset(n) {\n        return new Position(this.line, this.column + n);\n    };\n    var SourceLocation = function SourceLocation(p, start, end) {\n        this.start = start;\n        this.end = end;\n        if (p.sourceFile !== null) {\n            this.source = p.sourceFile;\n        }\n    };\n    // The `getLineInfo` function is mostly useful when the\n    // `locations` option is off (for performance reasons) and you\n    // want to find the line/column position for a given character\n    // offset. `input` should be the code string that the offset refers\n    // into.\n    function getLineInfo(input, offset) {\n        for(var line = 1, cur = 0;;){\n            var nextBreak = nextLineBreak(input, cur, offset);\n            if (nextBreak < 0) {\n                return new Position(line, offset - cur);\n            }\n            ++line;\n            cur = nextBreak;\n        }\n    }\n    // A second argument must be given to configure the parser process.\n    // These options are recognized (only `ecmaVersion` is required):\n    var defaultOptions = {\n        // `ecmaVersion` indicates the ECMAScript version to parse. Must be\n        // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10\n        // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `\"latest\"`\n        // (the latest version the library supports). This influences\n        // support for strict mode, the set of reserved words, and support\n        // for new syntax features.\n        ecmaVersion: null,\n        // `sourceType` indicates the mode the code should be parsed in.\n        // Can be either `\"script\"` or `\"module\"`. This influences global\n        // strict mode and parsing of `import` and `export` declarations.\n        sourceType: \"script\",\n        // `onInsertedSemicolon` can be a callback that will be called when\n        // a semicolon is automatically inserted. It will be passed the\n        // position of the inserted semicolon as an offset, and if\n        // `locations` is enabled, it is given the location as a `{line,\n        // column}` object as second argument.\n        onInsertedSemicolon: null,\n        // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n        // trailing commas.\n        onTrailingComma: null,\n        // By default, reserved words are only enforced if ecmaVersion >= 5.\n        // Set `allowReserved` to a boolean value to explicitly turn this on\n        // an off. When this option has the value \"never\", reserved words\n        // and keywords can also not be used as property names.\n        allowReserved: null,\n        // When enabled, a return at the top level is not considered an\n        // error.\n        allowReturnOutsideFunction: false,\n        // When enabled, import/export statements are not constrained to\n        // appearing at the top of the program, and an import.meta expression\n        // in a script isn't considered an error.\n        allowImportExportEverywhere: false,\n        // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.\n        // When enabled, await identifiers are allowed to appear at the top-level scope,\n        // but they are still not allowed in non-async functions.\n        allowAwaitOutsideFunction: null,\n        // When enabled, super identifiers are not constrained to\n        // appearing in methods and do not raise an error when they appear elsewhere.\n        allowSuperOutsideMethod: null,\n        // When enabled, hashbang directive in the beginning of file is\n        // allowed and treated as a line comment. Enabled by default when\n        // `ecmaVersion` >= 2023.\n        allowHashBang: false,\n        // By default, the parser will verify that private properties are\n        // only used in places where they are valid and have been declared.\n        // Set this to false to turn such checks off.\n        checkPrivateFields: true,\n        // When `locations` is on, `loc` properties holding objects with\n        // `start` and `end` properties in `{line, column}` form (with\n        // line being 1-based and column 0-based) will be attached to the\n        // nodes.\n        locations: false,\n        // A function can be passed as `onToken` option, which will\n        // cause Acorn to call that function with object in the same\n        // format as tokens returned from `tokenizer().getToken()`. Note\n        // that you are not allowed to call the parser from the\n        // callback—that will corrupt its internal state.\n        onToken: null,\n        // A function can be passed as `onComment` option, which will\n        // cause Acorn to call that function with `(block, text, start,\n        // end)` parameters whenever a comment is skipped. `block` is a\n        // boolean indicating whether this is a block (`/* */`) comment,\n        // `text` is the content of the comment, and `start` and `end` are\n        // character offsets that denote the start and end of the comment.\n        // When the `locations` option is on, two more parameters are\n        // passed, the full `{line, column}` locations of the start and\n        // end of the comments. Note that you are not allowed to call the\n        // parser from the callback—that will corrupt its internal state.\n        // When this option has an array as value, objects representing the\n        // comments are pushed to it.\n        onComment: null,\n        // Nodes have their start and end characters offsets recorded in\n        // `start` and `end` properties (directly on the node, rather than\n        // the `loc` object, which holds line/column data. To also add a\n        // [semi-standardized][range] `range` property holding a `[start,\n        // end]` array with the same numbers, set the `ranges` option to\n        // `true`.\n        //\n        // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n        ranges: false,\n        // It is possible to parse multiple files into a single AST by\n        // passing the tree produced by parsing the first file as\n        // `program` option in subsequent parses. This will add the\n        // toplevel forms of the parsed file to the `Program` (top) node\n        // of an existing parse tree.\n        program: null,\n        // When `locations` is on, you can pass this to record the source\n        // file in every node's `loc` object.\n        sourceFile: null,\n        // This value, if given, is stored in every node, whether\n        // `locations` is on or off.\n        directSourceFile: null,\n        // When enabled, parenthesized expressions are represented by\n        // (non-standard) ParenthesizedExpression nodes\n        preserveParens: false\n    };\n    // Interpret and default an options object\n    var warnedAboutEcmaVersion = false;\n    function getOptions(opts) {\n        var options = {};\n        for(var opt in defaultOptions){\n            options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];\n        }\n        if (options.ecmaVersion === \"latest\") {\n            options.ecmaVersion = 1e8;\n        } else if (options.ecmaVersion == null) {\n            if (!warnedAboutEcmaVersion && typeof console === \"object\" && console.warn) {\n                warnedAboutEcmaVersion = true;\n                console.warn(\"Since Acorn 8.0.0, options.ecmaVersion is required.\\nDefaulting to 2020, but this will stop working in the future.\");\n            }\n            options.ecmaVersion = 11;\n        } else if (options.ecmaVersion >= 2015) {\n            options.ecmaVersion -= 2009;\n        }\n        if (options.allowReserved == null) {\n            options.allowReserved = options.ecmaVersion < 5;\n        }\n        if (!opts || opts.allowHashBang == null) {\n            options.allowHashBang = options.ecmaVersion >= 14;\n        }\n        if (isArray(options.onToken)) {\n            var tokens = options.onToken;\n            options.onToken = function(token) {\n                return tokens.push(token);\n            };\n        }\n        if (isArray(options.onComment)) {\n            options.onComment = pushComment(options, options.onComment);\n        }\n        return options;\n    }\n    function pushComment(options, array) {\n        return function(block, text, start, end, startLoc, endLoc) {\n            var comment = {\n                type: block ? \"Block\" : \"Line\",\n                value: text,\n                start: start,\n                end: end\n            };\n            if (options.locations) {\n                comment.loc = new SourceLocation(this, startLoc, endLoc);\n            }\n            if (options.ranges) {\n                comment.range = [\n                    start,\n                    end\n                ];\n            }\n            array.push(comment);\n        };\n    }\n    // Each scope gets a bitset that may contain these flags\n    var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_CLASS_FIELD_INIT = 512, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;\n    function functionFlags(async, generator) {\n        return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);\n    }\n    // Used in checkLVal* and declareName to determine the type of a binding\n    var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5; // Special case for function names as bound inside the function\n    var Parser = function Parser(options, input, startPos) {\n        this.options = options = getOptions(options);\n        this.sourceFile = options.sourceFile;\n        this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === \"module\" ? \"5module\" : 5]);\n        var reserved = \"\";\n        if (options.allowReserved !== true) {\n            reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];\n            if (options.sourceType === \"module\") {\n                reserved += \" await\";\n            }\n        }\n        this.reservedWords = wordsRegexp(reserved);\n        var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n        this.reservedWordsStrict = wordsRegexp(reservedStrict);\n        this.reservedWordsStrictBind = wordsRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n        this.input = String(input);\n        // Used to signal to callers of `readWord1` whether the word\n        // contained any escape sequences. This is needed because words with\n        // escape sequences must not be interpreted as keywords.\n        this.containsEsc = false;\n        // Set up token state\n        // The current position of the tokenizer in the input.\n        if (startPos) {\n            this.pos = startPos;\n            this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n            this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n        } else {\n            this.pos = this.lineStart = 0;\n            this.curLine = 1;\n        }\n        // Properties of the current token:\n        // Its type\n        this.type = types$1.eof;\n        // For tokens that include more information than their type, the value\n        this.value = null;\n        // Its start and end offset\n        this.start = this.end = this.pos;\n        // And, if locations are used, the {line, column} object\n        // corresponding to those offsets\n        this.startLoc = this.endLoc = this.curPosition();\n        // Position information for the previous token\n        this.lastTokEndLoc = this.lastTokStartLoc = null;\n        this.lastTokStart = this.lastTokEnd = this.pos;\n        // The context stack is used to superficially track syntactic\n        // context to predict whether a regular expression is allowed in a\n        // given position.\n        this.context = this.initialContext();\n        this.exprAllowed = true;\n        // Figure out if it's a module code.\n        this.inModule = options.sourceType === \"module\";\n        this.strict = this.inModule || this.strictDirective(this.pos);\n        // Used to signify the start of a potential arrow function\n        this.potentialArrowAt = -1;\n        this.potentialArrowInForAwait = false;\n        // Positions to delayed-check that yield/await does not exist in default parameters.\n        this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;\n        // Labels in scope.\n        this.labels = [];\n        // Thus-far undefined exports.\n        this.undefinedExports = Object.create(null);\n        // If enabled, skip leading hashbang line.\n        if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\") {\n            this.skipLineComment(2);\n        }\n        // Scope tracking for duplicate variable names (see scope.js)\n        this.scopeStack = [];\n        this.enterScope(SCOPE_TOP);\n        // For RegExp validation\n        this.regexpState = null;\n        // The stack of private names.\n        // Each element has two properties: 'declared' and 'used'.\n        // When it exited from the outermost class definition, all used private names must be declared.\n        this.privateNameStack = [];\n    };\n    var prototypeAccessors = {\n        inFunction: {\n            configurable: true\n        },\n        inGenerator: {\n            configurable: true\n        },\n        inAsync: {\n            configurable: true\n        },\n        canAwait: {\n            configurable: true\n        },\n        allowSuper: {\n            configurable: true\n        },\n        allowDirectSuper: {\n            configurable: true\n        },\n        treatFunctionsAsVar: {\n            configurable: true\n        },\n        allowNewDotTarget: {\n            configurable: true\n        },\n        inClassStaticBlock: {\n            configurable: true\n        }\n    };\n    Parser.prototype.parse = function parse() {\n        var node = this.options.program || this.startNode();\n        this.nextToken();\n        return this.parseTopLevel(node);\n    };\n    prototypeAccessors.inFunction.get = function() {\n        return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;\n    };\n    prototypeAccessors.inGenerator.get = function() {\n        return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;\n    };\n    prototypeAccessors.inAsync.get = function() {\n        return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;\n    };\n    prototypeAccessors.canAwait.get = function() {\n        for(var i = this.scopeStack.length - 1; i >= 0; i--){\n            var ref = this.scopeStack[i];\n            var flags = ref.flags;\n            if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT)) {\n                return false;\n            }\n            if (flags & SCOPE_FUNCTION) {\n                return (flags & SCOPE_ASYNC) > 0;\n            }\n        }\n        return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;\n    };\n    prototypeAccessors.allowSuper.get = function() {\n        var ref = this.currentThisScope();\n        var flags = ref.flags;\n        return (flags & SCOPE_SUPER) > 0 || this.options.allowSuperOutsideMethod;\n    };\n    prototypeAccessors.allowDirectSuper.get = function() {\n        return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;\n    };\n    prototypeAccessors.treatFunctionsAsVar.get = function() {\n        return this.treatFunctionsAsVarInScope(this.currentScope());\n    };\n    prototypeAccessors.allowNewDotTarget.get = function() {\n        for(var i = this.scopeStack.length - 1; i >= 0; i--){\n            var ref = this.scopeStack[i];\n            var flags = ref.flags;\n            if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT) || flags & SCOPE_FUNCTION && !(flags & SCOPE_ARROW)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    prototypeAccessors.inClassStaticBlock.get = function() {\n        return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;\n    };\n    Parser.extend = function extend() {\n        var plugins = [], len = arguments.length;\n        while(len--)plugins[len] = arguments[len];\n        var cls = this;\n        for(var i = 0; i < plugins.length; i++){\n            cls = plugins[i](cls);\n        }\n        return cls;\n    };\n    Parser.parse = function parse(input, options) {\n        return new this(options, input).parse();\n    };\n    Parser.parseExpressionAt = function parseExpressionAt(input, pos, options) {\n        var parser = new this(options, input, pos);\n        parser.nextToken();\n        return parser.parseExpression();\n    };\n    Parser.tokenizer = function tokenizer(input, options) {\n        return new this(options, input);\n    };\n    Object.defineProperties(Parser.prototype, prototypeAccessors);\n    var pp$9 = Parser.prototype;\n    // ## Parser utilities\n    var literal = /^(?:'((?:\\\\[^]|[^'\\\\])*?)'|\"((?:\\\\[^]|[^\"\\\\])*?)\")/;\n    pp$9.strictDirective = function(start) {\n        if (this.options.ecmaVersion < 5) {\n            return false;\n        }\n        for(;;){\n            // Try to find string literal.\n            skipWhiteSpace.lastIndex = start;\n            start += skipWhiteSpace.exec(this.input)[0].length;\n            var match = literal.exec(this.input.slice(start));\n            if (!match) {\n                return false;\n            }\n            if ((match[1] || match[2]) === \"use strict\") {\n                skipWhiteSpace.lastIndex = start + match[0].length;\n                var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;\n                var next = this.input.charAt(end);\n                return next === \";\" || next === \"}\" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\\-/*%<>=,?^&]/.test(next) || next === \"!\" && this.input.charAt(end + 1) === \"=\");\n            }\n            start += match[0].length;\n            // Skip semicolon, if any.\n            skipWhiteSpace.lastIndex = start;\n            start += skipWhiteSpace.exec(this.input)[0].length;\n            if (this.input[start] === \";\") {\n                start++;\n            }\n        }\n    };\n    // Predicate that tests whether the next token is of the given\n    // type, and if yes, consumes it as a side effect.\n    pp$9.eat = function(type) {\n        if (this.type === type) {\n            this.next();\n            return true;\n        } else {\n            return false;\n        }\n    };\n    // Tests whether parsed token is a contextual keyword.\n    pp$9.isContextual = function(name) {\n        return this.type === types$1.name && this.value === name && !this.containsEsc;\n    };\n    // Consumes contextual keyword if possible.\n    pp$9.eatContextual = function(name) {\n        if (!this.isContextual(name)) {\n            return false;\n        }\n        this.next();\n        return true;\n    };\n    // Asserts that following token is given contextual keyword.\n    pp$9.expectContextual = function(name) {\n        if (!this.eatContextual(name)) {\n            this.unexpected();\n        }\n    };\n    // Test whether a semicolon can be inserted at the current position.\n    pp$9.canInsertSemicolon = function() {\n        return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n    };\n    pp$9.insertSemicolon = function() {\n        if (this.canInsertSemicolon()) {\n            if (this.options.onInsertedSemicolon) {\n                this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);\n            }\n            return true;\n        }\n    };\n    // Consume a semicolon, or, failing that, see if we are allowed to\n    // pretend that there is a semicolon at this position.\n    pp$9.semicolon = function() {\n        if (!this.eat(types$1.semi) && !this.insertSemicolon()) {\n            this.unexpected();\n        }\n    };\n    pp$9.afterTrailingComma = function(tokType, notNext) {\n        if (this.type === tokType) {\n            if (this.options.onTrailingComma) {\n                this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);\n            }\n            if (!notNext) {\n                this.next();\n            }\n            return true;\n        }\n    };\n    // Expect a token of a given type. If found, consume it, otherwise,\n    // raise an unexpected token error.\n    pp$9.expect = function(type) {\n        this.eat(type) || this.unexpected();\n    };\n    // Raise an unexpected token error.\n    pp$9.unexpected = function(pos) {\n        this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n    };\n    var DestructuringErrors = function DestructuringErrors() {\n        this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;\n    };\n    pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n        if (!refDestructuringErrors) {\n            return;\n        }\n        if (refDestructuringErrors.trailingComma > -1) {\n            this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\");\n        }\n        var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n        if (parens > -1) {\n            this.raiseRecoverable(parens, isAssign ? \"Assigning to rvalue\" : \"Parenthesized pattern\");\n        }\n    };\n    pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n        if (!refDestructuringErrors) {\n            return false;\n        }\n        var shorthandAssign = refDestructuringErrors.shorthandAssign;\n        var doubleProto = refDestructuringErrors.doubleProto;\n        if (!andThrow) {\n            return shorthandAssign >= 0 || doubleProto >= 0;\n        }\n        if (shorthandAssign >= 0) {\n            this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\");\n        }\n        if (doubleProto >= 0) {\n            this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\");\n        }\n    };\n    pp$9.checkYieldAwaitInDefaultParams = function() {\n        if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {\n            this.raise(this.yieldPos, \"Yield expression cannot be a default value\");\n        }\n        if (this.awaitPos) {\n            this.raise(this.awaitPos, \"Await expression cannot be a default value\");\n        }\n    };\n    pp$9.isSimpleAssignTarget = function(expr) {\n        if (expr.type === \"ParenthesizedExpression\") {\n            return this.isSimpleAssignTarget(expr.expression);\n        }\n        return expr.type === \"Identifier\" || expr.type === \"MemberExpression\";\n    };\n    var pp$8 = Parser.prototype;\n    // ### Statement parsing\n    // Parse a program. Initializes the parser, reads any number of\n    // statements, and wraps them in a Program node.  Optionally takes a\n    // `program` argument.  If present, the statements will be appended\n    // to its body instead of creating a new node.\n    pp$8.parseTopLevel = function(node) {\n        var exports1 = Object.create(null);\n        if (!node.body) {\n            node.body = [];\n        }\n        while(this.type !== types$1.eof){\n            var stmt = this.parseStatement(null, true, exports1);\n            node.body.push(stmt);\n        }\n        if (this.inModule) {\n            for(var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1){\n                var name = list[i];\n                this.raiseRecoverable(this.undefinedExports[name].start, \"Export '\" + name + \"' is not defined\");\n            }\n        }\n        this.adaptDirectivePrologue(node.body);\n        this.next();\n        node.sourceType = this.options.sourceType;\n        return this.finishNode(node, \"Program\");\n    };\n    var loopLabel = {\n        kind: \"loop\"\n    }, switchLabel = {\n        kind: \"switch\"\n    };\n    pp$8.isLet = function(context) {\n        if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) {\n            return false;\n        }\n        skipWhiteSpace.lastIndex = this.pos;\n        var skip = skipWhiteSpace.exec(this.input);\n        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n        // For ambiguous cases, determine if a LexicalDeclaration (or only a\n        // Statement) is allowed here. If context is not empty then only a Statement\n        // is allowed. However, `let [` is an explicit negative lookahead for\n        // ExpressionStatement, so special-case it first.\n        if (nextCh === 91 || nextCh === 92) {\n            return true;\n        } // '[', '\\'\n        if (context) {\n            return false;\n        }\n        if (nextCh === 123 || nextCh > 0xd7ff && nextCh < 0xdc00) {\n            return true;\n        } // '{', astral\n        if (isIdentifierStart(nextCh, true)) {\n            var pos = next + 1;\n            while(isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)){\n                ++pos;\n            }\n            if (nextCh === 92 || nextCh > 0xd7ff && nextCh < 0xdc00) {\n                return true;\n            }\n            var ident = this.input.slice(next, pos);\n            if (!keywordRelationalOperator.test(ident)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    // check 'async [no LineTerminator here] function'\n    // - 'async /*foo*/ function' is OK.\n    // - 'async /*\\n*/ function' is invalid.\n    pp$8.isAsyncFunction = function() {\n        if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\")) {\n            return false;\n        }\n        skipWhiteSpace.lastIndex = this.pos;\n        var skip = skipWhiteSpace.exec(this.input);\n        var next = this.pos + skip[0].length, after;\n        return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === \"function\" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 0xd7ff && after < 0xdc00));\n    };\n    // Parse a single statement.\n    //\n    // If expecting a statement and finding a slash operator, parse a\n    // regular expression literal. This is to handle cases like\n    // `if (foo) /blah/.exec(foo)`, where looking at the previous token\n    // does not help.\n    pp$8.parseStatement = function(context, topLevel, exports1) {\n        var starttype = this.type, node = this.startNode(), kind;\n        if (this.isLet(context)) {\n            starttype = types$1._var;\n            kind = \"let\";\n        }\n        // Most types of statements are recognized by the keyword they\n        // start with. Many are trivial to parse, some require a bit of\n        // complexity.\n        switch(starttype){\n            case types$1._break:\n            case types$1._continue:\n                return this.parseBreakContinueStatement(node, starttype.keyword);\n            case types$1._debugger:\n                return this.parseDebuggerStatement(node);\n            case types$1._do:\n                return this.parseDoStatement(node);\n            case types$1._for:\n                return this.parseForStatement(node);\n            case types$1._function:\n                // Function as sole body of either an if statement or a labeled statement\n                // works, but not when it is part of a labeled statement that is the sole\n                // body of an if statement.\n                if (context && (this.strict || context !== \"if\" && context !== \"label\") && this.options.ecmaVersion >= 6) {\n                    this.unexpected();\n                }\n                return this.parseFunctionStatement(node, false, !context);\n            case types$1._class:\n                if (context) {\n                    this.unexpected();\n                }\n                return this.parseClass(node, true);\n            case types$1._if:\n                return this.parseIfStatement(node);\n            case types$1._return:\n                return this.parseReturnStatement(node);\n            case types$1._switch:\n                return this.parseSwitchStatement(node);\n            case types$1._throw:\n                return this.parseThrowStatement(node);\n            case types$1._try:\n                return this.parseTryStatement(node);\n            case types$1._const:\n            case types$1._var:\n                kind = kind || this.value;\n                if (context && kind !== \"var\") {\n                    this.unexpected();\n                }\n                return this.parseVarStatement(node, kind);\n            case types$1._while:\n                return this.parseWhileStatement(node);\n            case types$1._with:\n                return this.parseWithStatement(node);\n            case types$1.braceL:\n                return this.parseBlock(true, node);\n            case types$1.semi:\n                return this.parseEmptyStatement(node);\n            case types$1._export:\n            case types$1._import:\n                if (this.options.ecmaVersion > 10 && starttype === types$1._import) {\n                    skipWhiteSpace.lastIndex = this.pos;\n                    var skip = skipWhiteSpace.exec(this.input);\n                    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n                    if (nextCh === 40 || nextCh === 46) {\n                        return this.parseExpressionStatement(node, this.parseExpression());\n                    }\n                }\n                if (!this.options.allowImportExportEverywhere) {\n                    if (!topLevel) {\n                        this.raise(this.start, \"'import' and 'export' may only appear at the top level\");\n                    }\n                    if (!this.inModule) {\n                        this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\");\n                    }\n                }\n                return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports1);\n            // If the statement does not start with a statement keyword or a\n            // brace, it's an ExpressionStatement or LabeledStatement. We\n            // simply start parsing an expression, and afterwards, if the\n            // next token is a colon and the expression was a simple\n            // Identifier node, we switch to interpreting it as a label.\n            default:\n                if (this.isAsyncFunction()) {\n                    if (context) {\n                        this.unexpected();\n                    }\n                    this.next();\n                    return this.parseFunctionStatement(node, true, !context);\n                }\n                var maybeName = this.value, expr = this.parseExpression();\n                if (starttype === types$1.name && expr.type === \"Identifier\" && this.eat(types$1.colon)) {\n                    return this.parseLabeledStatement(node, maybeName, expr, context);\n                } else {\n                    return this.parseExpressionStatement(node, expr);\n                }\n        }\n    };\n    pp$8.parseBreakContinueStatement = function(node, keyword) {\n        var isBreak = keyword === \"break\";\n        this.next();\n        if (this.eat(types$1.semi) || this.insertSemicolon()) {\n            node.label = null;\n        } else if (this.type !== types$1.name) {\n            this.unexpected();\n        } else {\n            node.label = this.parseIdent();\n            this.semicolon();\n        }\n        // Verify that there is an actual destination to break or\n        // continue to.\n        var i = 0;\n        for(; i < this.labels.length; ++i){\n            var lab = this.labels[i];\n            if (node.label == null || lab.name === node.label.name) {\n                if (lab.kind != null && (isBreak || lab.kind === \"loop\")) {\n                    break;\n                }\n                if (node.label && isBreak) {\n                    break;\n                }\n            }\n        }\n        if (i === this.labels.length) {\n            this.raise(node.start, \"Unsyntactic \" + keyword);\n        }\n        return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n    };\n    pp$8.parseDebuggerStatement = function(node) {\n        this.next();\n        this.semicolon();\n        return this.finishNode(node, \"DebuggerStatement\");\n    };\n    pp$8.parseDoStatement = function(node) {\n        this.next();\n        this.labels.push(loopLabel);\n        node.body = this.parseStatement(\"do\");\n        this.labels.pop();\n        this.expect(types$1._while);\n        node.test = this.parseParenExpression();\n        if (this.options.ecmaVersion >= 6) {\n            this.eat(types$1.semi);\n        } else {\n            this.semicolon();\n        }\n        return this.finishNode(node, \"DoWhileStatement\");\n    };\n    // Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n    // loop is non-trivial. Basically, we have to parse the init `var`\n    // statement or expression, disallowing the `in` operator (see\n    // the second parameter to `parseExpression`), and then check\n    // whether the next token is `in` or `of`. When there is no init\n    // part (semicolon immediately after the opening parenthesis), it\n    // is a regular `for` loop.\n    pp$8.parseForStatement = function(node) {\n        this.next();\n        var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual(\"await\") ? this.lastTokStart : -1;\n        this.labels.push(loopLabel);\n        this.enterScope(0);\n        this.expect(types$1.parenL);\n        if (this.type === types$1.semi) {\n            if (awaitAt > -1) {\n                this.unexpected(awaitAt);\n            }\n            return this.parseFor(node, null);\n        }\n        var isLet = this.isLet();\n        if (this.type === types$1._var || this.type === types$1._const || isLet) {\n            var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value;\n            this.next();\n            this.parseVar(init$1, true, kind);\n            this.finishNode(init$1, \"VariableDeclaration\");\n            if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\")) && init$1.declarations.length === 1) {\n                if (this.options.ecmaVersion >= 9) {\n                    if (this.type === types$1._in) {\n                        if (awaitAt > -1) {\n                            this.unexpected(awaitAt);\n                        }\n                    } else {\n                        node.await = awaitAt > -1;\n                    }\n                }\n                return this.parseForIn(node, init$1);\n            }\n            if (awaitAt > -1) {\n                this.unexpected(awaitAt);\n            }\n            return this.parseFor(node, init$1);\n        }\n        var startsWithLet = this.isContextual(\"let\"), isForOf = false;\n        var containsEsc = this.containsEsc;\n        var refDestructuringErrors = new DestructuringErrors;\n        var initPos = this.start;\n        var init = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, \"await\") : this.parseExpression(true, refDestructuringErrors);\n        if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n            if (awaitAt > -1) {\n                if (this.type === types$1._in) {\n                    this.unexpected(awaitAt);\n                }\n                node.await = true;\n            } else if (isForOf && this.options.ecmaVersion >= 8) {\n                if (init.start === initPos && !containsEsc && init.type === \"Identifier\" && init.name === \"async\") {\n                    this.unexpected();\n                } else if (this.options.ecmaVersion >= 9) {\n                    node.await = false;\n                }\n            }\n            if (startsWithLet && isForOf) {\n                this.raise(init.start, \"The left-hand side of a for-of loop may not start with 'let'.\");\n            }\n            this.toAssignable(init, false, refDestructuringErrors);\n            this.checkLValPattern(init);\n            return this.parseForIn(node, init);\n        } else {\n            this.checkExpressionErrors(refDestructuringErrors, true);\n        }\n        if (awaitAt > -1) {\n            this.unexpected(awaitAt);\n        }\n        return this.parseFor(node, init);\n    };\n    pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {\n        this.next();\n        return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);\n    };\n    pp$8.parseIfStatement = function(node) {\n        this.next();\n        node.test = this.parseParenExpression();\n        // allow function declarations in branches, but only in non-strict mode\n        node.consequent = this.parseStatement(\"if\");\n        node.alternate = this.eat(types$1._else) ? this.parseStatement(\"if\") : null;\n        return this.finishNode(node, \"IfStatement\");\n    };\n    pp$8.parseReturnStatement = function(node) {\n        if (!this.inFunction && !this.options.allowReturnOutsideFunction) {\n            this.raise(this.start, \"'return' outside of function\");\n        }\n        this.next();\n        // In `return` (and `break`/`continue`), the keywords with\n        // optional arguments, we eagerly look for a semicolon or the\n        // possibility to insert one.\n        if (this.eat(types$1.semi) || this.insertSemicolon()) {\n            node.argument = null;\n        } else {\n            node.argument = this.parseExpression();\n            this.semicolon();\n        }\n        return this.finishNode(node, \"ReturnStatement\");\n    };\n    pp$8.parseSwitchStatement = function(node) {\n        this.next();\n        node.discriminant = this.parseParenExpression();\n        node.cases = [];\n        this.expect(types$1.braceL);\n        this.labels.push(switchLabel);\n        this.enterScope(0);\n        // Statements under must be grouped (by label) in SwitchCase\n        // nodes. `cur` is used to keep the node that we are currently\n        // adding statements to.\n        var cur;\n        for(var sawDefault = false; this.type !== types$1.braceR;){\n            if (this.type === types$1._case || this.type === types$1._default) {\n                var isCase = this.type === types$1._case;\n                if (cur) {\n                    this.finishNode(cur, \"SwitchCase\");\n                }\n                node.cases.push(cur = this.startNode());\n                cur.consequent = [];\n                this.next();\n                if (isCase) {\n                    cur.test = this.parseExpression();\n                } else {\n                    if (sawDefault) {\n                        this.raiseRecoverable(this.lastTokStart, \"Multiple default clauses\");\n                    }\n                    sawDefault = true;\n                    cur.test = null;\n                }\n                this.expect(types$1.colon);\n            } else {\n                if (!cur) {\n                    this.unexpected();\n                }\n                cur.consequent.push(this.parseStatement(null));\n            }\n        }\n        this.exitScope();\n        if (cur) {\n            this.finishNode(cur, \"SwitchCase\");\n        }\n        this.next(); // Closing brace\n        this.labels.pop();\n        return this.finishNode(node, \"SwitchStatement\");\n    };\n    pp$8.parseThrowStatement = function(node) {\n        this.next();\n        if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {\n            this.raise(this.lastTokEnd, \"Illegal newline after throw\");\n        }\n        node.argument = this.parseExpression();\n        this.semicolon();\n        return this.finishNode(node, \"ThrowStatement\");\n    };\n    // Reused empty array added for node fields that are always empty.\n    var empty$1 = [];\n    pp$8.parseCatchClauseParam = function() {\n        var param = this.parseBindingAtom();\n        var simple = param.type === \"Identifier\";\n        this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);\n        this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);\n        this.expect(types$1.parenR);\n        return param;\n    };\n    pp$8.parseTryStatement = function(node) {\n        this.next();\n        node.block = this.parseBlock();\n        node.handler = null;\n        if (this.type === types$1._catch) {\n            var clause = this.startNode();\n            this.next();\n            if (this.eat(types$1.parenL)) {\n                clause.param = this.parseCatchClauseParam();\n            } else {\n                if (this.options.ecmaVersion < 10) {\n                    this.unexpected();\n                }\n                clause.param = null;\n                this.enterScope(0);\n            }\n            clause.body = this.parseBlock(false);\n            this.exitScope();\n            node.handler = this.finishNode(clause, \"CatchClause\");\n        }\n        node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;\n        if (!node.handler && !node.finalizer) {\n            this.raise(node.start, \"Missing catch or finally clause\");\n        }\n        return this.finishNode(node, \"TryStatement\");\n    };\n    pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {\n        this.next();\n        this.parseVar(node, false, kind, allowMissingInitializer);\n        this.semicolon();\n        return this.finishNode(node, \"VariableDeclaration\");\n    };\n    pp$8.parseWhileStatement = function(node) {\n        this.next();\n        node.test = this.parseParenExpression();\n        this.labels.push(loopLabel);\n        node.body = this.parseStatement(\"while\");\n        this.labels.pop();\n        return this.finishNode(node, \"WhileStatement\");\n    };\n    pp$8.parseWithStatement = function(node) {\n        if (this.strict) {\n            this.raise(this.start, \"'with' in strict mode\");\n        }\n        this.next();\n        node.object = this.parseParenExpression();\n        node.body = this.parseStatement(\"with\");\n        return this.finishNode(node, \"WithStatement\");\n    };\n    pp$8.parseEmptyStatement = function(node) {\n        this.next();\n        return this.finishNode(node, \"EmptyStatement\");\n    };\n    pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {\n        for(var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1){\n            var label = list[i$1];\n            if (label.name === maybeName) {\n                this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n            }\n        }\n        var kind = this.type.isLoop ? \"loop\" : this.type === types$1._switch ? \"switch\" : null;\n        for(var i = this.labels.length - 1; i >= 0; i--){\n            var label$1 = this.labels[i];\n            if (label$1.statementStart === node.start) {\n                // Update information about previous labels on this node\n                label$1.statementStart = this.start;\n                label$1.kind = kind;\n            } else {\n                break;\n            }\n        }\n        this.labels.push({\n            name: maybeName,\n            kind: kind,\n            statementStart: this.start\n        });\n        node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n        this.labels.pop();\n        node.label = expr;\n        return this.finishNode(node, \"LabeledStatement\");\n    };\n    pp$8.parseExpressionStatement = function(node, expr) {\n        node.expression = expr;\n        this.semicolon();\n        return this.finishNode(node, \"ExpressionStatement\");\n    };\n    // Parse a semicolon-enclosed block of statements, handling `\"use\n    // strict\"` declarations when `allowStrict` is true (used for\n    // function bodies).\n    pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {\n        if (createNewLexicalScope === void 0) createNewLexicalScope = true;\n        if (node === void 0) node = this.startNode();\n        node.body = [];\n        this.expect(types$1.braceL);\n        if (createNewLexicalScope) {\n            this.enterScope(0);\n        }\n        while(this.type !== types$1.braceR){\n            var stmt = this.parseStatement(null);\n            node.body.push(stmt);\n        }\n        if (exitStrict) {\n            this.strict = false;\n        }\n        this.next();\n        if (createNewLexicalScope) {\n            this.exitScope();\n        }\n        return this.finishNode(node, \"BlockStatement\");\n    };\n    // Parse a regular `for` loop. The disambiguation code in\n    // `parseStatement` will already have parsed the init statement or\n    // expression.\n    pp$8.parseFor = function(node, init) {\n        node.init = init;\n        this.expect(types$1.semi);\n        node.test = this.type === types$1.semi ? null : this.parseExpression();\n        this.expect(types$1.semi);\n        node.update = this.type === types$1.parenR ? null : this.parseExpression();\n        this.expect(types$1.parenR);\n        node.body = this.parseStatement(\"for\");\n        this.exitScope();\n        this.labels.pop();\n        return this.finishNode(node, \"ForStatement\");\n    };\n    // Parse a `for`/`in` and `for`/`of` loop, which are almost\n    // same from parser's perspective.\n    pp$8.parseForIn = function(node, init) {\n        var isForIn = this.type === types$1._in;\n        this.next();\n        if (init.type === \"VariableDeclaration\" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== \"var\" || init.declarations[0].id.type !== \"Identifier\")) {\n            this.raise(init.start, (isForIn ? \"for-in\" : \"for-of\") + \" loop variable declaration may not have an initializer\");\n        }\n        node.left = init;\n        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();\n        this.expect(types$1.parenR);\n        node.body = this.parseStatement(\"for\");\n        this.exitScope();\n        this.labels.pop();\n        return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\");\n    };\n    // Parse a list of variable declarations.\n    pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {\n        node.declarations = [];\n        node.kind = kind;\n        for(;;){\n            var decl = this.startNode();\n            this.parseVarId(decl, kind);\n            if (this.eat(types$1.eq)) {\n                decl.init = this.parseMaybeAssign(isFor);\n            } else if (!allowMissingInitializer && kind === \"const\" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n                this.unexpected();\n            } else if (!allowMissingInitializer && decl.id.type !== \"Identifier\" && !(isFor && (this.type === types$1._in || this.isContextual(\"of\")))) {\n                this.raise(this.lastTokEnd, \"Complex binding patterns require an initialization value\");\n            } else {\n                decl.init = null;\n            }\n            node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n            if (!this.eat(types$1.comma)) {\n                break;\n            }\n        }\n        return node;\n    };\n    pp$8.parseVarId = function(decl, kind) {\n        decl.id = this.parseBindingAtom();\n        this.checkLValPattern(decl.id, kind === \"var\" ? BIND_VAR : BIND_LEXICAL, false);\n    };\n    var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;\n    // Parse a function declaration or literal (depending on the\n    // `statement & FUNC_STATEMENT`).\n    // Remove `allowExpressionBody` for 7.0.0, as it is only called with false\n    pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {\n        this.initFunction(node);\n        if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {\n            if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {\n                this.unexpected();\n            }\n            node.generator = this.eat(types$1.star);\n        }\n        if (this.options.ecmaVersion >= 8) {\n            node.async = !!isAsync;\n        }\n        if (statement & FUNC_STATEMENT) {\n            node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();\n            if (node.id && !(statement & FUNC_HANGING_STATEMENT)) // If it is a regular function declaration in sloppy mode, then it is\n            // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding\n            // mode depends on properties of the current scope (see\n            // treatFunctionsAsVar).\n            {\n                this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);\n            }\n        }\n        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n        this.yieldPos = 0;\n        this.awaitPos = 0;\n        this.awaitIdentPos = 0;\n        this.enterScope(functionFlags(node.async, node.generator));\n        if (!(statement & FUNC_STATEMENT)) {\n            node.id = this.type === types$1.name ? this.parseIdent() : null;\n        }\n        this.parseFunctionParams(node);\n        this.parseFunctionBody(node, allowExpressionBody, false, forInit);\n        this.yieldPos = oldYieldPos;\n        this.awaitPos = oldAwaitPos;\n        this.awaitIdentPos = oldAwaitIdentPos;\n        return this.finishNode(node, statement & FUNC_STATEMENT ? \"FunctionDeclaration\" : \"FunctionExpression\");\n    };\n    pp$8.parseFunctionParams = function(node) {\n        this.expect(types$1.parenL);\n        node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);\n        this.checkYieldAwaitInDefaultParams();\n    };\n    // Parse a class declaration or literal (depending on the\n    // `isStatement` parameter).\n    pp$8.parseClass = function(node, isStatement) {\n        this.next();\n        // ecma-262 14.6 Class Definitions\n        // A class definition is always strict mode code.\n        var oldStrict = this.strict;\n        this.strict = true;\n        this.parseClassId(node, isStatement);\n        this.parseClassSuper(node);\n        var privateNameMap = this.enterClassBody();\n        var classBody = this.startNode();\n        var hadConstructor = false;\n        classBody.body = [];\n        this.expect(types$1.braceL);\n        while(this.type !== types$1.braceR){\n            var element = this.parseClassElement(node.superClass !== null);\n            if (element) {\n                classBody.body.push(element);\n                if (element.type === \"MethodDefinition\" && element.kind === \"constructor\") {\n                    if (hadConstructor) {\n                        this.raiseRecoverable(element.start, \"Duplicate constructor in the same class\");\n                    }\n                    hadConstructor = true;\n                } else if (element.key && element.key.type === \"PrivateIdentifier\" && isPrivateNameConflicted(privateNameMap, element)) {\n                    this.raiseRecoverable(element.key.start, \"Identifier '#\" + element.key.name + \"' has already been declared\");\n                }\n            }\n        }\n        this.strict = oldStrict;\n        this.next();\n        node.body = this.finishNode(classBody, \"ClassBody\");\n        this.exitClassBody();\n        return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n    };\n    pp$8.parseClassElement = function(constructorAllowsSuper) {\n        if (this.eat(types$1.semi)) {\n            return null;\n        }\n        var ecmaVersion = this.options.ecmaVersion;\n        var node = this.startNode();\n        var keyName = \"\";\n        var isGenerator = false;\n        var isAsync = false;\n        var kind = \"method\";\n        var isStatic = false;\n        if (this.eatContextual(\"static\")) {\n            // Parse static init block\n            if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {\n                this.parseClassStaticBlock(node);\n                return node;\n            }\n            if (this.isClassElementNameStart() || this.type === types$1.star) {\n                isStatic = true;\n            } else {\n                keyName = \"static\";\n            }\n        }\n        node.static = isStatic;\n        if (!keyName && ecmaVersion >= 8 && this.eatContextual(\"async\")) {\n            if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {\n                isAsync = true;\n            } else {\n                keyName = \"async\";\n            }\n        }\n        if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {\n            isGenerator = true;\n        }\n        if (!keyName && !isAsync && !isGenerator) {\n            var lastValue = this.value;\n            if (this.eatContextual(\"get\") || this.eatContextual(\"set\")) {\n                if (this.isClassElementNameStart()) {\n                    kind = lastValue;\n                } else {\n                    keyName = lastValue;\n                }\n            }\n        }\n        // Parse element name\n        if (keyName) {\n            // 'async', 'get', 'set', or 'static' were not a keyword contextually.\n            // The last token is any of those. Make it the element name.\n            node.computed = false;\n            node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);\n            node.key.name = keyName;\n            this.finishNode(node.key, \"Identifier\");\n        } else {\n            this.parseClassElementName(node);\n        }\n        // Parse element value\n        if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== \"method\" || isGenerator || isAsync) {\n            var isConstructor = !node.static && checkKeyName(node, \"constructor\");\n            var allowsDirectSuper = isConstructor && constructorAllowsSuper;\n            // Couldn't move this check into the 'parseClassMethod' method for backward compatibility.\n            if (isConstructor && kind !== \"method\") {\n                this.raise(node.key.start, \"Constructor can't have get/set modifier\");\n            }\n            node.kind = isConstructor ? \"constructor\" : kind;\n            this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);\n        } else {\n            this.parseClassField(node);\n        }\n        return node;\n    };\n    pp$8.isClassElementNameStart = function() {\n        return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;\n    };\n    pp$8.parseClassElementName = function(element) {\n        if (this.type === types$1.privateId) {\n            if (this.value === \"constructor\") {\n                this.raise(this.start, \"Classes can't have an element named '#constructor'\");\n            }\n            element.computed = false;\n            element.key = this.parsePrivateIdent();\n        } else {\n            this.parsePropertyName(element);\n        }\n    };\n    pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {\n        // Check key and flags\n        var key = method.key;\n        if (method.kind === \"constructor\") {\n            if (isGenerator) {\n                this.raise(key.start, \"Constructor can't be a generator\");\n            }\n            if (isAsync) {\n                this.raise(key.start, \"Constructor can't be an async method\");\n            }\n        } else if (method.static && checkKeyName(method, \"prototype\")) {\n            this.raise(key.start, \"Classes may not have a static property named prototype\");\n        }\n        // Parse value\n        var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);\n        // Check value\n        if (method.kind === \"get\" && value.params.length !== 0) {\n            this.raiseRecoverable(value.start, \"getter should have no params\");\n        }\n        if (method.kind === \"set\" && value.params.length !== 1) {\n            this.raiseRecoverable(value.start, \"setter should have exactly one param\");\n        }\n        if (method.kind === \"set\" && value.params[0].type === \"RestElement\") {\n            this.raiseRecoverable(value.params[0].start, \"Setter cannot use rest params\");\n        }\n        return this.finishNode(method, \"MethodDefinition\");\n    };\n    pp$8.parseClassField = function(field) {\n        if (checkKeyName(field, \"constructor\")) {\n            this.raise(field.key.start, \"Classes can't have a field named 'constructor'\");\n        } else if (field.static && checkKeyName(field, \"prototype\")) {\n            this.raise(field.key.start, \"Classes can't have a static field named 'prototype'\");\n        }\n        if (this.eat(types$1.eq)) {\n            // To raise SyntaxError if 'arguments' exists in the initializer.\n            this.enterScope(SCOPE_CLASS_FIELD_INIT | SCOPE_SUPER);\n            field.value = this.parseMaybeAssign();\n            this.exitScope();\n        } else {\n            field.value = null;\n        }\n        this.semicolon();\n        return this.finishNode(field, \"PropertyDefinition\");\n    };\n    pp$8.parseClassStaticBlock = function(node) {\n        node.body = [];\n        var oldLabels = this.labels;\n        this.labels = [];\n        this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);\n        while(this.type !== types$1.braceR){\n            var stmt = this.parseStatement(null);\n            node.body.push(stmt);\n        }\n        this.next();\n        this.exitScope();\n        this.labels = oldLabels;\n        return this.finishNode(node, \"StaticBlock\");\n    };\n    pp$8.parseClassId = function(node, isStatement) {\n        if (this.type === types$1.name) {\n            node.id = this.parseIdent();\n            if (isStatement) {\n                this.checkLValSimple(node.id, BIND_LEXICAL, false);\n            }\n        } else {\n            if (isStatement === true) {\n                this.unexpected();\n            }\n            node.id = null;\n        }\n    };\n    pp$8.parseClassSuper = function(node) {\n        node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;\n    };\n    pp$8.enterClassBody = function() {\n        var element = {\n            declared: Object.create(null),\n            used: []\n        };\n        this.privateNameStack.push(element);\n        return element.declared;\n    };\n    pp$8.exitClassBody = function() {\n        var ref = this.privateNameStack.pop();\n        var declared = ref.declared;\n        var used = ref.used;\n        if (!this.options.checkPrivateFields) {\n            return;\n        }\n        var len = this.privateNameStack.length;\n        var parent = len === 0 ? null : this.privateNameStack[len - 1];\n        for(var i = 0; i < used.length; ++i){\n            var id = used[i];\n            if (!hasOwn(declared, id.name)) {\n                if (parent) {\n                    parent.used.push(id);\n                } else {\n                    this.raiseRecoverable(id.start, \"Private field '#\" + id.name + \"' must be declared in an enclosing class\");\n                }\n            }\n        }\n    };\n    function isPrivateNameConflicted(privateNameMap, element) {\n        var name = element.key.name;\n        var curr = privateNameMap[name];\n        var next = \"true\";\n        if (element.type === \"MethodDefinition\" && (element.kind === \"get\" || element.kind === \"set\")) {\n            next = (element.static ? \"s\" : \"i\") + element.kind;\n        }\n        // `class { get #a(){}; static set #a(_){} }` is also conflict.\n        if (curr === \"iget\" && next === \"iset\" || curr === \"iset\" && next === \"iget\" || curr === \"sget\" && next === \"sset\" || curr === \"sset\" && next === \"sget\") {\n            privateNameMap[name] = \"true\";\n            return false;\n        } else if (!curr) {\n            privateNameMap[name] = next;\n            return false;\n        } else {\n            return true;\n        }\n    }\n    function checkKeyName(node, name) {\n        var computed = node.computed;\n        var key = node.key;\n        return !computed && (key.type === \"Identifier\" && key.name === name || key.type === \"Literal\" && key.value === name);\n    }\n    // Parses module export declaration.\n    pp$8.parseExportAllDeclaration = function(node, exports1) {\n        if (this.options.ecmaVersion >= 11) {\n            if (this.eatContextual(\"as\")) {\n                node.exported = this.parseModuleExportName();\n                this.checkExport(exports1, node.exported, this.lastTokStart);\n            } else {\n                node.exported = null;\n            }\n        }\n        this.expectContextual(\"from\");\n        if (this.type !== types$1.string) {\n            this.unexpected();\n        }\n        node.source = this.parseExprAtom();\n        if (this.options.ecmaVersion >= 16) {\n            node.attributes = this.parseWithClause();\n        }\n        this.semicolon();\n        return this.finishNode(node, \"ExportAllDeclaration\");\n    };\n    pp$8.parseExport = function(node, exports1) {\n        this.next();\n        // export * from '...'\n        if (this.eat(types$1.star)) {\n            return this.parseExportAllDeclaration(node, exports1);\n        }\n        if (this.eat(types$1._default)) {\n            this.checkExport(exports1, \"default\", this.lastTokStart);\n            node.declaration = this.parseExportDefaultDeclaration();\n            return this.finishNode(node, \"ExportDefaultDeclaration\");\n        }\n        // export var|const|let|function|class ...\n        if (this.shouldParseExportStatement()) {\n            node.declaration = this.parseExportDeclaration(node);\n            if (node.declaration.type === \"VariableDeclaration\") {\n                this.checkVariableExport(exports1, node.declaration.declarations);\n            } else {\n                this.checkExport(exports1, node.declaration.id, node.declaration.id.start);\n            }\n            node.specifiers = [];\n            node.source = null;\n            if (this.options.ecmaVersion >= 16) {\n                node.attributes = [];\n            }\n        } else {\n            node.declaration = null;\n            node.specifiers = this.parseExportSpecifiers(exports1);\n            if (this.eatContextual(\"from\")) {\n                if (this.type !== types$1.string) {\n                    this.unexpected();\n                }\n                node.source = this.parseExprAtom();\n                if (this.options.ecmaVersion >= 16) {\n                    node.attributes = this.parseWithClause();\n                }\n            } else {\n                for(var i = 0, list = node.specifiers; i < list.length; i += 1){\n                    // check for keywords used as local names\n                    var spec = list[i];\n                    this.checkUnreserved(spec.local);\n                    // check if export is defined\n                    this.checkLocalExport(spec.local);\n                    if (spec.local.type === \"Literal\") {\n                        this.raise(spec.local.start, \"A string literal cannot be used as an exported binding without `from`.\");\n                    }\n                }\n                node.source = null;\n                if (this.options.ecmaVersion >= 16) {\n                    node.attributes = [];\n                }\n            }\n            this.semicolon();\n        }\n        return this.finishNode(node, \"ExportNamedDeclaration\");\n    };\n    pp$8.parseExportDeclaration = function(node) {\n        return this.parseStatement(null);\n    };\n    pp$8.parseExportDefaultDeclaration = function() {\n        var isAsync;\n        if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {\n            var fNode = this.startNode();\n            this.next();\n            if (isAsync) {\n                this.next();\n            }\n            return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n        } else if (this.type === types$1._class) {\n            var cNode = this.startNode();\n            return this.parseClass(cNode, \"nullableID\");\n        } else {\n            var declaration = this.parseMaybeAssign();\n            this.semicolon();\n            return declaration;\n        }\n    };\n    pp$8.checkExport = function(exports1, name, pos) {\n        if (!exports1) {\n            return;\n        }\n        if (typeof name !== \"string\") {\n            name = name.type === \"Identifier\" ? name.name : name.value;\n        }\n        if (hasOwn(exports1, name)) {\n            this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\");\n        }\n        exports1[name] = true;\n    };\n    pp$8.checkPatternExport = function(exports1, pat) {\n        var type = pat.type;\n        if (type === \"Identifier\") {\n            this.checkExport(exports1, pat, pat.start);\n        } else if (type === \"ObjectPattern\") {\n            for(var i = 0, list = pat.properties; i < list.length; i += 1){\n                var prop = list[i];\n                this.checkPatternExport(exports1, prop);\n            }\n        } else if (type === \"ArrayPattern\") {\n            for(var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1){\n                var elt = list$1[i$1];\n                if (elt) {\n                    this.checkPatternExport(exports1, elt);\n                }\n            }\n        } else if (type === \"Property\") {\n            this.checkPatternExport(exports1, pat.value);\n        } else if (type === \"AssignmentPattern\") {\n            this.checkPatternExport(exports1, pat.left);\n        } else if (type === \"RestElement\") {\n            this.checkPatternExport(exports1, pat.argument);\n        }\n    };\n    pp$8.checkVariableExport = function(exports1, decls) {\n        if (!exports1) {\n            return;\n        }\n        for(var i = 0, list = decls; i < list.length; i += 1){\n            var decl = list[i];\n            this.checkPatternExport(exports1, decl.id);\n        }\n    };\n    pp$8.shouldParseExportStatement = function() {\n        return this.type.keyword === \"var\" || this.type.keyword === \"const\" || this.type.keyword === \"class\" || this.type.keyword === \"function\" || this.isLet() || this.isAsyncFunction();\n    };\n    // Parses a comma-separated list of module exports.\n    pp$8.parseExportSpecifier = function(exports1) {\n        var node = this.startNode();\n        node.local = this.parseModuleExportName();\n        node.exported = this.eatContextual(\"as\") ? this.parseModuleExportName() : node.local;\n        this.checkExport(exports1, node.exported, node.exported.start);\n        return this.finishNode(node, \"ExportSpecifier\");\n    };\n    pp$8.parseExportSpecifiers = function(exports1) {\n        var nodes = [], first = true;\n        // export { x, y as z } [from '...']\n        this.expect(types$1.braceL);\n        while(!this.eat(types$1.braceR)){\n            if (!first) {\n                this.expect(types$1.comma);\n                if (this.afterTrailingComma(types$1.braceR)) {\n                    break;\n                }\n            } else {\n                first = false;\n            }\n            nodes.push(this.parseExportSpecifier(exports1));\n        }\n        return nodes;\n    };\n    // Parses import declaration.\n    pp$8.parseImport = function(node) {\n        this.next();\n        // import '...'\n        if (this.type === types$1.string) {\n            node.specifiers = empty$1;\n            node.source = this.parseExprAtom();\n        } else {\n            node.specifiers = this.parseImportSpecifiers();\n            this.expectContextual(\"from\");\n            node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();\n        }\n        if (this.options.ecmaVersion >= 16) {\n            node.attributes = this.parseWithClause();\n        }\n        this.semicolon();\n        return this.finishNode(node, \"ImportDeclaration\");\n    };\n    // Parses a comma-separated list of module imports.\n    pp$8.parseImportSpecifier = function() {\n        var node = this.startNode();\n        node.imported = this.parseModuleExportName();\n        if (this.eatContextual(\"as\")) {\n            node.local = this.parseIdent();\n        } else {\n            this.checkUnreserved(node.imported);\n            node.local = node.imported;\n        }\n        this.checkLValSimple(node.local, BIND_LEXICAL);\n        return this.finishNode(node, \"ImportSpecifier\");\n    };\n    pp$8.parseImportDefaultSpecifier = function() {\n        // import defaultObj, { x, y as z } from '...'\n        var node = this.startNode();\n        node.local = this.parseIdent();\n        this.checkLValSimple(node.local, BIND_LEXICAL);\n        return this.finishNode(node, \"ImportDefaultSpecifier\");\n    };\n    pp$8.parseImportNamespaceSpecifier = function() {\n        var node = this.startNode();\n        this.next();\n        this.expectContextual(\"as\");\n        node.local = this.parseIdent();\n        this.checkLValSimple(node.local, BIND_LEXICAL);\n        return this.finishNode(node, \"ImportNamespaceSpecifier\");\n    };\n    pp$8.parseImportSpecifiers = function() {\n        var nodes = [], first = true;\n        if (this.type === types$1.name) {\n            nodes.push(this.parseImportDefaultSpecifier());\n            if (!this.eat(types$1.comma)) {\n                return nodes;\n            }\n        }\n        if (this.type === types$1.star) {\n            nodes.push(this.parseImportNamespaceSpecifier());\n            return nodes;\n        }\n        this.expect(types$1.braceL);\n        while(!this.eat(types$1.braceR)){\n            if (!first) {\n                this.expect(types$1.comma);\n                if (this.afterTrailingComma(types$1.braceR)) {\n                    break;\n                }\n            } else {\n                first = false;\n            }\n            nodes.push(this.parseImportSpecifier());\n        }\n        return nodes;\n    };\n    pp$8.parseWithClause = function() {\n        var nodes = [];\n        if (!this.eat(types$1._with)) {\n            return nodes;\n        }\n        this.expect(types$1.braceL);\n        var attributeKeys = {};\n        var first = true;\n        while(!this.eat(types$1.braceR)){\n            if (!first) {\n                this.expect(types$1.comma);\n                if (this.afterTrailingComma(types$1.braceR)) {\n                    break;\n                }\n            } else {\n                first = false;\n            }\n            var attr = this.parseImportAttribute();\n            var keyName = attr.key.type === \"Identifier\" ? attr.key.name : attr.key.value;\n            if (hasOwn(attributeKeys, keyName)) {\n                this.raiseRecoverable(attr.key.start, \"Duplicate attribute key '\" + keyName + \"'\");\n            }\n            attributeKeys[keyName] = true;\n            nodes.push(attr);\n        }\n        return nodes;\n    };\n    pp$8.parseImportAttribute = function() {\n        var node = this.startNode();\n        node.key = this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== \"never\");\n        this.expect(types$1.colon);\n        if (this.type !== types$1.string) {\n            this.unexpected();\n        }\n        node.value = this.parseExprAtom();\n        return this.finishNode(node, \"ImportAttribute\");\n    };\n    pp$8.parseModuleExportName = function() {\n        if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {\n            var stringLiteral = this.parseLiteral(this.value);\n            if (loneSurrogate.test(stringLiteral.value)) {\n                this.raise(stringLiteral.start, \"An export name cannot include a lone surrogate.\");\n            }\n            return stringLiteral;\n        }\n        return this.parseIdent(true);\n    };\n    // Set `ExpressionStatement#directive` property for directive prologues.\n    pp$8.adaptDirectivePrologue = function(statements) {\n        for(var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i){\n            statements[i].directive = statements[i].expression.raw.slice(1, -1);\n        }\n    };\n    pp$8.isDirectiveCandidate = function(statement) {\n        return this.options.ecmaVersion >= 5 && statement.type === \"ExpressionStatement\" && statement.expression.type === \"Literal\" && typeof statement.expression.value === \"string\" && // Reject parenthesized strings.\n        (this.input[statement.start] === '\"' || this.input[statement.start] === \"'\");\n    };\n    var pp$7 = Parser.prototype;\n    // Convert existing expression atom to assignable pattern\n    // if possible.\n    pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {\n        if (this.options.ecmaVersion >= 6 && node) {\n            switch(node.type){\n                case \"Identifier\":\n                    if (this.inAsync && node.name === \"await\") {\n                        this.raise(node.start, \"Cannot use 'await' as identifier inside an async function\");\n                    }\n                    break;\n                case \"ObjectPattern\":\n                case \"ArrayPattern\":\n                case \"AssignmentPattern\":\n                case \"RestElement\":\n                    break;\n                case \"ObjectExpression\":\n                    node.type = \"ObjectPattern\";\n                    if (refDestructuringErrors) {\n                        this.checkPatternErrors(refDestructuringErrors, true);\n                    }\n                    for(var i = 0, list = node.properties; i < list.length; i += 1){\n                        var prop = list[i];\n                        this.toAssignable(prop, isBinding);\n                        // Early error:\n                        //   AssignmentRestProperty[Yield, Await] :\n                        //     `...` DestructuringAssignmentTarget[Yield, Await]\n                        //\n                        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.\n                        if (prop.type === \"RestElement\" && (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")) {\n                            this.raise(prop.argument.start, \"Unexpected token\");\n                        }\n                    }\n                    break;\n                case \"Property\":\n                    // AssignmentProperty has type === \"Property\"\n                    if (node.kind !== \"init\") {\n                        this.raise(node.key.start, \"Object pattern can't contain getter or setter\");\n                    }\n                    this.toAssignable(node.value, isBinding);\n                    break;\n                case \"ArrayExpression\":\n                    node.type = \"ArrayPattern\";\n                    if (refDestructuringErrors) {\n                        this.checkPatternErrors(refDestructuringErrors, true);\n                    }\n                    this.toAssignableList(node.elements, isBinding);\n                    break;\n                case \"SpreadElement\":\n                    node.type = \"RestElement\";\n                    this.toAssignable(node.argument, isBinding);\n                    if (node.argument.type === \"AssignmentPattern\") {\n                        this.raise(node.argument.start, \"Rest elements cannot have a default value\");\n                    }\n                    break;\n                case \"AssignmentExpression\":\n                    if (node.operator !== \"=\") {\n                        this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\");\n                    }\n                    node.type = \"AssignmentPattern\";\n                    delete node.operator;\n                    this.toAssignable(node.left, isBinding);\n                    break;\n                case \"ParenthesizedExpression\":\n                    this.toAssignable(node.expression, isBinding, refDestructuringErrors);\n                    break;\n                case \"ChainExpression\":\n                    this.raiseRecoverable(node.start, \"Optional chaining cannot appear in left-hand side\");\n                    break;\n                case \"MemberExpression\":\n                    if (!isBinding) {\n                        break;\n                    }\n                default:\n                    this.raise(node.start, \"Assigning to rvalue\");\n            }\n        } else if (refDestructuringErrors) {\n            this.checkPatternErrors(refDestructuringErrors, true);\n        }\n        return node;\n    };\n    // Convert list of expression atoms to binding list.\n    pp$7.toAssignableList = function(exprList, isBinding) {\n        var end = exprList.length;\n        for(var i = 0; i < end; i++){\n            var elt = exprList[i];\n            if (elt) {\n                this.toAssignable(elt, isBinding);\n            }\n        }\n        if (end) {\n            var last = exprList[end - 1];\n            if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\") {\n                this.unexpected(last.argument.start);\n            }\n        }\n        return exprList;\n    };\n    // Parses spread element.\n    pp$7.parseSpread = function(refDestructuringErrors) {\n        var node = this.startNode();\n        this.next();\n        node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n        return this.finishNode(node, \"SpreadElement\");\n    };\n    pp$7.parseRestBinding = function() {\n        var node = this.startNode();\n        this.next();\n        // RestElement inside of a function parameter must be an identifier\n        if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {\n            this.unexpected();\n        }\n        node.argument = this.parseBindingAtom();\n        return this.finishNode(node, \"RestElement\");\n    };\n    // Parses lvalue (assignable) atom.\n    pp$7.parseBindingAtom = function() {\n        if (this.options.ecmaVersion >= 6) {\n            switch(this.type){\n                case types$1.bracketL:\n                    var node = this.startNode();\n                    this.next();\n                    node.elements = this.parseBindingList(types$1.bracketR, true, true);\n                    return this.finishNode(node, \"ArrayPattern\");\n                case types$1.braceL:\n                    return this.parseObj(true);\n            }\n        }\n        return this.parseIdent();\n    };\n    pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {\n        var elts = [], first = true;\n        while(!this.eat(close)){\n            if (first) {\n                first = false;\n            } else {\n                this.expect(types$1.comma);\n            }\n            if (allowEmpty && this.type === types$1.comma) {\n                elts.push(null);\n            } else if (allowTrailingComma && this.afterTrailingComma(close)) {\n                break;\n            } else if (this.type === types$1.ellipsis) {\n                var rest = this.parseRestBinding();\n                this.parseBindingListItem(rest);\n                elts.push(rest);\n                if (this.type === types$1.comma) {\n                    this.raiseRecoverable(this.start, \"Comma is not permitted after the rest element\");\n                }\n                this.expect(close);\n                break;\n            } else {\n                elts.push(this.parseAssignableListItem(allowModifiers));\n            }\n        }\n        return elts;\n    };\n    pp$7.parseAssignableListItem = function(allowModifiers) {\n        var elem = this.parseMaybeDefault(this.start, this.startLoc);\n        this.parseBindingListItem(elem);\n        return elem;\n    };\n    pp$7.parseBindingListItem = function(param) {\n        return param;\n    };\n    // Parses assignment pattern around given atom if possible.\n    pp$7.parseMaybeDefault = function(startPos, startLoc, left) {\n        left = left || this.parseBindingAtom();\n        if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {\n            return left;\n        }\n        var node = this.startNodeAt(startPos, startLoc);\n        node.left = left;\n        node.right = this.parseMaybeAssign();\n        return this.finishNode(node, \"AssignmentPattern\");\n    };\n    // The following three functions all verify that a node is an lvalue —\n    // something that can be bound, or assigned to. In order to do so, they perform\n    // a variety of checks:\n    //\n    // - Check that none of the bound/assigned-to identifiers are reserved words.\n    // - Record name declarations for bindings in the appropriate scope.\n    // - Check duplicate argument names, if checkClashes is set.\n    //\n    // If a complex binding pattern is encountered (e.g., object and array\n    // destructuring), the entire pattern is recursively checked.\n    //\n    // There are three versions of checkLVal*() appropriate for different\n    // circumstances:\n    //\n    // - checkLValSimple() shall be used if the syntactic construct supports\n    //   nothing other than identifiers and member expressions. Parenthesized\n    //   expressions are also correctly handled. This is generally appropriate for\n    //   constructs for which the spec says\n    //\n    //   > It is a Syntax Error if AssignmentTargetType of [the production] is not\n    //   > simple.\n    //\n    //   It is also appropriate for checking if an identifier is valid and not\n    //   defined elsewhere, like import declarations or function/class identifiers.\n    //\n    //   Examples where this is used include:\n    //     a += …;\n    //     import a from '…';\n    //   where a is the node to be checked.\n    //\n    // - checkLValPattern() shall be used if the syntactic construct supports\n    //   anything checkLValSimple() supports, as well as object and array\n    //   destructuring patterns. This is generally appropriate for constructs for\n    //   which the spec says\n    //\n    //   > It is a Syntax Error if [the production] is neither an ObjectLiteral nor\n    //   > an ArrayLiteral and AssignmentTargetType of [the production] is not\n    //   > simple.\n    //\n    //   Examples where this is used include:\n    //     (a = …);\n    //     const a = …;\n    //     try { … } catch (a) { … }\n    //   where a is the node to be checked.\n    //\n    // - checkLValInnerPattern() shall be used if the syntactic construct supports\n    //   anything checkLValPattern() supports, as well as default assignment\n    //   patterns, rest elements, and other constructs that may appear within an\n    //   object or array destructuring pattern.\n    //\n    //   As a special case, function parameters also use checkLValInnerPattern(),\n    //   as they also support defaults and rest constructs.\n    //\n    // These functions deliberately support both assignment and binding constructs,\n    // as the logic for both is exceedingly similar. If the node is the target of\n    // an assignment, then bindingType should be set to BIND_NONE. Otherwise, it\n    // should be set to the appropriate BIND_* constant, like BIND_VAR or\n    // BIND_LEXICAL.\n    //\n    // If the function is called with a non-BIND_NONE bindingType, then\n    // additionally a checkClashes object may be specified to allow checking for\n    // duplicate argument names. checkClashes is ignored if the provided construct\n    // is an assignment (i.e., bindingType is BIND_NONE).\n    pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {\n        if (bindingType === void 0) bindingType = BIND_NONE;\n        var isBind = bindingType !== BIND_NONE;\n        switch(expr.type){\n            case \"Identifier\":\n                if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {\n                    this.raiseRecoverable(expr.start, (isBind ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\");\n                }\n                if (isBind) {\n                    if (bindingType === BIND_LEXICAL && expr.name === \"let\") {\n                        this.raiseRecoverable(expr.start, \"let is disallowed as a lexically bound name\");\n                    }\n                    if (checkClashes) {\n                        if (hasOwn(checkClashes, expr.name)) {\n                            this.raiseRecoverable(expr.start, \"Argument name clash\");\n                        }\n                        checkClashes[expr.name] = true;\n                    }\n                    if (bindingType !== BIND_OUTSIDE) {\n                        this.declareName(expr.name, bindingType, expr.start);\n                    }\n                }\n                break;\n            case \"ChainExpression\":\n                this.raiseRecoverable(expr.start, \"Optional chaining cannot appear in left-hand side\");\n                break;\n            case \"MemberExpression\":\n                if (isBind) {\n                    this.raiseRecoverable(expr.start, \"Binding member expression\");\n                }\n                break;\n            case \"ParenthesizedExpression\":\n                if (isBind) {\n                    this.raiseRecoverable(expr.start, \"Binding parenthesized expression\");\n                }\n                return this.checkLValSimple(expr.expression, bindingType, checkClashes);\n            default:\n                this.raise(expr.start, (isBind ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n        }\n    };\n    pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {\n        if (bindingType === void 0) bindingType = BIND_NONE;\n        switch(expr.type){\n            case \"ObjectPattern\":\n                for(var i = 0, list = expr.properties; i < list.length; i += 1){\n                    var prop = list[i];\n                    this.checkLValInnerPattern(prop, bindingType, checkClashes);\n                }\n                break;\n            case \"ArrayPattern\":\n                for(var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1){\n                    var elem = list$1[i$1];\n                    if (elem) {\n                        this.checkLValInnerPattern(elem, bindingType, checkClashes);\n                    }\n                }\n                break;\n            default:\n                this.checkLValSimple(expr, bindingType, checkClashes);\n        }\n    };\n    pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {\n        if (bindingType === void 0) bindingType = BIND_NONE;\n        switch(expr.type){\n            case \"Property\":\n                // AssignmentProperty has type === \"Property\"\n                this.checkLValInnerPattern(expr.value, bindingType, checkClashes);\n                break;\n            case \"AssignmentPattern\":\n                this.checkLValPattern(expr.left, bindingType, checkClashes);\n                break;\n            case \"RestElement\":\n                this.checkLValPattern(expr.argument, bindingType, checkClashes);\n                break;\n            default:\n                this.checkLValPattern(expr, bindingType, checkClashes);\n        }\n    };\n    // The algorithm used to determine whether a regexp can appear at a\n    // given point in the program is loosely based on sweet.js' approach.\n    // See https://github.com/mozilla/sweet.js/wiki/design\n    var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n        this.token = token;\n        this.isExpr = !!isExpr;\n        this.preserveSpace = !!preserveSpace;\n        this.override = override;\n        this.generator = !!generator;\n    };\n    var types = {\n        b_stat: new TokContext(\"{\", false),\n        b_expr: new TokContext(\"{\", true),\n        b_tmpl: new TokContext(\"${\", false),\n        p_stat: new TokContext(\"(\", false),\n        p_expr: new TokContext(\"(\", true),\n        q_tmpl: new TokContext(\"`\", true, true, function(p) {\n            return p.tryReadTemplateToken();\n        }),\n        f_stat: new TokContext(\"function\", false),\n        f_expr: new TokContext(\"function\", true),\n        f_expr_gen: new TokContext(\"function\", true, false, null, true),\n        f_gen: new TokContext(\"function\", false, false, null, true)\n    };\n    var pp$6 = Parser.prototype;\n    pp$6.initialContext = function() {\n        return [\n            types.b_stat\n        ];\n    };\n    pp$6.curContext = function() {\n        return this.context[this.context.length - 1];\n    };\n    pp$6.braceIsBlock = function(prevType) {\n        var parent = this.curContext();\n        if (parent === types.f_expr || parent === types.f_stat) {\n            return true;\n        }\n        if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {\n            return !parent.isExpr;\n        }\n        // The check for `tt.name && exprAllowed` detects whether we are\n        // after a `yield` or `of` construct. See the `updateContext` for\n        // `tt.name`.\n        if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {\n            return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n        }\n        if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {\n            return true;\n        }\n        if (prevType === types$1.braceL) {\n            return parent === types.b_stat;\n        }\n        if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {\n            return false;\n        }\n        return !this.exprAllowed;\n    };\n    pp$6.inGeneratorContext = function() {\n        for(var i = this.context.length - 1; i >= 1; i--){\n            var context = this.context[i];\n            if (context.token === \"function\") {\n                return context.generator;\n            }\n        }\n        return false;\n    };\n    pp$6.updateContext = function(prevType) {\n        var update, type = this.type;\n        if (type.keyword && prevType === types$1.dot) {\n            this.exprAllowed = false;\n        } else if (update = type.updateContext) {\n            update.call(this, prevType);\n        } else {\n            this.exprAllowed = type.beforeExpr;\n        }\n    };\n    // Used to handle edge cases when token context could not be inferred correctly during tokenization phase\n    pp$6.overrideContext = function(tokenCtx) {\n        if (this.curContext() !== tokenCtx) {\n            this.context[this.context.length - 1] = tokenCtx;\n        }\n    };\n    // Token-specific context update code\n    types$1.parenR.updateContext = types$1.braceR.updateContext = function() {\n        if (this.context.length === 1) {\n            this.exprAllowed = true;\n            return;\n        }\n        var out = this.context.pop();\n        if (out === types.b_stat && this.curContext().token === \"function\") {\n            out = this.context.pop();\n        }\n        this.exprAllowed = !out.isExpr;\n    };\n    types$1.braceL.updateContext = function(prevType) {\n        this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);\n        this.exprAllowed = true;\n    };\n    types$1.dollarBraceL.updateContext = function() {\n        this.context.push(types.b_tmpl);\n        this.exprAllowed = true;\n    };\n    types$1.parenL.updateContext = function(prevType) {\n        var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;\n        this.context.push(statementParens ? types.p_stat : types.p_expr);\n        this.exprAllowed = true;\n    };\n    types$1.incDec.updateContext = function() {\n    // tokExprAllowed stays unchanged\n    };\n    types$1._function.updateContext = types$1._class.updateContext = function(prevType) {\n        if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {\n            this.context.push(types.f_expr);\n        } else {\n            this.context.push(types.f_stat);\n        }\n        this.exprAllowed = false;\n    };\n    types$1.colon.updateContext = function() {\n        if (this.curContext().token === \"function\") {\n            this.context.pop();\n        }\n        this.exprAllowed = true;\n    };\n    types$1.backQuote.updateContext = function() {\n        if (this.curContext() === types.q_tmpl) {\n            this.context.pop();\n        } else {\n            this.context.push(types.q_tmpl);\n        }\n        this.exprAllowed = false;\n    };\n    types$1.star.updateContext = function(prevType) {\n        if (prevType === types$1._function) {\n            var index = this.context.length - 1;\n            if (this.context[index] === types.f_expr) {\n                this.context[index] = types.f_expr_gen;\n            } else {\n                this.context[index] = types.f_gen;\n            }\n        }\n        this.exprAllowed = true;\n    };\n    types$1.name.updateContext = function(prevType) {\n        var allowed = false;\n        if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {\n            if (this.value === \"of\" && !this.exprAllowed || this.value === \"yield\" && this.inGeneratorContext()) {\n                allowed = true;\n            }\n        }\n        this.exprAllowed = allowed;\n    };\n    // A recursive descent parser operates by defining functions for all\n    // syntactic elements, and recursively calling those, each function\n    // advancing the input stream and returning an AST node. Precedence\n    // of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n    // instead of `(!x)[1]` is handled by the fact that the parser\n    // function that parses unary prefix operators is called first, and\n    // in turn calls the function that parses `[]` subscripts — that\n    // way, it'll receive the node for `x[1]` already parsed, and wraps\n    // *that* in the unary operator node.\n    //\n    // Acorn uses an [operator precedence parser][opp] to handle binary\n    // operator precedence, because it is much more compact than using\n    // the technique outlined above, which uses different, nesting\n    // functions to specify precedence, for all of the ten binary\n    // precedence levels that JavaScript defines.\n    //\n    // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n    var pp$5 = Parser.prototype;\n    // Check if property name clashes with already added.\n    // Object/class getters and setters are not allowed to clash —\n    // either with each other or with an init property — and in\n    // strict mode, init properties are also not allowed to be repeated.\n    pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {\n        if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\") {\n            return;\n        }\n        if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {\n            return;\n        }\n        var key = prop.key;\n        var name;\n        switch(key.type){\n            case \"Identifier\":\n                name = key.name;\n                break;\n            case \"Literal\":\n                name = String(key.value);\n                break;\n            default:\n                return;\n        }\n        var kind = prop.kind;\n        if (this.options.ecmaVersion >= 6) {\n            if (name === \"__proto__\" && kind === \"init\") {\n                if (propHash.proto) {\n                    if (refDestructuringErrors) {\n                        if (refDestructuringErrors.doubleProto < 0) {\n                            refDestructuringErrors.doubleProto = key.start;\n                        }\n                    } else {\n                        this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\");\n                    }\n                }\n                propHash.proto = true;\n            }\n            return;\n        }\n        name = \"$\" + name;\n        var other = propHash[name];\n        if (other) {\n            var redefinition;\n            if (kind === \"init\") {\n                redefinition = this.strict && other.init || other.get || other.set;\n            } else {\n                redefinition = other.init || other[kind];\n            }\n            if (redefinition) {\n                this.raiseRecoverable(key.start, \"Redefinition of property\");\n            }\n        } else {\n            other = propHash[name] = {\n                init: false,\n                get: false,\n                set: false\n            };\n        }\n        other[kind] = true;\n    };\n    // ### Expression parsing\n    // These nest, from the most general expression type at the top to\n    // 'atomic', nondivisible expression types at the bottom. Most of\n    // the functions will simply let the function(s) below them parse,\n    // and, *if* the syntactic construct they handle is present, wrap\n    // the AST node that the inner parser gave them in another node.\n    // Parse a full expression. The optional arguments are used to\n    // forbid the `in` operator (in for loops initalization expressions)\n    // and provide reference for storing '=' operator inside shorthand\n    // property assignment in contexts where both object expression\n    // and object pattern might appear (so it's possible to raise\n    // delayed syntax error at correct position).\n    pp$5.parseExpression = function(forInit, refDestructuringErrors) {\n        var startPos = this.start, startLoc = this.startLoc;\n        var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);\n        if (this.type === types$1.comma) {\n            var node = this.startNodeAt(startPos, startLoc);\n            node.expressions = [\n                expr\n            ];\n            while(this.eat(types$1.comma)){\n                node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));\n            }\n            return this.finishNode(node, \"SequenceExpression\");\n        }\n        return expr;\n    };\n    // Parse an assignment expression. This includes applications of\n    // operators like `+=`.\n    pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {\n        if (this.isContextual(\"yield\")) {\n            if (this.inGenerator) {\n                return this.parseYield(forInit);\n            } else {\n                this.exprAllowed = false;\n            }\n        }\n        var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;\n        if (refDestructuringErrors) {\n            oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n            oldTrailingComma = refDestructuringErrors.trailingComma;\n            oldDoubleProto = refDestructuringErrors.doubleProto;\n            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\n        } else {\n            refDestructuringErrors = new DestructuringErrors;\n            ownDestructuringErrors = true;\n        }\n        var startPos = this.start, startLoc = this.startLoc;\n        if (this.type === types$1.parenL || this.type === types$1.name) {\n            this.potentialArrowAt = this.start;\n            this.potentialArrowInForAwait = forInit === \"await\";\n        }\n        var left = this.parseMaybeConditional(forInit, refDestructuringErrors);\n        if (afterLeftParse) {\n            left = afterLeftParse.call(this, left, startPos, startLoc);\n        }\n        if (this.type.isAssign) {\n            var node = this.startNodeAt(startPos, startLoc);\n            node.operator = this.value;\n            if (this.type === types$1.eq) {\n                left = this.toAssignable(left, false, refDestructuringErrors);\n            }\n            if (!ownDestructuringErrors) {\n                refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;\n            }\n            if (refDestructuringErrors.shorthandAssign >= left.start) {\n                refDestructuringErrors.shorthandAssign = -1;\n            } // reset because shorthand default was used correctly\n            if (this.type === types$1.eq) {\n                this.checkLValPattern(left);\n            } else {\n                this.checkLValSimple(left);\n            }\n            node.left = left;\n            this.next();\n            node.right = this.parseMaybeAssign(forInit);\n            if (oldDoubleProto > -1) {\n                refDestructuringErrors.doubleProto = oldDoubleProto;\n            }\n            return this.finishNode(node, \"AssignmentExpression\");\n        } else {\n            if (ownDestructuringErrors) {\n                this.checkExpressionErrors(refDestructuringErrors, true);\n            }\n        }\n        if (oldParenAssign > -1) {\n            refDestructuringErrors.parenthesizedAssign = oldParenAssign;\n        }\n        if (oldTrailingComma > -1) {\n            refDestructuringErrors.trailingComma = oldTrailingComma;\n        }\n        return left;\n    };\n    // Parse a ternary conditional (`?:`) operator.\n    pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {\n        var startPos = this.start, startLoc = this.startLoc;\n        var expr = this.parseExprOps(forInit, refDestructuringErrors);\n        if (this.checkExpressionErrors(refDestructuringErrors)) {\n            return expr;\n        }\n        if (this.eat(types$1.question)) {\n            var node = this.startNodeAt(startPos, startLoc);\n            node.test = expr;\n            node.consequent = this.parseMaybeAssign();\n            this.expect(types$1.colon);\n            node.alternate = this.parseMaybeAssign(forInit);\n            return this.finishNode(node, \"ConditionalExpression\");\n        }\n        return expr;\n    };\n    // Start the precedence parser.\n    pp$5.parseExprOps = function(forInit, refDestructuringErrors) {\n        var startPos = this.start, startLoc = this.startLoc;\n        var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);\n        if (this.checkExpressionErrors(refDestructuringErrors)) {\n            return expr;\n        }\n        return expr.start === startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);\n    };\n    // Parse binary operators with the operator precedence parsing\n    // algorithm. `left` is the left-hand side of the operator.\n    // `minPrec` provides context that allows the function to stop and\n    // defer further parser to one of its callers when it encounters an\n    // operator that has a lower precedence than the set it is parsing.\n    pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {\n        var prec = this.type.binop;\n        if (prec != null && (!forInit || this.type !== types$1._in)) {\n            if (prec > minPrec) {\n                var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;\n                var coalesce = this.type === types$1.coalesce;\n                if (coalesce) {\n                    // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.\n                    // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.\n                    prec = types$1.logicalAND.binop;\n                }\n                var op = this.value;\n                this.next();\n                var startPos = this.start, startLoc = this.startLoc;\n                var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);\n                var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);\n                if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {\n                    this.raiseRecoverable(this.start, \"Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses\");\n                }\n                return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);\n            }\n        }\n        return left;\n    };\n    pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n        if (right.type === \"PrivateIdentifier\") {\n            this.raise(right.start, \"Private identifier can only be left side of binary expression\");\n        }\n        var node = this.startNodeAt(startPos, startLoc);\n        node.left = left;\n        node.operator = op;\n        node.right = right;\n        return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\");\n    };\n    // Parse unary operators, both prefix and postfix.\n    pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {\n        var startPos = this.start, startLoc = this.startLoc, expr;\n        if (this.isContextual(\"await\") && this.canAwait) {\n            expr = this.parseAwait(forInit);\n            sawUnary = true;\n        } else if (this.type.prefix) {\n            var node = this.startNode(), update = this.type === types$1.incDec;\n            node.operator = this.value;\n            node.prefix = true;\n            this.next();\n            node.argument = this.parseMaybeUnary(null, true, update, forInit);\n            this.checkExpressionErrors(refDestructuringErrors, true);\n            if (update) {\n                this.checkLValSimple(node.argument);\n            } else if (this.strict && node.operator === \"delete\" && isLocalVariableAccess(node.argument)) {\n                this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\");\n            } else if (node.operator === \"delete\" && isPrivateFieldAccess(node.argument)) {\n                this.raiseRecoverable(node.start, \"Private fields can not be deleted\");\n            } else {\n                sawUnary = true;\n            }\n            expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n        } else if (!sawUnary && this.type === types$1.privateId) {\n            if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {\n                this.unexpected();\n            }\n            expr = this.parsePrivateIdent();\n            // only could be private fields in 'in', such as #x in obj\n            if (this.type !== types$1._in) {\n                this.unexpected();\n            }\n        } else {\n            expr = this.parseExprSubscripts(refDestructuringErrors, forInit);\n            if (this.checkExpressionErrors(refDestructuringErrors)) {\n                return expr;\n            }\n            while(this.type.postfix && !this.canInsertSemicolon()){\n                var node$1 = this.startNodeAt(startPos, startLoc);\n                node$1.operator = this.value;\n                node$1.prefix = false;\n                node$1.argument = expr;\n                this.checkLValSimple(expr);\n                this.next();\n                expr = this.finishNode(node$1, \"UpdateExpression\");\n            }\n        }\n        if (!incDec && this.eat(types$1.starstar)) {\n            if (sawUnary) {\n                this.unexpected(this.lastTokStart);\n            } else {\n                return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), \"**\", false);\n            }\n        } else {\n            return expr;\n        }\n    };\n    function isLocalVariableAccess(node) {\n        return node.type === \"Identifier\" || node.type === \"ParenthesizedExpression\" && isLocalVariableAccess(node.expression);\n    }\n    function isPrivateFieldAccess(node) {\n        return node.type === \"MemberExpression\" && node.property.type === \"PrivateIdentifier\" || node.type === \"ChainExpression\" && isPrivateFieldAccess(node.expression) || node.type === \"ParenthesizedExpression\" && isPrivateFieldAccess(node.expression);\n    }\n    // Parse call, dot, and `[]`-subscript expressions.\n    pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {\n        var startPos = this.start, startLoc = this.startLoc;\n        var expr = this.parseExprAtom(refDestructuringErrors, forInit);\n        if (expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\") {\n            return expr;\n        }\n        var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);\n        if (refDestructuringErrors && result.type === \"MemberExpression\") {\n            if (refDestructuringErrors.parenthesizedAssign >= result.start) {\n                refDestructuringErrors.parenthesizedAssign = -1;\n            }\n            if (refDestructuringErrors.parenthesizedBind >= result.start) {\n                refDestructuringErrors.parenthesizedBind = -1;\n            }\n            if (refDestructuringErrors.trailingComma >= result.start) {\n                refDestructuringErrors.trailingComma = -1;\n            }\n        }\n        return result;\n    };\n    pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {\n        var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;\n        var optionalChained = false;\n        while(true){\n            var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);\n            if (element.optional) {\n                optionalChained = true;\n            }\n            if (element === base || element.type === \"ArrowFunctionExpression\") {\n                if (optionalChained) {\n                    var chainNode = this.startNodeAt(startPos, startLoc);\n                    chainNode.expression = element;\n                    element = this.finishNode(chainNode, \"ChainExpression\");\n                }\n                return element;\n            }\n            base = element;\n        }\n    };\n    pp$5.shouldParseAsyncArrow = function() {\n        return !this.canInsertSemicolon() && this.eat(types$1.arrow);\n    };\n    pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);\n    };\n    pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {\n        var optionalSupported = this.options.ecmaVersion >= 11;\n        var optional = optionalSupported && this.eat(types$1.questionDot);\n        if (noCalls && optional) {\n            this.raise(this.lastTokStart, \"Optional chaining cannot appear in the callee of new expressions\");\n        }\n        var computed = this.eat(types$1.bracketL);\n        if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {\n            var node = this.startNodeAt(startPos, startLoc);\n            node.object = base;\n            if (computed) {\n                node.property = this.parseExpression();\n                this.expect(types$1.bracketR);\n            } else if (this.type === types$1.privateId && base.type !== \"Super\") {\n                node.property = this.parsePrivateIdent();\n            } else {\n                node.property = this.parseIdent(this.options.allowReserved !== \"never\");\n            }\n            node.computed = !!computed;\n            if (optionalSupported) {\n                node.optional = optional;\n            }\n            base = this.finishNode(node, \"MemberExpression\");\n        } else if (!noCalls && this.eat(types$1.parenL)) {\n            var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n            this.yieldPos = 0;\n            this.awaitPos = 0;\n            this.awaitIdentPos = 0;\n            var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);\n            if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {\n                this.checkPatternErrors(refDestructuringErrors, false);\n                this.checkYieldAwaitInDefaultParams();\n                if (this.awaitIdentPos > 0) {\n                    this.raise(this.awaitIdentPos, \"Cannot use 'await' as identifier inside an async function\");\n                }\n                this.yieldPos = oldYieldPos;\n                this.awaitPos = oldAwaitPos;\n                this.awaitIdentPos = oldAwaitIdentPos;\n                return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);\n            }\n            this.checkExpressionErrors(refDestructuringErrors, true);\n            this.yieldPos = oldYieldPos || this.yieldPos;\n            this.awaitPos = oldAwaitPos || this.awaitPos;\n            this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;\n            var node$1 = this.startNodeAt(startPos, startLoc);\n            node$1.callee = base;\n            node$1.arguments = exprList;\n            if (optionalSupported) {\n                node$1.optional = optional;\n            }\n            base = this.finishNode(node$1, \"CallExpression\");\n        } else if (this.type === types$1.backQuote) {\n            if (optional || optionalChained) {\n                this.raise(this.start, \"Optional chaining cannot appear in the tag of tagged template expressions\");\n            }\n            var node$2 = this.startNodeAt(startPos, startLoc);\n            node$2.tag = base;\n            node$2.quasi = this.parseTemplate({\n                isTagged: true\n            });\n            base = this.finishNode(node$2, \"TaggedTemplateExpression\");\n        }\n        return base;\n    };\n    // Parse an atomic expression — either a single token that is an\n    // expression, an expression started by a keyword like `function` or\n    // `new`, or an expression wrapped in punctuation like `()`, `[]`,\n    // or `{}`.\n    pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {\n        // If a division operator appears in an expression position, the\n        // tokenizer got confused, and we force it to read a regexp instead.\n        if (this.type === types$1.slash) {\n            this.readRegexp();\n        }\n        var node, canBeArrow = this.potentialArrowAt === this.start;\n        switch(this.type){\n            case types$1._super:\n                if (!this.allowSuper) {\n                    this.raise(this.start, \"'super' keyword outside a method\");\n                }\n                node = this.startNode();\n                this.next();\n                if (this.type === types$1.parenL && !this.allowDirectSuper) {\n                    this.raise(node.start, \"super() call outside constructor of a subclass\");\n                }\n                // The `super` keyword can appear at below:\n                // SuperProperty:\n                //     super [ Expression ]\n                //     super . IdentifierName\n                // SuperCall:\n                //     super ( Arguments )\n                if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {\n                    this.unexpected();\n                }\n                return this.finishNode(node, \"Super\");\n            case types$1._this:\n                node = this.startNode();\n                this.next();\n                return this.finishNode(node, \"ThisExpression\");\n            case types$1.name:\n                var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\n                var id = this.parseIdent(false);\n                if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types$1._function)) {\n                    this.overrideContext(types.f_expr);\n                    return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);\n                }\n                if (canBeArrow && !this.canInsertSemicolon()) {\n                    if (this.eat(types$1.arrow)) {\n                        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [\n                            id\n                        ], false, forInit);\n                    }\n                    if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== \"of\" || this.containsEsc)) {\n                        id = this.parseIdent(false);\n                        if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {\n                            this.unexpected();\n                        }\n                        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [\n                            id\n                        ], true, forInit);\n                    }\n                }\n                return id;\n            case types$1.regexp:\n                var value = this.value;\n                node = this.parseLiteral(value.value);\n                node.regex = {\n                    pattern: value.pattern,\n                    flags: value.flags\n                };\n                return node;\n            case types$1.num:\n            case types$1.string:\n                return this.parseLiteral(this.value);\n            case types$1._null:\n            case types$1._true:\n            case types$1._false:\n                node = this.startNode();\n                node.value = this.type === types$1._null ? null : this.type === types$1._true;\n                node.raw = this.type.keyword;\n                this.next();\n                return this.finishNode(node, \"Literal\");\n            case types$1.parenL:\n                var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);\n                if (refDestructuringErrors) {\n                    if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {\n                        refDestructuringErrors.parenthesizedAssign = start;\n                    }\n                    if (refDestructuringErrors.parenthesizedBind < 0) {\n                        refDestructuringErrors.parenthesizedBind = start;\n                    }\n                }\n                return expr;\n            case types$1.bracketL:\n                node = this.startNode();\n                this.next();\n                node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);\n                return this.finishNode(node, \"ArrayExpression\");\n            case types$1.braceL:\n                this.overrideContext(types.b_expr);\n                return this.parseObj(false, refDestructuringErrors);\n            case types$1._function:\n                node = this.startNode();\n                this.next();\n                return this.parseFunction(node, 0);\n            case types$1._class:\n                return this.parseClass(this.startNode(), false);\n            case types$1._new:\n                return this.parseNew();\n            case types$1.backQuote:\n                return this.parseTemplate();\n            case types$1._import:\n                if (this.options.ecmaVersion >= 11) {\n                    return this.parseExprImport(forNew);\n                } else {\n                    return this.unexpected();\n                }\n            default:\n                return this.parseExprAtomDefault();\n        }\n    };\n    pp$5.parseExprAtomDefault = function() {\n        this.unexpected();\n    };\n    pp$5.parseExprImport = function(forNew) {\n        var node = this.startNode();\n        // Consume `import` as an identifier for `import.meta`.\n        // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.\n        if (this.containsEsc) {\n            this.raiseRecoverable(this.start, \"Escape sequence in keyword import\");\n        }\n        this.next();\n        if (this.type === types$1.parenL && !forNew) {\n            return this.parseDynamicImport(node);\n        } else if (this.type === types$1.dot) {\n            var meta = this.startNodeAt(node.start, node.loc && node.loc.start);\n            meta.name = \"import\";\n            node.meta = this.finishNode(meta, \"Identifier\");\n            return this.parseImportMeta(node);\n        } else {\n            this.unexpected();\n        }\n    };\n    pp$5.parseDynamicImport = function(node) {\n        this.next(); // skip `(`\n        // Parse node.source.\n        node.source = this.parseMaybeAssign();\n        if (this.options.ecmaVersion >= 16) {\n            if (!this.eat(types$1.parenR)) {\n                this.expect(types$1.comma);\n                if (!this.afterTrailingComma(types$1.parenR)) {\n                    node.options = this.parseMaybeAssign();\n                    if (!this.eat(types$1.parenR)) {\n                        this.expect(types$1.comma);\n                        if (!this.afterTrailingComma(types$1.parenR)) {\n                            this.unexpected();\n                        }\n                    }\n                } else {\n                    node.options = null;\n                }\n            } else {\n                node.options = null;\n            }\n        } else {\n            // Verify ending.\n            if (!this.eat(types$1.parenR)) {\n                var errorPos = this.start;\n                if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {\n                    this.raiseRecoverable(errorPos, \"Trailing comma is not allowed in import()\");\n                } else {\n                    this.unexpected(errorPos);\n                }\n            }\n        }\n        return this.finishNode(node, \"ImportExpression\");\n    };\n    pp$5.parseImportMeta = function(node) {\n        this.next(); // skip `.`\n        var containsEsc = this.containsEsc;\n        node.property = this.parseIdent(true);\n        if (node.property.name !== \"meta\") {\n            this.raiseRecoverable(node.property.start, \"The only valid meta property for import is 'import.meta'\");\n        }\n        if (containsEsc) {\n            this.raiseRecoverable(node.start, \"'import.meta' must not contain escaped characters\");\n        }\n        if (this.options.sourceType !== \"module\" && !this.options.allowImportExportEverywhere) {\n            this.raiseRecoverable(node.start, \"Cannot use 'import.meta' outside a module\");\n        }\n        return this.finishNode(node, \"MetaProperty\");\n    };\n    pp$5.parseLiteral = function(value) {\n        var node = this.startNode();\n        node.value = value;\n        node.raw = this.input.slice(this.start, this.end);\n        if (node.raw.charCodeAt(node.raw.length - 1) === 110) {\n            node.bigint = node.raw.slice(0, -1).replace(/_/g, \"\");\n        }\n        this.next();\n        return this.finishNode(node, \"Literal\");\n    };\n    pp$5.parseParenExpression = function() {\n        this.expect(types$1.parenL);\n        var val = this.parseExpression();\n        this.expect(types$1.parenR);\n        return val;\n    };\n    pp$5.shouldParseArrow = function(exprList) {\n        return !this.canInsertSemicolon();\n    };\n    pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {\n        var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\n        if (this.options.ecmaVersion >= 6) {\n            this.next();\n            var innerStartPos = this.start, innerStartLoc = this.startLoc;\n            var exprList = [], first = true, lastIsComma = false;\n            var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\n            this.yieldPos = 0;\n            this.awaitPos = 0;\n            // Do not save awaitIdentPos to allow checking awaits nested in parameters\n            while(this.type !== types$1.parenR){\n                first ? first = false : this.expect(types$1.comma);\n                if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {\n                    lastIsComma = true;\n                    break;\n                } else if (this.type === types$1.ellipsis) {\n                    spreadStart = this.start;\n                    exprList.push(this.parseParenItem(this.parseRestBinding()));\n                    if (this.type === types$1.comma) {\n                        this.raiseRecoverable(this.start, \"Comma is not permitted after the rest element\");\n                    }\n                    break;\n                } else {\n                    exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));\n                }\n            }\n            var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;\n            this.expect(types$1.parenR);\n            if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {\n                this.checkPatternErrors(refDestructuringErrors, false);\n                this.checkYieldAwaitInDefaultParams();\n                this.yieldPos = oldYieldPos;\n                this.awaitPos = oldAwaitPos;\n                return this.parseParenArrowList(startPos, startLoc, exprList, forInit);\n            }\n            if (!exprList.length || lastIsComma) {\n                this.unexpected(this.lastTokStart);\n            }\n            if (spreadStart) {\n                this.unexpected(spreadStart);\n            }\n            this.checkExpressionErrors(refDestructuringErrors, true);\n            this.yieldPos = oldYieldPos || this.yieldPos;\n            this.awaitPos = oldAwaitPos || this.awaitPos;\n            if (exprList.length > 1) {\n                val = this.startNodeAt(innerStartPos, innerStartLoc);\n                val.expressions = exprList;\n                this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n            } else {\n                val = exprList[0];\n            }\n        } else {\n            val = this.parseParenExpression();\n        }\n        if (this.options.preserveParens) {\n            var par = this.startNodeAt(startPos, startLoc);\n            par.expression = val;\n            return this.finishNode(par, \"ParenthesizedExpression\");\n        } else {\n            return val;\n        }\n    };\n    pp$5.parseParenItem = function(item) {\n        return item;\n    };\n    pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);\n    };\n    // New's precedence is slightly tricky. It must allow its argument to\n    // be a `[]` or dot subscript expression, but not a call — at least,\n    // not without wrapping it in parentheses. Thus, it uses the noCalls\n    // argument to parseSubscripts to prevent it from consuming the\n    // argument list.\n    var empty = [];\n    pp$5.parseNew = function() {\n        if (this.containsEsc) {\n            this.raiseRecoverable(this.start, \"Escape sequence in keyword new\");\n        }\n        var node = this.startNode();\n        this.next();\n        if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {\n            var meta = this.startNodeAt(node.start, node.loc && node.loc.start);\n            meta.name = \"new\";\n            node.meta = this.finishNode(meta, \"Identifier\");\n            this.next();\n            var containsEsc = this.containsEsc;\n            node.property = this.parseIdent(true);\n            if (node.property.name !== \"target\") {\n                this.raiseRecoverable(node.property.start, \"The only valid meta property for new is 'new.target'\");\n            }\n            if (containsEsc) {\n                this.raiseRecoverable(node.start, \"'new.target' must not contain escaped characters\");\n            }\n            if (!this.allowNewDotTarget) {\n                this.raiseRecoverable(node.start, \"'new.target' can only be used in functions and class static block\");\n            }\n            return this.finishNode(node, \"MetaProperty\");\n        }\n        var startPos = this.start, startLoc = this.startLoc;\n        node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);\n        if (this.eat(types$1.parenL)) {\n            node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);\n        } else {\n            node.arguments = empty;\n        }\n        return this.finishNode(node, \"NewExpression\");\n    };\n    // Parse template expression.\n    pp$5.parseTemplateElement = function(ref) {\n        var isTagged = ref.isTagged;\n        var elem = this.startNode();\n        if (this.type === types$1.invalidTemplate) {\n            if (!isTagged) {\n                this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\n            }\n            elem.value = {\n                raw: this.value.replace(/\\r\\n?/g, \"\\n\"),\n                cooked: null\n            };\n        } else {\n            elem.value = {\n                raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n                cooked: this.value\n            };\n        }\n        this.next();\n        elem.tail = this.type === types$1.backQuote;\n        return this.finishNode(elem, \"TemplateElement\");\n    };\n    pp$5.parseTemplate = function(ref) {\n        if (ref === void 0) ref = {};\n        var isTagged = ref.isTagged;\n        if (isTagged === void 0) isTagged = false;\n        var node = this.startNode();\n        this.next();\n        node.expressions = [];\n        var curElt = this.parseTemplateElement({\n            isTagged: isTagged\n        });\n        node.quasis = [\n            curElt\n        ];\n        while(!curElt.tail){\n            if (this.type === types$1.eof) {\n                this.raise(this.pos, \"Unterminated template literal\");\n            }\n            this.expect(types$1.dollarBraceL);\n            node.expressions.push(this.parseExpression());\n            this.expect(types$1.braceR);\n            node.quasis.push(curElt = this.parseTemplateElement({\n                isTagged: isTagged\n            }));\n        }\n        this.next();\n        return this.finishNode(node, \"TemplateLiteral\");\n    };\n    pp$5.isAsyncProp = function(prop) {\n        return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n    };\n    // Parse an object literal or binding pattern.\n    pp$5.parseObj = function(isPattern, refDestructuringErrors) {\n        var node = this.startNode(), first = true, propHash = {};\n        node.properties = [];\n        this.next();\n        while(!this.eat(types$1.braceR)){\n            if (!first) {\n                this.expect(types$1.comma);\n                if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {\n                    break;\n                }\n            } else {\n                first = false;\n            }\n            var prop = this.parseProperty(isPattern, refDestructuringErrors);\n            if (!isPattern) {\n                this.checkPropClash(prop, propHash, refDestructuringErrors);\n            }\n            node.properties.push(prop);\n        }\n        return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\");\n    };\n    pp$5.parseProperty = function(isPattern, refDestructuringErrors) {\n        var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;\n        if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {\n            if (isPattern) {\n                prop.argument = this.parseIdent(false);\n                if (this.type === types$1.comma) {\n                    this.raiseRecoverable(this.start, \"Comma is not permitted after the rest element\");\n                }\n                return this.finishNode(prop, \"RestElement\");\n            }\n            // Parse argument.\n            prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n            // To disallow trailing comma via `this.toAssignable()`.\n            if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\n                refDestructuringErrors.trailingComma = this.start;\n            }\n            // Finish\n            return this.finishNode(prop, \"SpreadElement\");\n        }\n        if (this.options.ecmaVersion >= 6) {\n            prop.method = false;\n            prop.shorthand = false;\n            if (isPattern || refDestructuringErrors) {\n                startPos = this.start;\n                startLoc = this.startLoc;\n            }\n            if (!isPattern) {\n                isGenerator = this.eat(types$1.star);\n            }\n        }\n        var containsEsc = this.containsEsc;\n        this.parsePropertyName(prop);\n        if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\n            isAsync = true;\n            isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);\n            this.parsePropertyName(prop);\n        } else {\n            isAsync = false;\n        }\n        this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\n        return this.finishNode(prop, \"Property\");\n    };\n    pp$5.parseGetterSetter = function(prop) {\n        var kind = prop.key.name;\n        this.parsePropertyName(prop);\n        prop.value = this.parseMethod(false);\n        prop.kind = kind;\n        var paramCount = prop.kind === \"get\" ? 0 : 1;\n        if (prop.value.params.length !== paramCount) {\n            var start = prop.value.start;\n            if (prop.kind === \"get\") {\n                this.raiseRecoverable(start, \"getter should have no params\");\n            } else {\n                this.raiseRecoverable(start, \"setter should have exactly one param\");\n            }\n        } else {\n            if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\") {\n                this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\");\n            }\n        }\n    };\n    pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\n        if ((isGenerator || isAsync) && this.type === types$1.colon) {\n            this.unexpected();\n        }\n        if (this.eat(types$1.colon)) {\n            prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n            prop.kind = \"init\";\n        } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {\n            if (isPattern) {\n                this.unexpected();\n            }\n            prop.method = true;\n            prop.value = this.parseMethod(isGenerator, isAsync);\n            prop.kind = \"init\";\n        } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" && (prop.key.name === \"get\" || prop.key.name === \"set\") && this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq) {\n            if (isGenerator || isAsync) {\n                this.unexpected();\n            }\n            this.parseGetterSetter(prop);\n        } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n            if (isGenerator || isAsync) {\n                this.unexpected();\n            }\n            this.checkUnreserved(prop.key);\n            if (prop.key.name === \"await\" && !this.awaitIdentPos) {\n                this.awaitIdentPos = startPos;\n            }\n            if (isPattern) {\n                prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));\n            } else if (this.type === types$1.eq && refDestructuringErrors) {\n                if (refDestructuringErrors.shorthandAssign < 0) {\n                    refDestructuringErrors.shorthandAssign = this.start;\n                }\n                prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));\n            } else {\n                prop.value = this.copyNode(prop.key);\n            }\n            prop.kind = \"init\";\n            prop.shorthand = true;\n        } else {\n            this.unexpected();\n        }\n    };\n    pp$5.parsePropertyName = function(prop) {\n        if (this.options.ecmaVersion >= 6) {\n            if (this.eat(types$1.bracketL)) {\n                prop.computed = true;\n                prop.key = this.parseMaybeAssign();\n                this.expect(types$1.bracketR);\n                return prop.key;\n            } else {\n                prop.computed = false;\n            }\n        }\n        return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== \"never\");\n    };\n    // Initialize empty function node.\n    pp$5.initFunction = function(node) {\n        node.id = null;\n        if (this.options.ecmaVersion >= 6) {\n            node.generator = node.expression = false;\n        }\n        if (this.options.ecmaVersion >= 8) {\n            node.async = false;\n        }\n    };\n    // Parse object or class method.\n    pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {\n        var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n        this.initFunction(node);\n        if (this.options.ecmaVersion >= 6) {\n            node.generator = isGenerator;\n        }\n        if (this.options.ecmaVersion >= 8) {\n            node.async = !!isAsync;\n        }\n        this.yieldPos = 0;\n        this.awaitPos = 0;\n        this.awaitIdentPos = 0;\n        this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n        this.expect(types$1.parenL);\n        node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);\n        this.checkYieldAwaitInDefaultParams();\n        this.parseFunctionBody(node, false, true, false);\n        this.yieldPos = oldYieldPos;\n        this.awaitPos = oldAwaitPos;\n        this.awaitIdentPos = oldAwaitIdentPos;\n        return this.finishNode(node, \"FunctionExpression\");\n    };\n    // Parse arrow function expression with given parameters.\n    pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {\n        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n        this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);\n        this.initFunction(node);\n        if (this.options.ecmaVersion >= 8) {\n            node.async = !!isAsync;\n        }\n        this.yieldPos = 0;\n        this.awaitPos = 0;\n        this.awaitIdentPos = 0;\n        node.params = this.toAssignableList(params, true);\n        this.parseFunctionBody(node, true, false, forInit);\n        this.yieldPos = oldYieldPos;\n        this.awaitPos = oldAwaitPos;\n        this.awaitIdentPos = oldAwaitIdentPos;\n        return this.finishNode(node, \"ArrowFunctionExpression\");\n    };\n    // Parse function body and check parameters.\n    pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {\n        var isExpression = isArrowFunction && this.type !== types$1.braceL;\n        var oldStrict = this.strict, useStrict = false;\n        if (isExpression) {\n            node.body = this.parseMaybeAssign(forInit);\n            node.expression = true;\n            this.checkParams(node, false);\n        } else {\n            var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n            if (!oldStrict || nonSimple) {\n                useStrict = this.strictDirective(this.end);\n                // If this is a strict mode function, verify that argument names\n                // are not repeated, and it does not try to bind the words `eval`\n                // or `arguments`.\n                if (useStrict && nonSimple) {\n                    this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\");\n                }\n            }\n            // Start a new scope with regard to labels and the `inFunction`\n            // flag (restore them to their old value afterwards).\n            var oldLabels = this.labels;\n            this.labels = [];\n            if (useStrict) {\n                this.strict = true;\n            }\n            // Add the params to varDeclaredNames to ensure that an error is thrown\n            // if a let/const declaration in the function clashes with one of the params.\n            this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));\n            // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n            if (this.strict && node.id) {\n                this.checkLValSimple(node.id, BIND_OUTSIDE);\n            }\n            node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);\n            node.expression = false;\n            this.adaptDirectivePrologue(node.body.body);\n            this.labels = oldLabels;\n        }\n        this.exitScope();\n    };\n    pp$5.isSimpleParamList = function(params) {\n        for(var i = 0, list = params; i < list.length; i += 1){\n            var param = list[i];\n            if (param.type !== \"Identifier\") {\n                return false;\n            }\n        }\n        return true;\n    };\n    // Checks function params for various disallowed patterns such as using \"eval\"\n    // or \"arguments\" and duplicate parameters.\n    pp$5.checkParams = function(node, allowDuplicates) {\n        var nameHash = Object.create(null);\n        for(var i = 0, list = node.params; i < list.length; i += 1){\n            var param = list[i];\n            this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);\n        }\n    };\n    // Parses a comma-separated list of expressions, and returns them as\n    // an array. `close` is the token type that ends the list, and\n    // `allowEmpty` can be turned on to allow subsequent commas with\n    // nothing in between them to be parsed as `null` (which is needed\n    // for array literals).\n    pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n        var elts = [], first = true;\n        while(!this.eat(close)){\n            if (!first) {\n                this.expect(types$1.comma);\n                if (allowTrailingComma && this.afterTrailingComma(close)) {\n                    break;\n                }\n            } else {\n                first = false;\n            }\n            var elt = void 0;\n            if (allowEmpty && this.type === types$1.comma) {\n                elt = null;\n            } else if (this.type === types$1.ellipsis) {\n                elt = this.parseSpread(refDestructuringErrors);\n                if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {\n                    refDestructuringErrors.trailingComma = this.start;\n                }\n            } else {\n                elt = this.parseMaybeAssign(false, refDestructuringErrors);\n            }\n            elts.push(elt);\n        }\n        return elts;\n    };\n    pp$5.checkUnreserved = function(ref) {\n        var start = ref.start;\n        var end = ref.end;\n        var name = ref.name;\n        if (this.inGenerator && name === \"yield\") {\n            this.raiseRecoverable(start, \"Cannot use 'yield' as identifier inside a generator\");\n        }\n        if (this.inAsync && name === \"await\") {\n            this.raiseRecoverable(start, \"Cannot use 'await' as identifier inside an async function\");\n        }\n        if (!(this.currentThisScope().flags & SCOPE_VAR) && name === \"arguments\") {\n            this.raiseRecoverable(start, \"Cannot use 'arguments' in class field initializer\");\n        }\n        if (this.inClassStaticBlock && (name === \"arguments\" || name === \"await\")) {\n            this.raise(start, \"Cannot use \" + name + \" in class static initialization block\");\n        }\n        if (this.keywords.test(name)) {\n            this.raise(start, \"Unexpected keyword '\" + name + \"'\");\n        }\n        if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf(\"\\\\\") !== -1) {\n            return;\n        }\n        var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n        if (re.test(name)) {\n            if (!this.inAsync && name === \"await\") {\n                this.raiseRecoverable(start, \"Cannot use keyword 'await' outside an async function\");\n            }\n            this.raiseRecoverable(start, \"The keyword '\" + name + \"' is reserved\");\n        }\n    };\n    // Parse the next token as an identifier. If `liberal` is true (used\n    // when parsing properties), it will also convert keywords into\n    // identifiers.\n    pp$5.parseIdent = function(liberal) {\n        var node = this.parseIdentNode();\n        this.next(!!liberal);\n        this.finishNode(node, \"Identifier\");\n        if (!liberal) {\n            this.checkUnreserved(node);\n            if (node.name === \"await\" && !this.awaitIdentPos) {\n                this.awaitIdentPos = node.start;\n            }\n        }\n        return node;\n    };\n    pp$5.parseIdentNode = function() {\n        var node = this.startNode();\n        if (this.type === types$1.name) {\n            node.name = this.value;\n        } else if (this.type.keyword) {\n            node.name = this.type.keyword;\n            // To fix https://github.com/acornjs/acorn/issues/575\n            // `class` and `function` keywords push new context into this.context.\n            // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.\n            // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword\n            if ((node.name === \"class\" || node.name === \"function\") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\n                this.context.pop();\n            }\n            this.type = types$1.name;\n        } else {\n            this.unexpected();\n        }\n        return node;\n    };\n    pp$5.parsePrivateIdent = function() {\n        var node = this.startNode();\n        if (this.type === types$1.privateId) {\n            node.name = this.value;\n        } else {\n            this.unexpected();\n        }\n        this.next();\n        this.finishNode(node, \"PrivateIdentifier\");\n        // For validating existence\n        if (this.options.checkPrivateFields) {\n            if (this.privateNameStack.length === 0) {\n                this.raise(node.start, \"Private field '#\" + node.name + \"' must be declared in an enclosing class\");\n            } else {\n                this.privateNameStack[this.privateNameStack.length - 1].used.push(node);\n            }\n        }\n        return node;\n    };\n    // Parses yield expression inside generator.\n    pp$5.parseYield = function(forInit) {\n        if (!this.yieldPos) {\n            this.yieldPos = this.start;\n        }\n        var node = this.startNode();\n        this.next();\n        if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {\n            node.delegate = false;\n            node.argument = null;\n        } else {\n            node.delegate = this.eat(types$1.star);\n            node.argument = this.parseMaybeAssign(forInit);\n        }\n        return this.finishNode(node, \"YieldExpression\");\n    };\n    pp$5.parseAwait = function(forInit) {\n        if (!this.awaitPos) {\n            this.awaitPos = this.start;\n        }\n        var node = this.startNode();\n        this.next();\n        node.argument = this.parseMaybeUnary(null, true, false, forInit);\n        return this.finishNode(node, \"AwaitExpression\");\n    };\n    var pp$4 = Parser.prototype;\n    // This function is used to raise exceptions on parse errors. It\n    // takes an offset integer (into the current `input`) to indicate\n    // the location of the error, attaches the position to the end\n    // of the error message, and then raises a `SyntaxError` with that\n    // message.\n    pp$4.raise = function(pos, message) {\n        var loc = getLineInfo(this.input, pos);\n        message += \" (\" + loc.line + \":\" + loc.column + \")\";\n        if (this.sourceFile) {\n            message += \" in \" + this.sourceFile;\n        }\n        var err = new SyntaxError(message);\n        err.pos = pos;\n        err.loc = loc;\n        err.raisedAt = this.pos;\n        throw err;\n    };\n    pp$4.raiseRecoverable = pp$4.raise;\n    pp$4.curPosition = function() {\n        if (this.options.locations) {\n            return new Position(this.curLine, this.pos - this.lineStart);\n        }\n    };\n    var pp$3 = Parser.prototype;\n    var Scope = function Scope(flags) {\n        this.flags = flags;\n        // A list of var-declared names in the current lexical scope\n        this.var = [];\n        // A list of lexically-declared names in the current lexical scope\n        this.lexical = [];\n        // A list of lexically-declared FunctionDeclaration names in the current lexical scope\n        this.functions = [];\n    };\n    // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n    pp$3.enterScope = function(flags) {\n        this.scopeStack.push(new Scope(flags));\n    };\n    pp$3.exitScope = function() {\n        this.scopeStack.pop();\n    };\n    // The spec says:\n    // > At the top level of a function, or script, function declarations are\n    // > treated like var declarations rather than like lexical declarations.\n    pp$3.treatFunctionsAsVarInScope = function(scope) {\n        return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;\n    };\n    pp$3.declareName = function(name, bindingType, pos) {\n        var redeclared = false;\n        if (bindingType === BIND_LEXICAL) {\n            var scope = this.currentScope();\n            redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\n            scope.lexical.push(name);\n            if (this.inModule && scope.flags & SCOPE_TOP) {\n                delete this.undefinedExports[name];\n            }\n        } else if (bindingType === BIND_SIMPLE_CATCH) {\n            var scope$1 = this.currentScope();\n            scope$1.lexical.push(name);\n        } else if (bindingType === BIND_FUNCTION) {\n            var scope$2 = this.currentScope();\n            if (this.treatFunctionsAsVar) {\n                redeclared = scope$2.lexical.indexOf(name) > -1;\n            } else {\n                redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;\n            }\n            scope$2.functions.push(name);\n        } else {\n            for(var i = this.scopeStack.length - 1; i >= 0; --i){\n                var scope$3 = this.scopeStack[i];\n                if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {\n                    redeclared = true;\n                    break;\n                }\n                scope$3.var.push(name);\n                if (this.inModule && scope$3.flags & SCOPE_TOP) {\n                    delete this.undefinedExports[name];\n                }\n                if (scope$3.flags & SCOPE_VAR) {\n                    break;\n                }\n            }\n        }\n        if (redeclared) {\n            this.raiseRecoverable(pos, \"Identifier '\" + name + \"' has already been declared\");\n        }\n    };\n    pp$3.checkLocalExport = function(id) {\n        // scope.functions must be empty as Module code is always strict.\n        if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {\n            this.undefinedExports[id.name] = id;\n        }\n    };\n    pp$3.currentScope = function() {\n        return this.scopeStack[this.scopeStack.length - 1];\n    };\n    pp$3.currentVarScope = function() {\n        for(var i = this.scopeStack.length - 1;; i--){\n            var scope = this.scopeStack[i];\n            if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK)) {\n                return scope;\n            }\n        }\n    };\n    // Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.\n    pp$3.currentThisScope = function() {\n        for(var i = this.scopeStack.length - 1;; i--){\n            var scope = this.scopeStack[i];\n            if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK) && !(scope.flags & SCOPE_ARROW)) {\n                return scope;\n            }\n        }\n    };\n    var Node = function Node(parser, pos, loc) {\n        this.type = \"\";\n        this.start = pos;\n        this.end = 0;\n        if (parser.options.locations) {\n            this.loc = new SourceLocation(parser, loc);\n        }\n        if (parser.options.directSourceFile) {\n            this.sourceFile = parser.options.directSourceFile;\n        }\n        if (parser.options.ranges) {\n            this.range = [\n                pos,\n                0\n            ];\n        }\n    };\n    // Start an AST node, attaching a start offset.\n    var pp$2 = Parser.prototype;\n    pp$2.startNode = function() {\n        return new Node(this, this.start, this.startLoc);\n    };\n    pp$2.startNodeAt = function(pos, loc) {\n        return new Node(this, pos, loc);\n    };\n    // Finish an AST node, adding `type` and `end` properties.\n    function finishNodeAt(node, type, pos, loc) {\n        node.type = type;\n        node.end = pos;\n        if (this.options.locations) {\n            node.loc.end = loc;\n        }\n        if (this.options.ranges) {\n            node.range[1] = pos;\n        }\n        return node;\n    }\n    pp$2.finishNode = function(node, type) {\n        return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);\n    };\n    // Finish node at given position\n    pp$2.finishNodeAt = function(node, type, pos, loc) {\n        return finishNodeAt.call(this, node, type, pos, loc);\n    };\n    pp$2.copyNode = function(node) {\n        var newNode = new Node(this, node.start, this.startLoc);\n        for(var prop in node){\n            newNode[prop] = node[prop];\n        }\n        return newNode;\n    };\n    // This file was generated by \"bin/generate-unicode-script-values.js\". Do not modify manually!\n    var scriptValuesAddedInUnicode = \"Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz\";\n    // This file contains Unicode properties extracted from the ECMAScript specification.\n    // The lists are extracted like so:\n    // $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)\n    // #table-binary-unicode-properties\n    var ecma9BinaryProperties = \"ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS\";\n    var ecma10BinaryProperties = ecma9BinaryProperties + \" Extended_Pictographic\";\n    var ecma11BinaryProperties = ecma10BinaryProperties;\n    var ecma12BinaryProperties = ecma11BinaryProperties + \" EBase EComp EMod EPres ExtPict\";\n    var ecma13BinaryProperties = ecma12BinaryProperties;\n    var ecma14BinaryProperties = ecma13BinaryProperties;\n    var unicodeBinaryProperties = {\n        9: ecma9BinaryProperties,\n        10: ecma10BinaryProperties,\n        11: ecma11BinaryProperties,\n        12: ecma12BinaryProperties,\n        13: ecma13BinaryProperties,\n        14: ecma14BinaryProperties\n    };\n    // #table-binary-unicode-properties-of-strings\n    var ecma14BinaryPropertiesOfStrings = \"Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji\";\n    var unicodeBinaryPropertiesOfStrings = {\n        9: \"\",\n        10: \"\",\n        11: \"\",\n        12: \"\",\n        13: \"\",\n        14: ecma14BinaryPropertiesOfStrings\n    };\n    // #table-unicode-general-category-values\n    var unicodeGeneralCategoryValues = \"Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu\";\n    // #table-unicode-script-values\n    var ecma9ScriptValues = \"Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb\";\n    var ecma10ScriptValues = ecma9ScriptValues + \" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd\";\n    var ecma11ScriptValues = ecma10ScriptValues + \" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho\";\n    var ecma12ScriptValues = ecma11ScriptValues + \" Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi\";\n    var ecma13ScriptValues = ecma12ScriptValues + \" Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith\";\n    var ecma14ScriptValues = ecma13ScriptValues + \" \" + scriptValuesAddedInUnicode;\n    var unicodeScriptValues = {\n        9: ecma9ScriptValues,\n        10: ecma10ScriptValues,\n        11: ecma11ScriptValues,\n        12: ecma12ScriptValues,\n        13: ecma13ScriptValues,\n        14: ecma14ScriptValues\n    };\n    var data = {};\n    function buildUnicodeData(ecmaVersion) {\n        var d = data[ecmaVersion] = {\n            binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + \" \" + unicodeGeneralCategoryValues),\n            binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),\n            nonBinary: {\n                General_Category: wordsRegexp(unicodeGeneralCategoryValues),\n                Script: wordsRegexp(unicodeScriptValues[ecmaVersion])\n            }\n        };\n        d.nonBinary.Script_Extensions = d.nonBinary.Script;\n        d.nonBinary.gc = d.nonBinary.General_Category;\n        d.nonBinary.sc = d.nonBinary.Script;\n        d.nonBinary.scx = d.nonBinary.Script_Extensions;\n    }\n    for(var i = 0, list = [\n        9,\n        10,\n        11,\n        12,\n        13,\n        14\n    ]; i < list.length; i += 1){\n        var ecmaVersion = list[i];\n        buildUnicodeData(ecmaVersion);\n    }\n    var pp$1 = Parser.prototype;\n    // Track disjunction structure to determine whether a duplicate\n    // capture group name is allowed because it is in a separate branch.\n    var BranchID = function BranchID(parent, base) {\n        // Parent disjunction branch\n        this.parent = parent;\n        // Identifies this set of sibling branches\n        this.base = base || this;\n    };\n    BranchID.prototype.separatedFrom = function separatedFrom(alt) {\n        // A branch is separate from another branch if they or any of\n        // their parents are siblings in a given disjunction\n        for(var self1 = this; self1; self1 = self1.parent){\n            for(var other = alt; other; other = other.parent){\n                if (self1.base === other.base && self1 !== other) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n    BranchID.prototype.sibling = function sibling() {\n        return new BranchID(this.parent, this.base);\n    };\n    var RegExpValidationState = function RegExpValidationState(parser) {\n        this.parser = parser;\n        this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\") + (parser.options.ecmaVersion >= 13 ? \"d\" : \"\") + (parser.options.ecmaVersion >= 15 ? \"v\" : \"\");\n        this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];\n        this.source = \"\";\n        this.flags = \"\";\n        this.start = 0;\n        this.switchU = false;\n        this.switchV = false;\n        this.switchN = false;\n        this.pos = 0;\n        this.lastIntValue = 0;\n        this.lastStringValue = \"\";\n        this.lastAssertionIsQuantifiable = false;\n        this.numCapturingParens = 0;\n        this.maxBackReference = 0;\n        this.groupNames = Object.create(null);\n        this.backReferenceNames = [];\n        this.branchID = null;\n    };\n    RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {\n        var unicodeSets = flags.indexOf(\"v\") !== -1;\n        var unicode = flags.indexOf(\"u\") !== -1;\n        this.start = start | 0;\n        this.source = pattern + \"\";\n        this.flags = flags;\n        if (unicodeSets && this.parser.options.ecmaVersion >= 15) {\n            this.switchU = true;\n            this.switchV = true;\n            this.switchN = true;\n        } else {\n            this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\n            this.switchV = false;\n            this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\n        }\n    };\n    RegExpValidationState.prototype.raise = function raise(message) {\n        this.parser.raiseRecoverable(this.start, \"Invalid regular expression: /\" + this.source + \"/: \" + message);\n    };\n    // If u flag is given, this returns the code point at the index (it combines a surrogate pair).\n    // Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).\n    RegExpValidationState.prototype.at = function at(i, forceU) {\n        if (forceU === void 0) forceU = false;\n        var s = this.source;\n        var l = s.length;\n        if (i >= l) {\n            return -1;\n        }\n        var c = s.charCodeAt(i);\n        if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n            return c;\n        }\n        var next = s.charCodeAt(i + 1);\n        return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c;\n    };\n    RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {\n        if (forceU === void 0) forceU = false;\n        var s = this.source;\n        var l = s.length;\n        if (i >= l) {\n            return l;\n        }\n        var c = s.charCodeAt(i), next;\n        if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {\n            return i + 1;\n        }\n        return i + 2;\n    };\n    RegExpValidationState.prototype.current = function current(forceU) {\n        if (forceU === void 0) forceU = false;\n        return this.at(this.pos, forceU);\n    };\n    RegExpValidationState.prototype.lookahead = function lookahead(forceU) {\n        if (forceU === void 0) forceU = false;\n        return this.at(this.nextIndex(this.pos, forceU), forceU);\n    };\n    RegExpValidationState.prototype.advance = function advance(forceU) {\n        if (forceU === void 0) forceU = false;\n        this.pos = this.nextIndex(this.pos, forceU);\n    };\n    RegExpValidationState.prototype.eat = function eat(ch, forceU) {\n        if (forceU === void 0) forceU = false;\n        if (this.current(forceU) === ch) {\n            this.advance(forceU);\n            return true;\n        }\n        return false;\n    };\n    RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {\n        if (forceU === void 0) forceU = false;\n        var pos = this.pos;\n        for(var i = 0, list = chs; i < list.length; i += 1){\n            var ch = list[i];\n            var current = this.at(pos, forceU);\n            if (current === -1 || current !== ch) {\n                return false;\n            }\n            pos = this.nextIndex(pos, forceU);\n        }\n        this.pos = pos;\n        return true;\n    };\n    /**\n   * Validate the flags part of a given RegExpLiteral.\n   *\n   * @param {RegExpValidationState} state The state to validate RegExp.\n   * @returns {void}\n   */ pp$1.validateRegExpFlags = function(state) {\n        var validFlags = state.validFlags;\n        var flags = state.flags;\n        var u = false;\n        var v = false;\n        for(var i = 0; i < flags.length; i++){\n            var flag = flags.charAt(i);\n            if (validFlags.indexOf(flag) === -1) {\n                this.raise(state.start, \"Invalid regular expression flag\");\n            }\n            if (flags.indexOf(flag, i + 1) > -1) {\n                this.raise(state.start, \"Duplicate regular expression flag\");\n            }\n            if (flag === \"u\") {\n                u = true;\n            }\n            if (flag === \"v\") {\n                v = true;\n            }\n        }\n        if (this.options.ecmaVersion >= 15 && u && v) {\n            this.raise(state.start, \"Invalid regular expression flag\");\n        }\n    };\n    function hasProp(obj) {\n        for(var _ in obj){\n            return true;\n        }\n        return false;\n    }\n    /**\n   * Validate the pattern part of a given RegExpLiteral.\n   *\n   * @param {RegExpValidationState} state The state to validate RegExp.\n   * @returns {void}\n   */ pp$1.validateRegExpPattern = function(state) {\n        this.regexp_pattern(state);\n        // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of\n        // parsing contains a |GroupName|, reparse with the goal symbol\n        // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*\n        // exception if _P_ did not conform to the grammar, if any elements of _P_\n        // were not matched by the parse, or if any Early Error conditions exist.\n        if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {\n            state.switchN = true;\n            this.regexp_pattern(state);\n        }\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern\n    pp$1.regexp_pattern = function(state) {\n        state.pos = 0;\n        state.lastIntValue = 0;\n        state.lastStringValue = \"\";\n        state.lastAssertionIsQuantifiable = false;\n        state.numCapturingParens = 0;\n        state.maxBackReference = 0;\n        state.groupNames = Object.create(null);\n        state.backReferenceNames.length = 0;\n        state.branchID = null;\n        this.regexp_disjunction(state);\n        if (state.pos !== state.source.length) {\n            // Make the same messages as V8.\n            if (state.eat(0x29 /* ) */ )) {\n                state.raise(\"Unmatched ')'\");\n            }\n            if (state.eat(0x5D /* ] */ ) || state.eat(0x7D /* } */ )) {\n                state.raise(\"Lone quantifier brackets\");\n            }\n        }\n        if (state.maxBackReference > state.numCapturingParens) {\n            state.raise(\"Invalid escape\");\n        }\n        for(var i = 0, list = state.backReferenceNames; i < list.length; i += 1){\n            var name = list[i];\n            if (!state.groupNames[name]) {\n                state.raise(\"Invalid named capture referenced\");\n            }\n        }\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction\n    pp$1.regexp_disjunction = function(state) {\n        var trackDisjunction = this.options.ecmaVersion >= 16;\n        if (trackDisjunction) {\n            state.branchID = new BranchID(state.branchID, null);\n        }\n        this.regexp_alternative(state);\n        while(state.eat(0x7C /* | */ )){\n            if (trackDisjunction) {\n                state.branchID = state.branchID.sibling();\n            }\n            this.regexp_alternative(state);\n        }\n        if (trackDisjunction) {\n            state.branchID = state.branchID.parent;\n        }\n        // Make the same message as V8.\n        if (this.regexp_eatQuantifier(state, true)) {\n            state.raise(\"Nothing to repeat\");\n        }\n        if (state.eat(0x7B /* { */ )) {\n            state.raise(\"Lone quantifier brackets\");\n        }\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative\n    pp$1.regexp_alternative = function(state) {\n        while(state.pos < state.source.length && this.regexp_eatTerm(state)){}\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term\n    pp$1.regexp_eatTerm = function(state) {\n        if (this.regexp_eatAssertion(state)) {\n            // Handle `QuantifiableAssertion Quantifier` alternative.\n            // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion\n            // is a QuantifiableAssertion.\n            if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\n                // Make the same message as V8.\n                if (state.switchU) {\n                    state.raise(\"Invalid quantifier\");\n                }\n            }\n            return true;\n        }\n        if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\n            this.regexp_eatQuantifier(state);\n            return true;\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion\n    pp$1.regexp_eatAssertion = function(state) {\n        var start = state.pos;\n        state.lastAssertionIsQuantifiable = false;\n        // ^, $\n        if (state.eat(0x5E /* ^ */ ) || state.eat(0x24 /* $ */ )) {\n            return true;\n        }\n        // \\b \\B\n        if (state.eat(0x5C /* \\ */ )) {\n            if (state.eat(0x42 /* B */ ) || state.eat(0x62 /* b */ )) {\n                return true;\n            }\n            state.pos = start;\n        }\n        // Lookahead / Lookbehind\n        if (state.eat(0x28 /* ( */ ) && state.eat(0x3F /* ? */ )) {\n            var lookbehind = false;\n            if (this.options.ecmaVersion >= 9) {\n                lookbehind = state.eat(0x3C /* < */ );\n            }\n            if (state.eat(0x3D /* = */ ) || state.eat(0x21 /* ! */ )) {\n                this.regexp_disjunction(state);\n                if (!state.eat(0x29 /* ) */ )) {\n                    state.raise(\"Unterminated group\");\n                }\n                state.lastAssertionIsQuantifiable = !lookbehind;\n                return true;\n            }\n        }\n        state.pos = start;\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier\n    pp$1.regexp_eatQuantifier = function(state, noError) {\n        if (noError === void 0) noError = false;\n        if (this.regexp_eatQuantifierPrefix(state, noError)) {\n            state.eat(0x3F /* ? */ );\n            return true;\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix\n    pp$1.regexp_eatQuantifierPrefix = function(state, noError) {\n        return state.eat(0x2A /* * */ ) || state.eat(0x2B /* + */ ) || state.eat(0x3F /* ? */ ) || this.regexp_eatBracedQuantifier(state, noError);\n    };\n    pp$1.regexp_eatBracedQuantifier = function(state, noError) {\n        var start = state.pos;\n        if (state.eat(0x7B /* { */ )) {\n            var min = 0, max = -1;\n            if (this.regexp_eatDecimalDigits(state)) {\n                min = state.lastIntValue;\n                if (state.eat(0x2C /* , */ ) && this.regexp_eatDecimalDigits(state)) {\n                    max = state.lastIntValue;\n                }\n                if (state.eat(0x7D /* } */ )) {\n                    // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term\n                    if (max !== -1 && max < min && !noError) {\n                        state.raise(\"numbers out of order in {} quantifier\");\n                    }\n                    return true;\n                }\n            }\n            if (state.switchU && !noError) {\n                state.raise(\"Incomplete quantifier\");\n            }\n            state.pos = start;\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom\n    pp$1.regexp_eatAtom = function(state) {\n        return this.regexp_eatPatternCharacters(state) || state.eat(0x2E /* . */ ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);\n    };\n    pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {\n        var start = state.pos;\n        if (state.eat(0x5C /* \\ */ )) {\n            if (this.regexp_eatAtomEscape(state)) {\n                return true;\n            }\n            state.pos = start;\n        }\n        return false;\n    };\n    pp$1.regexp_eatUncapturingGroup = function(state) {\n        var start = state.pos;\n        if (state.eat(0x28 /* ( */ )) {\n            if (state.eat(0x3F /* ? */ )) {\n                if (this.options.ecmaVersion >= 16) {\n                    var addModifiers = this.regexp_eatModifiers(state);\n                    var hasHyphen = state.eat(0x2D /* - */ );\n                    if (addModifiers || hasHyphen) {\n                        for(var i = 0; i < addModifiers.length; i++){\n                            var modifier = addModifiers.charAt(i);\n                            if (addModifiers.indexOf(modifier, i + 1) > -1) {\n                                state.raise(\"Duplicate regular expression modifiers\");\n                            }\n                        }\n                        if (hasHyphen) {\n                            var removeModifiers = this.regexp_eatModifiers(state);\n                            if (!addModifiers && !removeModifiers && state.current() === 0x3A /* : */ ) {\n                                state.raise(\"Invalid regular expression modifiers\");\n                            }\n                            for(var i$1 = 0; i$1 < removeModifiers.length; i$1++){\n                                var modifier$1 = removeModifiers.charAt(i$1);\n                                if (removeModifiers.indexOf(modifier$1, i$1 + 1) > -1 || addModifiers.indexOf(modifier$1) > -1) {\n                                    state.raise(\"Duplicate regular expression modifiers\");\n                                }\n                            }\n                        }\n                    }\n                }\n                if (state.eat(0x3A /* : */ )) {\n                    this.regexp_disjunction(state);\n                    if (state.eat(0x29 /* ) */ )) {\n                        return true;\n                    }\n                    state.raise(\"Unterminated group\");\n                }\n            }\n            state.pos = start;\n        }\n        return false;\n    };\n    pp$1.regexp_eatCapturingGroup = function(state) {\n        if (state.eat(0x28 /* ( */ )) {\n            if (this.options.ecmaVersion >= 9) {\n                this.regexp_groupSpecifier(state);\n            } else if (state.current() === 0x3F /* ? */ ) {\n                state.raise(\"Invalid group\");\n            }\n            this.regexp_disjunction(state);\n            if (state.eat(0x29 /* ) */ )) {\n                state.numCapturingParens += 1;\n                return true;\n            }\n            state.raise(\"Unterminated group\");\n        }\n        return false;\n    };\n    // RegularExpressionModifiers ::\n    //   [empty]\n    //   RegularExpressionModifiers RegularExpressionModifier\n    pp$1.regexp_eatModifiers = function(state) {\n        var modifiers = \"\";\n        var ch = 0;\n        while((ch = state.current()) !== -1 && isRegularExpressionModifier(ch)){\n            modifiers += codePointToString(ch);\n            state.advance();\n        }\n        return modifiers;\n    };\n    // RegularExpressionModifier :: one of\n    //   `i` `m` `s`\n    function isRegularExpressionModifier(ch) {\n        return ch === 0x69 /* i */  || ch === 0x6d /* m */  || ch === 0x73 /* s */ ;\n    }\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom\n    pp$1.regexp_eatExtendedAtom = function(state) {\n        return state.eat(0x2E /* . */ ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier\n    pp$1.regexp_eatInvalidBracedQuantifier = function(state) {\n        if (this.regexp_eatBracedQuantifier(state, true)) {\n            state.raise(\"Nothing to repeat\");\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter\n    pp$1.regexp_eatSyntaxCharacter = function(state) {\n        var ch = state.current();\n        if (isSyntaxCharacter(ch)) {\n            state.lastIntValue = ch;\n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    function isSyntaxCharacter(ch) {\n        return ch === 0x24 /* $ */  || ch >= 0x28 /* ( */  && ch <= 0x2B /* + */  || ch === 0x2E /* . */  || ch === 0x3F /* ? */  || ch >= 0x5B /* [ */  && ch <= 0x5E /* ^ */  || ch >= 0x7B /* { */  && ch <= 0x7D /* } */ ;\n    }\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter\n    // But eat eager.\n    pp$1.regexp_eatPatternCharacters = function(state) {\n        var start = state.pos;\n        var ch = 0;\n        while((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)){\n            state.advance();\n        }\n        return state.pos !== start;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter\n    pp$1.regexp_eatExtendedPatternCharacter = function(state) {\n        var ch = state.current();\n        if (ch !== -1 && ch !== 0x24 /* $ */  && !(ch >= 0x28 /* ( */  && ch <= 0x2B /* + */ ) && ch !== 0x2E /* . */  && ch !== 0x3F /* ? */  && ch !== 0x5B /* [ */  && ch !== 0x5E /* ^ */  && ch !== 0x7C /* | */ ) {\n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    // GroupSpecifier ::\n    //   [empty]\n    //   `?` GroupName\n    pp$1.regexp_groupSpecifier = function(state) {\n        if (state.eat(0x3F /* ? */ )) {\n            if (!this.regexp_eatGroupName(state)) {\n                state.raise(\"Invalid group\");\n            }\n            var trackDisjunction = this.options.ecmaVersion >= 16;\n            var known = state.groupNames[state.lastStringValue];\n            if (known) {\n                if (trackDisjunction) {\n                    for(var i = 0, list = known; i < list.length; i += 1){\n                        var altID = list[i];\n                        if (!altID.separatedFrom(state.branchID)) {\n                            state.raise(\"Duplicate capture group name\");\n                        }\n                    }\n                } else {\n                    state.raise(\"Duplicate capture group name\");\n                }\n            }\n            if (trackDisjunction) {\n                (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);\n            } else {\n                state.groupNames[state.lastStringValue] = true;\n            }\n        }\n    };\n    // GroupName ::\n    //   `<` RegExpIdentifierName `>`\n    // Note: this updates `state.lastStringValue` property with the eaten name.\n    pp$1.regexp_eatGroupName = function(state) {\n        state.lastStringValue = \"\";\n        if (state.eat(0x3C /* < */ )) {\n            if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */ )) {\n                return true;\n            }\n            state.raise(\"Invalid capture group name\");\n        }\n        return false;\n    };\n    // RegExpIdentifierName ::\n    //   RegExpIdentifierStart\n    //   RegExpIdentifierName RegExpIdentifierPart\n    // Note: this updates `state.lastStringValue` property with the eaten name.\n    pp$1.regexp_eatRegExpIdentifierName = function(state) {\n        state.lastStringValue = \"\";\n        if (this.regexp_eatRegExpIdentifierStart(state)) {\n            state.lastStringValue += codePointToString(state.lastIntValue);\n            while(this.regexp_eatRegExpIdentifierPart(state)){\n                state.lastStringValue += codePointToString(state.lastIntValue);\n            }\n            return true;\n        }\n        return false;\n    };\n    // RegExpIdentifierStart ::\n    //   UnicodeIDStart\n    //   `$`\n    //   `_`\n    //   `\\` RegExpUnicodeEscapeSequence[+U]\n    pp$1.regexp_eatRegExpIdentifierStart = function(state) {\n        var start = state.pos;\n        var forceU = this.options.ecmaVersion >= 11;\n        var ch = state.current(forceU);\n        state.advance(forceU);\n        if (ch === 0x5C /* \\ */  && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {\n            ch = state.lastIntValue;\n        }\n        if (isRegExpIdentifierStart(ch)) {\n            state.lastIntValue = ch;\n            return true;\n        }\n        state.pos = start;\n        return false;\n    };\n    function isRegExpIdentifierStart(ch) {\n        return isIdentifierStart(ch, true) || ch === 0x24 /* $ */  || ch === 0x5F /* _ */ ;\n    }\n    // RegExpIdentifierPart ::\n    //   UnicodeIDContinue\n    //   `$`\n    //   `_`\n    //   `\\` RegExpUnicodeEscapeSequence[+U]\n    //   <ZWNJ>\n    //   <ZWJ>\n    pp$1.regexp_eatRegExpIdentifierPart = function(state) {\n        var start = state.pos;\n        var forceU = this.options.ecmaVersion >= 11;\n        var ch = state.current(forceU);\n        state.advance(forceU);\n        if (ch === 0x5C /* \\ */  && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {\n            ch = state.lastIntValue;\n        }\n        if (isRegExpIdentifierPart(ch)) {\n            state.lastIntValue = ch;\n            return true;\n        }\n        state.pos = start;\n        return false;\n    };\n    function isRegExpIdentifierPart(ch) {\n        return isIdentifierChar(ch, true) || ch === 0x24 /* $ */  || ch === 0x5F /* _ */  || ch === 0x200C /* <ZWNJ> */  || ch === 0x200D /* <ZWJ> */ ;\n    }\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape\n    pp$1.regexp_eatAtomEscape = function(state) {\n        if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {\n            return true;\n        }\n        if (state.switchU) {\n            // Make the same message as V8.\n            if (state.current() === 0x63 /* c */ ) {\n                state.raise(\"Invalid unicode escape\");\n            }\n            state.raise(\"Invalid escape\");\n        }\n        return false;\n    };\n    pp$1.regexp_eatBackReference = function(state) {\n        var start = state.pos;\n        if (this.regexp_eatDecimalEscape(state)) {\n            var n = state.lastIntValue;\n            if (state.switchU) {\n                // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape\n                if (n > state.maxBackReference) {\n                    state.maxBackReference = n;\n                }\n                return true;\n            }\n            if (n <= state.numCapturingParens) {\n                return true;\n            }\n            state.pos = start;\n        }\n        return false;\n    };\n    pp$1.regexp_eatKGroupName = function(state) {\n        if (state.eat(0x6B /* k */ )) {\n            if (this.regexp_eatGroupName(state)) {\n                state.backReferenceNames.push(state.lastStringValue);\n                return true;\n            }\n            state.raise(\"Invalid named reference\");\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape\n    pp$1.regexp_eatCharacterEscape = function(state) {\n        return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);\n    };\n    pp$1.regexp_eatCControlLetter = function(state) {\n        var start = state.pos;\n        if (state.eat(0x63 /* c */ )) {\n            if (this.regexp_eatControlLetter(state)) {\n                return true;\n            }\n            state.pos = start;\n        }\n        return false;\n    };\n    pp$1.regexp_eatZero = function(state) {\n        if (state.current() === 0x30 /* 0 */  && !isDecimalDigit(state.lookahead())) {\n            state.lastIntValue = 0;\n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape\n    pp$1.regexp_eatControlEscape = function(state) {\n        var ch = state.current();\n        if (ch === 0x74 /* t */ ) {\n            state.lastIntValue = 0x09; /* \\t */ \n            state.advance();\n            return true;\n        }\n        if (ch === 0x6E /* n */ ) {\n            state.lastIntValue = 0x0A; /* \\n */ \n            state.advance();\n            return true;\n        }\n        if (ch === 0x76 /* v */ ) {\n            state.lastIntValue = 0x0B; /* \\v */ \n            state.advance();\n            return true;\n        }\n        if (ch === 0x66 /* f */ ) {\n            state.lastIntValue = 0x0C; /* \\f */ \n            state.advance();\n            return true;\n        }\n        if (ch === 0x72 /* r */ ) {\n            state.lastIntValue = 0x0D; /* \\r */ \n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter\n    pp$1.regexp_eatControlLetter = function(state) {\n        var ch = state.current();\n        if (isControlLetter(ch)) {\n            state.lastIntValue = ch % 0x20;\n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    function isControlLetter(ch) {\n        return ch >= 0x41 /* A */  && ch <= 0x5A /* Z */  || ch >= 0x61 /* a */  && ch <= 0x7A /* z */ ;\n    }\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence\n    pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {\n        if (forceU === void 0) forceU = false;\n        var start = state.pos;\n        var switchU = forceU || state.switchU;\n        if (state.eat(0x75 /* u */ )) {\n            if (this.regexp_eatFixedHexDigits(state, 4)) {\n                var lead = state.lastIntValue;\n                if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {\n                    var leadSurrogateEnd = state.pos;\n                    if (state.eat(0x5C /* \\ */ ) && state.eat(0x75 /* u */ ) && this.regexp_eatFixedHexDigits(state, 4)) {\n                        var trail = state.lastIntValue;\n                        if (trail >= 0xDC00 && trail <= 0xDFFF) {\n                            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n                            return true;\n                        }\n                    }\n                    state.pos = leadSurrogateEnd;\n                    state.lastIntValue = lead;\n                }\n                return true;\n            }\n            if (switchU && state.eat(0x7B /* { */ ) && this.regexp_eatHexDigits(state) && state.eat(0x7D /* } */ ) && isValidUnicode(state.lastIntValue)) {\n                return true;\n            }\n            if (switchU) {\n                state.raise(\"Invalid unicode escape\");\n            }\n            state.pos = start;\n        }\n        return false;\n    };\n    function isValidUnicode(ch) {\n        return ch >= 0 && ch <= 0x10FFFF;\n    }\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape\n    pp$1.regexp_eatIdentityEscape = function(state) {\n        if (state.switchU) {\n            if (this.regexp_eatSyntaxCharacter(state)) {\n                return true;\n            }\n            if (state.eat(0x2F /* / */ )) {\n                state.lastIntValue = 0x2F; /* / */ \n                return true;\n            }\n            return false;\n        }\n        var ch = state.current();\n        if (ch !== 0x63 /* c */  && (!state.switchN || ch !== 0x6B /* k */ )) {\n            state.lastIntValue = ch;\n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape\n    pp$1.regexp_eatDecimalEscape = function(state) {\n        state.lastIntValue = 0;\n        var ch = state.current();\n        if (ch >= 0x31 /* 1 */  && ch <= 0x39 /* 9 */ ) {\n            do {\n                state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */ );\n                state.advance();\n            }while ((ch = state.current()) >= 0x30 /* 0 */  && ch <= 0x39 /* 9 */ );\n            return true;\n        }\n        return false;\n    };\n    // Return values used by character set parsing methods, needed to\n    // forbid negation of sets that can match strings.\n    var CharSetNone = 0; // Nothing parsed\n    var CharSetOk = 1; // Construct parsed, cannot contain strings\n    var CharSetString = 2; // Construct parsed, can contain strings\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape\n    pp$1.regexp_eatCharacterClassEscape = function(state) {\n        var ch = state.current();\n        if (isCharacterClassEscape(ch)) {\n            state.lastIntValue = -1;\n            state.advance();\n            return CharSetOk;\n        }\n        var negate = false;\n        if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 0x50 /* P */ ) || ch === 0x70 /* p */ )) {\n            state.lastIntValue = -1;\n            state.advance();\n            var result;\n            if (state.eat(0x7B /* { */ ) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(0x7D /* } */ )) {\n                if (negate && result === CharSetString) {\n                    state.raise(\"Invalid property name\");\n                }\n                return result;\n            }\n            state.raise(\"Invalid property name\");\n        }\n        return CharSetNone;\n    };\n    function isCharacterClassEscape(ch) {\n        return ch === 0x64 /* d */  || ch === 0x44 /* D */  || ch === 0x73 /* s */  || ch === 0x53 /* S */  || ch === 0x77 /* w */  || ch === 0x57 /* W */ ;\n    }\n    // UnicodePropertyValueExpression ::\n    //   UnicodePropertyName `=` UnicodePropertyValue\n    //   LoneUnicodePropertyNameOrValue\n    pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {\n        var start = state.pos;\n        // UnicodePropertyName `=` UnicodePropertyValue\n        if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */ )) {\n            var name = state.lastStringValue;\n            if (this.regexp_eatUnicodePropertyValue(state)) {\n                var value = state.lastStringValue;\n                this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\n                return CharSetOk;\n            }\n        }\n        state.pos = start;\n        // LoneUnicodePropertyNameOrValue\n        if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\n            var nameOrValue = state.lastStringValue;\n            return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);\n        }\n        return CharSetNone;\n    };\n    pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {\n        if (!hasOwn(state.unicodeProperties.nonBinary, name)) {\n            state.raise(\"Invalid property name\");\n        }\n        if (!state.unicodeProperties.nonBinary[name].test(value)) {\n            state.raise(\"Invalid property value\");\n        }\n    };\n    pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {\n        if (state.unicodeProperties.binary.test(nameOrValue)) {\n            return CharSetOk;\n        }\n        if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {\n            return CharSetString;\n        }\n        state.raise(\"Invalid property name\");\n    };\n    // UnicodePropertyName ::\n    //   UnicodePropertyNameCharacters\n    pp$1.regexp_eatUnicodePropertyName = function(state) {\n        var ch = 0;\n        state.lastStringValue = \"\";\n        while(isUnicodePropertyNameCharacter(ch = state.current())){\n            state.lastStringValue += codePointToString(ch);\n            state.advance();\n        }\n        return state.lastStringValue !== \"\";\n    };\n    function isUnicodePropertyNameCharacter(ch) {\n        return isControlLetter(ch) || ch === 0x5F /* _ */ ;\n    }\n    // UnicodePropertyValue ::\n    //   UnicodePropertyValueCharacters\n    pp$1.regexp_eatUnicodePropertyValue = function(state) {\n        var ch = 0;\n        state.lastStringValue = \"\";\n        while(isUnicodePropertyValueCharacter(ch = state.current())){\n            state.lastStringValue += codePointToString(ch);\n            state.advance();\n        }\n        return state.lastStringValue !== \"\";\n    };\n    function isUnicodePropertyValueCharacter(ch) {\n        return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);\n    }\n    // LoneUnicodePropertyNameOrValue ::\n    //   UnicodePropertyValueCharacters\n    pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {\n        return this.regexp_eatUnicodePropertyValue(state);\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass\n    pp$1.regexp_eatCharacterClass = function(state) {\n        if (state.eat(0x5B /* [ */ )) {\n            var negate = state.eat(0x5E /* ^ */ );\n            var result = this.regexp_classContents(state);\n            if (!state.eat(0x5D /* ] */ )) {\n                state.raise(\"Unterminated character class\");\n            }\n            if (negate && result === CharSetString) {\n                state.raise(\"Negated character class may contain strings\");\n            }\n            return true;\n        }\n        return false;\n    };\n    // https://tc39.es/ecma262/#prod-ClassContents\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges\n    pp$1.regexp_classContents = function(state) {\n        if (state.current() === 0x5D /* ] */ ) {\n            return CharSetOk;\n        }\n        if (state.switchV) {\n            return this.regexp_classSetExpression(state);\n        }\n        this.regexp_nonEmptyClassRanges(state);\n        return CharSetOk;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash\n    pp$1.regexp_nonEmptyClassRanges = function(state) {\n        while(this.regexp_eatClassAtom(state)){\n            var left = state.lastIntValue;\n            if (state.eat(0x2D /* - */ ) && this.regexp_eatClassAtom(state)) {\n                var right = state.lastIntValue;\n                if (state.switchU && (left === -1 || right === -1)) {\n                    state.raise(\"Invalid character class\");\n                }\n                if (left !== -1 && right !== -1 && left > right) {\n                    state.raise(\"Range out of order in character class\");\n                }\n            }\n        }\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash\n    pp$1.regexp_eatClassAtom = function(state) {\n        var start = state.pos;\n        if (state.eat(0x5C /* \\ */ )) {\n            if (this.regexp_eatClassEscape(state)) {\n                return true;\n            }\n            if (state.switchU) {\n                // Make the same message as V8.\n                var ch$1 = state.current();\n                if (ch$1 === 0x63 /* c */  || isOctalDigit(ch$1)) {\n                    state.raise(\"Invalid class escape\");\n                }\n                state.raise(\"Invalid escape\");\n            }\n            state.pos = start;\n        }\n        var ch = state.current();\n        if (ch !== 0x5D /* ] */ ) {\n            state.lastIntValue = ch;\n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape\n    pp$1.regexp_eatClassEscape = function(state) {\n        var start = state.pos;\n        if (state.eat(0x62 /* b */ )) {\n            state.lastIntValue = 0x08; /* <BS> */ \n            return true;\n        }\n        if (state.switchU && state.eat(0x2D /* - */ )) {\n            state.lastIntValue = 0x2D; /* - */ \n            return true;\n        }\n        if (!state.switchU && state.eat(0x63 /* c */ )) {\n            if (this.regexp_eatClassControlLetter(state)) {\n                return true;\n            }\n            state.pos = start;\n        }\n        return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);\n    };\n    // https://tc39.es/ecma262/#prod-ClassSetExpression\n    // https://tc39.es/ecma262/#prod-ClassUnion\n    // https://tc39.es/ecma262/#prod-ClassIntersection\n    // https://tc39.es/ecma262/#prod-ClassSubtraction\n    pp$1.regexp_classSetExpression = function(state) {\n        var result = CharSetOk, subResult;\n        if (this.regexp_eatClassSetRange(state)) ;\n        else if (subResult = this.regexp_eatClassSetOperand(state)) {\n            if (subResult === CharSetString) {\n                result = CharSetString;\n            }\n            // https://tc39.es/ecma262/#prod-ClassIntersection\n            var start = state.pos;\n            while(state.eatChars([\n                0x26,\n                0x26\n            ])){\n                if (state.current() !== 0x26 /* & */  && (subResult = this.regexp_eatClassSetOperand(state))) {\n                    if (subResult !== CharSetString) {\n                        result = CharSetOk;\n                    }\n                    continue;\n                }\n                state.raise(\"Invalid character in character class\");\n            }\n            if (start !== state.pos) {\n                return result;\n            }\n            // https://tc39.es/ecma262/#prod-ClassSubtraction\n            while(state.eatChars([\n                0x2D,\n                0x2D\n            ])){\n                if (this.regexp_eatClassSetOperand(state)) {\n                    continue;\n                }\n                state.raise(\"Invalid character in character class\");\n            }\n            if (start !== state.pos) {\n                return result;\n            }\n        } else {\n            state.raise(\"Invalid character in character class\");\n        }\n        // https://tc39.es/ecma262/#prod-ClassUnion\n        for(;;){\n            if (this.regexp_eatClassSetRange(state)) {\n                continue;\n            }\n            subResult = this.regexp_eatClassSetOperand(state);\n            if (!subResult) {\n                return result;\n            }\n            if (subResult === CharSetString) {\n                result = CharSetString;\n            }\n        }\n    };\n    // https://tc39.es/ecma262/#prod-ClassSetRange\n    pp$1.regexp_eatClassSetRange = function(state) {\n        var start = state.pos;\n        if (this.regexp_eatClassSetCharacter(state)) {\n            var left = state.lastIntValue;\n            if (state.eat(0x2D /* - */ ) && this.regexp_eatClassSetCharacter(state)) {\n                var right = state.lastIntValue;\n                if (left !== -1 && right !== -1 && left > right) {\n                    state.raise(\"Range out of order in character class\");\n                }\n                return true;\n            }\n            state.pos = start;\n        }\n        return false;\n    };\n    // https://tc39.es/ecma262/#prod-ClassSetOperand\n    pp$1.regexp_eatClassSetOperand = function(state) {\n        if (this.regexp_eatClassSetCharacter(state)) {\n            return CharSetOk;\n        }\n        return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);\n    };\n    // https://tc39.es/ecma262/#prod-NestedClass\n    pp$1.regexp_eatNestedClass = function(state) {\n        var start = state.pos;\n        if (state.eat(0x5B /* [ */ )) {\n            var negate = state.eat(0x5E /* ^ */ );\n            var result = this.regexp_classContents(state);\n            if (state.eat(0x5D /* ] */ )) {\n                if (negate && result === CharSetString) {\n                    state.raise(\"Negated character class may contain strings\");\n                }\n                return result;\n            }\n            state.pos = start;\n        }\n        if (state.eat(0x5C /* \\ */ )) {\n            var result$1 = this.regexp_eatCharacterClassEscape(state);\n            if (result$1) {\n                return result$1;\n            }\n            state.pos = start;\n        }\n        return null;\n    };\n    // https://tc39.es/ecma262/#prod-ClassStringDisjunction\n    pp$1.regexp_eatClassStringDisjunction = function(state) {\n        var start = state.pos;\n        if (state.eatChars([\n            0x5C,\n            0x71\n        ])) {\n            if (state.eat(0x7B /* { */ )) {\n                var result = this.regexp_classStringDisjunctionContents(state);\n                if (state.eat(0x7D /* } */ )) {\n                    return result;\n                }\n            } else {\n                // Make the same message as V8.\n                state.raise(\"Invalid escape\");\n            }\n            state.pos = start;\n        }\n        return null;\n    };\n    // https://tc39.es/ecma262/#prod-ClassStringDisjunctionContents\n    pp$1.regexp_classStringDisjunctionContents = function(state) {\n        var result = this.regexp_classString(state);\n        while(state.eat(0x7C /* | */ )){\n            if (this.regexp_classString(state) === CharSetString) {\n                result = CharSetString;\n            }\n        }\n        return result;\n    };\n    // https://tc39.es/ecma262/#prod-ClassString\n    // https://tc39.es/ecma262/#prod-NonEmptyClassString\n    pp$1.regexp_classString = function(state) {\n        var count = 0;\n        while(this.regexp_eatClassSetCharacter(state)){\n            count++;\n        }\n        return count === 1 ? CharSetOk : CharSetString;\n    };\n    // https://tc39.es/ecma262/#prod-ClassSetCharacter\n    pp$1.regexp_eatClassSetCharacter = function(state) {\n        var start = state.pos;\n        if (state.eat(0x5C /* \\ */ )) {\n            if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {\n                return true;\n            }\n            if (state.eat(0x62 /* b */ )) {\n                state.lastIntValue = 0x08; /* <BS> */ \n                return true;\n            }\n            state.pos = start;\n            return false;\n        }\n        var ch = state.current();\n        if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) {\n            return false;\n        }\n        if (isClassSetSyntaxCharacter(ch)) {\n            return false;\n        }\n        state.advance();\n        state.lastIntValue = ch;\n        return true;\n    };\n    // https://tc39.es/ecma262/#prod-ClassSetReservedDoublePunctuator\n    function isClassSetReservedDoublePunctuatorCharacter(ch) {\n        return ch === 0x21 /* ! */  || ch >= 0x23 /* # */  && ch <= 0x26 /* & */  || ch >= 0x2A /* * */  && ch <= 0x2C /* , */  || ch === 0x2E /* . */  || ch >= 0x3A /* : */  && ch <= 0x40 /* @ */  || ch === 0x5E /* ^ */  || ch === 0x60 /* ` */  || ch === 0x7E /* ~ */ ;\n    }\n    // https://tc39.es/ecma262/#prod-ClassSetSyntaxCharacter\n    function isClassSetSyntaxCharacter(ch) {\n        return ch === 0x28 /* ( */  || ch === 0x29 /* ) */  || ch === 0x2D /* - */  || ch === 0x2F /* / */  || ch >= 0x5B /* [ */  && ch <= 0x5D /* ] */  || ch >= 0x7B /* { */  && ch <= 0x7D /* } */ ;\n    }\n    // https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator\n    pp$1.regexp_eatClassSetReservedPunctuator = function(state) {\n        var ch = state.current();\n        if (isClassSetReservedPunctuator(ch)) {\n            state.lastIntValue = ch;\n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    // https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator\n    function isClassSetReservedPunctuator(ch) {\n        return ch === 0x21 /* ! */  || ch === 0x23 /* # */  || ch === 0x25 /* % */  || ch === 0x26 /* & */  || ch === 0x2C /* , */  || ch === 0x2D /* - */  || ch >= 0x3A /* : */  && ch <= 0x3E /* > */  || ch === 0x40 /* @ */  || ch === 0x60 /* ` */  || ch === 0x7E /* ~ */ ;\n    }\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter\n    pp$1.regexp_eatClassControlLetter = function(state) {\n        var ch = state.current();\n        if (isDecimalDigit(ch) || ch === 0x5F /* _ */ ) {\n            state.lastIntValue = ch % 0x20;\n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\n    pp$1.regexp_eatHexEscapeSequence = function(state) {\n        var start = state.pos;\n        if (state.eat(0x78 /* x */ )) {\n            if (this.regexp_eatFixedHexDigits(state, 2)) {\n                return true;\n            }\n            if (state.switchU) {\n                state.raise(\"Invalid escape\");\n            }\n            state.pos = start;\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits\n    pp$1.regexp_eatDecimalDigits = function(state) {\n        var start = state.pos;\n        var ch = 0;\n        state.lastIntValue = 0;\n        while(isDecimalDigit(ch = state.current())){\n            state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */ );\n            state.advance();\n        }\n        return state.pos !== start;\n    };\n    function isDecimalDigit(ch) {\n        return ch >= 0x30 /* 0 */  && ch <= 0x39 /* 9 */ ;\n    }\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits\n    pp$1.regexp_eatHexDigits = function(state) {\n        var start = state.pos;\n        var ch = 0;\n        state.lastIntValue = 0;\n        while(isHexDigit(ch = state.current())){\n            state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n            state.advance();\n        }\n        return state.pos !== start;\n    };\n    function isHexDigit(ch) {\n        return ch >= 0x30 /* 0 */  && ch <= 0x39 /* 9 */  || ch >= 0x41 /* A */  && ch <= 0x46 /* F */  || ch >= 0x61 /* a */  && ch <= 0x66 /* f */ ;\n    }\n    function hexToInt(ch) {\n        if (ch >= 0x41 /* A */  && ch <= 0x46 /* F */ ) {\n            return 10 + (ch - 0x41 /* A */ );\n        }\n        if (ch >= 0x61 /* a */  && ch <= 0x66 /* f */ ) {\n            return 10 + (ch - 0x61 /* a */ );\n        }\n        return ch - 0x30 /* 0 */ ;\n    }\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence\n    // Allows only 0-377(octal) i.e. 0-255(decimal).\n    pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {\n        if (this.regexp_eatOctalDigit(state)) {\n            var n1 = state.lastIntValue;\n            if (this.regexp_eatOctalDigit(state)) {\n                var n2 = state.lastIntValue;\n                if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\n                    state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\n                } else {\n                    state.lastIntValue = n1 * 8 + n2;\n                }\n            } else {\n                state.lastIntValue = n1;\n            }\n            return true;\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit\n    pp$1.regexp_eatOctalDigit = function(state) {\n        var ch = state.current();\n        if (isOctalDigit(ch)) {\n            state.lastIntValue = ch - 0x30; /* 0 */ \n            state.advance();\n            return true;\n        }\n        state.lastIntValue = 0;\n        return false;\n    };\n    function isOctalDigit(ch) {\n        return ch >= 0x30 /* 0 */  && ch <= 0x37 /* 7 */ ;\n    }\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit\n    // And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\n    pp$1.regexp_eatFixedHexDigits = function(state, length) {\n        var start = state.pos;\n        state.lastIntValue = 0;\n        for(var i = 0; i < length; ++i){\n            var ch = state.current();\n            if (!isHexDigit(ch)) {\n                state.pos = start;\n                return false;\n            }\n            state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n            state.advance();\n        }\n        return true;\n    };\n    // Object type used to represent tokens. Note that normally, tokens\n    // simply exist as properties on the parser object. This is only\n    // used for the onToken callback and the external tokenizer.\n    var Token = function Token(p) {\n        this.type = p.type;\n        this.value = p.value;\n        this.start = p.start;\n        this.end = p.end;\n        if (p.options.locations) {\n            this.loc = new SourceLocation(p, p.startLoc, p.endLoc);\n        }\n        if (p.options.ranges) {\n            this.range = [\n                p.start,\n                p.end\n            ];\n        }\n    };\n    // ## Tokenizer\n    var pp = Parser.prototype;\n    // Move to the next token\n    pp.next = function(ignoreEscapeSequenceInKeyword) {\n        if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {\n            this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + this.type.keyword);\n        }\n        if (this.options.onToken) {\n            this.options.onToken(new Token(this));\n        }\n        this.lastTokEnd = this.end;\n        this.lastTokStart = this.start;\n        this.lastTokEndLoc = this.endLoc;\n        this.lastTokStartLoc = this.startLoc;\n        this.nextToken();\n    };\n    pp.getToken = function() {\n        this.next();\n        return new Token(this);\n    };\n    // If we're in an ES6 environment, make parsers iterable\n    if (typeof Symbol !== \"undefined\") {\n        pp[Symbol.iterator] = function() {\n            var this$1$1 = this;\n            return {\n                next: function() {\n                    var token = this$1$1.getToken();\n                    return {\n                        done: token.type === types$1.eof,\n                        value: token\n                    };\n                }\n            };\n        };\n    }\n    // Toggle strict mode. Re-reads the next number or string to please\n    // pedantic tests (`\"use strict\"; 010;` should fail).\n    // Read a single token, updating the parser object's token-related\n    // properties.\n    pp.nextToken = function() {\n        var curContext = this.curContext();\n        if (!curContext || !curContext.preserveSpace) {\n            this.skipSpace();\n        }\n        this.start = this.pos;\n        if (this.options.locations) {\n            this.startLoc = this.curPosition();\n        }\n        if (this.pos >= this.input.length) {\n            return this.finishToken(types$1.eof);\n        }\n        if (curContext.override) {\n            return curContext.override(this);\n        } else {\n            this.readToken(this.fullCharCodeAtPos());\n        }\n    };\n    pp.readToken = function(code) {\n        // Identifier or keyword. '\\uXXXX' sequences are allowed in\n        // identifiers, so '\\' also dispatches to that.\n        if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */ ) {\n            return this.readWord();\n        }\n        return this.getTokenFromCode(code);\n    };\n    pp.fullCharCodeAtPos = function() {\n        var code = this.input.charCodeAt(this.pos);\n        if (code <= 0xd7ff || code >= 0xdc00) {\n            return code;\n        }\n        var next = this.input.charCodeAt(this.pos + 1);\n        return next <= 0xdbff || next >= 0xe000 ? code : (code << 10) + next - 0x35fdc00;\n    };\n    pp.skipBlockComment = function() {\n        var startLoc = this.options.onComment && this.curPosition();\n        var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\n        if (end === -1) {\n            this.raise(this.pos - 2, \"Unterminated comment\");\n        }\n        this.pos = end + 2;\n        if (this.options.locations) {\n            for(var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1;){\n                ++this.curLine;\n                pos = this.lineStart = nextBreak;\n            }\n        }\n        if (this.options.onComment) {\n            this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());\n        }\n    };\n    pp.skipLineComment = function(startSkip) {\n        var start = this.pos;\n        var startLoc = this.options.onComment && this.curPosition();\n        var ch = this.input.charCodeAt(this.pos += startSkip);\n        while(this.pos < this.input.length && !isNewLine(ch)){\n            ch = this.input.charCodeAt(++this.pos);\n        }\n        if (this.options.onComment) {\n            this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());\n        }\n    };\n    // Called at the start of the parse and after every token. Skips\n    // whitespace and comments, and.\n    pp.skipSpace = function() {\n        loop: while(this.pos < this.input.length){\n            var ch = this.input.charCodeAt(this.pos);\n            switch(ch){\n                case 32:\n                case 160:\n                    ++this.pos;\n                    break;\n                case 13:\n                    if (this.input.charCodeAt(this.pos + 1) === 10) {\n                        ++this.pos;\n                    }\n                case 10:\n                case 8232:\n                case 8233:\n                    ++this.pos;\n                    if (this.options.locations) {\n                        ++this.curLine;\n                        this.lineStart = this.pos;\n                    }\n                    break;\n                case 47:\n                    switch(this.input.charCodeAt(this.pos + 1)){\n                        case 42:\n                            this.skipBlockComment();\n                            break;\n                        case 47:\n                            this.skipLineComment(2);\n                            break;\n                        default:\n                            break loop;\n                    }\n                    break;\n                default:\n                    if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n                        ++this.pos;\n                    } else {\n                        break loop;\n                    }\n            }\n        }\n    };\n    // Called at the end of every token. Sets `end`, `val`, and\n    // maintains `context` and `exprAllowed`, and skips the space after\n    // the token, so that the next one's `start` will point at the\n    // right position.\n    pp.finishToken = function(type, val) {\n        this.end = this.pos;\n        if (this.options.locations) {\n            this.endLoc = this.curPosition();\n        }\n        var prevType = this.type;\n        this.type = type;\n        this.value = val;\n        this.updateContext(prevType);\n    };\n    // ### Token reading\n    // This is the function that is called to fetch the next token. It\n    // is somewhat obscure, because it works in character codes rather\n    // than characters, and because operator parsing has been inlined\n    // into it.\n    //\n    // All in the name of speed.\n    //\n    pp.readToken_dot = function() {\n        var next = this.input.charCodeAt(this.pos + 1);\n        if (next >= 48 && next <= 57) {\n            return this.readNumber(true);\n        }\n        var next2 = this.input.charCodeAt(this.pos + 2);\n        if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {\n            this.pos += 3;\n            return this.finishToken(types$1.ellipsis);\n        } else {\n            ++this.pos;\n            return this.finishToken(types$1.dot);\n        }\n    };\n    pp.readToken_slash = function() {\n        var next = this.input.charCodeAt(this.pos + 1);\n        if (this.exprAllowed) {\n            ++this.pos;\n            return this.readRegexp();\n        }\n        if (next === 61) {\n            return this.finishOp(types$1.assign, 2);\n        }\n        return this.finishOp(types$1.slash, 1);\n    };\n    pp.readToken_mult_modulo_exp = function(code) {\n        var next = this.input.charCodeAt(this.pos + 1);\n        var size = 1;\n        var tokentype = code === 42 ? types$1.star : types$1.modulo;\n        // exponentiation operator ** and **=\n        if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\n            ++size;\n            tokentype = types$1.starstar;\n            next = this.input.charCodeAt(this.pos + 2);\n        }\n        if (next === 61) {\n            return this.finishOp(types$1.assign, size + 1);\n        }\n        return this.finishOp(tokentype, size);\n    };\n    pp.readToken_pipe_amp = function(code) {\n        var next = this.input.charCodeAt(this.pos + 1);\n        if (next === code) {\n            if (this.options.ecmaVersion >= 12) {\n                var next2 = this.input.charCodeAt(this.pos + 2);\n                if (next2 === 61) {\n                    return this.finishOp(types$1.assign, 3);\n                }\n            }\n            return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);\n        }\n        if (next === 61) {\n            return this.finishOp(types$1.assign, 2);\n        }\n        return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);\n    };\n    pp.readToken_caret = function() {\n        var next = this.input.charCodeAt(this.pos + 1);\n        if (next === 61) {\n            return this.finishOp(types$1.assign, 2);\n        }\n        return this.finishOp(types$1.bitwiseXOR, 1);\n    };\n    pp.readToken_plus_min = function(code) {\n        var next = this.input.charCodeAt(this.pos + 1);\n        if (next === code) {\n            if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\n                // A `-->` line comment\n                this.skipLineComment(3);\n                this.skipSpace();\n                return this.nextToken();\n            }\n            return this.finishOp(types$1.incDec, 2);\n        }\n        if (next === 61) {\n            return this.finishOp(types$1.assign, 2);\n        }\n        return this.finishOp(types$1.plusMin, 1);\n    };\n    pp.readToken_lt_gt = function(code) {\n        var next = this.input.charCodeAt(this.pos + 1);\n        var size = 1;\n        if (next === code) {\n            size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n            if (this.input.charCodeAt(this.pos + size) === 61) {\n                return this.finishOp(types$1.assign, size + 1);\n            }\n            return this.finishOp(types$1.bitShift, size);\n        }\n        if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {\n            // `<!--`, an XML-style comment that should be interpreted as a line comment\n            this.skipLineComment(4);\n            this.skipSpace();\n            return this.nextToken();\n        }\n        if (next === 61) {\n            size = 2;\n        }\n        return this.finishOp(types$1.relational, size);\n    };\n    pp.readToken_eq_excl = function(code) {\n        var next = this.input.charCodeAt(this.pos + 1);\n        if (next === 61) {\n            return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);\n        }\n        if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {\n            this.pos += 2;\n            return this.finishToken(types$1.arrow);\n        }\n        return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);\n    };\n    pp.readToken_question = function() {\n        var ecmaVersion = this.options.ecmaVersion;\n        if (ecmaVersion >= 11) {\n            var next = this.input.charCodeAt(this.pos + 1);\n            if (next === 46) {\n                var next2 = this.input.charCodeAt(this.pos + 2);\n                if (next2 < 48 || next2 > 57) {\n                    return this.finishOp(types$1.questionDot, 2);\n                }\n            }\n            if (next === 63) {\n                if (ecmaVersion >= 12) {\n                    var next2$1 = this.input.charCodeAt(this.pos + 2);\n                    if (next2$1 === 61) {\n                        return this.finishOp(types$1.assign, 3);\n                    }\n                }\n                return this.finishOp(types$1.coalesce, 2);\n            }\n        }\n        return this.finishOp(types$1.question, 1);\n    };\n    pp.readToken_numberSign = function() {\n        var ecmaVersion = this.options.ecmaVersion;\n        var code = 35; // '#'\n        if (ecmaVersion >= 13) {\n            ++this.pos;\n            code = this.fullCharCodeAtPos();\n            if (isIdentifierStart(code, true) || code === 92 /* '\\' */ ) {\n                return this.finishToken(types$1.privateId, this.readWord1());\n            }\n        }\n        this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n    };\n    pp.getTokenFromCode = function(code) {\n        switch(code){\n            // The interpretation of a dot depends on whether it is followed\n            // by a digit or another two dots.\n            case 46:\n                return this.readToken_dot();\n            // Punctuation tokens.\n            case 40:\n                ++this.pos;\n                return this.finishToken(types$1.parenL);\n            case 41:\n                ++this.pos;\n                return this.finishToken(types$1.parenR);\n            case 59:\n                ++this.pos;\n                return this.finishToken(types$1.semi);\n            case 44:\n                ++this.pos;\n                return this.finishToken(types$1.comma);\n            case 91:\n                ++this.pos;\n                return this.finishToken(types$1.bracketL);\n            case 93:\n                ++this.pos;\n                return this.finishToken(types$1.bracketR);\n            case 123:\n                ++this.pos;\n                return this.finishToken(types$1.braceL);\n            case 125:\n                ++this.pos;\n                return this.finishToken(types$1.braceR);\n            case 58:\n                ++this.pos;\n                return this.finishToken(types$1.colon);\n            case 96:\n                if (this.options.ecmaVersion < 6) {\n                    break;\n                }\n                ++this.pos;\n                return this.finishToken(types$1.backQuote);\n            case 48:\n                var next = this.input.charCodeAt(this.pos + 1);\n                if (next === 120 || next === 88) {\n                    return this.readRadixNumber(16);\n                } // '0x', '0X' - hex number\n                if (this.options.ecmaVersion >= 6) {\n                    if (next === 111 || next === 79) {\n                        return this.readRadixNumber(8);\n                    } // '0o', '0O' - octal number\n                    if (next === 98 || next === 66) {\n                        return this.readRadixNumber(2);\n                    } // '0b', '0B' - binary number\n                }\n            // Anything else beginning with a digit is an integer, octal\n            // number, or float.\n            case 49:\n            case 50:\n            case 51:\n            case 52:\n            case 53:\n            case 54:\n            case 55:\n            case 56:\n            case 57:\n                return this.readNumber(false);\n            // Quotes produce strings.\n            case 34:\n            case 39:\n                return this.readString(code);\n            // Operators are parsed inline in tiny state machines. '=' (61) is\n            // often referred to. `finishOp` simply skips the amount of\n            // characters it is given as second argument, and returns a token\n            // of the type given by its first argument.\n            case 47:\n                return this.readToken_slash();\n            case 37:\n            case 42:\n                return this.readToken_mult_modulo_exp(code);\n            case 124:\n            case 38:\n                return this.readToken_pipe_amp(code);\n            case 94:\n                return this.readToken_caret();\n            case 43:\n            case 45:\n                return this.readToken_plus_min(code);\n            case 60:\n            case 62:\n                return this.readToken_lt_gt(code);\n            case 61:\n            case 33:\n                return this.readToken_eq_excl(code);\n            case 63:\n                return this.readToken_question();\n            case 126:\n                return this.finishOp(types$1.prefix, 1);\n            case 35:\n                return this.readToken_numberSign();\n        }\n        this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n    };\n    pp.finishOp = function(type, size) {\n        var str = this.input.slice(this.pos, this.pos + size);\n        this.pos += size;\n        return this.finishToken(type, str);\n    };\n    pp.readRegexp = function() {\n        var escaped, inClass, start = this.pos;\n        for(;;){\n            if (this.pos >= this.input.length) {\n                this.raise(start, \"Unterminated regular expression\");\n            }\n            var ch = this.input.charAt(this.pos);\n            if (lineBreak.test(ch)) {\n                this.raise(start, \"Unterminated regular expression\");\n            }\n            if (!escaped) {\n                if (ch === \"[\") {\n                    inClass = true;\n                } else if (ch === \"]\" && inClass) {\n                    inClass = false;\n                } else if (ch === \"/\" && !inClass) {\n                    break;\n                }\n                escaped = ch === \"\\\\\";\n            } else {\n                escaped = false;\n            }\n            ++this.pos;\n        }\n        var pattern = this.input.slice(start, this.pos);\n        ++this.pos;\n        var flagsStart = this.pos;\n        var flags = this.readWord1();\n        if (this.containsEsc) {\n            this.unexpected(flagsStart);\n        }\n        // Validate pattern\n        var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\n        state.reset(start, pattern, flags);\n        this.validateRegExpFlags(state);\n        this.validateRegExpPattern(state);\n        // Create Literal#value property value.\n        var value = null;\n        try {\n            value = new RegExp(pattern, flags);\n        } catch (e) {\n        // ESTree requires null if it failed to instantiate RegExp object.\n        // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral\n        }\n        return this.finishToken(types$1.regexp, {\n            pattern: pattern,\n            flags: flags,\n            value: value\n        });\n    };\n    // Read an integer in the given radix. Return null if zero digits\n    // were read, the integer value otherwise. When `len` is given, this\n    // will return `null` unless the integer has exactly `len` digits.\n    pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {\n        // `len` is used for character escape sequences. In that case, disallow separators.\n        var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;\n        // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)\n        // and isn't fraction part nor exponent part. In that case, if the first digit\n        // is zero then disallow separators.\n        var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;\n        var start = this.pos, total = 0, lastCode = 0;\n        for(var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos){\n            var code = this.input.charCodeAt(this.pos), val = void 0;\n            if (allowSeparators && code === 95) {\n                if (isLegacyOctalNumericLiteral) {\n                    this.raiseRecoverable(this.pos, \"Numeric separator is not allowed in legacy octal numeric literals\");\n                }\n                if (lastCode === 95) {\n                    this.raiseRecoverable(this.pos, \"Numeric separator must be exactly one underscore\");\n                }\n                if (i === 0) {\n                    this.raiseRecoverable(this.pos, \"Numeric separator is not allowed at the first of digits\");\n                }\n                lastCode = code;\n                continue;\n            }\n            if (code >= 97) {\n                val = code - 97 + 10;\n            } else if (code >= 65) {\n                val = code - 65 + 10;\n            } else if (code >= 48 && code <= 57) {\n                val = code - 48;\n            } else {\n                val = Infinity;\n            }\n            if (val >= radix) {\n                break;\n            }\n            lastCode = code;\n            total = total * radix + val;\n        }\n        if (allowSeparators && lastCode === 95) {\n            this.raiseRecoverable(this.pos - 1, \"Numeric separator is not allowed at the last of digits\");\n        }\n        if (this.pos === start || len != null && this.pos - start !== len) {\n            return null;\n        }\n        return total;\n    };\n    function stringToNumber(str, isLegacyOctalNumericLiteral) {\n        if (isLegacyOctalNumericLiteral) {\n            return parseInt(str, 8);\n        }\n        // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.\n        return parseFloat(str.replace(/_/g, \"\"));\n    }\n    function stringToBigInt(str) {\n        if (typeof BigInt !== \"function\") {\n            return null;\n        }\n        // `BigInt(value)` throws syntax error if the string contains numeric separators.\n        return BigInt(str.replace(/_/g, \"\"));\n    }\n    pp.readRadixNumber = function(radix) {\n        var start = this.pos;\n        this.pos += 2; // 0x\n        var val = this.readInt(radix);\n        if (val == null) {\n            this.raise(this.start + 2, \"Expected number in radix \" + radix);\n        }\n        if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {\n            val = stringToBigInt(this.input.slice(start, this.pos));\n            ++this.pos;\n        } else if (isIdentifierStart(this.fullCharCodeAtPos())) {\n            this.raise(this.pos, \"Identifier directly after number\");\n        }\n        return this.finishToken(types$1.num, val);\n    };\n    // Read an integer, octal integer, or floating-point number.\n    pp.readNumber = function(startsWithDot) {\n        var start = this.pos;\n        if (!startsWithDot && this.readInt(10, undefined, true) === null) {\n            this.raise(start, \"Invalid number\");\n        }\n        var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n        if (octal && this.strict) {\n            this.raise(start, \"Invalid number\");\n        }\n        var next = this.input.charCodeAt(this.pos);\n        if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {\n            var val$1 = stringToBigInt(this.input.slice(start, this.pos));\n            ++this.pos;\n            if (isIdentifierStart(this.fullCharCodeAtPos())) {\n                this.raise(this.pos, \"Identifier directly after number\");\n            }\n            return this.finishToken(types$1.num, val$1);\n        }\n        if (octal && /[89]/.test(this.input.slice(start, this.pos))) {\n            octal = false;\n        }\n        if (next === 46 && !octal) {\n            ++this.pos;\n            this.readInt(10);\n            next = this.input.charCodeAt(this.pos);\n        }\n        if ((next === 69 || next === 101) && !octal) {\n            next = this.input.charCodeAt(++this.pos);\n            if (next === 43 || next === 45) {\n                ++this.pos;\n            } // '+-'\n            if (this.readInt(10) === null) {\n                this.raise(start, \"Invalid number\");\n            }\n        }\n        if (isIdentifierStart(this.fullCharCodeAtPos())) {\n            this.raise(this.pos, \"Identifier directly after number\");\n        }\n        var val = stringToNumber(this.input.slice(start, this.pos), octal);\n        return this.finishToken(types$1.num, val);\n    };\n    // Read a string value, interpreting backslash-escapes.\n    pp.readCodePoint = function() {\n        var ch = this.input.charCodeAt(this.pos), code;\n        if (ch === 123) {\n            if (this.options.ecmaVersion < 6) {\n                this.unexpected();\n            }\n            var codePos = ++this.pos;\n            code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n            ++this.pos;\n            if (code > 0x10FFFF) {\n                this.invalidStringToken(codePos, \"Code point out of bounds\");\n            }\n        } else {\n            code = this.readHexChar(4);\n        }\n        return code;\n    };\n    pp.readString = function(quote) {\n        var out = \"\", chunkStart = ++this.pos;\n        for(;;){\n            if (this.pos >= this.input.length) {\n                this.raise(this.start, \"Unterminated string constant\");\n            }\n            var ch = this.input.charCodeAt(this.pos);\n            if (ch === quote) {\n                break;\n            }\n            if (ch === 92) {\n                out += this.input.slice(chunkStart, this.pos);\n                out += this.readEscapedChar(false);\n                chunkStart = this.pos;\n            } else if (ch === 0x2028 || ch === 0x2029) {\n                if (this.options.ecmaVersion < 10) {\n                    this.raise(this.start, \"Unterminated string constant\");\n                }\n                ++this.pos;\n                if (this.options.locations) {\n                    this.curLine++;\n                    this.lineStart = this.pos;\n                }\n            } else {\n                if (isNewLine(ch)) {\n                    this.raise(this.start, \"Unterminated string constant\");\n                }\n                ++this.pos;\n            }\n        }\n        out += this.input.slice(chunkStart, this.pos++);\n        return this.finishToken(types$1.string, out);\n    };\n    // Reads template string tokens.\n    var INVALID_TEMPLATE_ESCAPE_ERROR = {};\n    pp.tryReadTemplateToken = function() {\n        this.inTemplateElement = true;\n        try {\n            this.readTmplToken();\n        } catch (err) {\n            if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\n                this.readInvalidTemplateToken();\n            } else {\n                throw err;\n            }\n        }\n        this.inTemplateElement = false;\n    };\n    pp.invalidStringToken = function(position, message) {\n        if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\n            throw INVALID_TEMPLATE_ESCAPE_ERROR;\n        } else {\n            this.raise(position, message);\n        }\n    };\n    pp.readTmplToken = function() {\n        var out = \"\", chunkStart = this.pos;\n        for(;;){\n            if (this.pos >= this.input.length) {\n                this.raise(this.start, \"Unterminated template\");\n            }\n            var ch = this.input.charCodeAt(this.pos);\n            if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {\n                if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {\n                    if (ch === 36) {\n                        this.pos += 2;\n                        return this.finishToken(types$1.dollarBraceL);\n                    } else {\n                        ++this.pos;\n                        return this.finishToken(types$1.backQuote);\n                    }\n                }\n                out += this.input.slice(chunkStart, this.pos);\n                return this.finishToken(types$1.template, out);\n            }\n            if (ch === 92) {\n                out += this.input.slice(chunkStart, this.pos);\n                out += this.readEscapedChar(true);\n                chunkStart = this.pos;\n            } else if (isNewLine(ch)) {\n                out += this.input.slice(chunkStart, this.pos);\n                ++this.pos;\n                switch(ch){\n                    case 13:\n                        if (this.input.charCodeAt(this.pos) === 10) {\n                            ++this.pos;\n                        }\n                    case 10:\n                        out += \"\\n\";\n                        break;\n                    default:\n                        out += String.fromCharCode(ch);\n                        break;\n                }\n                if (this.options.locations) {\n                    ++this.curLine;\n                    this.lineStart = this.pos;\n                }\n                chunkStart = this.pos;\n            } else {\n                ++this.pos;\n            }\n        }\n    };\n    // Reads a template token to search for the end, without validating any escape sequences\n    pp.readInvalidTemplateToken = function() {\n        for(; this.pos < this.input.length; this.pos++){\n            switch(this.input[this.pos]){\n                case \"\\\\\":\n                    ++this.pos;\n                    break;\n                case \"$\":\n                    if (this.input[this.pos + 1] !== \"{\") {\n                        break;\n                    }\n                // fall through\n                case \"`\":\n                    return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));\n                case \"\\r\":\n                    if (this.input[this.pos + 1] === \"\\n\") {\n                        ++this.pos;\n                    }\n                // fall through\n                case \"\\n\":\n                case \"\\u2028\":\n                case \"\\u2029\":\n                    ++this.curLine;\n                    this.lineStart = this.pos + 1;\n                    break;\n            }\n        }\n        this.raise(this.start, \"Unterminated template\");\n    };\n    // Used to read escaped characters\n    pp.readEscapedChar = function(inTemplate) {\n        var ch = this.input.charCodeAt(++this.pos);\n        ++this.pos;\n        switch(ch){\n            case 110:\n                return \"\\n\" // 'n' -> '\\n'\n                ;\n            case 114:\n                return \"\\r\" // 'r' -> '\\r'\n                ;\n            case 120:\n                return String.fromCharCode(this.readHexChar(2)) // 'x'\n                ;\n            case 117:\n                return codePointToString(this.readCodePoint()) // 'u'\n                ;\n            case 116:\n                return \"\t\" // 't' -> '\\t'\n                ;\n            case 98:\n                return \"\\b\" // 'b' -> '\\b'\n                ;\n            case 118:\n                return \"\\v\" // 'v' -> '\\u000b'\n                ;\n            case 102:\n                return \"\\f\" // 'f' -> '\\f'\n                ;\n            case 13:\n                if (this.input.charCodeAt(this.pos) === 10) {\n                    ++this.pos;\n                } // '\\r\\n'\n            case 10:\n                if (this.options.locations) {\n                    this.lineStart = this.pos;\n                    ++this.curLine;\n                }\n                return \"\";\n            case 56:\n            case 57:\n                if (this.strict) {\n                    this.invalidStringToken(this.pos - 1, \"Invalid escape sequence\");\n                }\n                if (inTemplate) {\n                    var codePos = this.pos - 1;\n                    this.invalidStringToken(codePos, \"Invalid escape sequence in template string\");\n                }\n            default:\n                if (ch >= 48 && ch <= 55) {\n                    var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n                    var octal = parseInt(octalStr, 8);\n                    if (octal > 255) {\n                        octalStr = octalStr.slice(0, -1);\n                        octal = parseInt(octalStr, 8);\n                    }\n                    this.pos += octalStr.length - 1;\n                    ch = this.input.charCodeAt(this.pos);\n                    if ((octalStr !== \"0\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {\n                        this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? \"Octal literal in template string\" : \"Octal literal in strict mode\");\n                    }\n                    return String.fromCharCode(octal);\n                }\n                if (isNewLine(ch)) {\n                    // Unicode new line characters after \\ get removed from output in both\n                    // template literals and strings\n                    if (this.options.locations) {\n                        this.lineStart = this.pos;\n                        ++this.curLine;\n                    }\n                    return \"\";\n                }\n                return String.fromCharCode(ch);\n        }\n    };\n    // Used to read character escape sequences ('\\x', '\\u', '\\U').\n    pp.readHexChar = function(len) {\n        var codePos = this.pos;\n        var n = this.readInt(16, len);\n        if (n === null) {\n            this.invalidStringToken(codePos, \"Bad character escape sequence\");\n        }\n        return n;\n    };\n    // Read an identifier, and return it as a string. Sets `this.containsEsc`\n    // to whether the word contained a '\\u' escape.\n    //\n    // Incrementally adds only escaped chars, adding other chunks as-is\n    // as a micro-optimization.\n    pp.readWord1 = function() {\n        this.containsEsc = false;\n        var word = \"\", first = true, chunkStart = this.pos;\n        var astral = this.options.ecmaVersion >= 6;\n        while(this.pos < this.input.length){\n            var ch = this.fullCharCodeAtPos();\n            if (isIdentifierChar(ch, astral)) {\n                this.pos += ch <= 0xffff ? 1 : 2;\n            } else if (ch === 92) {\n                this.containsEsc = true;\n                word += this.input.slice(chunkStart, this.pos);\n                var escStart = this.pos;\n                if (this.input.charCodeAt(++this.pos) !== 117) {\n                    this.invalidStringToken(this.pos, \"Expecting Unicode escape sequence \\\\uXXXX\");\n                }\n                ++this.pos;\n                var esc = this.readCodePoint();\n                if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {\n                    this.invalidStringToken(escStart, \"Invalid Unicode escape\");\n                }\n                word += codePointToString(esc);\n                chunkStart = this.pos;\n            } else {\n                break;\n            }\n            first = false;\n        }\n        return word + this.input.slice(chunkStart, this.pos);\n    };\n    // Read an identifier or keyword token. Will check for reserved\n    // words when necessary.\n    pp.readWord = function() {\n        var word = this.readWord1();\n        var type = types$1.name;\n        if (this.keywords.test(word)) {\n            type = keywords[word];\n        }\n        return this.finishToken(type, word);\n    };\n    // Acorn is a tiny, fast JavaScript parser written in JavaScript.\n    //\n    // Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and\n    // various contributors and released under an MIT license.\n    //\n    // Git repositories for Acorn are available at\n    //\n    //     http://marijnhaverbeke.nl/git/acorn\n    //     https://github.com/acornjs/acorn.git\n    //\n    // Please use the [github bug tracker][ghbt] to report issues.\n    //\n    // [ghbt]: https://github.com/acornjs/acorn/issues\n    //\n    // [walk]: util/walk.js\n    var version = \"8.14.1\";\n    Parser.acorn = {\n        Parser: Parser,\n        version: version,\n        defaultOptions: defaultOptions,\n        Position: Position,\n        SourceLocation: SourceLocation,\n        getLineInfo: getLineInfo,\n        Node: Node,\n        TokenType: TokenType,\n        tokTypes: types$1,\n        keywordTypes: keywords,\n        TokContext: TokContext,\n        tokContexts: types,\n        isIdentifierChar: isIdentifierChar,\n        isIdentifierStart: isIdentifierStart,\n        Token: Token,\n        isNewLine: isNewLine,\n        lineBreak: lineBreak,\n        lineBreakG: lineBreakG,\n        nonASCIIwhitespace: nonASCIIwhitespace\n    };\n    // The main exported interface (under `self.acorn` when in the\n    // browser) is a `parse` function that takes a code string and returns\n    // an abstract syntax tree as specified by the [ESTree spec][estree].\n    //\n    // [estree]: https://github.com/estree/estree\n    function parse(input, options) {\n        return Parser.parse(input, options);\n    }\n    // This function tries to parse a single expression at a given\n    // offset in a string. Useful for parsing mixed-language formats\n    // that embed JavaScript expressions.\n    function parseExpressionAt(input, pos, options) {\n        return Parser.parseExpressionAt(input, pos, options);\n    }\n    // Acorn is organized as a tokenizer and a recursive-descent parser.\n    // The `tokenizer` export provides an interface to the tokenizer.\n    function tokenizer(input, options) {\n        return Parser.tokenizer(input, options);\n    }\n    exports1.Node = Node;\n    exports1.Parser = Parser;\n    exports1.Position = Position;\n    exports1.SourceLocation = SourceLocation;\n    exports1.TokContext = TokContext;\n    exports1.Token = Token;\n    exports1.TokenType = TokenType;\n    exports1.defaultOptions = defaultOptions;\n    exports1.getLineInfo = getLineInfo;\n    exports1.isIdentifierChar = isIdentifierChar;\n    exports1.isIdentifierStart = isIdentifierStart;\n    exports1.isNewLine = isNewLine;\n    exports1.keywordTypes = keywords;\n    exports1.lineBreak = lineBreak;\n    exports1.lineBreakG = lineBreakG;\n    exports1.nonASCIIwhitespace = nonASCIIwhitespace;\n    exports1.parse = parse;\n    exports1.parseExpressionAt = parseExpressionAt;\n    exports1.tokContexts = types;\n    exports1.tokTypes = types$1;\n    exports1.tokenizer = tokenizer;\n    exports1.version = version;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWNvcm4vZGlzdC9hY29ybi5qcyIsIm1hcHBpbmdzIjoiQUFBQyxVQUFVQSxNQUFNLEVBQUVDLE9BQU87SUFDeEIsS0FBaUQsR0FBY0EsUUFBUUMsV0FDdkUsQ0FDcUc7QUFDdkcsR0FBRyxJQUFJLEVBQUcsU0FBVUEsUUFBTztJQUFJO0lBRTdCLG1EQUFtRDtJQUNuRCxJQUFJTyx3QkFBd0I7UUFBQztRQUFLO1FBQUc7UUFBSztRQUFHO1FBQUs7UUFBRztRQUFLO1FBQUc7UUFBTTtRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFLO1FBQUc7UUFBSztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUs7UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFJO1FBQUk7UUFBRztRQUFLO1FBQUc7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBSTtRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUk7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUs7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBSTtRQUFJO1FBQUc7UUFBSztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFJO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUs7UUFBSTtRQUFLO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBSztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSztRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBSTtRQUFHO1FBQUk7UUFBSztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUs7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFJO1FBQU07UUFBRztRQUFHO1FBQUk7UUFBTztRQUFJO1FBQU07UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBSztRQUFHO1FBQUs7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBTztRQUFHO1FBQU07UUFBRztRQUFLO1FBQUk7UUFBRztRQUFJO1FBQUs7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBSztRQUFHO1FBQU07UUFBSTtRQUFLO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBSTtRQUFNO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUs7UUFBRztRQUFLO1FBQUc7UUFBSTtRQUFHO1FBQUs7UUFBRztRQUFJO1FBQUk7UUFBSztRQUFJO1FBQUs7UUFBRztRQUFHO1FBQUc7UUFBSztRQUFHO1FBQUs7UUFBRztRQUFHO1FBQUc7UUFBTTtRQUFHO1FBQVE7S0FBSTtJQUUxb0MsbURBQW1EO0lBQ25ELElBQUlDLDZCQUE2QjtRQUFDO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBSztRQUFJO1FBQUk7UUFBSztRQUFJO1FBQUc7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUc7UUFBSTtRQUFJO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFLO1FBQUk7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFJO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFJO1FBQUs7UUFBSTtRQUFJO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFHO1FBQUc7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFJO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUs7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUs7UUFBSTtRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFJO1FBQUk7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFJO1FBQUc7UUFBSTtRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBSTtRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUs7UUFBSTtRQUFJO1FBQUc7UUFBSTtRQUFJO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBSTtRQUFHO1FBQUk7UUFBSTtRQUFJO1FBQUc7UUFBSztRQUFJO1FBQUs7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBSTtRQUFHO1FBQUk7UUFBSTtRQUFLO1FBQUk7UUFBSTtRQUFHO1FBQUc7UUFBSTtRQUFJO1FBQUc7UUFBSTtRQUFJO1FBQUs7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFJO1FBQUc7UUFBSztRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUs7UUFBRztRQUFJO1FBQUs7UUFBSztRQUFLO1FBQUk7UUFBSztRQUFNO1FBQUk7UUFBSTtRQUFNO1FBQUk7UUFBRztRQUFJO1FBQU07UUFBRztRQUFLO1FBQU07UUFBSTtRQUFNO1FBQUs7UUFBRztRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBRztRQUFJO1FBQUs7UUFBSTtRQUFLO1FBQUk7UUFBSztRQUFJO1FBQUc7UUFBRztRQUFJO1FBQUk7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFJO1FBQU07UUFBRztRQUFNO1FBQUk7UUFBRztRQUFNO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUs7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBSztRQUFNO1FBQUs7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBTTtRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFLO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBTTtRQUFJO1FBQUc7UUFBRztRQUFLO1FBQUk7UUFBSztRQUFJO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBSztRQUFJO1FBQUk7UUFBSTtRQUFLO1FBQUk7UUFBSztRQUFJO1FBQUc7UUFBRztRQUFLO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBSTtRQUFHO1FBQUc7UUFBTTtRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBTTtRQUFPO1FBQUk7UUFBTTtRQUFHO1FBQUs7UUFBRztRQUFNO1FBQUk7UUFBTTtRQUFJO1FBQUs7UUFBTTtRQUFLO1FBQU07UUFBTTtRQUFHO0tBQUs7SUFFcHBFLG1EQUFtRDtJQUNuRCxJQUFJQywwQkFBMEI7SUFFOUIsbURBQW1EO0lBQ25ELElBQUlDLCtCQUErQjtJQUVuQyxrRUFBa0U7SUFDbEUsZ0VBQWdFO0lBQ2hFLG1FQUFtRTtJQUNuRSwwREFBMEQ7SUFFMUQsMkRBQTJEO0lBRTNELElBQUlDLGdCQUFnQjtRQUNsQixHQUFHO1FBQ0gsR0FBRztRQUNILEdBQUc7UUFDSEMsUUFBUTtRQUNSQyxZQUFZO0lBQ2Q7SUFFQSxtQkFBbUI7SUFFbkIsSUFBSUMsdUJBQXVCO0lBRTNCLElBQUlDLGFBQWE7UUFDZixHQUFHRDtRQUNILFdBQVdBLHVCQUF1QjtRQUNsQyxHQUFHQSx1QkFBdUI7SUFDNUI7SUFFQSxJQUFJRSw0QkFBNEI7SUFFaEMsMEJBQTBCO0lBRTFCLElBQUlDLDBCQUEwQixJQUFJQyxPQUFPLE1BQU1SLCtCQUErQjtJQUM5RSxJQUFJUyxxQkFBcUIsSUFBSUQsT0FBTyxNQUFNUiwrQkFBK0JELDBCQUEwQjtJQUVuRyw2REFBNkQ7SUFDN0QsZ0VBQWdFO0lBQ2hFLFFBQVE7SUFDUixTQUFTVyxjQUFjQyxJQUFJLEVBQUVDLEdBQUc7UUFDOUIsSUFBSUMsTUFBTTtRQUNWLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRixJQUFJRyxNQUFNLEVBQUVELEtBQUssRUFBRztZQUN0Q0QsT0FBT0QsR0FBRyxDQUFDRSxFQUFFO1lBQ2IsSUFBSUQsTUFBTUYsTUFBTTtnQkFBRSxPQUFPO1lBQU07WUFDL0JFLE9BQU9ELEdBQUcsQ0FBQ0UsSUFBSSxFQUFFO1lBQ2pCLElBQUlELE9BQU9GLE1BQU07Z0JBQUUsT0FBTztZQUFLO1FBQ2pDO1FBQ0EsT0FBTztJQUNUO0lBRUEsNERBQTREO0lBRTVELFNBQVNLLGtCQUFrQkwsSUFBSSxFQUFFTSxNQUFNO1FBQ3JDLElBQUlOLE9BQU8sSUFBSTtZQUFFLE9BQU9BLFNBQVM7UUFBRztRQUNwQyxJQUFJQSxPQUFPLElBQUk7WUFBRSxPQUFPO1FBQUs7UUFDN0IsSUFBSUEsT0FBTyxJQUFJO1lBQUUsT0FBT0EsU0FBUztRQUFHO1FBQ3BDLElBQUlBLE9BQU8sS0FBSztZQUFFLE9BQU87UUFBSztRQUM5QixJQUFJQSxRQUFRLFFBQVE7WUFBRSxPQUFPQSxRQUFRLFFBQVFKLHdCQUF3QlcsSUFBSSxDQUFDQyxPQUFPQyxZQUFZLENBQUNUO1FBQU87UUFDckcsSUFBSU0sV0FBVyxPQUFPO1lBQUUsT0FBTztRQUFNO1FBQ3JDLE9BQU9QLGNBQWNDLE1BQU1iO0lBQzdCO0lBRUEsMkRBQTJEO0lBRTNELFNBQVN1QixpQkFBaUJWLElBQUksRUFBRU0sTUFBTTtRQUNwQyxJQUFJTixPQUFPLElBQUk7WUFBRSxPQUFPQSxTQUFTO1FBQUc7UUFDcEMsSUFBSUEsT0FBTyxJQUFJO1lBQUUsT0FBTztRQUFLO1FBQzdCLElBQUlBLE9BQU8sSUFBSTtZQUFFLE9BQU87UUFBTTtRQUM5QixJQUFJQSxPQUFPLElBQUk7WUFBRSxPQUFPO1FBQUs7UUFDN0IsSUFBSUEsT0FBTyxJQUFJO1lBQUUsT0FBT0EsU0FBUztRQUFHO1FBQ3BDLElBQUlBLE9BQU8sS0FBSztZQUFFLE9BQU87UUFBSztRQUM5QixJQUFJQSxRQUFRLFFBQVE7WUFBRSxPQUFPQSxRQUFRLFFBQVFGLG1CQUFtQlMsSUFBSSxDQUFDQyxPQUFPQyxZQUFZLENBQUNUO1FBQU87UUFDaEcsSUFBSU0sV0FBVyxPQUFPO1lBQUUsT0FBTztRQUFNO1FBQ3JDLE9BQU9QLGNBQWNDLE1BQU1iLCtCQUErQlksY0FBY0MsTUFBTWQ7SUFDaEY7SUFFQSxpQkFBaUI7SUFFakIsb0VBQW9FO0lBQ3BFLCtEQUErRDtJQUMvRCwrREFBK0Q7SUFFL0Qsa0VBQWtFO0lBQ2xFLHFCQUFxQjtJQUVyQixvRUFBb0U7SUFDcEUsbUVBQW1FO0lBQ25FLG9FQUFvRTtJQUNwRSx1QkFBdUI7SUFDdkIsRUFBRTtJQUNGLGlFQUFpRTtJQUNqRSxtRUFBbUU7SUFDbkUsOERBQThEO0lBQzlELHNEQUFzRDtJQUN0RCxFQUFFO0lBQ0Ysa0VBQWtFO0lBQ2xFLDhEQUE4RDtJQUM5RCxnQ0FBZ0M7SUFFaEMsSUFBSXlCLFlBQVksU0FBU0EsVUFBVUMsS0FBSyxFQUFFQyxJQUFJO1FBQzVDLElBQUtBLFNBQVMsS0FBSyxHQUFJQSxPQUFPLENBQUM7UUFFL0IsSUFBSSxDQUFDRCxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDRSxPQUFPLEdBQUdELEtBQUtDLE9BQU87UUFDM0IsSUFBSSxDQUFDQyxVQUFVLEdBQUcsQ0FBQyxDQUFDRixLQUFLRSxVQUFVO1FBQ25DLElBQUksQ0FBQ0MsVUFBVSxHQUFHLENBQUMsQ0FBQ0gsS0FBS0csVUFBVTtRQUNuQyxJQUFJLENBQUNDLE1BQU0sR0FBRyxDQUFDLENBQUNKLEtBQUtJLE1BQU07UUFDM0IsSUFBSSxDQUFDQyxRQUFRLEdBQUcsQ0FBQyxDQUFDTCxLQUFLSyxRQUFRO1FBQy9CLElBQUksQ0FBQ0MsTUFBTSxHQUFHLENBQUMsQ0FBQ04sS0FBS00sTUFBTTtRQUMzQixJQUFJLENBQUNDLE9BQU8sR0FBRyxDQUFDLENBQUNQLEtBQUtPLE9BQU87UUFDN0IsSUFBSSxDQUFDQyxLQUFLLEdBQUdSLEtBQUtRLEtBQUssSUFBSTtRQUMzQixJQUFJLENBQUNDLGFBQWEsR0FBRztJQUN2QjtJQUVBLFNBQVNELE1BQU1FLElBQUksRUFBRUMsSUFBSTtRQUN2QixPQUFPLElBQUliLFVBQVVZLE1BQU07WUFBQ1IsWUFBWTtZQUFNTSxPQUFPRztRQUFJO0lBQzNEO0lBQ0EsSUFBSVQsYUFBYTtRQUFDQSxZQUFZO0lBQUksR0FBR0MsYUFBYTtRQUFDQSxZQUFZO0lBQUk7SUFFbkUsb0NBQW9DO0lBRXBDLElBQUlTLFdBQVcsQ0FBQztJQUVoQiw4Q0FBOEM7SUFDOUMsU0FBU0MsR0FBR0gsSUFBSSxFQUFFSSxPQUFPO1FBQ3ZCLElBQUtBLFlBQVksS0FBSyxHQUFJQSxVQUFVLENBQUM7UUFFckNBLFFBQVFiLE9BQU8sR0FBR1M7UUFDbEIsT0FBT0UsUUFBUSxDQUFDRixLQUFLLEdBQUcsSUFBSVosVUFBVVksTUFBTUk7SUFDOUM7SUFFQSxJQUFJQyxVQUFVO1FBQ1pDLEtBQUssSUFBSWxCLFVBQVUsT0FBT0s7UUFDMUJjLFFBQVEsSUFBSW5CLFVBQVUsVUFBVUs7UUFDaENlLFFBQVEsSUFBSXBCLFVBQVUsVUFBVUs7UUFDaENPLE1BQU0sSUFBSVosVUFBVSxRQUFRSztRQUM1QmdCLFdBQVcsSUFBSXJCLFVBQVUsYUFBYUs7UUFDdENpQixLQUFLLElBQUl0QixVQUFVO1FBRW5CLDJCQUEyQjtRQUMzQnVCLFVBQVUsSUFBSXZCLFVBQVUsS0FBSztZQUFDSSxZQUFZO1lBQU1DLFlBQVk7UUFBSTtRQUNoRW1CLFVBQVUsSUFBSXhCLFVBQVU7UUFDeEJ5QixRQUFRLElBQUl6QixVQUFVLEtBQUs7WUFBQ0ksWUFBWTtZQUFNQyxZQUFZO1FBQUk7UUFDOURxQixRQUFRLElBQUkxQixVQUFVO1FBQ3RCMkIsUUFBUSxJQUFJM0IsVUFBVSxLQUFLO1lBQUNJLFlBQVk7WUFBTUMsWUFBWTtRQUFJO1FBQzlEdUIsUUFBUSxJQUFJNUIsVUFBVTtRQUN0QjZCLE9BQU8sSUFBSTdCLFVBQVUsS0FBS0k7UUFDMUIwQixNQUFNLElBQUk5QixVQUFVLEtBQUtJO1FBQ3pCMkIsT0FBTyxJQUFJL0IsVUFBVSxLQUFLSTtRQUMxQjRCLEtBQUssSUFBSWhDLFVBQVU7UUFDbkJpQyxVQUFVLElBQUlqQyxVQUFVLEtBQUtJO1FBQzdCOEIsYUFBYSxJQUFJbEMsVUFBVTtRQUMzQm1DLE9BQU8sSUFBSW5DLFVBQVUsTUFBTUk7UUFDM0JnQyxVQUFVLElBQUlwQyxVQUFVO1FBQ3hCcUMsaUJBQWlCLElBQUlyQyxVQUFVO1FBQy9Cc0MsVUFBVSxJQUFJdEMsVUFBVSxPQUFPSTtRQUMvQm1DLFdBQVcsSUFBSXZDLFVBQVUsS0FBS0s7UUFDOUJtQyxjQUFjLElBQUl4QyxVQUFVLE1BQU07WUFBQ0ksWUFBWTtZQUFNQyxZQUFZO1FBQUk7UUFFckUsaUVBQWlFO1FBQ2pFLGdFQUFnRTtRQUNoRSx1Q0FBdUM7UUFDdkMsRUFBRTtRQUNGLGtFQUFrRTtRQUNsRSw4Q0FBOEM7UUFDOUMsRUFBRTtRQUNGLGtFQUFrRTtRQUNsRSxrQkFBa0I7UUFDbEIsRUFBRTtRQUNGLGlFQUFpRTtRQUNqRSxrRUFBa0U7UUFDbEUsaUNBQWlDO1FBRWpDb0MsSUFBSSxJQUFJekMsVUFBVSxLQUFLO1lBQUNJLFlBQVk7WUFBTUcsVUFBVTtRQUFJO1FBQ3hEbUMsUUFBUSxJQUFJMUMsVUFBVSxNQUFNO1lBQUNJLFlBQVk7WUFBTUcsVUFBVTtRQUFJO1FBQzdEb0MsUUFBUSxJQUFJM0MsVUFBVSxTQUFTO1lBQUNRLFFBQVE7WUFBTUMsU0FBUztZQUFNSixZQUFZO1FBQUk7UUFDN0VHLFFBQVEsSUFBSVIsVUFBVSxPQUFPO1lBQUNJLFlBQVk7WUFBTUksUUFBUTtZQUFNSCxZQUFZO1FBQUk7UUFDOUV1QyxXQUFXbEMsTUFBTSxNQUFNO1FBQ3ZCbUMsWUFBWW5DLE1BQU0sTUFBTTtRQUN4Qm9DLFdBQVdwQyxNQUFNLEtBQUs7UUFDdEJxQyxZQUFZckMsTUFBTSxLQUFLO1FBQ3ZCc0MsWUFBWXRDLE1BQU0sS0FBSztRQUN2QnVDLFVBQVV2QyxNQUFNLGlCQUFpQjtRQUNqQ3dDLFlBQVl4QyxNQUFNLGFBQWE7UUFDL0J5QyxVQUFVekMsTUFBTSxhQUFhO1FBQzdCMEMsU0FBUyxJQUFJcEQsVUFBVSxPQUFPO1lBQUNJLFlBQVk7WUFBTU0sT0FBTztZQUFHRixRQUFRO1lBQU1ILFlBQVk7UUFBSTtRQUN6RmdELFFBQVEzQyxNQUFNLEtBQUs7UUFDbkI0QyxNQUFNNUMsTUFBTSxLQUFLO1FBQ2pCNkMsT0FBTzdDLE1BQU0sS0FBSztRQUNsQjhDLFVBQVUsSUFBSXhELFVBQVUsTUFBTTtZQUFDSSxZQUFZO1FBQUk7UUFDL0NxRCxVQUFVL0MsTUFBTSxNQUFNO1FBRXRCLHVCQUF1QjtRQUN2QmdELFFBQVEzQyxHQUFHO1FBQ1g0QyxPQUFPNUMsR0FBRyxRQUFRWDtRQUNsQndELFFBQVE3QyxHQUFHO1FBQ1g4QyxXQUFXOUMsR0FBRztRQUNkK0MsV0FBVy9DLEdBQUc7UUFDZGdELFVBQVVoRCxHQUFHLFdBQVdYO1FBQ3hCNEQsS0FBS2pELEdBQUcsTUFBTTtZQUFDVCxRQUFRO1lBQU1GLFlBQVk7UUFBSTtRQUM3QzZELE9BQU9sRCxHQUFHLFFBQVFYO1FBQ2xCOEQsVUFBVW5ELEdBQUc7UUFDYm9ELE1BQU1wRCxHQUFHLE9BQU87WUFBQ1QsUUFBUTtRQUFJO1FBQzdCOEQsV0FBV3JELEdBQUcsWUFBWVY7UUFDMUJnRSxLQUFLdEQsR0FBRztRQUNSdUQsU0FBU3ZELEdBQUcsVUFBVVg7UUFDdEJtRSxTQUFTeEQsR0FBRztRQUNaeUQsUUFBUXpELEdBQUcsU0FBU1g7UUFDcEJxRSxNQUFNMUQsR0FBRztRQUNUMkQsTUFBTTNELEdBQUc7UUFDVDRELFFBQVE1RCxHQUFHO1FBQ1g2RCxRQUFRN0QsR0FBRyxTQUFTO1lBQUNULFFBQVE7UUFBSTtRQUNqQ3VFLE9BQU85RCxHQUFHO1FBQ1YrRCxNQUFNL0QsR0FBRyxPQUFPO1lBQUNYLFlBQVk7WUFBTUMsWUFBWTtRQUFJO1FBQ25EMEUsT0FBT2hFLEdBQUcsUUFBUVY7UUFDbEIyRSxRQUFRakUsR0FBRyxTQUFTVjtRQUNwQjRFLFFBQVFsRSxHQUFHLFNBQVNWO1FBQ3BCNkUsVUFBVW5FLEdBQUcsV0FBV1g7UUFDeEIrRSxTQUFTcEUsR0FBRztRQUNacUUsU0FBU3JFLEdBQUcsVUFBVVY7UUFDdEJnRixPQUFPdEUsR0FBRyxRQUFRVjtRQUNsQmlGLE9BQU92RSxHQUFHLFFBQVFWO1FBQ2xCa0YsUUFBUXhFLEdBQUcsU0FBU1Y7UUFDcEJtRixLQUFLekUsR0FBRyxNQUFNO1lBQUNYLFlBQVk7WUFBTU0sT0FBTztRQUFDO1FBQ3pDK0UsYUFBYTFFLEdBQUcsY0FBYztZQUFDWCxZQUFZO1lBQU1NLE9BQU87UUFBQztRQUN6RGdGLFNBQVMzRSxHQUFHLFVBQVU7WUFBQ1gsWUFBWTtZQUFNSSxRQUFRO1lBQU1ILFlBQVk7UUFBSTtRQUN2RXNGLE9BQU81RSxHQUFHLFFBQVE7WUFBQ1gsWUFBWTtZQUFNSSxRQUFRO1lBQU1ILFlBQVk7UUFBSTtRQUNuRXVGLFNBQVM3RSxHQUFHLFVBQVU7WUFBQ1gsWUFBWTtZQUFNSSxRQUFRO1lBQU1ILFlBQVk7UUFBSTtJQUN6RTtJQUVBLGdFQUFnRTtJQUNoRSxvQ0FBb0M7SUFFcEMsSUFBSXdGLFlBQVk7SUFDaEIsSUFBSUMsYUFBYSxJQUFJNUcsT0FBTzJHLFVBQVVFLE1BQU0sRUFBRTtJQUU5QyxTQUFTQyxVQUFVM0csSUFBSTtRQUNyQixPQUFPQSxTQUFTLE1BQU1BLFNBQVMsTUFBTUEsU0FBUyxVQUFVQSxTQUFTO0lBQ25FO0lBRUEsU0FBUzRHLGNBQWM1RyxJQUFJLEVBQUU2RyxJQUFJLEVBQUVDLEdBQUc7UUFDcEMsSUFBS0EsUUFBUSxLQUFLLEdBQUlBLE1BQU05RyxLQUFLSSxNQUFNO1FBRXZDLElBQUssSUFBSUQsSUFBSTBHLE1BQU0xRyxJQUFJMkcsS0FBSzNHLElBQUs7WUFDL0IsSUFBSTRHLE9BQU8vRyxLQUFLZ0gsVUFBVSxDQUFDN0c7WUFDM0IsSUFBSXdHLFVBQVVJLE9BQ1o7Z0JBQUUsT0FBTzVHLElBQUkyRyxNQUFNLEtBQUtDLFNBQVMsTUFBTS9HLEtBQUtnSCxVQUFVLENBQUM3RyxJQUFJLE9BQU8sS0FBS0EsSUFBSSxJQUFJQSxJQUFJO1lBQUU7UUFDekY7UUFDQSxPQUFPLENBQUM7SUFDVjtJQUVBLElBQUk4RyxxQkFBcUI7SUFFekIsSUFBSUMsaUJBQWlCO0lBRXJCLElBQUlDLE1BQU1DLE9BQU9DLFNBQVM7SUFDMUIsSUFBSUMsaUJBQWlCSCxJQUFJRyxjQUFjO0lBQ3ZDLElBQUlDLFdBQVdKLElBQUlJLFFBQVE7SUFFM0IsSUFBSUMsU0FBU0osT0FBT0ksTUFBTSxJQUFLLFNBQVVDLEdBQUcsRUFBRUMsUUFBUTtRQUFJLE9BQ3hESixlQUFlSyxJQUFJLENBQUNGLEtBQUtDO0lBQ3hCO0lBRUgsSUFBSUUsVUFBVUMsTUFBTUQsT0FBTyxJQUFLLFNBQVVILEdBQUc7UUFBSSxPQUMvQ0YsU0FBU0ksSUFBSSxDQUFDRixTQUFTO0lBQ3RCO0lBRUgsSUFBSUssY0FBY1YsT0FBT1csTUFBTSxDQUFDO0lBRWhDLFNBQVNDLFlBQVlDLEtBQUs7UUFDeEIsT0FBT0gsV0FBVyxDQUFDRyxNQUFNLElBQUtILENBQUFBLFdBQVcsQ0FBQ0csTUFBTSxHQUFHLElBQUlwSSxPQUFPLFNBQVNvSSxNQUFNQyxPQUFPLENBQUMsTUFBTSxPQUFPLEtBQUk7SUFDeEc7SUFFQSxTQUFTQyxrQkFBa0JuSSxJQUFJO1FBQzdCLGtCQUFrQjtRQUNsQixJQUFJQSxRQUFRLFFBQVE7WUFBRSxPQUFPUSxPQUFPQyxZQUFZLENBQUNUO1FBQU07UUFDdkRBLFFBQVE7UUFDUixPQUFPUSxPQUFPQyxZQUFZLENBQUMsQ0FBQ1QsUUFBUSxFQUFDLElBQUssUUFBUSxDQUFDQSxPQUFPLElBQUcsSUFBSztJQUNwRTtJQUVBLElBQUlvSSxnQkFBZ0I7SUFFcEIseURBQXlEO0lBQ3pELHNDQUFzQztJQUV0QyxJQUFJQyxXQUFXLFNBQVNBLFNBQVNDLElBQUksRUFBRUMsR0FBRztRQUN4QyxJQUFJLENBQUNELElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNFLE1BQU0sR0FBR0Q7SUFDaEI7SUFFQUYsU0FBU2hCLFNBQVMsQ0FBQ29CLE1BQU0sR0FBRyxTQUFTQSxPQUFRQyxDQUFDO1FBQzVDLE9BQU8sSUFBSUwsU0FBUyxJQUFJLENBQUNDLElBQUksRUFBRSxJQUFJLENBQUNFLE1BQU0sR0FBR0U7SUFDL0M7SUFFQSxJQUFJQyxpQkFBaUIsU0FBU0EsZUFBZUMsQ0FBQyxFQUFFQyxLQUFLLEVBQUUvQixHQUFHO1FBQ3hELElBQUksQ0FBQytCLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUMvQixHQUFHLEdBQUdBO1FBQ1gsSUFBSThCLEVBQUVFLFVBQVUsS0FBSyxNQUFNO1lBQUUsSUFBSSxDQUFDcEMsTUFBTSxHQUFHa0MsRUFBRUUsVUFBVTtRQUFFO0lBQzNEO0lBRUEsdURBQXVEO0lBQ3ZELDhEQUE4RDtJQUM5RCw4REFBOEQ7SUFDOUQsbUVBQW1FO0lBQ25FLFFBQVE7SUFFUixTQUFTQyxZQUFZQyxLQUFLLEVBQUVQLE1BQU07UUFDaEMsSUFBSyxJQUFJSCxPQUFPLEdBQUdXLE1BQU0sSUFBSztZQUM1QixJQUFJQyxZQUFZdEMsY0FBY29DLE9BQU9DLEtBQUtSO1lBQzFDLElBQUlTLFlBQVksR0FBRztnQkFBRSxPQUFPLElBQUliLFNBQVNDLE1BQU1HLFNBQVNRO1lBQUs7WUFDN0QsRUFBRVg7WUFDRlcsTUFBTUM7UUFDUjtJQUNGO0lBRUEsbUVBQW1FO0lBQ25FLGlFQUFpRTtJQUVqRSxJQUFJQyxpQkFBaUI7UUFDbkIsbUVBQW1FO1FBQ25FLDZEQUE2RDtRQUM3RCxvRUFBb0U7UUFDcEUsNkRBQTZEO1FBQzdELGtFQUFrRTtRQUNsRSwyQkFBMkI7UUFDM0JDLGFBQWE7UUFDYixnRUFBZ0U7UUFDaEUsaUVBQWlFO1FBQ2pFLGlFQUFpRTtRQUNqRUMsWUFBWTtRQUNaLG1FQUFtRTtRQUNuRSwrREFBK0Q7UUFDL0QsMERBQTBEO1FBQzFELGdFQUFnRTtRQUNoRSxzQ0FBc0M7UUFDdENDLHFCQUFxQjtRQUNyQixpRUFBaUU7UUFDakUsbUJBQW1CO1FBQ25CQyxpQkFBaUI7UUFDakIsb0VBQW9FO1FBQ3BFLG9FQUFvRTtRQUNwRSxpRUFBaUU7UUFDakUsdURBQXVEO1FBQ3ZEQyxlQUFlO1FBQ2YsK0RBQStEO1FBQy9ELFNBQVM7UUFDVEMsNEJBQTRCO1FBQzVCLGdFQUFnRTtRQUNoRSxxRUFBcUU7UUFDckUseUNBQXlDO1FBQ3pDQyw2QkFBNkI7UUFDN0IsMEdBQTBHO1FBQzFHLGdGQUFnRjtRQUNoRix5REFBeUQ7UUFDekRDLDJCQUEyQjtRQUMzQix5REFBeUQ7UUFDekQsNkVBQTZFO1FBQzdFQyx5QkFBeUI7UUFDekIsK0RBQStEO1FBQy9ELGlFQUFpRTtRQUNqRSx5QkFBeUI7UUFDekJDLGVBQWU7UUFDZixpRUFBaUU7UUFDakUsbUVBQW1FO1FBQ25FLDZDQUE2QztRQUM3Q0Msb0JBQW9CO1FBQ3BCLGdFQUFnRTtRQUNoRSw4REFBOEQ7UUFDOUQsaUVBQWlFO1FBQ2pFLFNBQVM7UUFDVEMsV0FBVztRQUNYLDJEQUEyRDtRQUMzRCw0REFBNEQ7UUFDNUQsZ0VBQWdFO1FBQ2hFLHVEQUF1RDtRQUN2RCxpREFBaUQ7UUFDakRDLFNBQVM7UUFDVCw2REFBNkQ7UUFDN0QsK0RBQStEO1FBQy9ELCtEQUErRDtRQUMvRCxnRUFBZ0U7UUFDaEUsa0VBQWtFO1FBQ2xFLGtFQUFrRTtRQUNsRSw2REFBNkQ7UUFDN0QsK0RBQStEO1FBQy9ELGlFQUFpRTtRQUNqRSxpRUFBaUU7UUFDakUsbUVBQW1FO1FBQ25FLDZCQUE2QjtRQUM3QkMsV0FBVztRQUNYLGdFQUFnRTtRQUNoRSxrRUFBa0U7UUFDbEUsZ0VBQWdFO1FBQ2hFLGlFQUFpRTtRQUNqRSxnRUFBZ0U7UUFDaEUsVUFBVTtRQUNWLEVBQUU7UUFDRiwrREFBK0Q7UUFDL0RDLFFBQVE7UUFDUiw4REFBOEQ7UUFDOUQseURBQXlEO1FBQ3pELDJEQUEyRDtRQUMzRCxnRUFBZ0U7UUFDaEUsNkJBQTZCO1FBQzdCQyxTQUFTO1FBQ1QsaUVBQWlFO1FBQ2pFLHFDQUFxQztRQUNyQ3JCLFlBQVk7UUFDWix5REFBeUQ7UUFDekQsNEJBQTRCO1FBQzVCc0Isa0JBQWtCO1FBQ2xCLDZEQUE2RDtRQUM3RCwrQ0FBK0M7UUFDL0NDLGdCQUFnQjtJQUNsQjtJQUVBLDBDQUEwQztJQUUxQyxJQUFJQyx5QkFBeUI7SUFFN0IsU0FBU0MsV0FBV0MsSUFBSTtRQUN0QixJQUFJN0ksVUFBVSxDQUFDO1FBRWYsSUFBSyxJQUFJOEksT0FBT3RCLGVBQ2Q7WUFBRXhILE9BQU8sQ0FBQzhJLElBQUksR0FBR0QsUUFBUWhELE9BQU9nRCxNQUFNQyxPQUFPRCxJQUFJLENBQUNDLElBQUksR0FBR3RCLGNBQWMsQ0FBQ3NCLElBQUk7UUFBRTtRQUVoRixJQUFJOUksUUFBUXlILFdBQVcsS0FBSyxVQUFVO1lBQ3BDekgsUUFBUXlILFdBQVcsR0FBRztRQUN4QixPQUFPLElBQUl6SCxRQUFReUgsV0FBVyxJQUFJLE1BQU07WUFDdEMsSUFBSSxDQUFDa0IsMEJBQTBCLE9BQU9JLFlBQVksWUFBWUEsUUFBUUMsSUFBSSxFQUFFO2dCQUMxRUwseUJBQXlCO2dCQUN6QkksUUFBUUMsSUFBSSxDQUFDO1lBQ2Y7WUFDQWhKLFFBQVF5SCxXQUFXLEdBQUc7UUFDeEIsT0FBTyxJQUFJekgsUUFBUXlILFdBQVcsSUFBSSxNQUFNO1lBQ3RDekgsUUFBUXlILFdBQVcsSUFBSTtRQUN6QjtRQUVBLElBQUl6SCxRQUFRNkgsYUFBYSxJQUFJLE1BQzNCO1lBQUU3SCxRQUFRNkgsYUFBYSxHQUFHN0gsUUFBUXlILFdBQVcsR0FBRztRQUFHO1FBRXJELElBQUksQ0FBQ29CLFFBQVFBLEtBQUtYLGFBQWEsSUFBSSxNQUNqQztZQUFFbEksUUFBUWtJLGFBQWEsR0FBR2xJLFFBQVF5SCxXQUFXLElBQUk7UUFBSTtRQUV2RCxJQUFJeEIsUUFBUWpHLFFBQVFxSSxPQUFPLEdBQUc7WUFDNUIsSUFBSVksU0FBU2pKLFFBQVFxSSxPQUFPO1lBQzVCckksUUFBUXFJLE9BQU8sR0FBRyxTQUFVYSxLQUFLO2dCQUFJLE9BQU9ELE9BQU9FLElBQUksQ0FBQ0Q7WUFBUTtRQUNsRTtRQUNBLElBQUlqRCxRQUFRakcsUUFBUXNJLFNBQVMsR0FDM0I7WUFBRXRJLFFBQVFzSSxTQUFTLEdBQUdjLFlBQVlwSixTQUFTQSxRQUFRc0ksU0FBUztRQUFHO1FBRWpFLE9BQU90STtJQUNUO0lBRUEsU0FBU29KLFlBQVlwSixPQUFPLEVBQUVxSixLQUFLO1FBQ2pDLE9BQU8sU0FBU0MsS0FBSyxFQUFFQyxJQUFJLEVBQUVyQyxLQUFLLEVBQUUvQixHQUFHLEVBQUVxRSxRQUFRLEVBQUVDLE1BQU07WUFDdkQsSUFBSUMsVUFBVTtnQkFDWkMsTUFBTUwsUUFBUSxVQUFVO2dCQUN4Qk0sT0FBT0w7Z0JBQ1ByQyxPQUFPQTtnQkFDUC9CLEtBQUtBO1lBQ1A7WUFDQSxJQUFJbkYsUUFBUW9JLFNBQVMsRUFDbkI7Z0JBQUVzQixRQUFRRyxHQUFHLEdBQUcsSUFBSTdDLGVBQWUsSUFBSSxFQUFFd0MsVUFBVUM7WUFBUztZQUM5RCxJQUFJekosUUFBUXVJLE1BQU0sRUFDaEI7Z0JBQUVtQixRQUFRSSxLQUFLLEdBQUc7b0JBQUM1QztvQkFBTy9CO2lCQUFJO1lBQUU7WUFDbENrRSxNQUFNRixJQUFJLENBQUNPO1FBQ2I7SUFDRjtJQUVBLHdEQUF3RDtJQUN4RCxJQUNJSyxZQUFZLEdBQ1pDLGlCQUFpQixHQUNqQkMsY0FBYyxHQUNkQyxrQkFBa0IsR0FDbEJDLGNBQWMsSUFDZEMscUJBQXFCLElBQ3JCQyxjQUFjLElBQ2RDLHFCQUFxQixLQUNyQkMsMkJBQTJCLEtBQzNCQyx5QkFBeUIsS0FDekJDLFlBQVlWLFlBQVlDLGlCQUFpQk87SUFFN0MsU0FBU0csY0FBY0MsS0FBSyxFQUFFQyxTQUFTO1FBQ3JDLE9BQU9aLGlCQUFrQlcsQ0FBQUEsUUFBUVYsY0FBYyxLQUFNVyxDQUFBQSxZQUFZVixrQkFBa0I7SUFDckY7SUFFQSx3RUFBd0U7SUFDeEUsSUFDSVcsWUFBWSxHQUNaQyxXQUFXLEdBQ1hDLGVBQWUsR0FDZkMsZ0JBQWdCLEdBQ2hCQyxvQkFBb0IsR0FDcEJDLGVBQWUsR0FBRywrREFBK0Q7SUFFckYsSUFBSUMsU0FBUyxTQUFTQSxPQUFPbkwsT0FBTyxFQUFFcUgsS0FBSyxFQUFFK0QsUUFBUTtRQUNuRCxJQUFJLENBQUNwTCxPQUFPLEdBQUdBLFVBQVU0SSxXQUFXNUk7UUFDcEMsSUFBSSxDQUFDbUgsVUFBVSxHQUFHbkgsUUFBUW1ILFVBQVU7UUFDcEMsSUFBSSxDQUFDckgsUUFBUSxHQUFHdUcsWUFBWXRJLFVBQVUsQ0FBQ2lDLFFBQVF5SCxXQUFXLElBQUksSUFBSSxJQUFJekgsUUFBUTBILFVBQVUsS0FBSyxXQUFXLFlBQVksRUFBRTtRQUN0SCxJQUFJMkQsV0FBVztRQUNmLElBQUlyTCxRQUFRNkgsYUFBYSxLQUFLLE1BQU07WUFDbEN3RCxXQUFXMU4sYUFBYSxDQUFDcUMsUUFBUXlILFdBQVcsSUFBSSxJQUFJLElBQUl6SCxRQUFReUgsV0FBVyxLQUFLLElBQUksSUFBSSxFQUFFO1lBQzFGLElBQUl6SCxRQUFRMEgsVUFBVSxLQUFLLFVBQVU7Z0JBQUUyRCxZQUFZO1lBQVU7UUFDL0Q7UUFDQSxJQUFJLENBQUMxTixhQUFhLEdBQUcwSSxZQUFZZ0Y7UUFDakMsSUFBSUMsaUJBQWlCLENBQUNELFdBQVdBLFdBQVcsTUFBTSxFQUFDLElBQUsxTixjQUFjQyxNQUFNO1FBQzVFLElBQUksQ0FBQzJOLG1CQUFtQixHQUFHbEYsWUFBWWlGO1FBQ3ZDLElBQUksQ0FBQ0UsdUJBQXVCLEdBQUduRixZQUFZaUYsaUJBQWlCLE1BQU0zTixjQUFjRSxVQUFVO1FBQzFGLElBQUksQ0FBQ3dKLEtBQUssR0FBR3hJLE9BQU93STtRQUVwQiw0REFBNEQ7UUFDNUQsb0VBQW9FO1FBQ3BFLHdEQUF3RDtRQUN4RCxJQUFJLENBQUNvRSxXQUFXLEdBQUc7UUFFbkIscUJBQXFCO1FBRXJCLHNEQUFzRDtRQUN0RCxJQUFJTCxVQUFVO1lBQ1osSUFBSSxDQUFDN00sR0FBRyxHQUFHNk07WUFDWCxJQUFJLENBQUNNLFNBQVMsR0FBRyxJQUFJLENBQUNyRSxLQUFLLENBQUNzRSxXQUFXLENBQUMsTUFBTVAsV0FBVyxLQUFLO1lBQzlELElBQUksQ0FBQ1EsT0FBTyxHQUFHLElBQUksQ0FBQ3ZFLEtBQUssQ0FBQ3dFLEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQ0gsU0FBUyxFQUFFSSxLQUFLLENBQUNqSCxXQUFXcEcsTUFBTTtRQUM1RSxPQUFPO1lBQ0wsSUFBSSxDQUFDRixHQUFHLEdBQUcsSUFBSSxDQUFDbU4sU0FBUyxHQUFHO1lBQzVCLElBQUksQ0FBQ0UsT0FBTyxHQUFHO1FBQ2pCO1FBRUEsbUNBQW1DO1FBQ25DLFdBQVc7UUFDWCxJQUFJLENBQUNqQyxJQUFJLEdBQUcxSixRQUFRSyxHQUFHO1FBQ3ZCLHNFQUFzRTtRQUN0RSxJQUFJLENBQUNzSixLQUFLLEdBQUc7UUFDYiwyQkFBMkI7UUFDM0IsSUFBSSxDQUFDMUMsS0FBSyxHQUFHLElBQUksQ0FBQy9CLEdBQUcsR0FBRyxJQUFJLENBQUM1RyxHQUFHO1FBQ2hDLHdEQUF3RDtRQUN4RCxpQ0FBaUM7UUFDakMsSUFBSSxDQUFDaUwsUUFBUSxHQUFHLElBQUksQ0FBQ0MsTUFBTSxHQUFHLElBQUksQ0FBQ3NDLFdBQVc7UUFFOUMsOENBQThDO1FBQzlDLElBQUksQ0FBQ0MsYUFBYSxHQUFHLElBQUksQ0FBQ0MsZUFBZSxHQUFHO1FBQzVDLElBQUksQ0FBQ0MsWUFBWSxHQUFHLElBQUksQ0FBQ0MsVUFBVSxHQUFHLElBQUksQ0FBQzVOLEdBQUc7UUFFOUMsNkRBQTZEO1FBQzdELGtFQUFrRTtRQUNsRSxrQkFBa0I7UUFDbEIsSUFBSSxDQUFDNk4sT0FBTyxHQUFHLElBQUksQ0FBQ0MsY0FBYztRQUNsQyxJQUFJLENBQUNDLFdBQVcsR0FBRztRQUVuQixvQ0FBb0M7UUFDcEMsSUFBSSxDQUFDQyxRQUFRLEdBQUd2TSxRQUFRMEgsVUFBVSxLQUFLO1FBQ3ZDLElBQUksQ0FBQzlKLE1BQU0sR0FBRyxJQUFJLENBQUMyTyxRQUFRLElBQUksSUFBSSxDQUFDQyxlQUFlLENBQUMsSUFBSSxDQUFDak8sR0FBRztRQUU1RCwwREFBMEQ7UUFDMUQsSUFBSSxDQUFDa08sZ0JBQWdCLEdBQUcsQ0FBQztRQUN6QixJQUFJLENBQUNDLHdCQUF3QixHQUFHO1FBRWhDLG9GQUFvRjtRQUNwRixJQUFJLENBQUNDLFFBQVEsR0FBRyxJQUFJLENBQUNDLFFBQVEsR0FBRyxJQUFJLENBQUNDLGFBQWEsR0FBRztRQUNyRCxtQkFBbUI7UUFDbkIsSUFBSSxDQUFDQyxNQUFNLEdBQUcsRUFBRTtRQUNoQiw4QkFBOEI7UUFDOUIsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBR3RILE9BQU9XLE1BQU0sQ0FBQztRQUV0QywwQ0FBMEM7UUFDMUMsSUFBSSxJQUFJLENBQUM3SCxHQUFHLEtBQUssS0FBS3lCLFFBQVFrSSxhQUFhLElBQUksSUFBSSxDQUFDYixLQUFLLENBQUN3RSxLQUFLLENBQUMsR0FBRyxPQUFPLE1BQ3hFO1lBQUUsSUFBSSxDQUFDbUIsZUFBZSxDQUFDO1FBQUk7UUFFN0IsNkRBQTZEO1FBQzdELElBQUksQ0FBQ0MsVUFBVSxHQUFHLEVBQUU7UUFDcEIsSUFBSSxDQUFDQyxVQUFVLENBQUNuRDtRQUVoQix3QkFBd0I7UUFDeEIsSUFBSSxDQUFDb0QsV0FBVyxHQUFHO1FBRW5CLDhCQUE4QjtRQUM5QiwwREFBMEQ7UUFDMUQsK0ZBQStGO1FBQy9GLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUcsRUFBRTtJQUM1QjtJQUVBLElBQUlDLHFCQUFxQjtRQUFFQyxZQUFZO1lBQUVDLGNBQWM7UUFBSztRQUFFQyxhQUFhO1lBQUVELGNBQWM7UUFBSztRQUFFRSxTQUFTO1lBQUVGLGNBQWM7UUFBSztRQUFFRyxVQUFVO1lBQUVILGNBQWM7UUFBSztRQUFFSSxZQUFZO1lBQUVKLGNBQWM7UUFBSztRQUFFSyxrQkFBa0I7WUFBRUwsY0FBYztRQUFLO1FBQUVNLHFCQUFxQjtZQUFFTixjQUFjO1FBQUs7UUFBRU8sbUJBQW1CO1lBQUVQLGNBQWM7UUFBSztRQUFFUSxvQkFBb0I7WUFBRVIsY0FBYztRQUFLO0lBQUU7SUFFaFhwQyxPQUFPekYsU0FBUyxDQUFDc0ksS0FBSyxHQUFHLFNBQVNBO1FBQ2hDLElBQUlDLE9BQU8sSUFBSSxDQUFDak8sT0FBTyxDQUFDd0ksT0FBTyxJQUFJLElBQUksQ0FBQzBGLFNBQVM7UUFDakQsSUFBSSxDQUFDQyxTQUFTO1FBQ2QsT0FBTyxJQUFJLENBQUNDLGFBQWEsQ0FBQ0g7SUFDNUI7SUFFQVosbUJBQW1CQyxVQUFVLENBQUNlLEdBQUcsR0FBRztRQUFjLE9BQU8sQ0FBQyxJQUFJLENBQUNDLGVBQWUsR0FBR0MsS0FBSyxHQUFHdkUsY0FBYSxJQUFLO0lBQUU7SUFFN0dxRCxtQkFBbUJHLFdBQVcsQ0FBQ2EsR0FBRyxHQUFHO1FBQWMsT0FBTyxDQUFDLElBQUksQ0FBQ0MsZUFBZSxHQUFHQyxLQUFLLEdBQUdyRSxlQUFjLElBQUs7SUFBRTtJQUUvR21ELG1CQUFtQkksT0FBTyxDQUFDWSxHQUFHLEdBQUc7UUFBYyxPQUFPLENBQUMsSUFBSSxDQUFDQyxlQUFlLEdBQUdDLEtBQUssR0FBR3RFLFdBQVUsSUFBSztJQUFFO0lBRXZHb0QsbUJBQW1CSyxRQUFRLENBQUNXLEdBQUcsR0FBRztRQUNoQyxJQUFLLElBQUk3UCxJQUFJLElBQUksQ0FBQ3lPLFVBQVUsQ0FBQ3hPLE1BQU0sR0FBRyxHQUFHRCxLQUFLLEdBQUdBLElBQUs7WUFDcEQsSUFBSWdILE1BQU0sSUFBSSxDQUFDeUgsVUFBVSxDQUFDek8sRUFBRTtZQUMxQixJQUFJK1AsUUFBUS9JLElBQUkrSSxLQUFLO1lBQ3ZCLElBQUlBLFFBQVNoRSxDQUFBQSwyQkFBMkJDLHNCQUFxQixHQUFJO2dCQUFFLE9BQU87WUFBTTtZQUNoRixJQUFJK0QsUUFBUXZFLGdCQUFnQjtnQkFBRSxPQUFPLENBQUN1RSxRQUFRdEUsV0FBVSxJQUFLO1lBQUU7UUFDakU7UUFDQSxPQUFPLElBQUssQ0FBQ3NDLFFBQVEsSUFBSSxJQUFJLENBQUN2TSxPQUFPLENBQUN5SCxXQUFXLElBQUksTUFBTyxJQUFJLENBQUN6SCxPQUFPLENBQUNnSSx5QkFBeUI7SUFDcEc7SUFFQXFGLG1CQUFtQk0sVUFBVSxDQUFDVSxHQUFHLEdBQUc7UUFDbEMsSUFBSTdJLE1BQU0sSUFBSSxDQUFDZ0osZ0JBQWdCO1FBQzdCLElBQUlELFFBQVEvSSxJQUFJK0ksS0FBSztRQUN2QixPQUFPLENBQUNBLFFBQVFsRSxXQUFVLElBQUssS0FBSyxJQUFJLENBQUNySyxPQUFPLENBQUNpSSx1QkFBdUI7SUFDMUU7SUFFQW9GLG1CQUFtQk8sZ0JBQWdCLENBQUNTLEdBQUcsR0FBRztRQUFjLE9BQU8sQ0FBQyxJQUFJLENBQUNHLGdCQUFnQixHQUFHRCxLQUFLLEdBQUdqRSxrQkFBaUIsSUFBSztJQUFFO0lBRXhIK0MsbUJBQW1CUSxtQkFBbUIsQ0FBQ1EsR0FBRyxHQUFHO1FBQWMsT0FBTyxJQUFJLENBQUNJLDBCQUEwQixDQUFDLElBQUksQ0FBQ0MsWUFBWTtJQUFJO0lBRXZIckIsbUJBQW1CUyxpQkFBaUIsQ0FBQ08sR0FBRyxHQUFHO1FBQ3pDLElBQUssSUFBSTdQLElBQUksSUFBSSxDQUFDeU8sVUFBVSxDQUFDeE8sTUFBTSxHQUFHLEdBQUdELEtBQUssR0FBR0EsSUFBSztZQUNwRCxJQUFJZ0gsTUFBTSxJQUFJLENBQUN5SCxVQUFVLENBQUN6TyxFQUFFO1lBQzFCLElBQUkrUCxRQUFRL0ksSUFBSStJLEtBQUs7WUFDdkIsSUFBSUEsUUFBU2hFLENBQUFBLDJCQUEyQkMsc0JBQXFCLEtBQ3hELFFBQVNSLGtCQUFtQixDQUFFdUUsQ0FBQUEsUUFBUXBFLFdBQVUsR0FBSztnQkFBRSxPQUFPO1lBQUs7UUFDMUU7UUFDQSxPQUFPO0lBQ1Q7SUFFQWtELG1CQUFtQlUsa0JBQWtCLENBQUNNLEdBQUcsR0FBRztRQUMxQyxPQUFPLENBQUMsSUFBSSxDQUFDQyxlQUFlLEdBQUdDLEtBQUssR0FBR2hFLHdCQUF1QixJQUFLO0lBQ3JFO0lBRUFZLE9BQU93RCxNQUFNLEdBQUcsU0FBU0E7UUFDckIsSUFBSUMsVUFBVSxFQUFFLEVBQUVDLE1BQU1DLFVBQVVyUSxNQUFNO1FBQ3hDLE1BQVFvUSxNQUFRRCxPQUFPLENBQUVDLElBQUssR0FBR0MsU0FBUyxDQUFFRCxJQUFLO1FBRW5ELElBQUlFLE1BQU0sSUFBSTtRQUNkLElBQUssSUFBSXZRLElBQUksR0FBR0EsSUFBSW9RLFFBQVFuUSxNQUFNLEVBQUVELElBQUs7WUFBRXVRLE1BQU1ILE9BQU8sQ0FBQ3BRLEVBQUUsQ0FBQ3VRO1FBQU07UUFDbEUsT0FBT0E7SUFDVDtJQUVBNUQsT0FBTzZDLEtBQUssR0FBRyxTQUFTQSxNQUFPM0csS0FBSyxFQUFFckgsT0FBTztRQUMzQyxPQUFPLElBQUksSUFBSSxDQUFDQSxTQUFTcUgsT0FBTzJHLEtBQUs7SUFDdkM7SUFFQTdDLE9BQU82RCxpQkFBaUIsR0FBRyxTQUFTQSxrQkFBbUIzSCxLQUFLLEVBQUU5SSxHQUFHLEVBQUV5QixPQUFPO1FBQ3hFLElBQUlpUCxTQUFTLElBQUksSUFBSSxDQUFDalAsU0FBU3FILE9BQU85STtRQUN0QzBRLE9BQU9kLFNBQVM7UUFDaEIsT0FBT2MsT0FBT0MsZUFBZTtJQUMvQjtJQUVBL0QsT0FBT2dFLFNBQVMsR0FBRyxTQUFTQSxVQUFXOUgsS0FBSyxFQUFFckgsT0FBTztRQUNuRCxPQUFPLElBQUksSUFBSSxDQUFDQSxTQUFTcUg7SUFDM0I7SUFFQTVCLE9BQU8ySixnQkFBZ0IsQ0FBRWpFLE9BQU96RixTQUFTLEVBQUUySDtJQUUzQyxJQUFJZ0MsT0FBT2xFLE9BQU96RixTQUFTO0lBRTNCLHNCQUFzQjtJQUV0QixJQUFJNEosVUFBVTtJQUNkRCxLQUFLN0MsZUFBZSxHQUFHLFNBQVN0RixLQUFLO1FBQ25DLElBQUksSUFBSSxDQUFDbEgsT0FBTyxDQUFDeUgsV0FBVyxHQUFHLEdBQUc7WUFBRSxPQUFPO1FBQU07UUFDakQsT0FBUztZQUNQLDhCQUE4QjtZQUM5QmxDLGVBQWVnSyxTQUFTLEdBQUdySTtZQUMzQkEsU0FBUzNCLGVBQWVpSyxJQUFJLENBQUMsSUFBSSxDQUFDbkksS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDNUksTUFBTTtZQUNsRCxJQUFJZ1IsUUFBUUgsUUFBUUUsSUFBSSxDQUFDLElBQUksQ0FBQ25JLEtBQUssQ0FBQ3dFLEtBQUssQ0FBQzNFO1lBQzFDLElBQUksQ0FBQ3VJLE9BQU87Z0JBQUUsT0FBTztZQUFNO1lBQzNCLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEVBQUUsSUFBSUEsS0FBSyxDQUFDLEVBQUUsTUFBTSxjQUFjO2dCQUMzQ2xLLGVBQWVnSyxTQUFTLEdBQUdySSxRQUFRdUksS0FBSyxDQUFDLEVBQUUsQ0FBQ2hSLE1BQU07Z0JBQ2xELElBQUlpUixhQUFhbkssZUFBZWlLLElBQUksQ0FBQyxJQUFJLENBQUNuSSxLQUFLLEdBQUdsQyxNQUFNdUssV0FBV0MsS0FBSyxHQUFHRCxVQUFVLENBQUMsRUFBRSxDQUFDalIsTUFBTTtnQkFDL0YsSUFBSTJHLE9BQU8sSUFBSSxDQUFDaUMsS0FBSyxDQUFDdUksTUFBTSxDQUFDeks7Z0JBQzdCLE9BQU9DLFNBQVMsT0FBT0EsU0FBUyxPQUM3QlAsVUFBVWpHLElBQUksQ0FBQzhRLFVBQVUsQ0FBQyxFQUFFLEtBQzVCLENBQUUsdUJBQXNCOVEsSUFBSSxDQUFDd0csU0FBU0EsU0FBUyxPQUFPLElBQUksQ0FBQ2lDLEtBQUssQ0FBQ3VJLE1BQU0sQ0FBQ3pLLE1BQU0sT0FBTyxHQUFFO1lBQzVGO1lBQ0ErQixTQUFTdUksS0FBSyxDQUFDLEVBQUUsQ0FBQ2hSLE1BQU07WUFFeEIsMEJBQTBCO1lBQzFCOEcsZUFBZWdLLFNBQVMsR0FBR3JJO1lBQzNCQSxTQUFTM0IsZUFBZWlLLElBQUksQ0FBQyxJQUFJLENBQUNuSSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUM1SSxNQUFNO1lBQ2xELElBQUksSUFBSSxDQUFDNEksS0FBSyxDQUFDSCxNQUFNLEtBQUssS0FDeEI7Z0JBQUVBO1lBQVM7UUFDZjtJQUNGO0lBRUEsOERBQThEO0lBQzlELGtEQUFrRDtJQUVsRG1JLEtBQUtRLEdBQUcsR0FBRyxTQUFTbEcsSUFBSTtRQUN0QixJQUFJLElBQUksQ0FBQ0EsSUFBSSxLQUFLQSxNQUFNO1lBQ3RCLElBQUksQ0FBQ3ZFLElBQUk7WUFDVCxPQUFPO1FBQ1QsT0FBTztZQUNMLE9BQU87UUFDVDtJQUNGO0lBRUEsc0RBQXNEO0lBRXREaUssS0FBS1MsWUFBWSxHQUFHLFNBQVNsUSxJQUFJO1FBQy9CLE9BQU8sSUFBSSxDQUFDK0osSUFBSSxLQUFLMUosUUFBUUwsSUFBSSxJQUFJLElBQUksQ0FBQ2dLLEtBQUssS0FBS2hLLFFBQVEsQ0FBQyxJQUFJLENBQUM2TCxXQUFXO0lBQy9FO0lBRUEsMkNBQTJDO0lBRTNDNEQsS0FBS1UsYUFBYSxHQUFHLFNBQVNuUSxJQUFJO1FBQ2hDLElBQUksQ0FBQyxJQUFJLENBQUNrUSxZQUFZLENBQUNsUSxPQUFPO1lBQUUsT0FBTztRQUFNO1FBQzdDLElBQUksQ0FBQ3dGLElBQUk7UUFDVCxPQUFPO0lBQ1Q7SUFFQSw0REFBNEQ7SUFFNURpSyxLQUFLVyxnQkFBZ0IsR0FBRyxTQUFTcFEsSUFBSTtRQUNuQyxJQUFJLENBQUMsSUFBSSxDQUFDbVEsYUFBYSxDQUFDblEsT0FBTztZQUFFLElBQUksQ0FBQ3FRLFVBQVU7UUFBSTtJQUN0RDtJQUVBLG9FQUFvRTtJQUVwRVosS0FBS2Esa0JBQWtCLEdBQUc7UUFDeEIsT0FBTyxJQUFJLENBQUN2RyxJQUFJLEtBQUsxSixRQUFRSyxHQUFHLElBQzlCLElBQUksQ0FBQ3FKLElBQUksS0FBSzFKLFFBQVFTLE1BQU0sSUFDNUJtRSxVQUFVakcsSUFBSSxDQUFDLElBQUksQ0FBQ3lJLEtBQUssQ0FBQ3dFLEtBQUssQ0FBQyxJQUFJLENBQUNNLFVBQVUsRUFBRSxJQUFJLENBQUNqRixLQUFLO0lBQy9EO0lBRUFtSSxLQUFLYyxlQUFlLEdBQUc7UUFDckIsSUFBSSxJQUFJLENBQUNELGtCQUFrQixJQUFJO1lBQzdCLElBQUksSUFBSSxDQUFDbFEsT0FBTyxDQUFDMkgsbUJBQW1CLEVBQ2xDO2dCQUFFLElBQUksQ0FBQzNILE9BQU8sQ0FBQzJILG1CQUFtQixDQUFDLElBQUksQ0FBQ3dFLFVBQVUsRUFBRSxJQUFJLENBQUNILGFBQWE7WUFBRztZQUMzRSxPQUFPO1FBQ1Q7SUFDRjtJQUVBLGtFQUFrRTtJQUNsRSxzREFBc0Q7SUFFdERxRCxLQUFLZSxTQUFTLEdBQUc7UUFDZixJQUFJLENBQUMsSUFBSSxDQUFDUCxHQUFHLENBQUM1UCxRQUFRYSxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUNxUCxlQUFlLElBQUk7WUFBRSxJQUFJLENBQUNGLFVBQVU7UUFBSTtJQUMvRTtJQUVBWixLQUFLZ0Isa0JBQWtCLEdBQUcsU0FBU0MsT0FBTyxFQUFFQyxPQUFPO1FBQ2pELElBQUksSUFBSSxDQUFDNUcsSUFBSSxLQUFLMkcsU0FBUztZQUN6QixJQUFJLElBQUksQ0FBQ3RRLE9BQU8sQ0FBQzRILGVBQWUsRUFDOUI7Z0JBQUUsSUFBSSxDQUFDNUgsT0FBTyxDQUFDNEgsZUFBZSxDQUFDLElBQUksQ0FBQ3NFLFlBQVksRUFBRSxJQUFJLENBQUNELGVBQWU7WUFBRztZQUMzRSxJQUFJLENBQUNzRSxTQUNIO2dCQUFFLElBQUksQ0FBQ25MLElBQUk7WUFBSTtZQUNqQixPQUFPO1FBQ1Q7SUFDRjtJQUVBLG1FQUFtRTtJQUNuRSxtQ0FBbUM7SUFFbkNpSyxLQUFLbUIsTUFBTSxHQUFHLFNBQVM3RyxJQUFJO1FBQ3pCLElBQUksQ0FBQ2tHLEdBQUcsQ0FBQ2xHLFNBQVMsSUFBSSxDQUFDc0csVUFBVTtJQUNuQztJQUVBLG1DQUFtQztJQUVuQ1osS0FBS1ksVUFBVSxHQUFHLFNBQVMxUixHQUFHO1FBQzVCLElBQUksQ0FBQ2tTLEtBQUssQ0FBQ2xTLE9BQU8sT0FBT0EsTUFBTSxJQUFJLENBQUMySSxLQUFLLEVBQUU7SUFDN0M7SUFFQSxJQUFJd0osc0JBQXNCLFNBQVNBO1FBQ2pDLElBQUksQ0FBQ0MsZUFBZSxHQUNwQixJQUFJLENBQUNDLGFBQWEsR0FDbEIsSUFBSSxDQUFDQyxtQkFBbUIsR0FDeEIsSUFBSSxDQUFDQyxpQkFBaUIsR0FDdEIsSUFBSSxDQUFDQyxXQUFXLEdBQ2QsQ0FBQztJQUNMO0lBRUExQixLQUFLMkIsa0JBQWtCLEdBQUcsU0FBU0Msc0JBQXNCLEVBQUUxUixRQUFRO1FBQ2pFLElBQUksQ0FBQzBSLHdCQUF3QjtZQUFFO1FBQU87UUFDdEMsSUFBSUEsdUJBQXVCTCxhQUFhLEdBQUcsQ0FBQyxHQUMxQztZQUFFLElBQUksQ0FBQ00sZ0JBQWdCLENBQUNELHVCQUF1QkwsYUFBYSxFQUFFO1FBQWtEO1FBQ2xILElBQUlPLFNBQVM1UixXQUFXMFIsdUJBQXVCSixtQkFBbUIsR0FBR0ksdUJBQXVCSCxpQkFBaUI7UUFDN0csSUFBSUssU0FBUyxDQUFDLEdBQUc7WUFBRSxJQUFJLENBQUNELGdCQUFnQixDQUFDQyxRQUFRNVIsV0FBVyx3QkFBd0I7UUFBMEI7SUFDaEg7SUFFQThQLEtBQUsrQixxQkFBcUIsR0FBRyxTQUFTSCxzQkFBc0IsRUFBRUksUUFBUTtRQUNwRSxJQUFJLENBQUNKLHdCQUF3QjtZQUFFLE9BQU87UUFBTTtRQUM1QyxJQUFJTixrQkFBa0JNLHVCQUF1Qk4sZUFBZTtRQUM1RCxJQUFJSSxjQUFjRSx1QkFBdUJGLFdBQVc7UUFDcEQsSUFBSSxDQUFDTSxVQUFVO1lBQUUsT0FBT1YsbUJBQW1CLEtBQUtJLGVBQWU7UUFBRTtRQUNqRSxJQUFJSixtQkFBbUIsR0FDckI7WUFBRSxJQUFJLENBQUNGLEtBQUssQ0FBQ0UsaUJBQWlCO1FBQTRFO1FBQzVHLElBQUlJLGVBQWUsR0FDakI7WUFBRSxJQUFJLENBQUNHLGdCQUFnQixDQUFDSCxhQUFhO1FBQXVDO0lBQ2hGO0lBRUExQixLQUFLaUMsOEJBQThCLEdBQUc7UUFDcEMsSUFBSSxJQUFJLENBQUMzRSxRQUFRLElBQUssRUFBQyxJQUFJLENBQUNDLFFBQVEsSUFBSSxJQUFJLENBQUNELFFBQVEsR0FBRyxJQUFJLENBQUNDLFFBQVEsR0FDbkU7WUFBRSxJQUFJLENBQUM2RCxLQUFLLENBQUMsSUFBSSxDQUFDOUQsUUFBUSxFQUFFO1FBQStDO1FBQzdFLElBQUksSUFBSSxDQUFDQyxRQUFRLEVBQ2Y7WUFBRSxJQUFJLENBQUM2RCxLQUFLLENBQUMsSUFBSSxDQUFDN0QsUUFBUSxFQUFFO1FBQStDO0lBQy9FO0lBRUF5QyxLQUFLa0Msb0JBQW9CLEdBQUcsU0FBU0MsSUFBSTtRQUN2QyxJQUFJQSxLQUFLN0gsSUFBSSxLQUFLLDJCQUNoQjtZQUFFLE9BQU8sSUFBSSxDQUFDNEgsb0JBQW9CLENBQUNDLEtBQUtDLFVBQVU7UUFBRTtRQUN0RCxPQUFPRCxLQUFLN0gsSUFBSSxLQUFLLGdCQUFnQjZILEtBQUs3SCxJQUFJLEtBQUs7SUFDckQ7SUFFQSxJQUFJK0gsT0FBT3ZHLE9BQU96RixTQUFTO0lBRTNCLHdCQUF3QjtJQUV4QiwrREFBK0Q7SUFDL0Qsb0VBQW9FO0lBQ3BFLG1FQUFtRTtJQUNuRSw4Q0FBOEM7SUFFOUNnTSxLQUFLdEQsYUFBYSxHQUFHLFNBQVNILElBQUk7UUFDaEMsSUFBSWpSLFdBQVV5SSxPQUFPVyxNQUFNLENBQUM7UUFDNUIsSUFBSSxDQUFDNkgsS0FBSzBELElBQUksRUFBRTtZQUFFMUQsS0FBSzBELElBQUksR0FBRyxFQUFFO1FBQUU7UUFDbEMsTUFBTyxJQUFJLENBQUNoSSxJQUFJLEtBQUsxSixRQUFRSyxHQUFHLENBQUU7WUFDaEMsSUFBSXNSLE9BQU8sSUFBSSxDQUFDQyxjQUFjLENBQUMsTUFBTSxNQUFNN1U7WUFDM0NpUixLQUFLMEQsSUFBSSxDQUFDeEksSUFBSSxDQUFDeUk7UUFDakI7UUFDQSxJQUFJLElBQUksQ0FBQ3JGLFFBQVEsRUFDZjtZQUFFLElBQUssSUFBSS9OLElBQUksR0FBR3NULE9BQU9yTSxPQUFPc00sSUFBSSxDQUFDLElBQUksQ0FBQ2hGLGdCQUFnQixHQUFHdk8sSUFBSXNULEtBQUtyVCxNQUFNLEVBQUVELEtBQUssRUFDakY7Z0JBQ0UsSUFBSW9CLE9BQU9rUyxJQUFJLENBQUN0VCxFQUFFO2dCQUVsQixJQUFJLENBQUMwUyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUNuRSxnQkFBZ0IsQ0FBQ25OLEtBQUssQ0FBQ3NILEtBQUssRUFBRyxhQUFhdEgsT0FBTztZQUNoRjtRQUFFO1FBQ04sSUFBSSxDQUFDb1Msc0JBQXNCLENBQUMvRCxLQUFLMEQsSUFBSTtRQUNyQyxJQUFJLENBQUN2TSxJQUFJO1FBQ1Q2SSxLQUFLdkcsVUFBVSxHQUFHLElBQUksQ0FBQzFILE9BQU8sQ0FBQzBILFVBQVU7UUFDekMsT0FBTyxJQUFJLENBQUN1SyxVQUFVLENBQUNoRSxNQUFNO0lBQy9CO0lBRUEsSUFBSWlFLFlBQVk7UUFBQ0MsTUFBTTtJQUFNLEdBQUdDLGNBQWM7UUFBQ0QsTUFBTTtJQUFRO0lBRTdEVCxLQUFLVyxLQUFLLEdBQUcsU0FBU2pHLE9BQU87UUFDM0IsSUFBSSxJQUFJLENBQUNwTSxPQUFPLENBQUN5SCxXQUFXLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQ3FJLFlBQVksQ0FBQyxRQUFRO1lBQUUsT0FBTztRQUFNO1FBQzlFdkssZUFBZWdLLFNBQVMsR0FBRyxJQUFJLENBQUNoUixHQUFHO1FBQ25DLElBQUkrVCxPQUFPL00sZUFBZWlLLElBQUksQ0FBQyxJQUFJLENBQUNuSSxLQUFLO1FBQ3pDLElBQUlqQyxPQUFPLElBQUksQ0FBQzdHLEdBQUcsR0FBRytULElBQUksQ0FBQyxFQUFFLENBQUM3VCxNQUFNLEVBQUU4VCxTQUFTLElBQUksQ0FBQ2xMLEtBQUssQ0FBQ2hDLFVBQVUsQ0FBQ0Q7UUFDckUsb0VBQW9FO1FBQ3BFLDRFQUE0RTtRQUM1RSxxRUFBcUU7UUFDckUsaURBQWlEO1FBQ2pELElBQUltTixXQUFXLE1BQU1BLFdBQVcsSUFBSTtZQUFFLE9BQU87UUFBSyxFQUFFLFdBQVc7UUFDL0QsSUFBSW5HLFNBQVM7WUFBRSxPQUFPO1FBQU07UUFFNUIsSUFBSW1HLFdBQVcsT0FBT0EsU0FBUyxVQUFVQSxTQUFTLFFBQVE7WUFBRSxPQUFPO1FBQUssRUFBRSxjQUFjO1FBQ3hGLElBQUk3VCxrQkFBa0I2VCxRQUFRLE9BQU87WUFDbkMsSUFBSWhVLE1BQU02RyxPQUFPO1lBQ2pCLE1BQU9yRyxpQkFBaUJ3VCxTQUFTLElBQUksQ0FBQ2xMLEtBQUssQ0FBQ2hDLFVBQVUsQ0FBQzlHLE1BQU0sTUFBTztnQkFBRSxFQUFFQTtZQUFLO1lBQzdFLElBQUlnVSxXQUFXLE1BQU1BLFNBQVMsVUFBVUEsU0FBUyxRQUFRO2dCQUFFLE9BQU87WUFBSztZQUN2RSxJQUFJQyxRQUFRLElBQUksQ0FBQ25MLEtBQUssQ0FBQ3dFLEtBQUssQ0FBQ3pHLE1BQU03RztZQUNuQyxJQUFJLENBQUNQLDBCQUEwQlksSUFBSSxDQUFDNFQsUUFBUTtnQkFBRSxPQUFPO1lBQUs7UUFDNUQ7UUFDQSxPQUFPO0lBQ1Q7SUFFQSxrREFBa0Q7SUFDbEQsb0NBQW9DO0lBQ3BDLHdDQUF3QztJQUN4Q2QsS0FBS2UsZUFBZSxHQUFHO1FBQ3JCLElBQUksSUFBSSxDQUFDelMsT0FBTyxDQUFDeUgsV0FBVyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUNxSSxZQUFZLENBQUMsVUFDckQ7WUFBRSxPQUFPO1FBQU07UUFFakJ2SyxlQUFlZ0ssU0FBUyxHQUFHLElBQUksQ0FBQ2hSLEdBQUc7UUFDbkMsSUFBSStULE9BQU8vTSxlQUFlaUssSUFBSSxDQUFDLElBQUksQ0FBQ25JLEtBQUs7UUFDekMsSUFBSWpDLE9BQU8sSUFBSSxDQUFDN0csR0FBRyxHQUFHK1QsSUFBSSxDQUFDLEVBQUUsQ0FBQzdULE1BQU0sRUFBRWlVO1FBQ3RDLE9BQU8sQ0FBQzdOLFVBQVVqRyxJQUFJLENBQUMsSUFBSSxDQUFDeUksS0FBSyxDQUFDd0UsS0FBSyxDQUFDLElBQUksQ0FBQ3ROLEdBQUcsRUFBRTZHLFVBQ2hELElBQUksQ0FBQ2lDLEtBQUssQ0FBQ3dFLEtBQUssQ0FBQ3pHLE1BQU1BLE9BQU8sT0FBTyxjQUNwQ0EsQ0FBQUEsT0FBTyxNQUFNLElBQUksQ0FBQ2lDLEtBQUssQ0FBQzVJLE1BQU0sSUFDOUIsQ0FBRU0sQ0FBQUEsaUJBQWlCMlQsUUFBUSxJQUFJLENBQUNyTCxLQUFLLENBQUNoQyxVQUFVLENBQUNELE9BQU8sT0FBT3NOLFFBQVEsVUFBVUEsUUFBUSxNQUFLLENBQUM7SUFDcEc7SUFFQSw0QkFBNEI7SUFDNUIsRUFBRTtJQUNGLGlFQUFpRTtJQUNqRSwyREFBMkQ7SUFDM0QsbUVBQW1FO0lBQ25FLGlCQUFpQjtJQUVqQmhCLEtBQUtHLGNBQWMsR0FBRyxTQUFTekYsT0FBTyxFQUFFdUcsUUFBUSxFQUFFM1YsUUFBTztRQUN2RCxJQUFJNFYsWUFBWSxJQUFJLENBQUNqSixJQUFJLEVBQUVzRSxPQUFPLElBQUksQ0FBQ0MsU0FBUyxJQUFJaUU7UUFFcEQsSUFBSSxJQUFJLENBQUNFLEtBQUssQ0FBQ2pHLFVBQVU7WUFDdkJ3RyxZQUFZM1MsUUFBUXlELElBQUk7WUFDeEJ5TyxPQUFPO1FBQ1Q7UUFFQSw4REFBOEQ7UUFDOUQsK0RBQStEO1FBQy9ELGNBQWM7UUFFZCxPQUFRUztZQUNSLEtBQUszUyxRQUFReUMsTUFBTTtZQUFFLEtBQUt6QyxRQUFRNEMsU0FBUztnQkFBRSxPQUFPLElBQUksQ0FBQ2dRLDJCQUEyQixDQUFDNUUsTUFBTTJFLFVBQVV6VCxPQUFPO1lBQzVHLEtBQUtjLFFBQVE2QyxTQUFTO2dCQUFFLE9BQU8sSUFBSSxDQUFDZ1Esc0JBQXNCLENBQUM3RTtZQUMzRCxLQUFLaE8sUUFBUStDLEdBQUc7Z0JBQUUsT0FBTyxJQUFJLENBQUMrUCxnQkFBZ0IsQ0FBQzlFO1lBQy9DLEtBQUtoTyxRQUFRa0QsSUFBSTtnQkFBRSxPQUFPLElBQUksQ0FBQzZQLGlCQUFpQixDQUFDL0U7WUFDakQsS0FBS2hPLFFBQVFtRCxTQUFTO2dCQUNwQix5RUFBeUU7Z0JBQ3pFLHlFQUF5RTtnQkFDekUsMkJBQTJCO2dCQUMzQixJQUFJLFdBQWEsS0FBSSxDQUFDeEYsTUFBTSxJQUFJd08sWUFBWSxRQUFRQSxZQUFZLE9BQU0sS0FBTyxJQUFJLENBQUNwTSxPQUFPLENBQUN5SCxXQUFXLElBQUksR0FBRztvQkFBRSxJQUFJLENBQUN3SSxVQUFVO2dCQUFJO2dCQUNqSSxPQUFPLElBQUksQ0FBQ2dELHNCQUFzQixDQUFDaEYsTUFBTSxPQUFPLENBQUM3QjtZQUNuRCxLQUFLbk0sUUFBUWdFLE1BQU07Z0JBQ2pCLElBQUltSSxTQUFTO29CQUFFLElBQUksQ0FBQzZELFVBQVU7Z0JBQUk7Z0JBQ2xDLE9BQU8sSUFBSSxDQUFDaUQsVUFBVSxDQUFDakYsTUFBTTtZQUMvQixLQUFLaE8sUUFBUW9ELEdBQUc7Z0JBQUUsT0FBTyxJQUFJLENBQUM4UCxnQkFBZ0IsQ0FBQ2xGO1lBQy9DLEtBQUtoTyxRQUFRcUQsT0FBTztnQkFBRSxPQUFPLElBQUksQ0FBQzhQLG9CQUFvQixDQUFDbkY7WUFDdkQsS0FBS2hPLFFBQVFzRCxPQUFPO2dCQUFFLE9BQU8sSUFBSSxDQUFDOFAsb0JBQW9CLENBQUNwRjtZQUN2RCxLQUFLaE8sUUFBUXVELE1BQU07Z0JBQUUsT0FBTyxJQUFJLENBQUM4UCxtQkFBbUIsQ0FBQ3JGO1lBQ3JELEtBQUtoTyxRQUFRd0QsSUFBSTtnQkFBRSxPQUFPLElBQUksQ0FBQzhQLGlCQUFpQixDQUFDdEY7WUFDakQsS0FBS2hPLFFBQVEwRCxNQUFNO1lBQUUsS0FBSzFELFFBQVF5RCxJQUFJO2dCQUNwQ3lPLE9BQU9BLFFBQVEsSUFBSSxDQUFDdkksS0FBSztnQkFDekIsSUFBSXdDLFdBQVcrRixTQUFTLE9BQU87b0JBQUUsSUFBSSxDQUFDbEMsVUFBVTtnQkFBSTtnQkFDcEQsT0FBTyxJQUFJLENBQUN1RCxpQkFBaUIsQ0FBQ3ZGLE1BQU1rRTtZQUN0QyxLQUFLbFMsUUFBUTJELE1BQU07Z0JBQUUsT0FBTyxJQUFJLENBQUM2UCxtQkFBbUIsQ0FBQ3hGO1lBQ3JELEtBQUtoTyxRQUFRNEQsS0FBSztnQkFBRSxPQUFPLElBQUksQ0FBQzZQLGtCQUFrQixDQUFDekY7WUFDbkQsS0FBS2hPLFFBQVFRLE1BQU07Z0JBQUUsT0FBTyxJQUFJLENBQUNrVCxVQUFVLENBQUMsTUFBTTFGO1lBQ2xELEtBQUtoTyxRQUFRYSxJQUFJO2dCQUFFLE9BQU8sSUFBSSxDQUFDOFMsbUJBQW1CLENBQUMzRjtZQUNuRCxLQUFLaE8sUUFBUWtFLE9BQU87WUFDcEIsS0FBS2xFLFFBQVFtRSxPQUFPO2dCQUNsQixJQUFJLElBQUksQ0FBQ3BFLE9BQU8sQ0FBQ3lILFdBQVcsR0FBRyxNQUFNbUwsY0FBYzNTLFFBQVFtRSxPQUFPLEVBQUU7b0JBQ2xFbUIsZUFBZWdLLFNBQVMsR0FBRyxJQUFJLENBQUNoUixHQUFHO29CQUNuQyxJQUFJK1QsT0FBTy9NLGVBQWVpSyxJQUFJLENBQUMsSUFBSSxDQUFDbkksS0FBSztvQkFDekMsSUFBSWpDLE9BQU8sSUFBSSxDQUFDN0csR0FBRyxHQUFHK1QsSUFBSSxDQUFDLEVBQUUsQ0FBQzdULE1BQU0sRUFBRThULFNBQVMsSUFBSSxDQUFDbEwsS0FBSyxDQUFDaEMsVUFBVSxDQUFDRDtvQkFDckUsSUFBSW1OLFdBQVcsTUFBTUEsV0FBVyxJQUM5Qjt3QkFBRSxPQUFPLElBQUksQ0FBQ3NCLHdCQUF3QixDQUFDNUYsTUFBTSxJQUFJLENBQUNpQixlQUFlO29CQUFJO2dCQUN6RTtnQkFFQSxJQUFJLENBQUMsSUFBSSxDQUFDbFAsT0FBTyxDQUFDK0gsMkJBQTJCLEVBQUU7b0JBQzdDLElBQUksQ0FBQzRLLFVBQ0g7d0JBQUUsSUFBSSxDQUFDbEMsS0FBSyxDQUFDLElBQUksQ0FBQ3ZKLEtBQUssRUFBRTtvQkFBMkQ7b0JBQ3RGLElBQUksQ0FBQyxJQUFJLENBQUNxRixRQUFRLEVBQ2hCO3dCQUFFLElBQUksQ0FBQ2tFLEtBQUssQ0FBQyxJQUFJLENBQUN2SixLQUFLLEVBQUU7b0JBQW9FO2dCQUNqRztnQkFDQSxPQUFPMEwsY0FBYzNTLFFBQVFtRSxPQUFPLEdBQUcsSUFBSSxDQUFDMFAsV0FBVyxDQUFDN0YsUUFBUSxJQUFJLENBQUM4RixXQUFXLENBQUM5RixNQUFNalI7WUFFdkYsZ0VBQWdFO1lBQ2hFLDZEQUE2RDtZQUM3RCw2REFBNkQ7WUFDN0Qsd0RBQXdEO1lBQ3hELDREQUE0RDtZQUM5RDtnQkFDRSxJQUFJLElBQUksQ0FBQ3lWLGVBQWUsSUFBSTtvQkFDMUIsSUFBSXJHLFNBQVM7d0JBQUUsSUFBSSxDQUFDNkQsVUFBVTtvQkFBSTtvQkFDbEMsSUFBSSxDQUFDN0ssSUFBSTtvQkFDVCxPQUFPLElBQUksQ0FBQzZOLHNCQUFzQixDQUFDaEYsTUFBTSxNQUFNLENBQUM3QjtnQkFDbEQ7Z0JBRUEsSUFBSTRILFlBQVksSUFBSSxDQUFDcEssS0FBSyxFQUFFNEgsT0FBTyxJQUFJLENBQUN0QyxlQUFlO2dCQUN2RCxJQUFJMEQsY0FBYzNTLFFBQVFMLElBQUksSUFBSTRSLEtBQUs3SCxJQUFJLEtBQUssZ0JBQWdCLElBQUksQ0FBQ2tHLEdBQUcsQ0FBQzVQLFFBQVFjLEtBQUssR0FDcEY7b0JBQUUsT0FBTyxJQUFJLENBQUNrVCxxQkFBcUIsQ0FBQ2hHLE1BQU0rRixXQUFXeEMsTUFBTXBGO2dCQUFTLE9BQ2pFO29CQUFFLE9BQU8sSUFBSSxDQUFDeUgsd0JBQXdCLENBQUM1RixNQUFNdUQ7Z0JBQU07UUFDMUQ7SUFDRjtJQUVBRSxLQUFLbUIsMkJBQTJCLEdBQUcsU0FBUzVFLElBQUksRUFBRTlPLE9BQU87UUFDdkQsSUFBSStVLFVBQVUvVSxZQUFZO1FBQzFCLElBQUksQ0FBQ2lHLElBQUk7UUFDVCxJQUFJLElBQUksQ0FBQ3lLLEdBQUcsQ0FBQzVQLFFBQVFhLElBQUksS0FBSyxJQUFJLENBQUNxUCxlQUFlLElBQUk7WUFBRWxDLEtBQUtoUCxLQUFLLEdBQUc7UUFBTSxPQUN0RSxJQUFJLElBQUksQ0FBQzBLLElBQUksS0FBSzFKLFFBQVFMLElBQUksRUFBRTtZQUFFLElBQUksQ0FBQ3FRLFVBQVU7UUFBSSxPQUNyRDtZQUNIaEMsS0FBS2hQLEtBQUssR0FBRyxJQUFJLENBQUNrVixVQUFVO1lBQzVCLElBQUksQ0FBQy9ELFNBQVM7UUFDaEI7UUFFQSx5REFBeUQ7UUFDekQsZUFBZTtRQUNmLElBQUk1UixJQUFJO1FBQ1IsTUFBT0EsSUFBSSxJQUFJLENBQUNzTyxNQUFNLENBQUNyTyxNQUFNLEVBQUUsRUFBRUQsRUFBRztZQUNsQyxJQUFJNFYsTUFBTSxJQUFJLENBQUN0SCxNQUFNLENBQUN0TyxFQUFFO1lBQ3hCLElBQUl5UCxLQUFLaFAsS0FBSyxJQUFJLFFBQVFtVixJQUFJeFUsSUFBSSxLQUFLcU8sS0FBS2hQLEtBQUssQ0FBQ1csSUFBSSxFQUFFO2dCQUN0RCxJQUFJd1UsSUFBSWpDLElBQUksSUFBSSxRQUFTK0IsQ0FBQUEsV0FBV0UsSUFBSWpDLElBQUksS0FBSyxNQUFLLEdBQUk7b0JBQUU7Z0JBQU07Z0JBQ2xFLElBQUlsRSxLQUFLaFAsS0FBSyxJQUFJaVYsU0FBUztvQkFBRTtnQkFBTTtZQUNyQztRQUNGO1FBQ0EsSUFBSTFWLE1BQU0sSUFBSSxDQUFDc08sTUFBTSxDQUFDck8sTUFBTSxFQUFFO1lBQUUsSUFBSSxDQUFDZ1MsS0FBSyxDQUFDeEMsS0FBSy9HLEtBQUssRUFBRSxpQkFBaUIvSDtRQUFVO1FBQ2xGLE9BQU8sSUFBSSxDQUFDOFMsVUFBVSxDQUFDaEUsTUFBTWlHLFVBQVUsbUJBQW1CO0lBQzVEO0lBRUF4QyxLQUFLb0Isc0JBQXNCLEdBQUcsU0FBUzdFLElBQUk7UUFDekMsSUFBSSxDQUFDN0ksSUFBSTtRQUNULElBQUksQ0FBQ2dMLFNBQVM7UUFDZCxPQUFPLElBQUksQ0FBQzZCLFVBQVUsQ0FBQ2hFLE1BQU07SUFDL0I7SUFFQXlELEtBQUtxQixnQkFBZ0IsR0FBRyxTQUFTOUUsSUFBSTtRQUNuQyxJQUFJLENBQUM3SSxJQUFJO1FBQ1QsSUFBSSxDQUFDMEgsTUFBTSxDQUFDM0QsSUFBSSxDQUFDK0k7UUFDakJqRSxLQUFLMEQsSUFBSSxHQUFHLElBQUksQ0FBQ0UsY0FBYyxDQUFDO1FBQ2hDLElBQUksQ0FBQy9FLE1BQU0sQ0FBQ3VILEdBQUc7UUFDZixJQUFJLENBQUM3RCxNQUFNLENBQUN2USxRQUFRMkQsTUFBTTtRQUMxQnFLLEtBQUtyUCxJQUFJLEdBQUcsSUFBSSxDQUFDMFYsb0JBQW9CO1FBQ3JDLElBQUksSUFBSSxDQUFDdFUsT0FBTyxDQUFDeUgsV0FBVyxJQUFJLEdBQzlCO1lBQUUsSUFBSSxDQUFDb0ksR0FBRyxDQUFDNVAsUUFBUWEsSUFBSTtRQUFHLE9BRTFCO1lBQUUsSUFBSSxDQUFDc1AsU0FBUztRQUFJO1FBQ3RCLE9BQU8sSUFBSSxDQUFDNkIsVUFBVSxDQUFDaEUsTUFBTTtJQUMvQjtJQUVBLGdFQUFnRTtJQUNoRSxrRUFBa0U7SUFDbEUsOERBQThEO0lBQzlELDZEQUE2RDtJQUM3RCxnRUFBZ0U7SUFDaEUsaUVBQWlFO0lBQ2pFLDJCQUEyQjtJQUUzQnlELEtBQUtzQixpQkFBaUIsR0FBRyxTQUFTL0UsSUFBSTtRQUNwQyxJQUFJLENBQUM3SSxJQUFJO1FBQ1QsSUFBSW1QLFVBQVUsSUFBSyxDQUFDdlUsT0FBTyxDQUFDeUgsV0FBVyxJQUFJLEtBQUssSUFBSSxDQUFDaUcsUUFBUSxJQUFJLElBQUksQ0FBQ3FDLGFBQWEsQ0FBQyxXQUFZLElBQUksQ0FBQzdELFlBQVksR0FBRyxDQUFDO1FBQ3JILElBQUksQ0FBQ1ksTUFBTSxDQUFDM0QsSUFBSSxDQUFDK0k7UUFDakIsSUFBSSxDQUFDaEYsVUFBVSxDQUFDO1FBQ2hCLElBQUksQ0FBQ3NELE1BQU0sQ0FBQ3ZRLFFBQVFVLE1BQU07UUFDMUIsSUFBSSxJQUFJLENBQUNnSixJQUFJLEtBQUsxSixRQUFRYSxJQUFJLEVBQUU7WUFDOUIsSUFBSXlULFVBQVUsQ0FBQyxHQUFHO2dCQUFFLElBQUksQ0FBQ3RFLFVBQVUsQ0FBQ3NFO1lBQVU7WUFDOUMsT0FBTyxJQUFJLENBQUNDLFFBQVEsQ0FBQ3ZHLE1BQU07UUFDN0I7UUFDQSxJQUFJb0UsUUFBUSxJQUFJLENBQUNBLEtBQUs7UUFDdEIsSUFBSSxJQUFJLENBQUMxSSxJQUFJLEtBQUsxSixRQUFReUQsSUFBSSxJQUFJLElBQUksQ0FBQ2lHLElBQUksS0FBSzFKLFFBQVEwRCxNQUFNLElBQUkwTyxPQUFPO1lBQ3ZFLElBQUlvQyxTQUFTLElBQUksQ0FBQ3ZHLFNBQVMsSUFBSWlFLE9BQU9FLFFBQVEsUUFBUSxJQUFJLENBQUN6SSxLQUFLO1lBQ2hFLElBQUksQ0FBQ3hFLElBQUk7WUFDVCxJQUFJLENBQUNzUCxRQUFRLENBQUNELFFBQVEsTUFBTXRDO1lBQzVCLElBQUksQ0FBQ0YsVUFBVSxDQUFDd0MsUUFBUTtZQUN4QixJQUFJLENBQUMsSUFBSSxDQUFDOUssSUFBSSxLQUFLMUosUUFBUXVFLEdBQUcsSUFBSyxJQUFJLENBQUN4RSxPQUFPLENBQUN5SCxXQUFXLElBQUksS0FBSyxJQUFJLENBQUNxSSxZQUFZLENBQUMsS0FBSyxLQUFNMkUsT0FBT0UsWUFBWSxDQUFDbFcsTUFBTSxLQUFLLEdBQUc7Z0JBQ2pJLElBQUksSUFBSSxDQUFDdUIsT0FBTyxDQUFDeUgsV0FBVyxJQUFJLEdBQUc7b0JBQ2pDLElBQUksSUFBSSxDQUFDa0MsSUFBSSxLQUFLMUosUUFBUXVFLEdBQUcsRUFBRTt3QkFDN0IsSUFBSStQLFVBQVUsQ0FBQyxHQUFHOzRCQUFFLElBQUksQ0FBQ3RFLFVBQVUsQ0FBQ3NFO3dCQUFVO29CQUNoRCxPQUFPO3dCQUFFdEcsS0FBSzJHLEtBQUssR0FBR0wsVUFBVSxDQUFDO29CQUFHO2dCQUN0QztnQkFDQSxPQUFPLElBQUksQ0FBQ00sVUFBVSxDQUFDNUcsTUFBTXdHO1lBQy9CO1lBQ0EsSUFBSUYsVUFBVSxDQUFDLEdBQUc7Z0JBQUUsSUFBSSxDQUFDdEUsVUFBVSxDQUFDc0U7WUFBVTtZQUM5QyxPQUFPLElBQUksQ0FBQ0MsUUFBUSxDQUFDdkcsTUFBTXdHO1FBQzdCO1FBQ0EsSUFBSUssZ0JBQWdCLElBQUksQ0FBQ2hGLFlBQVksQ0FBQyxRQUFRaUYsVUFBVTtRQUN4RCxJQUFJdEosY0FBYyxJQUFJLENBQUNBLFdBQVc7UUFDbEMsSUFBSXdGLHlCQUF5QixJQUFJUDtRQUNqQyxJQUFJc0UsVUFBVSxJQUFJLENBQUM5TixLQUFLO1FBQ3hCLElBQUkrTixPQUFPVixVQUFVLENBQUMsSUFDbEIsSUFBSSxDQUFDVyxtQkFBbUIsQ0FBQ2pFLHdCQUF3QixXQUNqRCxJQUFJLENBQUMvQixlQUFlLENBQUMsTUFBTStCO1FBQy9CLElBQUksSUFBSSxDQUFDdEgsSUFBSSxLQUFLMUosUUFBUXVFLEdBQUcsSUFBS3VRLENBQUFBLFVBQVUsSUFBSSxDQUFDL1UsT0FBTyxDQUFDeUgsV0FBVyxJQUFJLEtBQUssSUFBSSxDQUFDcUksWUFBWSxDQUFDLEtBQUksR0FBSTtZQUNyRyxJQUFJeUUsVUFBVSxDQUFDLEdBQUc7Z0JBQ2hCLElBQUksSUFBSSxDQUFDNUssSUFBSSxLQUFLMUosUUFBUXVFLEdBQUcsRUFBRTtvQkFBRSxJQUFJLENBQUN5TCxVQUFVLENBQUNzRTtnQkFBVTtnQkFDM0R0RyxLQUFLMkcsS0FBSyxHQUFHO1lBQ2YsT0FBTyxJQUFJRyxXQUFXLElBQUksQ0FBQy9VLE9BQU8sQ0FBQ3lILFdBQVcsSUFBSSxHQUFHO2dCQUNuRCxJQUFJd04sS0FBSy9OLEtBQUssS0FBSzhOLFdBQVcsQ0FBQ3ZKLGVBQWV3SixLQUFLdEwsSUFBSSxLQUFLLGdCQUFnQnNMLEtBQUtyVixJQUFJLEtBQUssU0FBUztvQkFBRSxJQUFJLENBQUNxUSxVQUFVO2dCQUFJLE9BQ25ILElBQUksSUFBSSxDQUFDalEsT0FBTyxDQUFDeUgsV0FBVyxJQUFJLEdBQUc7b0JBQUV3RyxLQUFLMkcsS0FBSyxHQUFHO2dCQUFPO1lBQ2hFO1lBQ0EsSUFBSUUsaUJBQWlCQyxTQUFTO2dCQUFFLElBQUksQ0FBQ3RFLEtBQUssQ0FBQ3dFLEtBQUsvTixLQUFLLEVBQUU7WUFBa0U7WUFDekgsSUFBSSxDQUFDaU8sWUFBWSxDQUFDRixNQUFNLE9BQU9oRTtZQUMvQixJQUFJLENBQUNtRSxnQkFBZ0IsQ0FBQ0g7WUFDdEIsT0FBTyxJQUFJLENBQUNKLFVBQVUsQ0FBQzVHLE1BQU1nSDtRQUMvQixPQUFPO1lBQ0wsSUFBSSxDQUFDN0QscUJBQXFCLENBQUNILHdCQUF3QjtRQUNyRDtRQUNBLElBQUlzRCxVQUFVLENBQUMsR0FBRztZQUFFLElBQUksQ0FBQ3RFLFVBQVUsQ0FBQ3NFO1FBQVU7UUFDOUMsT0FBTyxJQUFJLENBQUNDLFFBQVEsQ0FBQ3ZHLE1BQU1nSDtJQUM3QjtJQUVBdkQsS0FBS3VCLHNCQUFzQixHQUFHLFNBQVNoRixJQUFJLEVBQUVvSCxPQUFPLEVBQUVDLG1CQUFtQjtRQUN2RSxJQUFJLENBQUNsUSxJQUFJO1FBQ1QsT0FBTyxJQUFJLENBQUNtUSxhQUFhLENBQUN0SCxNQUFNdUgsaUJBQWtCRixDQUFBQSxzQkFBc0IsSUFBSUcsc0JBQXFCLEdBQUksT0FBT0o7SUFDOUc7SUFFQTNELEtBQUt5QixnQkFBZ0IsR0FBRyxTQUFTbEYsSUFBSTtRQUNuQyxJQUFJLENBQUM3SSxJQUFJO1FBQ1Q2SSxLQUFLclAsSUFBSSxHQUFHLElBQUksQ0FBQzBWLG9CQUFvQjtRQUNyQyx1RUFBdUU7UUFDdkVyRyxLQUFLeUgsVUFBVSxHQUFHLElBQUksQ0FBQzdELGNBQWMsQ0FBQztRQUN0QzVELEtBQUswSCxTQUFTLEdBQUcsSUFBSSxDQUFDOUYsR0FBRyxDQUFDNVAsUUFBUWdELEtBQUssSUFBSSxJQUFJLENBQUM0TyxjQUFjLENBQUMsUUFBUTtRQUN2RSxPQUFPLElBQUksQ0FBQ0ksVUFBVSxDQUFDaEUsTUFBTTtJQUMvQjtJQUVBeUQsS0FBSzBCLG9CQUFvQixHQUFHLFNBQVNuRixJQUFJO1FBQ3ZDLElBQUksQ0FBQyxJQUFJLENBQUNYLFVBQVUsSUFBSSxDQUFDLElBQUksQ0FBQ3ROLE9BQU8sQ0FBQzhILDBCQUEwQixFQUM5RDtZQUFFLElBQUksQ0FBQzJJLEtBQUssQ0FBQyxJQUFJLENBQUN2SixLQUFLLEVBQUU7UUFBaUM7UUFDNUQsSUFBSSxDQUFDOUIsSUFBSTtRQUVULDBEQUEwRDtRQUMxRCw2REFBNkQ7UUFDN0QsNkJBQTZCO1FBRTdCLElBQUksSUFBSSxDQUFDeUssR0FBRyxDQUFDNVAsUUFBUWEsSUFBSSxLQUFLLElBQUksQ0FBQ3FQLGVBQWUsSUFBSTtZQUFFbEMsS0FBSzJILFFBQVEsR0FBRztRQUFNLE9BQ3pFO1lBQUUzSCxLQUFLMkgsUUFBUSxHQUFHLElBQUksQ0FBQzFHLGVBQWU7WUFBSSxJQUFJLENBQUNrQixTQUFTO1FBQUk7UUFDakUsT0FBTyxJQUFJLENBQUM2QixVQUFVLENBQUNoRSxNQUFNO0lBQy9CO0lBRUF5RCxLQUFLMkIsb0JBQW9CLEdBQUcsU0FBU3BGLElBQUk7UUFDdkMsSUFBSSxDQUFDN0ksSUFBSTtRQUNUNkksS0FBSzRILFlBQVksR0FBRyxJQUFJLENBQUN2QixvQkFBb0I7UUFDN0NyRyxLQUFLNkgsS0FBSyxHQUFHLEVBQUU7UUFDZixJQUFJLENBQUN0RixNQUFNLENBQUN2USxRQUFRUSxNQUFNO1FBQzFCLElBQUksQ0FBQ3FNLE1BQU0sQ0FBQzNELElBQUksQ0FBQ2lKO1FBQ2pCLElBQUksQ0FBQ2xGLFVBQVUsQ0FBQztRQUVoQiw0REFBNEQ7UUFDNUQsOERBQThEO1FBQzlELHdCQUF3QjtRQUV4QixJQUFJNUY7UUFDSixJQUFLLElBQUl5TyxhQUFhLE9BQU8sSUFBSSxDQUFDcE0sSUFBSSxLQUFLMUosUUFBUVMsTUFBTSxFQUFHO1lBQzFELElBQUksSUFBSSxDQUFDaUosSUFBSSxLQUFLMUosUUFBUTBDLEtBQUssSUFBSSxJQUFJLENBQUNnSCxJQUFJLEtBQUsxSixRQUFROEMsUUFBUSxFQUFFO2dCQUNqRSxJQUFJaVQsU0FBUyxJQUFJLENBQUNyTSxJQUFJLEtBQUsxSixRQUFRMEMsS0FBSztnQkFDeEMsSUFBSTJFLEtBQUs7b0JBQUUsSUFBSSxDQUFDMkssVUFBVSxDQUFDM0ssS0FBSztnQkFBZTtnQkFDL0MyRyxLQUFLNkgsS0FBSyxDQUFDM00sSUFBSSxDQUFDN0IsTUFBTSxJQUFJLENBQUM0RyxTQUFTO2dCQUNwQzVHLElBQUlvTyxVQUFVLEdBQUcsRUFBRTtnQkFDbkIsSUFBSSxDQUFDdFEsSUFBSTtnQkFDVCxJQUFJNFEsUUFBUTtvQkFDVjFPLElBQUkxSSxJQUFJLEdBQUcsSUFBSSxDQUFDc1EsZUFBZTtnQkFDakMsT0FBTztvQkFDTCxJQUFJNkcsWUFBWTt3QkFBRSxJQUFJLENBQUM3RSxnQkFBZ0IsQ0FBQyxJQUFJLENBQUNoRixZQUFZLEVBQUU7b0JBQTZCO29CQUN4RjZKLGFBQWE7b0JBQ2J6TyxJQUFJMUksSUFBSSxHQUFHO2dCQUNiO2dCQUNBLElBQUksQ0FBQzRSLE1BQU0sQ0FBQ3ZRLFFBQVFjLEtBQUs7WUFDM0IsT0FBTztnQkFDTCxJQUFJLENBQUN1RyxLQUFLO29CQUFFLElBQUksQ0FBQzJJLFVBQVU7Z0JBQUk7Z0JBQy9CM0ksSUFBSW9PLFVBQVUsQ0FBQ3ZNLElBQUksQ0FBQyxJQUFJLENBQUMwSSxjQUFjLENBQUM7WUFDMUM7UUFDRjtRQUNBLElBQUksQ0FBQ29FLFNBQVM7UUFDZCxJQUFJM08sS0FBSztZQUFFLElBQUksQ0FBQzJLLFVBQVUsQ0FBQzNLLEtBQUs7UUFBZTtRQUMvQyxJQUFJLENBQUNsQyxJQUFJLElBQUksZ0JBQWdCO1FBQzdCLElBQUksQ0FBQzBILE1BQU0sQ0FBQ3VILEdBQUc7UUFDZixPQUFPLElBQUksQ0FBQ3BDLFVBQVUsQ0FBQ2hFLE1BQU07SUFDL0I7SUFFQXlELEtBQUs0QixtQkFBbUIsR0FBRyxTQUFTckYsSUFBSTtRQUN0QyxJQUFJLENBQUM3SSxJQUFJO1FBQ1QsSUFBSVAsVUFBVWpHLElBQUksQ0FBQyxJQUFJLENBQUN5SSxLQUFLLENBQUN3RSxLQUFLLENBQUMsSUFBSSxDQUFDTSxVQUFVLEVBQUUsSUFBSSxDQUFDakYsS0FBSyxJQUM3RDtZQUFFLElBQUksQ0FBQ3VKLEtBQUssQ0FBQyxJQUFJLENBQUN0RSxVQUFVLEVBQUU7UUFBZ0M7UUFDaEU4QixLQUFLMkgsUUFBUSxHQUFHLElBQUksQ0FBQzFHLGVBQWU7UUFDcEMsSUFBSSxDQUFDa0IsU0FBUztRQUNkLE9BQU8sSUFBSSxDQUFDNkIsVUFBVSxDQUFDaEUsTUFBTTtJQUMvQjtJQUVBLGtFQUFrRTtJQUVsRSxJQUFJaUksVUFBVSxFQUFFO0lBRWhCeEUsS0FBS3lFLHFCQUFxQixHQUFHO1FBQzNCLElBQUlDLFFBQVEsSUFBSSxDQUFDQyxnQkFBZ0I7UUFDakMsSUFBSUMsU0FBU0YsTUFBTXpNLElBQUksS0FBSztRQUM1QixJQUFJLENBQUN1RCxVQUFVLENBQUNvSixTQUFTbE0scUJBQXFCO1FBQzlDLElBQUksQ0FBQ2dMLGdCQUFnQixDQUFDZ0IsT0FBT0UsU0FBU3JMLG9CQUFvQkY7UUFDMUQsSUFBSSxDQUFDeUYsTUFBTSxDQUFDdlEsUUFBUVcsTUFBTTtRQUUxQixPQUFPd1Y7SUFDVDtJQUVBMUUsS0FBSzZCLGlCQUFpQixHQUFHLFNBQVN0RixJQUFJO1FBQ3BDLElBQUksQ0FBQzdJLElBQUk7UUFDVDZJLEtBQUszRSxLQUFLLEdBQUcsSUFBSSxDQUFDcUssVUFBVTtRQUM1QjFGLEtBQUtzSSxPQUFPLEdBQUc7UUFDZixJQUFJLElBQUksQ0FBQzVNLElBQUksS0FBSzFKLFFBQVEyQyxNQUFNLEVBQUU7WUFDaEMsSUFBSTRULFNBQVMsSUFBSSxDQUFDdEksU0FBUztZQUMzQixJQUFJLENBQUM5SSxJQUFJO1lBQ1QsSUFBSSxJQUFJLENBQUN5SyxHQUFHLENBQUM1UCxRQUFRVSxNQUFNLEdBQUc7Z0JBQzVCNlYsT0FBT0osS0FBSyxHQUFHLElBQUksQ0FBQ0QscUJBQXFCO1lBQzNDLE9BQU87Z0JBQ0wsSUFBSSxJQUFJLENBQUNuVyxPQUFPLENBQUN5SCxXQUFXLEdBQUcsSUFBSTtvQkFBRSxJQUFJLENBQUN3SSxVQUFVO2dCQUFJO2dCQUN4RHVHLE9BQU9KLEtBQUssR0FBRztnQkFDZixJQUFJLENBQUNsSixVQUFVLENBQUM7WUFDbEI7WUFDQXNKLE9BQU83RSxJQUFJLEdBQUcsSUFBSSxDQUFDZ0MsVUFBVSxDQUFDO1lBQzlCLElBQUksQ0FBQ3NDLFNBQVM7WUFDZGhJLEtBQUtzSSxPQUFPLEdBQUcsSUFBSSxDQUFDdEUsVUFBVSxDQUFDdUUsUUFBUTtRQUN6QztRQUNBdkksS0FBS3dJLFNBQVMsR0FBRyxJQUFJLENBQUM1RyxHQUFHLENBQUM1UCxRQUFRaUQsUUFBUSxJQUFJLElBQUksQ0FBQ3lRLFVBQVUsS0FBSztRQUNsRSxJQUFJLENBQUMxRixLQUFLc0ksT0FBTyxJQUFJLENBQUN0SSxLQUFLd0ksU0FBUyxFQUNsQztZQUFFLElBQUksQ0FBQ2hHLEtBQUssQ0FBQ3hDLEtBQUsvRyxLQUFLLEVBQUU7UUFBb0M7UUFDL0QsT0FBTyxJQUFJLENBQUMrSyxVQUFVLENBQUNoRSxNQUFNO0lBQy9CO0lBRUF5RCxLQUFLOEIsaUJBQWlCLEdBQUcsU0FBU3ZGLElBQUksRUFBRWtFLElBQUksRUFBRXVFLHVCQUF1QjtRQUNuRSxJQUFJLENBQUN0UixJQUFJO1FBQ1QsSUFBSSxDQUFDc1AsUUFBUSxDQUFDekcsTUFBTSxPQUFPa0UsTUFBTXVFO1FBQ2pDLElBQUksQ0FBQ3RHLFNBQVM7UUFDZCxPQUFPLElBQUksQ0FBQzZCLFVBQVUsQ0FBQ2hFLE1BQU07SUFDL0I7SUFFQXlELEtBQUsrQixtQkFBbUIsR0FBRyxTQUFTeEYsSUFBSTtRQUN0QyxJQUFJLENBQUM3SSxJQUFJO1FBQ1Q2SSxLQUFLclAsSUFBSSxHQUFHLElBQUksQ0FBQzBWLG9CQUFvQjtRQUNyQyxJQUFJLENBQUN4SCxNQUFNLENBQUMzRCxJQUFJLENBQUMrSTtRQUNqQmpFLEtBQUswRCxJQUFJLEdBQUcsSUFBSSxDQUFDRSxjQUFjLENBQUM7UUFDaEMsSUFBSSxDQUFDL0UsTUFBTSxDQUFDdUgsR0FBRztRQUNmLE9BQU8sSUFBSSxDQUFDcEMsVUFBVSxDQUFDaEUsTUFBTTtJQUMvQjtJQUVBeUQsS0FBS2dDLGtCQUFrQixHQUFHLFNBQVN6RixJQUFJO1FBQ3JDLElBQUksSUFBSSxDQUFDclEsTUFBTSxFQUFFO1lBQUUsSUFBSSxDQUFDNlMsS0FBSyxDQUFDLElBQUksQ0FBQ3ZKLEtBQUssRUFBRTtRQUEwQjtRQUNwRSxJQUFJLENBQUM5QixJQUFJO1FBQ1Q2SSxLQUFLMEksTUFBTSxHQUFHLElBQUksQ0FBQ3JDLG9CQUFvQjtRQUN2Q3JHLEtBQUswRCxJQUFJLEdBQUcsSUFBSSxDQUFDRSxjQUFjLENBQUM7UUFDaEMsT0FBTyxJQUFJLENBQUNJLFVBQVUsQ0FBQ2hFLE1BQU07SUFDL0I7SUFFQXlELEtBQUtrQyxtQkFBbUIsR0FBRyxTQUFTM0YsSUFBSTtRQUN0QyxJQUFJLENBQUM3SSxJQUFJO1FBQ1QsT0FBTyxJQUFJLENBQUM2TSxVQUFVLENBQUNoRSxNQUFNO0lBQy9CO0lBRUF5RCxLQUFLdUMscUJBQXFCLEdBQUcsU0FBU2hHLElBQUksRUFBRStGLFNBQVMsRUFBRXhDLElBQUksRUFBRXBGLE9BQU87UUFDbEUsSUFBSyxJQUFJd0ssTUFBTSxHQUFHOUUsT0FBTyxJQUFJLENBQUNoRixNQUFNLEVBQUU4SixNQUFNOUUsS0FBS3JULE1BQU0sRUFBRW1ZLE9BQU8sRUFDOUQ7WUFDQSxJQUFJM1gsUUFBUTZTLElBQUksQ0FBQzhFLElBQUk7WUFFckIsSUFBSTNYLE1BQU1XLElBQUksS0FBS29VLFdBQ2pCO2dCQUFFLElBQUksQ0FBQ3ZELEtBQUssQ0FBQ2UsS0FBS3RLLEtBQUssRUFBRSxZQUFZOE0sWUFBWTtZQUNyRDtRQUFFO1FBQ0YsSUFBSTdCLE9BQU8sSUFBSSxDQUFDeEksSUFBSSxDQUFDckssTUFBTSxHQUFHLFNBQVMsSUFBSSxDQUFDcUssSUFBSSxLQUFLMUosUUFBUXNELE9BQU8sR0FBRyxXQUFXO1FBQ2xGLElBQUssSUFBSS9FLElBQUksSUFBSSxDQUFDc08sTUFBTSxDQUFDck8sTUFBTSxHQUFHLEdBQUdELEtBQUssR0FBR0EsSUFBSztZQUNoRCxJQUFJcVksVUFBVSxJQUFJLENBQUMvSixNQUFNLENBQUN0TyxFQUFFO1lBQzVCLElBQUlxWSxRQUFRQyxjQUFjLEtBQUs3SSxLQUFLL0csS0FBSyxFQUFFO2dCQUN6Qyx3REFBd0Q7Z0JBQ3hEMlAsUUFBUUMsY0FBYyxHQUFHLElBQUksQ0FBQzVQLEtBQUs7Z0JBQ25DMlAsUUFBUTFFLElBQUksR0FBR0E7WUFDakIsT0FBTztnQkFBRTtZQUFNO1FBQ2pCO1FBQ0EsSUFBSSxDQUFDckYsTUFBTSxDQUFDM0QsSUFBSSxDQUFDO1lBQUN2SixNQUFNb1U7WUFBVzdCLE1BQU1BO1lBQU0yRSxnQkFBZ0IsSUFBSSxDQUFDNVAsS0FBSztRQUFBO1FBQ3pFK0csS0FBSzBELElBQUksR0FBRyxJQUFJLENBQUNFLGNBQWMsQ0FBQ3pGLFVBQVVBLFFBQVEySyxPQUFPLENBQUMsYUFBYSxDQUFDLElBQUkzSyxVQUFVLFVBQVVBLFVBQVU7UUFDMUcsSUFBSSxDQUFDVSxNQUFNLENBQUN1SCxHQUFHO1FBQ2ZwRyxLQUFLaFAsS0FBSyxHQUFHdVM7UUFDYixPQUFPLElBQUksQ0FBQ1MsVUFBVSxDQUFDaEUsTUFBTTtJQUMvQjtJQUVBeUQsS0FBS21DLHdCQUF3QixHQUFHLFNBQVM1RixJQUFJLEVBQUV1RCxJQUFJO1FBQ2pEdkQsS0FBS3dELFVBQVUsR0FBR0Q7UUFDbEIsSUFBSSxDQUFDcEIsU0FBUztRQUNkLE9BQU8sSUFBSSxDQUFDNkIsVUFBVSxDQUFDaEUsTUFBTTtJQUMvQjtJQUVBLGlFQUFpRTtJQUNqRSw2REFBNkQ7SUFDN0Qsb0JBQW9CO0lBRXBCeUQsS0FBS2lDLFVBQVUsR0FBRyxTQUFTcUQscUJBQXFCLEVBQUUvSSxJQUFJLEVBQUVnSixVQUFVO1FBQ2hFLElBQUtELDBCQUEwQixLQUFLLEdBQUlBLHdCQUF3QjtRQUNoRSxJQUFLL0ksU0FBUyxLQUFLLEdBQUlBLE9BQU8sSUFBSSxDQUFDQyxTQUFTO1FBRTVDRCxLQUFLMEQsSUFBSSxHQUFHLEVBQUU7UUFDZCxJQUFJLENBQUNuQixNQUFNLENBQUN2USxRQUFRUSxNQUFNO1FBQzFCLElBQUl1Vyx1QkFBdUI7WUFBRSxJQUFJLENBQUM5SixVQUFVLENBQUM7UUFBSTtRQUNqRCxNQUFPLElBQUksQ0FBQ3ZELElBQUksS0FBSzFKLFFBQVFTLE1BQU0sQ0FBRTtZQUNuQyxJQUFJa1IsT0FBTyxJQUFJLENBQUNDLGNBQWMsQ0FBQztZQUMvQjVELEtBQUswRCxJQUFJLENBQUN4SSxJQUFJLENBQUN5STtRQUNqQjtRQUNBLElBQUlxRixZQUFZO1lBQUUsSUFBSSxDQUFDclosTUFBTSxHQUFHO1FBQU87UUFDdkMsSUFBSSxDQUFDd0gsSUFBSTtRQUNULElBQUk0Uix1QkFBdUI7WUFBRSxJQUFJLENBQUNmLFNBQVM7UUFBSTtRQUMvQyxPQUFPLElBQUksQ0FBQ2hFLFVBQVUsQ0FBQ2hFLE1BQU07SUFDL0I7SUFFQSx5REFBeUQ7SUFDekQsa0VBQWtFO0lBQ2xFLGNBQWM7SUFFZHlELEtBQUs4QyxRQUFRLEdBQUcsU0FBU3ZHLElBQUksRUFBRWdILElBQUk7UUFDakNoSCxLQUFLZ0gsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ3pFLE1BQU0sQ0FBQ3ZRLFFBQVFhLElBQUk7UUFDeEJtTixLQUFLclAsSUFBSSxHQUFHLElBQUksQ0FBQytLLElBQUksS0FBSzFKLFFBQVFhLElBQUksR0FBRyxPQUFPLElBQUksQ0FBQ29PLGVBQWU7UUFDcEUsSUFBSSxDQUFDc0IsTUFBTSxDQUFDdlEsUUFBUWEsSUFBSTtRQUN4Qm1OLEtBQUtpSixNQUFNLEdBQUcsSUFBSSxDQUFDdk4sSUFBSSxLQUFLMUosUUFBUVcsTUFBTSxHQUFHLE9BQU8sSUFBSSxDQUFDc08sZUFBZTtRQUN4RSxJQUFJLENBQUNzQixNQUFNLENBQUN2USxRQUFRVyxNQUFNO1FBQzFCcU4sS0FBSzBELElBQUksR0FBRyxJQUFJLENBQUNFLGNBQWMsQ0FBQztRQUNoQyxJQUFJLENBQUNvRSxTQUFTO1FBQ2QsSUFBSSxDQUFDbkosTUFBTSxDQUFDdUgsR0FBRztRQUNmLE9BQU8sSUFBSSxDQUFDcEMsVUFBVSxDQUFDaEUsTUFBTTtJQUMvQjtJQUVBLDJEQUEyRDtJQUMzRCxrQ0FBa0M7SUFFbEN5RCxLQUFLbUQsVUFBVSxHQUFHLFNBQVM1RyxJQUFJLEVBQUVnSCxJQUFJO1FBQ25DLElBQUlrQyxVQUFVLElBQUksQ0FBQ3hOLElBQUksS0FBSzFKLFFBQVF1RSxHQUFHO1FBQ3ZDLElBQUksQ0FBQ1ksSUFBSTtRQUVULElBQ0U2UCxLQUFLdEwsSUFBSSxLQUFLLHlCQUNkc0wsS0FBS04sWUFBWSxDQUFDLEVBQUUsQ0FBQ00sSUFBSSxJQUFJLFFBRTNCLEVBQUNrQyxXQUNELElBQUksQ0FBQ25YLE9BQU8sQ0FBQ3lILFdBQVcsR0FBRyxLQUMzQixJQUFJLENBQUM3SixNQUFNLElBQ1hxWCxLQUFLOUMsSUFBSSxLQUFLLFNBQ2Q4QyxLQUFLTixZQUFZLENBQUMsRUFBRSxDQUFDeUMsRUFBRSxDQUFDek4sSUFBSSxLQUFLLFlBQVcsR0FFOUM7WUFDQSxJQUFJLENBQUM4RyxLQUFLLENBQ1J3RSxLQUFLL04sS0FBSyxFQUNULENBQUNpUSxVQUFVLFdBQVcsUUFBTyxJQUFLO1FBRXZDO1FBQ0FsSixLQUFLb0osSUFBSSxHQUFHcEM7UUFDWmhILEtBQUtxSixLQUFLLEdBQUdILFVBQVUsSUFBSSxDQUFDakksZUFBZSxLQUFLLElBQUksQ0FBQ3FJLGdCQUFnQjtRQUNyRSxJQUFJLENBQUMvRyxNQUFNLENBQUN2USxRQUFRVyxNQUFNO1FBQzFCcU4sS0FBSzBELElBQUksR0FBRyxJQUFJLENBQUNFLGNBQWMsQ0FBQztRQUNoQyxJQUFJLENBQUNvRSxTQUFTO1FBQ2QsSUFBSSxDQUFDbkosTUFBTSxDQUFDdUgsR0FBRztRQUNmLE9BQU8sSUFBSSxDQUFDcEMsVUFBVSxDQUFDaEUsTUFBTWtKLFVBQVUsbUJBQW1CO0lBQzVEO0lBRUEseUNBQXlDO0lBRXpDekYsS0FBS2dELFFBQVEsR0FBRyxTQUFTekcsSUFBSSxFQUFFdUosS0FBSyxFQUFFckYsSUFBSSxFQUFFdUUsdUJBQXVCO1FBQ2pFekksS0FBSzBHLFlBQVksR0FBRyxFQUFFO1FBQ3RCMUcsS0FBS2tFLElBQUksR0FBR0E7UUFDWixPQUFTO1lBQ1AsSUFBSXNGLE9BQU8sSUFBSSxDQUFDdkosU0FBUztZQUN6QixJQUFJLENBQUN3SixVQUFVLENBQUNELE1BQU10RjtZQUN0QixJQUFJLElBQUksQ0FBQ3RDLEdBQUcsQ0FBQzVQLFFBQVF3QixFQUFFLEdBQUc7Z0JBQ3hCZ1csS0FBS3hDLElBQUksR0FBRyxJQUFJLENBQUNzQyxnQkFBZ0IsQ0FBQ0M7WUFDcEMsT0FBTyxJQUFJLENBQUNkLDJCQUEyQnZFLFNBQVMsV0FBVyxDQUFFLEtBQUksQ0FBQ3hJLElBQUksS0FBSzFKLFFBQVF1RSxHQUFHLElBQUssSUFBSSxDQUFDeEUsT0FBTyxDQUFDeUgsV0FBVyxJQUFJLEtBQUssSUFBSSxDQUFDcUksWUFBWSxDQUFDLEtBQUssR0FBSTtnQkFDckosSUFBSSxDQUFDRyxVQUFVO1lBQ2pCLE9BQU8sSUFBSSxDQUFDeUcsMkJBQTJCZSxLQUFLTCxFQUFFLENBQUN6TixJQUFJLEtBQUssZ0JBQWdCLENBQUU2TixDQUFBQSxTQUFVLEtBQUksQ0FBQzdOLElBQUksS0FBSzFKLFFBQVF1RSxHQUFHLElBQUksSUFBSSxDQUFDc0wsWUFBWSxDQUFDLEtBQUksQ0FBQyxHQUFJO2dCQUMxSSxJQUFJLENBQUNXLEtBQUssQ0FBQyxJQUFJLENBQUN0RSxVQUFVLEVBQUU7WUFDOUIsT0FBTztnQkFDTHNMLEtBQUt4QyxJQUFJLEdBQUc7WUFDZDtZQUNBaEgsS0FBSzBHLFlBQVksQ0FBQ3hMLElBQUksQ0FBQyxJQUFJLENBQUM4SSxVQUFVLENBQUN3RixNQUFNO1lBQzdDLElBQUksQ0FBQyxJQUFJLENBQUM1SCxHQUFHLENBQUM1UCxRQUFRWSxLQUFLLEdBQUc7Z0JBQUU7WUFBTTtRQUN4QztRQUNBLE9BQU9vTjtJQUNUO0lBRUF5RCxLQUFLZ0csVUFBVSxHQUFHLFNBQVNELElBQUksRUFBRXRGLElBQUk7UUFDbkNzRixLQUFLTCxFQUFFLEdBQUcsSUFBSSxDQUFDZixnQkFBZ0I7UUFDL0IsSUFBSSxDQUFDakIsZ0JBQWdCLENBQUNxQyxLQUFLTCxFQUFFLEVBQUVqRixTQUFTLFFBQVFySCxXQUFXQyxjQUFjO0lBQzNFO0lBRUEsSUFBSXlLLGlCQUFpQixHQUFHQyx5QkFBeUIsR0FBR2tDLG1CQUFtQjtJQUV2RSw0REFBNEQ7SUFDNUQsaUNBQWlDO0lBRWpDLDBFQUEwRTtJQUMxRWpHLEtBQUs2RCxhQUFhLEdBQUcsU0FBU3RILElBQUksRUFBRTJKLFNBQVMsRUFBRUMsbUJBQW1CLEVBQUV4QyxPQUFPLEVBQUV5QyxPQUFPO1FBQ2xGLElBQUksQ0FBQ0MsWUFBWSxDQUFDOUo7UUFDbEIsSUFBSSxJQUFJLENBQUNqTyxPQUFPLENBQUN5SCxXQUFXLElBQUksS0FBSyxJQUFJLENBQUN6SCxPQUFPLENBQUN5SCxXQUFXLElBQUksS0FBSyxDQUFDNE4sU0FBUztZQUM5RSxJQUFJLElBQUksQ0FBQzFMLElBQUksS0FBSzFKLFFBQVFxQyxJQUFJLElBQUtzVixZQUFZbkMsd0JBQzdDO2dCQUFFLElBQUksQ0FBQ3hGLFVBQVU7WUFBSTtZQUN2QmhDLEtBQUtyRCxTQUFTLEdBQUcsSUFBSSxDQUFDaUYsR0FBRyxDQUFDNVAsUUFBUXFDLElBQUk7UUFDeEM7UUFDQSxJQUFJLElBQUksQ0FBQ3RDLE9BQU8sQ0FBQ3lILFdBQVcsSUFBSSxHQUM5QjtZQUFFd0csS0FBS3RELEtBQUssR0FBRyxDQUFDLENBQUMwSztRQUFTO1FBRTVCLElBQUl1QyxZQUFZcEMsZ0JBQWdCO1lBQzlCdkgsS0FBS21KLEVBQUUsR0FBRyxZQUFhTyxvQkFBcUIsSUFBSSxDQUFDaE8sSUFBSSxLQUFLMUosUUFBUUwsSUFBSSxHQUFHLE9BQU8sSUFBSSxDQUFDdVUsVUFBVTtZQUMvRixJQUFJbEcsS0FBS21KLEVBQUUsSUFBSSxDQUFFUSxDQUFBQSxZQUFZbkMsc0JBQXFCLEdBQ2hELHFFQUFxRTtZQUNyRSx1RUFBdUU7WUFDdkUsdURBQXVEO1lBQ3ZELHdCQUF3QjtZQUN4QjtnQkFBRSxJQUFJLENBQUN1QyxlQUFlLENBQUMvSixLQUFLbUosRUFBRSxFQUFFLElBQUssQ0FBQ3haLE1BQU0sSUFBSXFRLEtBQUtyRCxTQUFTLElBQUlxRCxLQUFLdEQsS0FBSyxHQUFJLElBQUksQ0FBQ2tELG1CQUFtQixHQUFHL0MsV0FBV0MsZUFBZUM7WUFBZ0I7UUFDeko7UUFFQSxJQUFJaU4sY0FBYyxJQUFJLENBQUN0TCxRQUFRLEVBQUV1TCxjQUFjLElBQUksQ0FBQ3RMLFFBQVEsRUFBRXVMLG1CQUFtQixJQUFJLENBQUN0TCxhQUFhO1FBQ25HLElBQUksQ0FBQ0YsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ0ssVUFBVSxDQUFDeEMsY0FBY3VELEtBQUt0RCxLQUFLLEVBQUVzRCxLQUFLckQsU0FBUztRQUV4RCxJQUFJLENBQUVnTixDQUFBQSxZQUFZcEMsY0FBYSxHQUM3QjtZQUFFdkgsS0FBS21KLEVBQUUsR0FBRyxJQUFJLENBQUN6TixJQUFJLEtBQUsxSixRQUFRTCxJQUFJLEdBQUcsSUFBSSxDQUFDdVUsVUFBVSxLQUFLO1FBQU07UUFFckUsSUFBSSxDQUFDaUUsbUJBQW1CLENBQUNuSztRQUN6QixJQUFJLENBQUNvSyxpQkFBaUIsQ0FBQ3BLLE1BQU00SixxQkFBcUIsT0FBT0M7UUFFekQsSUFBSSxDQUFDbkwsUUFBUSxHQUFHc0w7UUFDaEIsSUFBSSxDQUFDckwsUUFBUSxHQUFHc0w7UUFDaEIsSUFBSSxDQUFDckwsYUFBYSxHQUFHc0w7UUFDckIsT0FBTyxJQUFJLENBQUNsRyxVQUFVLENBQUNoRSxNQUFNLFlBQWF1SCxpQkFBa0Isd0JBQXdCO0lBQ3RGO0lBRUE5RCxLQUFLMEcsbUJBQW1CLEdBQUcsU0FBU25LLElBQUk7UUFDdEMsSUFBSSxDQUFDdUMsTUFBTSxDQUFDdlEsUUFBUVUsTUFBTTtRQUMxQnNOLEtBQUtxSyxNQUFNLEdBQUcsSUFBSSxDQUFDQyxnQkFBZ0IsQ0FBQ3RZLFFBQVFXLE1BQU0sRUFBRSxPQUFPLElBQUksQ0FBQ1osT0FBTyxDQUFDeUgsV0FBVyxJQUFJO1FBQ3ZGLElBQUksQ0FBQzZKLDhCQUE4QjtJQUNyQztJQUVBLHlEQUF5RDtJQUN6RCw0QkFBNEI7SUFFNUJJLEtBQUt3QixVQUFVLEdBQUcsU0FBU2pGLElBQUksRUFBRXVLLFdBQVc7UUFDMUMsSUFBSSxDQUFDcFQsSUFBSTtRQUVULGtDQUFrQztRQUNsQyxpREFBaUQ7UUFDakQsSUFBSXFULFlBQVksSUFBSSxDQUFDN2EsTUFBTTtRQUMzQixJQUFJLENBQUNBLE1BQU0sR0FBRztRQUVkLElBQUksQ0FBQzhhLFlBQVksQ0FBQ3pLLE1BQU11SztRQUN4QixJQUFJLENBQUNHLGVBQWUsQ0FBQzFLO1FBQ3JCLElBQUkySyxpQkFBaUIsSUFBSSxDQUFDQyxjQUFjO1FBQ3hDLElBQUlDLFlBQVksSUFBSSxDQUFDNUssU0FBUztRQUM5QixJQUFJNkssaUJBQWlCO1FBQ3JCRCxVQUFVbkgsSUFBSSxHQUFHLEVBQUU7UUFDbkIsSUFBSSxDQUFDbkIsTUFBTSxDQUFDdlEsUUFBUVEsTUFBTTtRQUMxQixNQUFPLElBQUksQ0FBQ2tKLElBQUksS0FBSzFKLFFBQVFTLE1BQU0sQ0FBRTtZQUNuQyxJQUFJc1ksVUFBVSxJQUFJLENBQUNDLGlCQUFpQixDQUFDaEwsS0FBS2lMLFVBQVUsS0FBSztZQUN6RCxJQUFJRixTQUFTO2dCQUNYRixVQUFVbkgsSUFBSSxDQUFDeEksSUFBSSxDQUFDNlA7Z0JBQ3BCLElBQUlBLFFBQVFyUCxJQUFJLEtBQUssc0JBQXNCcVAsUUFBUTdHLElBQUksS0FBSyxlQUFlO29CQUN6RSxJQUFJNEcsZ0JBQWdCO3dCQUFFLElBQUksQ0FBQzdILGdCQUFnQixDQUFDOEgsUUFBUTlSLEtBQUssRUFBRTtvQkFBNEM7b0JBQ3ZHNlIsaUJBQWlCO2dCQUNuQixPQUFPLElBQUlDLFFBQVFHLEdBQUcsSUFBSUgsUUFBUUcsR0FBRyxDQUFDeFAsSUFBSSxLQUFLLHVCQUF1QnlQLHdCQUF3QlIsZ0JBQWdCSSxVQUFVO29CQUN0SCxJQUFJLENBQUM5SCxnQkFBZ0IsQ0FBQzhILFFBQVFHLEdBQUcsQ0FBQ2pTLEtBQUssRUFBRyxrQkFBbUI4UixRQUFRRyxHQUFHLENBQUN2WixJQUFJLEdBQUk7Z0JBQ25GO1lBQ0Y7UUFDRjtRQUNBLElBQUksQ0FBQ2hDLE1BQU0sR0FBRzZhO1FBQ2QsSUFBSSxDQUFDclQsSUFBSTtRQUNUNkksS0FBSzBELElBQUksR0FBRyxJQUFJLENBQUNNLFVBQVUsQ0FBQzZHLFdBQVc7UUFDdkMsSUFBSSxDQUFDTyxhQUFhO1FBQ2xCLE9BQU8sSUFBSSxDQUFDcEgsVUFBVSxDQUFDaEUsTUFBTXVLLGNBQWMscUJBQXFCO0lBQ2xFO0lBRUE5RyxLQUFLdUgsaUJBQWlCLEdBQUcsU0FBU0ssc0JBQXNCO1FBQ3RELElBQUksSUFBSSxDQUFDekosR0FBRyxDQUFDNVAsUUFBUWEsSUFBSSxHQUFHO1lBQUUsT0FBTztRQUFLO1FBRTFDLElBQUkyRyxjQUFjLElBQUksQ0FBQ3pILE9BQU8sQ0FBQ3lILFdBQVc7UUFDMUMsSUFBSXdHLE9BQU8sSUFBSSxDQUFDQyxTQUFTO1FBQ3pCLElBQUlxTCxVQUFVO1FBQ2QsSUFBSUMsY0FBYztRQUNsQixJQUFJbkUsVUFBVTtRQUNkLElBQUlsRCxPQUFPO1FBQ1gsSUFBSXNILFdBQVc7UUFFZixJQUFJLElBQUksQ0FBQzFKLGFBQWEsQ0FBQyxXQUFXO1lBQ2hDLDBCQUEwQjtZQUMxQixJQUFJdEksZUFBZSxNQUFNLElBQUksQ0FBQ29JLEdBQUcsQ0FBQzVQLFFBQVFRLE1BQU0sR0FBRztnQkFDakQsSUFBSSxDQUFDaVoscUJBQXFCLENBQUN6TDtnQkFDM0IsT0FBT0E7WUFDVDtZQUNBLElBQUksSUFBSSxDQUFDMEwsdUJBQXVCLE1BQU0sSUFBSSxDQUFDaFEsSUFBSSxLQUFLMUosUUFBUXFDLElBQUksRUFBRTtnQkFDaEVtWCxXQUFXO1lBQ2IsT0FBTztnQkFDTEYsVUFBVTtZQUNaO1FBQ0Y7UUFDQXRMLEtBQUsyTCxNQUFNLEdBQUdIO1FBQ2QsSUFBSSxDQUFDRixXQUFXOVIsZUFBZSxLQUFLLElBQUksQ0FBQ3NJLGFBQWEsQ0FBQyxVQUFVO1lBQy9ELElBQUksQ0FBQyxJQUFJLENBQUM0Six1QkFBdUIsTUFBTSxJQUFJLENBQUNoUSxJQUFJLEtBQUsxSixRQUFRcUMsSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDNE4sa0JBQWtCLElBQUk7Z0JBQ2hHbUYsVUFBVTtZQUNaLE9BQU87Z0JBQ0xrRSxVQUFVO1lBQ1o7UUFDRjtRQUNBLElBQUksQ0FBQ0EsV0FBWTlSLENBQUFBLGVBQWUsS0FBSyxDQUFDNE4sT0FBTSxLQUFNLElBQUksQ0FBQ3hGLEdBQUcsQ0FBQzVQLFFBQVFxQyxJQUFJLEdBQUc7WUFDeEVrWCxjQUFjO1FBQ2hCO1FBQ0EsSUFBSSxDQUFDRCxXQUFXLENBQUNsRSxXQUFXLENBQUNtRSxhQUFhO1lBQ3hDLElBQUlLLFlBQVksSUFBSSxDQUFDalEsS0FBSztZQUMxQixJQUFJLElBQUksQ0FBQ21HLGFBQWEsQ0FBQyxVQUFVLElBQUksQ0FBQ0EsYUFBYSxDQUFDLFFBQVE7Z0JBQzFELElBQUksSUFBSSxDQUFDNEosdUJBQXVCLElBQUk7b0JBQ2xDeEgsT0FBTzBIO2dCQUNULE9BQU87b0JBQ0xOLFVBQVVNO2dCQUNaO1lBQ0Y7UUFDRjtRQUVBLHFCQUFxQjtRQUNyQixJQUFJTixTQUFTO1lBQ1gsc0VBQXNFO1lBQ3RFLDREQUE0RDtZQUM1RHRMLEtBQUs2TCxRQUFRLEdBQUc7WUFDaEI3TCxLQUFLa0wsR0FBRyxHQUFHLElBQUksQ0FBQ1ksV0FBVyxDQUFDLElBQUksQ0FBQzdOLFlBQVksRUFBRSxJQUFJLENBQUNELGVBQWU7WUFDbkVnQyxLQUFLa0wsR0FBRyxDQUFDdlosSUFBSSxHQUFHMlo7WUFDaEIsSUFBSSxDQUFDdEgsVUFBVSxDQUFDaEUsS0FBS2tMLEdBQUcsRUFBRTtRQUM1QixPQUFPO1lBQ0wsSUFBSSxDQUFDYSxxQkFBcUIsQ0FBQy9MO1FBQzdCO1FBRUEsc0JBQXNCO1FBQ3RCLElBQUl4RyxjQUFjLE1BQU0sSUFBSSxDQUFDa0MsSUFBSSxLQUFLMUosUUFBUVUsTUFBTSxJQUFJd1IsU0FBUyxZQUFZcUgsZUFBZW5FLFNBQVM7WUFDbkcsSUFBSTRFLGdCQUFnQixDQUFDaE0sS0FBSzJMLE1BQU0sSUFBSU0sYUFBYWpNLE1BQU07WUFDdkQsSUFBSWtNLG9CQUFvQkYsaUJBQWlCWDtZQUN6QywwRkFBMEY7WUFDMUYsSUFBSVcsaUJBQWlCOUgsU0FBUyxVQUFVO2dCQUFFLElBQUksQ0FBQzFCLEtBQUssQ0FBQ3hDLEtBQUtrTCxHQUFHLENBQUNqUyxLQUFLLEVBQUU7WUFBNEM7WUFDakgrRyxLQUFLa0UsSUFBSSxHQUFHOEgsZ0JBQWdCLGdCQUFnQjlIO1lBQzVDLElBQUksQ0FBQ2lJLGdCQUFnQixDQUFDbk0sTUFBTXVMLGFBQWFuRSxTQUFTOEU7UUFDcEQsT0FBTztZQUNMLElBQUksQ0FBQ0UsZUFBZSxDQUFDcE07UUFDdkI7UUFFQSxPQUFPQTtJQUNUO0lBRUF5RCxLQUFLaUksdUJBQXVCLEdBQUc7UUFDN0IsT0FDRSxJQUFJLENBQUNoUSxJQUFJLEtBQUsxSixRQUFRTCxJQUFJLElBQzFCLElBQUksQ0FBQytKLElBQUksS0FBSzFKLFFBQVFJLFNBQVMsSUFDL0IsSUFBSSxDQUFDc0osSUFBSSxLQUFLMUosUUFBUUMsR0FBRyxJQUN6QixJQUFJLENBQUN5SixJQUFJLEtBQUsxSixRQUFRRyxNQUFNLElBQzVCLElBQUksQ0FBQ3VKLElBQUksS0FBSzFKLFFBQVFNLFFBQVEsSUFDOUIsSUFBSSxDQUFDb0osSUFBSSxDQUFDeEssT0FBTztJQUVyQjtJQUVBdVMsS0FBS3NJLHFCQUFxQixHQUFHLFNBQVNoQixPQUFPO1FBQzNDLElBQUksSUFBSSxDQUFDclAsSUFBSSxLQUFLMUosUUFBUUksU0FBUyxFQUFFO1lBQ25DLElBQUksSUFBSSxDQUFDdUosS0FBSyxLQUFLLGVBQWU7Z0JBQ2hDLElBQUksQ0FBQzZHLEtBQUssQ0FBQyxJQUFJLENBQUN2SixLQUFLLEVBQUU7WUFDekI7WUFDQThSLFFBQVFjLFFBQVEsR0FBRztZQUNuQmQsUUFBUUcsR0FBRyxHQUFHLElBQUksQ0FBQ21CLGlCQUFpQjtRQUN0QyxPQUFPO1lBQ0wsSUFBSSxDQUFDQyxpQkFBaUIsQ0FBQ3ZCO1FBQ3pCO0lBQ0Y7SUFFQXRILEtBQUswSSxnQkFBZ0IsR0FBRyxTQUFTSSxNQUFNLEVBQUVoQixXQUFXLEVBQUVuRSxPQUFPLEVBQUU4RSxpQkFBaUI7UUFDOUUsc0JBQXNCO1FBQ3RCLElBQUloQixNQUFNcUIsT0FBT3JCLEdBQUc7UUFDcEIsSUFBSXFCLE9BQU9ySSxJQUFJLEtBQUssZUFBZTtZQUNqQyxJQUFJcUgsYUFBYTtnQkFBRSxJQUFJLENBQUMvSSxLQUFLLENBQUMwSSxJQUFJalMsS0FBSyxFQUFFO1lBQXFDO1lBQzlFLElBQUltTyxTQUFTO2dCQUFFLElBQUksQ0FBQzVFLEtBQUssQ0FBQzBJLElBQUlqUyxLQUFLLEVBQUU7WUFBeUM7UUFDaEYsT0FBTyxJQUFJc1QsT0FBT1osTUFBTSxJQUFJTSxhQUFhTSxRQUFRLGNBQWM7WUFDN0QsSUFBSSxDQUFDL0osS0FBSyxDQUFDMEksSUFBSWpTLEtBQUssRUFBRTtRQUN4QjtRQUVBLGNBQWM7UUFDZCxJQUFJMEMsUUFBUTRRLE9BQU81USxLQUFLLEdBQUcsSUFBSSxDQUFDNlEsV0FBVyxDQUFDakIsYUFBYW5FLFNBQVM4RTtRQUVsRSxjQUFjO1FBQ2QsSUFBSUssT0FBT3JJLElBQUksS0FBSyxTQUFTdkksTUFBTTBPLE1BQU0sQ0FBQzdaLE1BQU0sS0FBSyxHQUNuRDtZQUFFLElBQUksQ0FBQ3lTLGdCQUFnQixDQUFDdEgsTUFBTTFDLEtBQUssRUFBRTtRQUFpQztRQUN4RSxJQUFJc1QsT0FBT3JJLElBQUksS0FBSyxTQUFTdkksTUFBTTBPLE1BQU0sQ0FBQzdaLE1BQU0sS0FBSyxHQUNuRDtZQUFFLElBQUksQ0FBQ3lTLGdCQUFnQixDQUFDdEgsTUFBTTFDLEtBQUssRUFBRTtRQUF5QztRQUNoRixJQUFJc1QsT0FBT3JJLElBQUksS0FBSyxTQUFTdkksTUFBTTBPLE1BQU0sQ0FBQyxFQUFFLENBQUMzTyxJQUFJLEtBQUssZUFDcEQ7WUFBRSxJQUFJLENBQUN1SCxnQkFBZ0IsQ0FBQ3RILE1BQU0wTyxNQUFNLENBQUMsRUFBRSxDQUFDcFIsS0FBSyxFQUFFO1FBQWtDO1FBRW5GLE9BQU8sSUFBSSxDQUFDK0ssVUFBVSxDQUFDdUksUUFBUTtJQUNqQztJQUVBOUksS0FBSzJJLGVBQWUsR0FBRyxTQUFTSyxLQUFLO1FBQ25DLElBQUlSLGFBQWFRLE9BQU8sZ0JBQWdCO1lBQ3RDLElBQUksQ0FBQ2pLLEtBQUssQ0FBQ2lLLE1BQU12QixHQUFHLENBQUNqUyxLQUFLLEVBQUU7UUFDOUIsT0FBTyxJQUFJd1QsTUFBTWQsTUFBTSxJQUFJTSxhQUFhUSxPQUFPLGNBQWM7WUFDM0QsSUFBSSxDQUFDakssS0FBSyxDQUFDaUssTUFBTXZCLEdBQUcsQ0FBQ2pTLEtBQUssRUFBRTtRQUM5QjtRQUVBLElBQUksSUFBSSxDQUFDMkksR0FBRyxDQUFDNVAsUUFBUXdCLEVBQUUsR0FBRztZQUN4QixpRUFBaUU7WUFDakUsSUFBSSxDQUFDeUwsVUFBVSxDQUFDMUMseUJBQXlCSDtZQUN6Q3FRLE1BQU05USxLQUFLLEdBQUcsSUFBSSxDQUFDMk4sZ0JBQWdCO1lBQ25DLElBQUksQ0FBQ3RCLFNBQVM7UUFDaEIsT0FBTztZQUNMeUUsTUFBTTlRLEtBQUssR0FBRztRQUNoQjtRQUNBLElBQUksQ0FBQ3dHLFNBQVM7UUFFZCxPQUFPLElBQUksQ0FBQzZCLFVBQVUsQ0FBQ3lJLE9BQU87SUFDaEM7SUFFQWhKLEtBQUtnSSxxQkFBcUIsR0FBRyxTQUFTekwsSUFBSTtRQUN4Q0EsS0FBSzBELElBQUksR0FBRyxFQUFFO1FBRWQsSUFBSWdKLFlBQVksSUFBSSxDQUFDN04sTUFBTTtRQUMzQixJQUFJLENBQUNBLE1BQU0sR0FBRyxFQUFFO1FBQ2hCLElBQUksQ0FBQ0ksVUFBVSxDQUFDM0MsMkJBQTJCRjtRQUMzQyxNQUFPLElBQUksQ0FBQ1YsSUFBSSxLQUFLMUosUUFBUVMsTUFBTSxDQUFFO1lBQ25DLElBQUlrUixPQUFPLElBQUksQ0FBQ0MsY0FBYyxDQUFDO1lBQy9CNUQsS0FBSzBELElBQUksQ0FBQ3hJLElBQUksQ0FBQ3lJO1FBQ2pCO1FBQ0EsSUFBSSxDQUFDeE0sSUFBSTtRQUNULElBQUksQ0FBQzZRLFNBQVM7UUFDZCxJQUFJLENBQUNuSixNQUFNLEdBQUc2TjtRQUVkLE9BQU8sSUFBSSxDQUFDMUksVUFBVSxDQUFDaEUsTUFBTTtJQUMvQjtJQUVBeUQsS0FBS2dILFlBQVksR0FBRyxTQUFTekssSUFBSSxFQUFFdUssV0FBVztRQUM1QyxJQUFJLElBQUksQ0FBQzdPLElBQUksS0FBSzFKLFFBQVFMLElBQUksRUFBRTtZQUM5QnFPLEtBQUttSixFQUFFLEdBQUcsSUFBSSxDQUFDakQsVUFBVTtZQUN6QixJQUFJcUUsYUFDRjtnQkFBRSxJQUFJLENBQUNSLGVBQWUsQ0FBQy9KLEtBQUttSixFQUFFLEVBQUVyTSxjQUFjO1lBQVE7UUFDMUQsT0FBTztZQUNMLElBQUl5TixnQkFBZ0IsTUFDbEI7Z0JBQUUsSUFBSSxDQUFDdkksVUFBVTtZQUFJO1lBQ3ZCaEMsS0FBS21KLEVBQUUsR0FBRztRQUNaO0lBQ0Y7SUFFQTFGLEtBQUtpSCxlQUFlLEdBQUcsU0FBUzFLLElBQUk7UUFDbENBLEtBQUtpTCxVQUFVLEdBQUcsSUFBSSxDQUFDckosR0FBRyxDQUFDNVAsUUFBUWlFLFFBQVEsSUFBSSxJQUFJLENBQUNnUixtQkFBbUIsQ0FBQyxNQUFNLFNBQVM7SUFDekY7SUFFQXhELEtBQUttSCxjQUFjLEdBQUc7UUFDcEIsSUFBSUcsVUFBVTtZQUFDNEIsVUFBVW5WLE9BQU9XLE1BQU0sQ0FBQztZQUFPeVUsTUFBTSxFQUFFO1FBQUE7UUFDdEQsSUFBSSxDQUFDek4sZ0JBQWdCLENBQUNqRSxJQUFJLENBQUM2UDtRQUMzQixPQUFPQSxRQUFRNEIsUUFBUTtJQUN6QjtJQUVBbEosS0FBSzJILGFBQWEsR0FBRztRQUNuQixJQUFJN1QsTUFBTSxJQUFJLENBQUM0SCxnQkFBZ0IsQ0FBQ2lILEdBQUc7UUFDbkMsSUFBSXVHLFdBQVdwVixJQUFJb1YsUUFBUTtRQUMzQixJQUFJQyxPQUFPclYsSUFBSXFWLElBQUk7UUFDbkIsSUFBSSxDQUFDLElBQUksQ0FBQzdhLE9BQU8sQ0FBQ21JLGtCQUFrQixFQUFFO1lBQUU7UUFBTztRQUMvQyxJQUFJMEcsTUFBTSxJQUFJLENBQUN6QixnQkFBZ0IsQ0FBQzNPLE1BQU07UUFDdEMsSUFBSXFjLFNBQVNqTSxRQUFRLElBQUksT0FBTyxJQUFJLENBQUN6QixnQkFBZ0IsQ0FBQ3lCLE1BQU0sRUFBRTtRQUM5RCxJQUFLLElBQUlyUSxJQUFJLEdBQUdBLElBQUlxYyxLQUFLcGMsTUFBTSxFQUFFLEVBQUVELEVBQUc7WUFDcEMsSUFBSTRZLEtBQUt5RCxJQUFJLENBQUNyYyxFQUFFO1lBQ2hCLElBQUksQ0FBQ3FILE9BQU8rVSxVQUFVeEQsR0FBR3hYLElBQUksR0FBRztnQkFDOUIsSUFBSWtiLFFBQVE7b0JBQ1ZBLE9BQU9ELElBQUksQ0FBQzFSLElBQUksQ0FBQ2lPO2dCQUNuQixPQUFPO29CQUNMLElBQUksQ0FBQ2xHLGdCQUFnQixDQUFDa0csR0FBR2xRLEtBQUssRUFBRyxxQkFBc0JrUSxHQUFHeFgsSUFBSSxHQUFJO2dCQUNwRTtZQUNGO1FBQ0Y7SUFDRjtJQUVBLFNBQVN3Wix3QkFBd0JSLGNBQWMsRUFBRUksT0FBTztRQUN0RCxJQUFJcFosT0FBT29aLFFBQVFHLEdBQUcsQ0FBQ3ZaLElBQUk7UUFDM0IsSUFBSW1iLE9BQU9uQyxjQUFjLENBQUNoWixLQUFLO1FBRS9CLElBQUl3RixPQUFPO1FBQ1gsSUFBSTRULFFBQVFyUCxJQUFJLEtBQUssc0JBQXVCcVAsQ0FBQUEsUUFBUTdHLElBQUksS0FBSyxTQUFTNkcsUUFBUTdHLElBQUksS0FBSyxLQUFJLEdBQUk7WUFDN0YvTSxPQUFPLENBQUM0VCxRQUFRWSxNQUFNLEdBQUcsTUFBTSxHQUFFLElBQUtaLFFBQVE3RyxJQUFJO1FBQ3BEO1FBRUEsK0RBQStEO1FBQy9ELElBQ0U0SSxTQUFTLFVBQVUzVixTQUFTLFVBQzVCMlYsU0FBUyxVQUFVM1YsU0FBUyxVQUM1QjJWLFNBQVMsVUFBVTNWLFNBQVMsVUFDNUIyVixTQUFTLFVBQVUzVixTQUFTLFFBQzVCO1lBQ0F3VCxjQUFjLENBQUNoWixLQUFLLEdBQUc7WUFDdkIsT0FBTztRQUNULE9BQU8sSUFBSSxDQUFDbWIsTUFBTTtZQUNoQm5DLGNBQWMsQ0FBQ2haLEtBQUssR0FBR3dGO1lBQ3ZCLE9BQU87UUFDVCxPQUFPO1lBQ0wsT0FBTztRQUNUO0lBQ0Y7SUFFQSxTQUFTOFUsYUFBYWpNLElBQUksRUFBRXJPLElBQUk7UUFDOUIsSUFBSWthLFdBQVc3TCxLQUFLNkwsUUFBUTtRQUM1QixJQUFJWCxNQUFNbEwsS0FBS2tMLEdBQUc7UUFDbEIsT0FBTyxDQUFDVyxZQUNOWCxDQUFBQSxJQUFJeFAsSUFBSSxLQUFLLGdCQUFnQndQLElBQUl2WixJQUFJLEtBQUtBLFFBQzFDdVosSUFBSXhQLElBQUksS0FBSyxhQUFhd1AsSUFBSXZQLEtBQUssS0FBS2hLLElBQUc7SUFFL0M7SUFFQSxvQ0FBb0M7SUFFcEM4UixLQUFLc0oseUJBQXlCLEdBQUcsU0FBUy9NLElBQUksRUFBRWpSLFFBQU87UUFDckQsSUFBSSxJQUFJLENBQUNnRCxPQUFPLENBQUN5SCxXQUFXLElBQUksSUFBSTtZQUNsQyxJQUFJLElBQUksQ0FBQ3NJLGFBQWEsQ0FBQyxPQUFPO2dCQUM1QjlCLEtBQUtnTixRQUFRLEdBQUcsSUFBSSxDQUFDQyxxQkFBcUI7Z0JBQzFDLElBQUksQ0FBQ0MsV0FBVyxDQUFDbmUsVUFBU2lSLEtBQUtnTixRQUFRLEVBQUUsSUFBSSxDQUFDL08sWUFBWTtZQUM1RCxPQUFPO2dCQUNMK0IsS0FBS2dOLFFBQVEsR0FBRztZQUNsQjtRQUNGO1FBQ0EsSUFBSSxDQUFDakwsZ0JBQWdCLENBQUM7UUFDdEIsSUFBSSxJQUFJLENBQUNyRyxJQUFJLEtBQUsxSixRQUFRRyxNQUFNLEVBQUU7WUFBRSxJQUFJLENBQUM2UCxVQUFVO1FBQUk7UUFDdkRoQyxLQUFLbEosTUFBTSxHQUFHLElBQUksQ0FBQ3FXLGFBQWE7UUFDaEMsSUFBSSxJQUFJLENBQUNwYixPQUFPLENBQUN5SCxXQUFXLElBQUksSUFDOUI7WUFBRXdHLEtBQUtvTixVQUFVLEdBQUcsSUFBSSxDQUFDQyxlQUFlO1FBQUk7UUFDOUMsSUFBSSxDQUFDbEwsU0FBUztRQUNkLE9BQU8sSUFBSSxDQUFDNkIsVUFBVSxDQUFDaEUsTUFBTTtJQUMvQjtJQUVBeUQsS0FBS3FDLFdBQVcsR0FBRyxTQUFTOUYsSUFBSSxFQUFFalIsUUFBTztRQUN2QyxJQUFJLENBQUNvSSxJQUFJO1FBQ1Qsc0JBQXNCO1FBQ3RCLElBQUksSUFBSSxDQUFDeUssR0FBRyxDQUFDNVAsUUFBUXFDLElBQUksR0FBRztZQUMxQixPQUFPLElBQUksQ0FBQzBZLHlCQUF5QixDQUFDL00sTUFBTWpSO1FBQzlDO1FBQ0EsSUFBSSxJQUFJLENBQUM2UyxHQUFHLENBQUM1UCxRQUFROEMsUUFBUSxHQUFHO1lBQzlCLElBQUksQ0FBQ29ZLFdBQVcsQ0FBQ25lLFVBQVMsV0FBVyxJQUFJLENBQUNrUCxZQUFZO1lBQ3REK0IsS0FBS3NOLFdBQVcsR0FBRyxJQUFJLENBQUNDLDZCQUE2QjtZQUNyRCxPQUFPLElBQUksQ0FBQ3ZKLFVBQVUsQ0FBQ2hFLE1BQU07UUFDL0I7UUFDQSwwQ0FBMEM7UUFDMUMsSUFBSSxJQUFJLENBQUN3TiwwQkFBMEIsSUFBSTtZQUNyQ3hOLEtBQUtzTixXQUFXLEdBQUcsSUFBSSxDQUFDRyxzQkFBc0IsQ0FBQ3pOO1lBQy9DLElBQUlBLEtBQUtzTixXQUFXLENBQUM1UixJQUFJLEtBQUssdUJBQzVCO2dCQUFFLElBQUksQ0FBQ2dTLG1CQUFtQixDQUFDM2UsVUFBU2lSLEtBQUtzTixXQUFXLENBQUM1RyxZQUFZO1lBQUcsT0FFcEU7Z0JBQUUsSUFBSSxDQUFDd0csV0FBVyxDQUFDbmUsVUFBU2lSLEtBQUtzTixXQUFXLENBQUNuRSxFQUFFLEVBQUVuSixLQUFLc04sV0FBVyxDQUFDbkUsRUFBRSxDQUFDbFEsS0FBSztZQUFHO1lBQy9FK0csS0FBSzJOLFVBQVUsR0FBRyxFQUFFO1lBQ3BCM04sS0FBS2xKLE1BQU0sR0FBRztZQUNkLElBQUksSUFBSSxDQUFDL0UsT0FBTyxDQUFDeUgsV0FBVyxJQUFJLElBQzlCO2dCQUFFd0csS0FBS29OLFVBQVUsR0FBRyxFQUFFO1lBQUU7UUFDNUIsT0FBTztZQUNMcE4sS0FBS3NOLFdBQVcsR0FBRztZQUNuQnROLEtBQUsyTixVQUFVLEdBQUcsSUFBSSxDQUFDQyxxQkFBcUIsQ0FBQzdlO1lBQzdDLElBQUksSUFBSSxDQUFDK1MsYUFBYSxDQUFDLFNBQVM7Z0JBQzlCLElBQUksSUFBSSxDQUFDcEcsSUFBSSxLQUFLMUosUUFBUUcsTUFBTSxFQUFFO29CQUFFLElBQUksQ0FBQzZQLFVBQVU7Z0JBQUk7Z0JBQ3ZEaEMsS0FBS2xKLE1BQU0sR0FBRyxJQUFJLENBQUNxVyxhQUFhO2dCQUNoQyxJQUFJLElBQUksQ0FBQ3BiLE9BQU8sQ0FBQ3lILFdBQVcsSUFBSSxJQUM5QjtvQkFBRXdHLEtBQUtvTixVQUFVLEdBQUcsSUFBSSxDQUFDQyxlQUFlO2dCQUFJO1lBQ2hELE9BQU87Z0JBQ0wsSUFBSyxJQUFJOWMsSUFBSSxHQUFHc1QsT0FBTzdELEtBQUsyTixVQUFVLEVBQUVwZCxJQUFJc1QsS0FBS3JULE1BQU0sRUFBRUQsS0FBSyxFQUFHO29CQUMvRCx5Q0FBeUM7b0JBQ3pDLElBQUlzZCxPQUFPaEssSUFBSSxDQUFDdFQsRUFBRTtvQkFFbEIsSUFBSSxDQUFDdWQsZUFBZSxDQUFDRCxLQUFLRSxLQUFLO29CQUMvQiw2QkFBNkI7b0JBQzdCLElBQUksQ0FBQ0MsZ0JBQWdCLENBQUNILEtBQUtFLEtBQUs7b0JBRWhDLElBQUlGLEtBQUtFLEtBQUssQ0FBQ3JTLElBQUksS0FBSyxXQUFXO3dCQUNqQyxJQUFJLENBQUM4RyxLQUFLLENBQUNxTCxLQUFLRSxLQUFLLENBQUM5VSxLQUFLLEVBQUU7b0JBQy9CO2dCQUNGO2dCQUVBK0csS0FBS2xKLE1BQU0sR0FBRztnQkFDZCxJQUFJLElBQUksQ0FBQy9FLE9BQU8sQ0FBQ3lILFdBQVcsSUFBSSxJQUM5QjtvQkFBRXdHLEtBQUtvTixVQUFVLEdBQUcsRUFBRTtnQkFBRTtZQUM1QjtZQUNBLElBQUksQ0FBQ2pMLFNBQVM7UUFDaEI7UUFDQSxPQUFPLElBQUksQ0FBQzZCLFVBQVUsQ0FBQ2hFLE1BQU07SUFDL0I7SUFFQXlELEtBQUtnSyxzQkFBc0IsR0FBRyxTQUFTek4sSUFBSTtRQUN6QyxPQUFPLElBQUksQ0FBQzRELGNBQWMsQ0FBQztJQUM3QjtJQUVBSCxLQUFLOEosNkJBQTZCLEdBQUc7UUFDbkMsSUFBSW5HO1FBQ0osSUFBSSxJQUFJLENBQUMxTCxJQUFJLEtBQUsxSixRQUFRbUQsU0FBUyxJQUFLaVMsQ0FBQUEsVUFBVSxJQUFJLENBQUM1QyxlQUFlLEVBQUMsR0FBSTtZQUN6RSxJQUFJeUosUUFBUSxJQUFJLENBQUNoTyxTQUFTO1lBQzFCLElBQUksQ0FBQzlJLElBQUk7WUFDVCxJQUFJaVEsU0FBUztnQkFBRSxJQUFJLENBQUNqUSxJQUFJO1lBQUk7WUFDNUIsT0FBTyxJQUFJLENBQUNtUSxhQUFhLENBQUMyRyxPQUFPMUcsaUJBQWlCbUMsa0JBQWtCLE9BQU90QztRQUM3RSxPQUFPLElBQUksSUFBSSxDQUFDMUwsSUFBSSxLQUFLMUosUUFBUWdFLE1BQU0sRUFBRTtZQUN2QyxJQUFJa1ksUUFBUSxJQUFJLENBQUNqTyxTQUFTO1lBQzFCLE9BQU8sSUFBSSxDQUFDZ0YsVUFBVSxDQUFDaUosT0FBTztRQUNoQyxPQUFPO1lBQ0wsSUFBSVosY0FBYyxJQUFJLENBQUNoRSxnQkFBZ0I7WUFDdkMsSUFBSSxDQUFDbkgsU0FBUztZQUNkLE9BQU9tTDtRQUNUO0lBQ0Y7SUFFQTdKLEtBQUt5SixXQUFXLEdBQUcsU0FBU25lLFFBQU8sRUFBRTRDLElBQUksRUFBRXJCLEdBQUc7UUFDNUMsSUFBSSxDQUFDdkIsVUFBUztZQUFFO1FBQU87UUFDdkIsSUFBSSxPQUFPNEMsU0FBUyxVQUNsQjtZQUFFQSxPQUFPQSxLQUFLK0osSUFBSSxLQUFLLGVBQWUvSixLQUFLQSxJQUFJLEdBQUdBLEtBQUtnSyxLQUFLO1FBQUU7UUFDaEUsSUFBSS9ELE9BQU83SSxVQUFTNEMsT0FDbEI7WUFBRSxJQUFJLENBQUNzUixnQkFBZ0IsQ0FBQzNTLEtBQUssdUJBQXVCcUIsT0FBTztRQUFNO1FBQ25FNUMsUUFBTyxDQUFDNEMsS0FBSyxHQUFHO0lBQ2xCO0lBRUE4UixLQUFLMEssa0JBQWtCLEdBQUcsU0FBU3BmLFFBQU8sRUFBRXFmLEdBQUc7UUFDN0MsSUFBSTFTLE9BQU8wUyxJQUFJMVMsSUFBSTtRQUNuQixJQUFJQSxTQUFTLGNBQ1g7WUFBRSxJQUFJLENBQUN3UixXQUFXLENBQUNuZSxVQUFTcWYsS0FBS0EsSUFBSW5WLEtBQUs7UUFBRyxPQUMxQyxJQUFJeUMsU0FBUyxpQkFDaEI7WUFBRSxJQUFLLElBQUluTCxJQUFJLEdBQUdzVCxPQUFPdUssSUFBSUMsVUFBVSxFQUFFOWQsSUFBSXNULEtBQUtyVCxNQUFNLEVBQUVELEtBQUssRUFDN0Q7Z0JBQ0UsSUFBSStkLE9BQU96SyxJQUFJLENBQUN0VCxFQUFFO2dCQUVsQixJQUFJLENBQUM0ZCxrQkFBa0IsQ0FBQ3BmLFVBQVN1ZjtZQUNuQztRQUFFLE9BQ0QsSUFBSTVTLFNBQVMsZ0JBQ2hCO1lBQUUsSUFBSyxJQUFJaU4sTUFBTSxHQUFHNEYsU0FBU0gsSUFBSUksUUFBUSxFQUFFN0YsTUFBTTRGLE9BQU8vZCxNQUFNLEVBQUVtWSxPQUFPLEVBQUc7Z0JBQ3hFLElBQUk4RixNQUFNRixNQUFNLENBQUM1RixJQUFJO2dCQUVuQixJQUFJOEYsS0FBSztvQkFBRSxJQUFJLENBQUNOLGtCQUFrQixDQUFDcGYsVUFBUzBmO2dCQUFNO1lBQ3REO1FBQUUsT0FDQyxJQUFJL1MsU0FBUyxZQUNoQjtZQUFFLElBQUksQ0FBQ3lTLGtCQUFrQixDQUFDcGYsVUFBU3FmLElBQUl6UyxLQUFLO1FBQUcsT0FDNUMsSUFBSUQsU0FBUyxxQkFDaEI7WUFBRSxJQUFJLENBQUN5UyxrQkFBa0IsQ0FBQ3BmLFVBQVNxZixJQUFJaEYsSUFBSTtRQUFHLE9BQzNDLElBQUkxTixTQUFTLGVBQ2hCO1lBQUUsSUFBSSxDQUFDeVMsa0JBQWtCLENBQUNwZixVQUFTcWYsSUFBSXpHLFFBQVE7UUFBRztJQUN0RDtJQUVBbEUsS0FBS2lLLG1CQUFtQixHQUFHLFNBQVMzZSxRQUFPLEVBQUUyZixLQUFLO1FBQ2hELElBQUksQ0FBQzNmLFVBQVM7WUFBRTtRQUFPO1FBQ3ZCLElBQUssSUFBSXdCLElBQUksR0FBR3NULE9BQU82SyxPQUFPbmUsSUFBSXNULEtBQUtyVCxNQUFNLEVBQUVELEtBQUssRUFDbEQ7WUFDQSxJQUFJaVosT0FBTzNGLElBQUksQ0FBQ3RULEVBQUU7WUFFbEIsSUFBSSxDQUFDNGQsa0JBQWtCLENBQUNwZixVQUFTeWEsS0FBS0wsRUFBRTtRQUMxQztJQUNGO0lBRUExRixLQUFLK0osMEJBQTBCLEdBQUc7UUFDaEMsT0FBTyxJQUFJLENBQUM5UixJQUFJLENBQUN4SyxPQUFPLEtBQUssU0FDM0IsSUFBSSxDQUFDd0ssSUFBSSxDQUFDeEssT0FBTyxLQUFLLFdBQ3RCLElBQUksQ0FBQ3dLLElBQUksQ0FBQ3hLLE9BQU8sS0FBSyxXQUN0QixJQUFJLENBQUN3SyxJQUFJLENBQUN4SyxPQUFPLEtBQUssY0FDdEIsSUFBSSxDQUFDa1QsS0FBSyxNQUNWLElBQUksQ0FBQ0ksZUFBZTtJQUN4QjtJQUVBLG1EQUFtRDtJQUVuRGYsS0FBS2tMLG9CQUFvQixHQUFHLFNBQVM1ZixRQUFPO1FBQzFDLElBQUlpUixPQUFPLElBQUksQ0FBQ0MsU0FBUztRQUN6QkQsS0FBSytOLEtBQUssR0FBRyxJQUFJLENBQUNkLHFCQUFxQjtRQUV2Q2pOLEtBQUtnTixRQUFRLEdBQUcsSUFBSSxDQUFDbEwsYUFBYSxDQUFDLFFBQVEsSUFBSSxDQUFDbUwscUJBQXFCLEtBQUtqTixLQUFLK04sS0FBSztRQUNwRixJQUFJLENBQUNiLFdBQVcsQ0FDZG5lLFVBQ0FpUixLQUFLZ04sUUFBUSxFQUNiaE4sS0FBS2dOLFFBQVEsQ0FBQy9ULEtBQUs7UUFHckIsT0FBTyxJQUFJLENBQUMrSyxVQUFVLENBQUNoRSxNQUFNO0lBQy9CO0lBRUF5RCxLQUFLbUsscUJBQXFCLEdBQUcsU0FBUzdlLFFBQU87UUFDM0MsSUFBSTZmLFFBQVEsRUFBRSxFQUFFQyxRQUFRO1FBQ3hCLG9DQUFvQztRQUNwQyxJQUFJLENBQUN0TSxNQUFNLENBQUN2USxRQUFRUSxNQUFNO1FBQzFCLE1BQU8sQ0FBQyxJQUFJLENBQUNvUCxHQUFHLENBQUM1UCxRQUFRUyxNQUFNLEVBQUc7WUFDaEMsSUFBSSxDQUFDb2MsT0FBTztnQkFDVixJQUFJLENBQUN0TSxNQUFNLENBQUN2USxRQUFRWSxLQUFLO2dCQUN6QixJQUFJLElBQUksQ0FBQ3dQLGtCQUFrQixDQUFDcFEsUUFBUVMsTUFBTSxHQUFHO29CQUFFO2dCQUFNO1lBQ3ZELE9BQU87Z0JBQUVvYyxRQUFRO1lBQU87WUFFeEJELE1BQU0xVCxJQUFJLENBQUMsSUFBSSxDQUFDeVQsb0JBQW9CLENBQUM1ZjtRQUN2QztRQUNBLE9BQU82ZjtJQUNUO0lBRUEsNkJBQTZCO0lBRTdCbkwsS0FBS29DLFdBQVcsR0FBRyxTQUFTN0YsSUFBSTtRQUM5QixJQUFJLENBQUM3SSxJQUFJO1FBRVQsZUFBZTtRQUNmLElBQUksSUFBSSxDQUFDdUUsSUFBSSxLQUFLMUosUUFBUUcsTUFBTSxFQUFFO1lBQ2hDNk4sS0FBSzJOLFVBQVUsR0FBRzFGO1lBQ2xCakksS0FBS2xKLE1BQU0sR0FBRyxJQUFJLENBQUNxVyxhQUFhO1FBQ2xDLE9BQU87WUFDTG5OLEtBQUsyTixVQUFVLEdBQUcsSUFBSSxDQUFDbUIscUJBQXFCO1lBQzVDLElBQUksQ0FBQy9NLGdCQUFnQixDQUFDO1lBQ3RCL0IsS0FBS2xKLE1BQU0sR0FBRyxJQUFJLENBQUM0RSxJQUFJLEtBQUsxSixRQUFRRyxNQUFNLEdBQUcsSUFBSSxDQUFDZ2IsYUFBYSxLQUFLLElBQUksQ0FBQ25MLFVBQVU7UUFDckY7UUFDQSxJQUFJLElBQUksQ0FBQ2pRLE9BQU8sQ0FBQ3lILFdBQVcsSUFBSSxJQUM5QjtZQUFFd0csS0FBS29OLFVBQVUsR0FBRyxJQUFJLENBQUNDLGVBQWU7UUFBSTtRQUM5QyxJQUFJLENBQUNsTCxTQUFTO1FBQ2QsT0FBTyxJQUFJLENBQUM2QixVQUFVLENBQUNoRSxNQUFNO0lBQy9CO0lBRUEsbURBQW1EO0lBRW5EeUQsS0FBS3NMLG9CQUFvQixHQUFHO1FBQzFCLElBQUkvTyxPQUFPLElBQUksQ0FBQ0MsU0FBUztRQUN6QkQsS0FBS2dQLFFBQVEsR0FBRyxJQUFJLENBQUMvQixxQkFBcUI7UUFFMUMsSUFBSSxJQUFJLENBQUNuTCxhQUFhLENBQUMsT0FBTztZQUM1QjlCLEtBQUsrTixLQUFLLEdBQUcsSUFBSSxDQUFDN0gsVUFBVTtRQUM5QixPQUFPO1lBQ0wsSUFBSSxDQUFDNEgsZUFBZSxDQUFDOU4sS0FBS2dQLFFBQVE7WUFDbENoUCxLQUFLK04sS0FBSyxHQUFHL04sS0FBS2dQLFFBQVE7UUFDNUI7UUFDQSxJQUFJLENBQUNqRixlQUFlLENBQUMvSixLQUFLK04sS0FBSyxFQUFFalI7UUFFakMsT0FBTyxJQUFJLENBQUNrSCxVQUFVLENBQUNoRSxNQUFNO0lBQy9CO0lBRUF5RCxLQUFLd0wsMkJBQTJCLEdBQUc7UUFDakMsOENBQThDO1FBQzlDLElBQUlqUCxPQUFPLElBQUksQ0FBQ0MsU0FBUztRQUN6QkQsS0FBSytOLEtBQUssR0FBRyxJQUFJLENBQUM3SCxVQUFVO1FBQzVCLElBQUksQ0FBQzZELGVBQWUsQ0FBQy9KLEtBQUsrTixLQUFLLEVBQUVqUjtRQUNqQyxPQUFPLElBQUksQ0FBQ2tILFVBQVUsQ0FBQ2hFLE1BQU07SUFDL0I7SUFFQXlELEtBQUt5TCw2QkFBNkIsR0FBRztRQUNuQyxJQUFJbFAsT0FBTyxJQUFJLENBQUNDLFNBQVM7UUFDekIsSUFBSSxDQUFDOUksSUFBSTtRQUNULElBQUksQ0FBQzRLLGdCQUFnQixDQUFDO1FBQ3RCL0IsS0FBSytOLEtBQUssR0FBRyxJQUFJLENBQUM3SCxVQUFVO1FBQzVCLElBQUksQ0FBQzZELGVBQWUsQ0FBQy9KLEtBQUsrTixLQUFLLEVBQUVqUjtRQUNqQyxPQUFPLElBQUksQ0FBQ2tILFVBQVUsQ0FBQ2hFLE1BQU07SUFDL0I7SUFFQXlELEtBQUtxTCxxQkFBcUIsR0FBRztRQUMzQixJQUFJRixRQUFRLEVBQUUsRUFBRUMsUUFBUTtRQUN4QixJQUFJLElBQUksQ0FBQ25ULElBQUksS0FBSzFKLFFBQVFMLElBQUksRUFBRTtZQUM5QmlkLE1BQU0xVCxJQUFJLENBQUMsSUFBSSxDQUFDK1QsMkJBQTJCO1lBQzNDLElBQUksQ0FBQyxJQUFJLENBQUNyTixHQUFHLENBQUM1UCxRQUFRWSxLQUFLLEdBQUc7Z0JBQUUsT0FBT2djO1lBQU07UUFDL0M7UUFDQSxJQUFJLElBQUksQ0FBQ2xULElBQUksS0FBSzFKLFFBQVFxQyxJQUFJLEVBQUU7WUFDOUJ1YSxNQUFNMVQsSUFBSSxDQUFDLElBQUksQ0FBQ2dVLDZCQUE2QjtZQUM3QyxPQUFPTjtRQUNUO1FBQ0EsSUFBSSxDQUFDck0sTUFBTSxDQUFDdlEsUUFBUVEsTUFBTTtRQUMxQixNQUFPLENBQUMsSUFBSSxDQUFDb1AsR0FBRyxDQUFDNVAsUUFBUVMsTUFBTSxFQUFHO1lBQ2hDLElBQUksQ0FBQ29jLE9BQU87Z0JBQ1YsSUFBSSxDQUFDdE0sTUFBTSxDQUFDdlEsUUFBUVksS0FBSztnQkFDekIsSUFBSSxJQUFJLENBQUN3UCxrQkFBa0IsQ0FBQ3BRLFFBQVFTLE1BQU0sR0FBRztvQkFBRTtnQkFBTTtZQUN2RCxPQUFPO2dCQUFFb2MsUUFBUTtZQUFPO1lBRXhCRCxNQUFNMVQsSUFBSSxDQUFDLElBQUksQ0FBQzZULG9CQUFvQjtRQUN0QztRQUNBLE9BQU9IO0lBQ1Q7SUFFQW5MLEtBQUs0SixlQUFlLEdBQUc7UUFDckIsSUFBSXVCLFFBQVEsRUFBRTtRQUNkLElBQUksQ0FBQyxJQUFJLENBQUNoTixHQUFHLENBQUM1UCxRQUFRNEQsS0FBSyxHQUFHO1lBQzVCLE9BQU9nWjtRQUNUO1FBQ0EsSUFBSSxDQUFDck0sTUFBTSxDQUFDdlEsUUFBUVEsTUFBTTtRQUMxQixJQUFJMmMsZ0JBQWdCLENBQUM7UUFDckIsSUFBSU4sUUFBUTtRQUNaLE1BQU8sQ0FBQyxJQUFJLENBQUNqTixHQUFHLENBQUM1UCxRQUFRUyxNQUFNLEVBQUc7WUFDaEMsSUFBSSxDQUFDb2MsT0FBTztnQkFDVixJQUFJLENBQUN0TSxNQUFNLENBQUN2USxRQUFRWSxLQUFLO2dCQUN6QixJQUFJLElBQUksQ0FBQ3dQLGtCQUFrQixDQUFDcFEsUUFBUVMsTUFBTSxHQUFHO29CQUFFO2dCQUFNO1lBQ3ZELE9BQU87Z0JBQUVvYyxRQUFRO1lBQU87WUFFeEIsSUFBSU8sT0FBTyxJQUFJLENBQUNDLG9CQUFvQjtZQUNwQyxJQUFJL0QsVUFBVThELEtBQUtsRSxHQUFHLENBQUN4UCxJQUFJLEtBQUssZUFBZTBULEtBQUtsRSxHQUFHLENBQUN2WixJQUFJLEdBQUd5ZCxLQUFLbEUsR0FBRyxDQUFDdlAsS0FBSztZQUM3RSxJQUFJL0QsT0FBT3VYLGVBQWU3RCxVQUN4QjtnQkFBRSxJQUFJLENBQUNySSxnQkFBZ0IsQ0FBQ21NLEtBQUtsRSxHQUFHLENBQUNqUyxLQUFLLEVBQUUsOEJBQThCcVMsVUFBVTtZQUFNO1lBQ3hGNkQsYUFBYSxDQUFDN0QsUUFBUSxHQUFHO1lBQ3pCc0QsTUFBTTFULElBQUksQ0FBQ2tVO1FBQ2I7UUFDQSxPQUFPUjtJQUNUO0lBRUFuTCxLQUFLNEwsb0JBQW9CLEdBQUc7UUFDMUIsSUFBSXJQLE9BQU8sSUFBSSxDQUFDQyxTQUFTO1FBQ3pCRCxLQUFLa0wsR0FBRyxHQUFHLElBQUksQ0FBQ3hQLElBQUksS0FBSzFKLFFBQVFHLE1BQU0sR0FBRyxJQUFJLENBQUNnYixhQUFhLEtBQUssSUFBSSxDQUFDakgsVUFBVSxDQUFDLElBQUksQ0FBQ25VLE9BQU8sQ0FBQzZILGFBQWEsS0FBSztRQUNoSCxJQUFJLENBQUMySSxNQUFNLENBQUN2USxRQUFRYyxLQUFLO1FBQ3pCLElBQUksSUFBSSxDQUFDNEksSUFBSSxLQUFLMUosUUFBUUcsTUFBTSxFQUFFO1lBQ2hDLElBQUksQ0FBQzZQLFVBQVU7UUFDakI7UUFDQWhDLEtBQUtyRSxLQUFLLEdBQUcsSUFBSSxDQUFDd1IsYUFBYTtRQUMvQixPQUFPLElBQUksQ0FBQ25KLFVBQVUsQ0FBQ2hFLE1BQU07SUFDL0I7SUFFQXlELEtBQUt3SixxQkFBcUIsR0FBRztRQUMzQixJQUFJLElBQUksQ0FBQ2xiLE9BQU8sQ0FBQ3lILFdBQVcsSUFBSSxNQUFNLElBQUksQ0FBQ2tDLElBQUksS0FBSzFKLFFBQVFHLE1BQU0sRUFBRTtZQUNsRSxJQUFJbWQsZ0JBQWdCLElBQUksQ0FBQ0MsWUFBWSxDQUFDLElBQUksQ0FBQzVULEtBQUs7WUFDaEQsSUFBSW5ELGNBQWM3SCxJQUFJLENBQUMyZSxjQUFjM1QsS0FBSyxHQUFHO2dCQUMzQyxJQUFJLENBQUM2RyxLQUFLLENBQUM4TSxjQUFjclcsS0FBSyxFQUFFO1lBQ2xDO1lBQ0EsT0FBT3FXO1FBQ1Q7UUFDQSxPQUFPLElBQUksQ0FBQ3BKLFVBQVUsQ0FBQztJQUN6QjtJQUVBLHdFQUF3RTtJQUN4RXpDLEtBQUtNLHNCQUFzQixHQUFHLFNBQVN5TCxVQUFVO1FBQy9DLElBQUssSUFBSWpmLElBQUksR0FBR0EsSUFBSWlmLFdBQVdoZixNQUFNLElBQUksSUFBSSxDQUFDaWYsb0JBQW9CLENBQUNELFVBQVUsQ0FBQ2pmLEVBQUUsR0FBRyxFQUFFQSxFQUFHO1lBQ3RGaWYsVUFBVSxDQUFDamYsRUFBRSxDQUFDbWYsU0FBUyxHQUFHRixVQUFVLENBQUNqZixFQUFFLENBQUNpVCxVQUFVLENBQUNtTSxHQUFHLENBQUMvUixLQUFLLENBQUMsR0FBRyxDQUFDO1FBQ25FO0lBQ0Y7SUFDQTZGLEtBQUtnTSxvQkFBb0IsR0FBRyxTQUFTOUYsU0FBUztRQUM1QyxPQUNFLElBQUksQ0FBQzVYLE9BQU8sQ0FBQ3lILFdBQVcsSUFBSSxLQUM1Qm1RLFVBQVVqTyxJQUFJLEtBQUsseUJBQ25CaU8sVUFBVW5HLFVBQVUsQ0FBQzlILElBQUksS0FBSyxhQUM5QixPQUFPaU8sVUFBVW5HLFVBQVUsQ0FBQzdILEtBQUssS0FBSyxZQUN0QyxnQ0FBZ0M7UUFDL0IsS0FBSSxDQUFDdkMsS0FBSyxDQUFDdVEsVUFBVTFRLEtBQUssQ0FBQyxLQUFLLE9BQVEsSUFBSSxDQUFDRyxLQUFLLENBQUN1USxVQUFVMVEsS0FBSyxDQUFDLEtBQUssR0FBRTtJQUUvRTtJQUVBLElBQUkyVyxPQUFPMVMsT0FBT3pGLFNBQVM7SUFFM0IseURBQXlEO0lBQ3pELGVBQWU7SUFFZm1ZLEtBQUsxSSxZQUFZLEdBQUcsU0FBU2xILElBQUksRUFBRTZQLFNBQVMsRUFBRTdNLHNCQUFzQjtRQUNsRSxJQUFJLElBQUksQ0FBQ2pSLE9BQU8sQ0FBQ3lILFdBQVcsSUFBSSxLQUFLd0csTUFBTTtZQUN6QyxPQUFRQSxLQUFLdEUsSUFBSTtnQkFDakIsS0FBSztvQkFDSCxJQUFJLElBQUksQ0FBQzhELE9BQU8sSUFBSVEsS0FBS3JPLElBQUksS0FBSyxTQUNoQzt3QkFBRSxJQUFJLENBQUM2USxLQUFLLENBQUN4QyxLQUFLL0csS0FBSyxFQUFFO29CQUE4RDtvQkFDekY7Z0JBRUYsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztvQkFDSDtnQkFFRixLQUFLO29CQUNIK0csS0FBS3RFLElBQUksR0FBRztvQkFDWixJQUFJc0gsd0JBQXdCO3dCQUFFLElBQUksQ0FBQ0Qsa0JBQWtCLENBQUNDLHdCQUF3QjtvQkFBTztvQkFDckYsSUFBSyxJQUFJelMsSUFBSSxHQUFHc1QsT0FBTzdELEtBQUtxTyxVQUFVLEVBQUU5ZCxJQUFJc1QsS0FBS3JULE1BQU0sRUFBRUQsS0FBSyxFQUFHO3dCQUMvRCxJQUFJK2QsT0FBT3pLLElBQUksQ0FBQ3RULEVBQUU7d0JBRXBCLElBQUksQ0FBQzJXLFlBQVksQ0FBQ29ILE1BQU11Qjt3QkFDdEIsZUFBZTt3QkFDZiwyQ0FBMkM7d0JBQzNDLHdEQUF3RDt3QkFDeEQsRUFBRTt3QkFDRix3R0FBd0c7d0JBQ3hHLElBQ0V2QixLQUFLNVMsSUFBSSxLQUFLLGlCQUNiNFMsQ0FBQUEsS0FBSzNHLFFBQVEsQ0FBQ2pNLElBQUksS0FBSyxrQkFBa0I0UyxLQUFLM0csUUFBUSxDQUFDak0sSUFBSSxLQUFLLGVBQWMsR0FDL0U7NEJBQ0EsSUFBSSxDQUFDOEcsS0FBSyxDQUFDOEwsS0FBSzNHLFFBQVEsQ0FBQzFPLEtBQUssRUFBRTt3QkFDbEM7b0JBQ0Y7b0JBQ0E7Z0JBRUYsS0FBSztvQkFDSCw2Q0FBNkM7b0JBQzdDLElBQUkrRyxLQUFLa0UsSUFBSSxLQUFLLFFBQVE7d0JBQUUsSUFBSSxDQUFDMUIsS0FBSyxDQUFDeEMsS0FBS2tMLEdBQUcsQ0FBQ2pTLEtBQUssRUFBRTtvQkFBa0Q7b0JBQ3pHLElBQUksQ0FBQ2lPLFlBQVksQ0FBQ2xILEtBQUtyRSxLQUFLLEVBQUVrVTtvQkFDOUI7Z0JBRUYsS0FBSztvQkFDSDdQLEtBQUt0RSxJQUFJLEdBQUc7b0JBQ1osSUFBSXNILHdCQUF3Qjt3QkFBRSxJQUFJLENBQUNELGtCQUFrQixDQUFDQyx3QkFBd0I7b0JBQU87b0JBQ3JGLElBQUksQ0FBQzhNLGdCQUFnQixDQUFDOVAsS0FBS3dPLFFBQVEsRUFBRXFCO29CQUNyQztnQkFFRixLQUFLO29CQUNIN1AsS0FBS3RFLElBQUksR0FBRztvQkFDWixJQUFJLENBQUN3TCxZQUFZLENBQUNsSCxLQUFLMkgsUUFBUSxFQUFFa0k7b0JBQ2pDLElBQUk3UCxLQUFLMkgsUUFBUSxDQUFDak0sSUFBSSxLQUFLLHFCQUN6Qjt3QkFBRSxJQUFJLENBQUM4RyxLQUFLLENBQUN4QyxLQUFLMkgsUUFBUSxDQUFDMU8sS0FBSyxFQUFFO29CQUE4QztvQkFDbEY7Z0JBRUYsS0FBSztvQkFDSCxJQUFJK0csS0FBSytQLFFBQVEsS0FBSyxLQUFLO3dCQUFFLElBQUksQ0FBQ3ZOLEtBQUssQ0FBQ3hDLEtBQUtvSixJQUFJLENBQUNsUyxHQUFHLEVBQUU7b0JBQWdFO29CQUN2SDhJLEtBQUt0RSxJQUFJLEdBQUc7b0JBQ1osT0FBT3NFLEtBQUsrUCxRQUFRO29CQUNwQixJQUFJLENBQUM3SSxZQUFZLENBQUNsSCxLQUFLb0osSUFBSSxFQUFFeUc7b0JBQzdCO2dCQUVGLEtBQUs7b0JBQ0gsSUFBSSxDQUFDM0ksWUFBWSxDQUFDbEgsS0FBS3dELFVBQVUsRUFBRXFNLFdBQVc3TTtvQkFDOUM7Z0JBRUYsS0FBSztvQkFDSCxJQUFJLENBQUNDLGdCQUFnQixDQUFDakQsS0FBSy9HLEtBQUssRUFBRTtvQkFDbEM7Z0JBRUYsS0FBSztvQkFDSCxJQUFJLENBQUM0VyxXQUFXO3dCQUFFO29CQUFNO2dCQUUxQjtvQkFDRSxJQUFJLENBQUNyTixLQUFLLENBQUN4QyxLQUFLL0csS0FBSyxFQUFFO1lBQ3pCO1FBQ0YsT0FBTyxJQUFJK0osd0JBQXdCO1lBQUUsSUFBSSxDQUFDRCxrQkFBa0IsQ0FBQ0Msd0JBQXdCO1FBQU87UUFDNUYsT0FBT2hEO0lBQ1Q7SUFFQSxvREFBb0Q7SUFFcEQ0UCxLQUFLRSxnQkFBZ0IsR0FBRyxTQUFTRSxRQUFRLEVBQUVILFNBQVM7UUFDbEQsSUFBSTNZLE1BQU04WSxTQUFTeGYsTUFBTTtRQUN6QixJQUFLLElBQUlELElBQUksR0FBR0EsSUFBSTJHLEtBQUszRyxJQUFLO1lBQzVCLElBQUlrZSxNQUFNdUIsUUFBUSxDQUFDemYsRUFBRTtZQUNyQixJQUFJa2UsS0FBSztnQkFBRSxJQUFJLENBQUN2SCxZQUFZLENBQUN1SCxLQUFLb0I7WUFBWTtRQUNoRDtRQUNBLElBQUkzWSxLQUFLO1lBQ1AsSUFBSStZLE9BQU9ELFFBQVEsQ0FBQzlZLE1BQU0sRUFBRTtZQUM1QixJQUFJLElBQUksQ0FBQ25GLE9BQU8sQ0FBQ3lILFdBQVcsS0FBSyxLQUFLcVcsYUFBYUksUUFBUUEsS0FBS3ZVLElBQUksS0FBSyxpQkFBaUJ1VSxLQUFLdEksUUFBUSxDQUFDak0sSUFBSSxLQUFLLGNBQy9HO2dCQUFFLElBQUksQ0FBQ3NHLFVBQVUsQ0FBQ2lPLEtBQUt0SSxRQUFRLENBQUMxTyxLQUFLO1lBQUc7UUFDNUM7UUFDQSxPQUFPK1c7SUFDVDtJQUVBLHlCQUF5QjtJQUV6QkosS0FBS00sV0FBVyxHQUFHLFNBQVNsTixzQkFBc0I7UUFDaEQsSUFBSWhELE9BQU8sSUFBSSxDQUFDQyxTQUFTO1FBQ3pCLElBQUksQ0FBQzlJLElBQUk7UUFDVDZJLEtBQUsySCxRQUFRLEdBQUcsSUFBSSxDQUFDMkIsZ0JBQWdCLENBQUMsT0FBT3RHO1FBQzdDLE9BQU8sSUFBSSxDQUFDZ0IsVUFBVSxDQUFDaEUsTUFBTTtJQUMvQjtJQUVBNFAsS0FBS08sZ0JBQWdCLEdBQUc7UUFDdEIsSUFBSW5RLE9BQU8sSUFBSSxDQUFDQyxTQUFTO1FBQ3pCLElBQUksQ0FBQzlJLElBQUk7UUFFVCxtRUFBbUU7UUFDbkUsSUFBSSxJQUFJLENBQUNwRixPQUFPLENBQUN5SCxXQUFXLEtBQUssS0FBSyxJQUFJLENBQUNrQyxJQUFJLEtBQUsxSixRQUFRTCxJQUFJLEVBQzlEO1lBQUUsSUFBSSxDQUFDcVEsVUFBVTtRQUFJO1FBRXZCaEMsS0FBSzJILFFBQVEsR0FBRyxJQUFJLENBQUNTLGdCQUFnQjtRQUVyQyxPQUFPLElBQUksQ0FBQ3BFLFVBQVUsQ0FBQ2hFLE1BQU07SUFDL0I7SUFFQSxtQ0FBbUM7SUFFbkM0UCxLQUFLeEgsZ0JBQWdCLEdBQUc7UUFDdEIsSUFBSSxJQUFJLENBQUNyVyxPQUFPLENBQUN5SCxXQUFXLElBQUksR0FBRztZQUNqQyxPQUFRLElBQUksQ0FBQ2tDLElBQUk7Z0JBQ2pCLEtBQUsxSixRQUFRTSxRQUFRO29CQUNuQixJQUFJME4sT0FBTyxJQUFJLENBQUNDLFNBQVM7b0JBQ3pCLElBQUksQ0FBQzlJLElBQUk7b0JBQ1Q2SSxLQUFLd08sUUFBUSxHQUFHLElBQUksQ0FBQ2xFLGdCQUFnQixDQUFDdFksUUFBUU8sUUFBUSxFQUFFLE1BQU07b0JBQzlELE9BQU8sSUFBSSxDQUFDeVIsVUFBVSxDQUFDaEUsTUFBTTtnQkFFL0IsS0FBS2hPLFFBQVFRLE1BQU07b0JBQ2pCLE9BQU8sSUFBSSxDQUFDNGQsUUFBUSxDQUFDO1lBQ3ZCO1FBQ0Y7UUFDQSxPQUFPLElBQUksQ0FBQ2xLLFVBQVU7SUFDeEI7SUFFQTBKLEtBQUt0RixnQkFBZ0IsR0FBRyxTQUFTK0YsS0FBSyxFQUFFQyxVQUFVLEVBQUVDLGtCQUFrQixFQUFFQyxjQUFjO1FBQ3BGLElBQUlDLE9BQU8sRUFBRSxFQUFFNUIsUUFBUTtRQUN2QixNQUFPLENBQUMsSUFBSSxDQUFDak4sR0FBRyxDQUFDeU8sT0FBUTtZQUN2QixJQUFJeEIsT0FBTztnQkFBRUEsUUFBUTtZQUFPLE9BQ3ZCO2dCQUFFLElBQUksQ0FBQ3RNLE1BQU0sQ0FBQ3ZRLFFBQVFZLEtBQUs7WUFBRztZQUNuQyxJQUFJMGQsY0FBYyxJQUFJLENBQUM1VSxJQUFJLEtBQUsxSixRQUFRWSxLQUFLLEVBQUU7Z0JBQzdDNmQsS0FBS3ZWLElBQUksQ0FBQztZQUNaLE9BQU8sSUFBSXFWLHNCQUFzQixJQUFJLENBQUNuTyxrQkFBa0IsQ0FBQ2lPLFFBQVE7Z0JBQy9EO1lBQ0YsT0FBTyxJQUFJLElBQUksQ0FBQzNVLElBQUksS0FBSzFKLFFBQVFxQixRQUFRLEVBQUU7Z0JBQ3pDLElBQUlxZCxPQUFPLElBQUksQ0FBQ1AsZ0JBQWdCO2dCQUNoQyxJQUFJLENBQUNRLG9CQUFvQixDQUFDRDtnQkFDMUJELEtBQUt2VixJQUFJLENBQUN3VjtnQkFDVixJQUFJLElBQUksQ0FBQ2hWLElBQUksS0FBSzFKLFFBQVFZLEtBQUssRUFBRTtvQkFBRSxJQUFJLENBQUNxUSxnQkFBZ0IsQ0FBQyxJQUFJLENBQUNoSyxLQUFLLEVBQUU7Z0JBQWtEO2dCQUN2SCxJQUFJLENBQUNzSixNQUFNLENBQUM4TjtnQkFDWjtZQUNGLE9BQU87Z0JBQ0xJLEtBQUt2VixJQUFJLENBQUMsSUFBSSxDQUFDMFYsdUJBQXVCLENBQUNKO1lBQ3pDO1FBQ0Y7UUFDQSxPQUFPQztJQUNUO0lBRUFiLEtBQUtnQix1QkFBdUIsR0FBRyxTQUFTSixjQUFjO1FBQ3BELElBQUlLLE9BQU8sSUFBSSxDQUFDQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUM3WCxLQUFLLEVBQUUsSUFBSSxDQUFDc0MsUUFBUTtRQUMzRCxJQUFJLENBQUNvVixvQkFBb0IsQ0FBQ0U7UUFDMUIsT0FBT0E7SUFDVDtJQUVBakIsS0FBS2Usb0JBQW9CLEdBQUcsU0FBU3hJLEtBQUs7UUFDeEMsT0FBT0E7SUFDVDtJQUVBLDJEQUEyRDtJQUUzRHlILEtBQUtrQixpQkFBaUIsR0FBRyxTQUFTM1QsUUFBUSxFQUFFNUIsUUFBUSxFQUFFNk4sSUFBSTtRQUN4REEsT0FBT0EsUUFBUSxJQUFJLENBQUNoQixnQkFBZ0I7UUFDcEMsSUFBSSxJQUFJLENBQUNyVyxPQUFPLENBQUN5SCxXQUFXLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQ29JLEdBQUcsQ0FBQzVQLFFBQVF3QixFQUFFLEdBQUc7WUFBRSxPQUFPNFY7UUFBSztRQUN6RSxJQUFJcEosT0FBTyxJQUFJLENBQUM4TCxXQUFXLENBQUMzTyxVQUFVNUI7UUFDdEN5RSxLQUFLb0osSUFBSSxHQUFHQTtRQUNacEosS0FBS3FKLEtBQUssR0FBRyxJQUFJLENBQUNDLGdCQUFnQjtRQUNsQyxPQUFPLElBQUksQ0FBQ3RGLFVBQVUsQ0FBQ2hFLE1BQU07SUFDL0I7SUFFQSxzRUFBc0U7SUFDdEUsK0VBQStFO0lBQy9FLHVCQUF1QjtJQUN2QixFQUFFO0lBQ0YsNkVBQTZFO0lBQzdFLG9FQUFvRTtJQUNwRSw0REFBNEQ7SUFDNUQsRUFBRTtJQUNGLHNFQUFzRTtJQUN0RSw2REFBNkQ7SUFDN0QsRUFBRTtJQUNGLHFFQUFxRTtJQUNyRSxpQkFBaUI7SUFDakIsRUFBRTtJQUNGLHdFQUF3RTtJQUN4RSx5RUFBeUU7SUFDekUsOEVBQThFO0lBQzlFLHVDQUF1QztJQUN2QyxFQUFFO0lBQ0YsOEVBQThFO0lBQzlFLGNBQWM7SUFDZCxFQUFFO0lBQ0YsMEVBQTBFO0lBQzFFLCtFQUErRTtJQUMvRSxFQUFFO0lBQ0YseUNBQXlDO0lBQ3pDLGNBQWM7SUFDZCx5QkFBeUI7SUFDekIsdUNBQXVDO0lBQ3ZDLEVBQUU7SUFDRix5RUFBeUU7SUFDekUscUVBQXFFO0lBQ3JFLDZFQUE2RTtJQUM3RSx3QkFBd0I7SUFDeEIsRUFBRTtJQUNGLCtFQUErRTtJQUMvRSwwRUFBMEU7SUFDMUUsY0FBYztJQUNkLEVBQUU7SUFDRix5Q0FBeUM7SUFDekMsZUFBZTtJQUNmLG1CQUFtQjtJQUNuQixnQ0FBZ0M7SUFDaEMsdUNBQXVDO0lBQ3ZDLEVBQUU7SUFDRiw4RUFBOEU7SUFDOUUsd0VBQXdFO0lBQ3hFLDRFQUE0RTtJQUM1RSwyQ0FBMkM7SUFDM0MsRUFBRTtJQUNGLDZFQUE2RTtJQUM3RSx1REFBdUQ7SUFDdkQsRUFBRTtJQUNGLCtFQUErRTtJQUMvRSw2RUFBNkU7SUFDN0UsNEVBQTRFO0lBQzVFLHFFQUFxRTtJQUNyRSxnQkFBZ0I7SUFDaEIsRUFBRTtJQUNGLG1FQUFtRTtJQUNuRSw0RUFBNEU7SUFDNUUsOEVBQThFO0lBQzlFLHFEQUFxRDtJQUVyRDRQLEtBQUs3RixlQUFlLEdBQUcsU0FBU3hHLElBQUksRUFBRXdOLFdBQVcsRUFBRUMsWUFBWTtRQUM3RCxJQUFLRCxnQkFBZ0IsS0FBSyxHQUFJQSxjQUFjblU7UUFFNUMsSUFBSXFVLFNBQVNGLGdCQUFnQm5VO1FBRTdCLE9BQVEyRyxLQUFLN0gsSUFBSTtZQUNqQixLQUFLO2dCQUNILElBQUksSUFBSSxDQUFDL0wsTUFBTSxJQUFJLElBQUksQ0FBQzROLHVCQUF1QixDQUFDNU0sSUFBSSxDQUFDNFMsS0FBSzVSLElBQUksR0FDNUQ7b0JBQUUsSUFBSSxDQUFDc1IsZ0JBQWdCLENBQUNNLEtBQUt0SyxLQUFLLEVBQUUsQ0FBQ2dZLFNBQVMsYUFBYSxlQUFjLElBQUsxTixLQUFLNVIsSUFBSSxHQUFHO2dCQUFvQjtnQkFDaEgsSUFBSXNmLFFBQVE7b0JBQ1YsSUFBSUYsZ0JBQWdCalUsZ0JBQWdCeUcsS0FBSzVSLElBQUksS0FBSyxPQUNoRDt3QkFBRSxJQUFJLENBQUNzUixnQkFBZ0IsQ0FBQ00sS0FBS3RLLEtBQUssRUFBRTtvQkFBZ0Q7b0JBQ3RGLElBQUkrWCxjQUFjO3dCQUNoQixJQUFJcFosT0FBT29aLGNBQWN6TixLQUFLNVIsSUFBSSxHQUNoQzs0QkFBRSxJQUFJLENBQUNzUixnQkFBZ0IsQ0FBQ00sS0FBS3RLLEtBQUssRUFBRTt3QkFBd0I7d0JBQzlEK1gsWUFBWSxDQUFDek4sS0FBSzVSLElBQUksQ0FBQyxHQUFHO29CQUM1QjtvQkFDQSxJQUFJb2YsZ0JBQWdCOVQsY0FBYzt3QkFBRSxJQUFJLENBQUNpVSxXQUFXLENBQUMzTixLQUFLNVIsSUFBSSxFQUFFb2YsYUFBYXhOLEtBQUt0SyxLQUFLO29CQUFHO2dCQUM1RjtnQkFDQTtZQUVGLEtBQUs7Z0JBQ0gsSUFBSSxDQUFDZ0ssZ0JBQWdCLENBQUNNLEtBQUt0SyxLQUFLLEVBQUU7Z0JBQ2xDO1lBRUYsS0FBSztnQkFDSCxJQUFJZ1ksUUFBUTtvQkFBRSxJQUFJLENBQUNoTyxnQkFBZ0IsQ0FBQ00sS0FBS3RLLEtBQUssRUFBRTtnQkFBOEI7Z0JBQzlFO1lBRUYsS0FBSztnQkFDSCxJQUFJZ1ksUUFBUTtvQkFBRSxJQUFJLENBQUNoTyxnQkFBZ0IsQ0FBQ00sS0FBS3RLLEtBQUssRUFBRTtnQkFBcUM7Z0JBQ3JGLE9BQU8sSUFBSSxDQUFDOFEsZUFBZSxDQUFDeEcsS0FBS0MsVUFBVSxFQUFFdU4sYUFBYUM7WUFFNUQ7Z0JBQ0UsSUFBSSxDQUFDeE8sS0FBSyxDQUFDZSxLQUFLdEssS0FBSyxFQUFFLENBQUNnWSxTQUFTLFlBQVksY0FBYSxJQUFLO1FBQ2pFO0lBQ0Y7SUFFQXJCLEtBQUt6SSxnQkFBZ0IsR0FBRyxTQUFTNUQsSUFBSSxFQUFFd04sV0FBVyxFQUFFQyxZQUFZO1FBQzlELElBQUtELGdCQUFnQixLQUFLLEdBQUlBLGNBQWNuVTtRQUU1QyxPQUFRMkcsS0FBSzdILElBQUk7WUFDakIsS0FBSztnQkFDSCxJQUFLLElBQUluTCxJQUFJLEdBQUdzVCxPQUFPTixLQUFLOEssVUFBVSxFQUFFOWQsSUFBSXNULEtBQUtyVCxNQUFNLEVBQUVELEtBQUssRUFBRztvQkFDL0QsSUFBSStkLE9BQU96SyxJQUFJLENBQUN0VCxFQUFFO29CQUVwQixJQUFJLENBQUM0Z0IscUJBQXFCLENBQUM3QyxNQUFNeUMsYUFBYUM7Z0JBQzlDO2dCQUNBO1lBRUYsS0FBSztnQkFDSCxJQUFLLElBQUlySSxNQUFNLEdBQUc0RixTQUFTaEwsS0FBS2lMLFFBQVEsRUFBRTdGLE1BQU00RixPQUFPL2QsTUFBTSxFQUFFbVksT0FBTyxFQUFHO29CQUN2RSxJQUFJa0ksT0FBT3RDLE1BQU0sQ0FBQzVGLElBQUk7b0JBRXhCLElBQUlrSSxNQUFNO3dCQUFFLElBQUksQ0FBQ00scUJBQXFCLENBQUNOLE1BQU1FLGFBQWFDO29CQUFlO2dCQUN6RTtnQkFDQTtZQUVGO2dCQUNFLElBQUksQ0FBQ2pILGVBQWUsQ0FBQ3hHLE1BQU13TixhQUFhQztRQUMxQztJQUNGO0lBRUFwQixLQUFLdUIscUJBQXFCLEdBQUcsU0FBUzVOLElBQUksRUFBRXdOLFdBQVcsRUFBRUMsWUFBWTtRQUNuRSxJQUFLRCxnQkFBZ0IsS0FBSyxHQUFJQSxjQUFjblU7UUFFNUMsT0FBUTJHLEtBQUs3SCxJQUFJO1lBQ2pCLEtBQUs7Z0JBQ0gsNkNBQTZDO2dCQUM3QyxJQUFJLENBQUN5VixxQkFBcUIsQ0FBQzVOLEtBQUs1SCxLQUFLLEVBQUVvVixhQUFhQztnQkFDcEQ7WUFFRixLQUFLO2dCQUNILElBQUksQ0FBQzdKLGdCQUFnQixDQUFDNUQsS0FBSzZGLElBQUksRUFBRTJILGFBQWFDO2dCQUM5QztZQUVGLEtBQUs7Z0JBQ0gsSUFBSSxDQUFDN0osZ0JBQWdCLENBQUM1RCxLQUFLb0UsUUFBUSxFQUFFb0osYUFBYUM7Z0JBQ2xEO1lBRUY7Z0JBQ0UsSUFBSSxDQUFDN0osZ0JBQWdCLENBQUM1RCxNQUFNd04sYUFBYUM7UUFDM0M7SUFDRjtJQUVBLG1FQUFtRTtJQUNuRSxxRUFBcUU7SUFDckUsc0RBQXNEO0lBR3RELElBQUlJLGFBQWEsU0FBU0EsV0FBV25XLEtBQUssRUFBRW9XLE1BQU0sRUFBRUMsYUFBYSxFQUFFQyxRQUFRLEVBQUU1VSxTQUFTO1FBQ3BGLElBQUksQ0FBQzFCLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNvVyxNQUFNLEdBQUcsQ0FBQyxDQUFDQTtRQUNoQixJQUFJLENBQUNDLGFBQWEsR0FBRyxDQUFDLENBQUNBO1FBQ3ZCLElBQUksQ0FBQ0MsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUM1VSxTQUFTLEdBQUcsQ0FBQyxDQUFDQTtJQUNyQjtJQUVBLElBQUk2VSxRQUFRO1FBQ1ZDLFFBQVEsSUFBSUwsV0FBVyxLQUFLO1FBQzVCTSxRQUFRLElBQUlOLFdBQVcsS0FBSztRQUM1Qk8sUUFBUSxJQUFJUCxXQUFXLE1BQU07UUFDN0JRLFFBQVEsSUFBSVIsV0FBVyxLQUFLO1FBQzVCUyxRQUFRLElBQUlULFdBQVcsS0FBSztRQUM1QlUsUUFBUSxJQUFJVixXQUFXLEtBQUssTUFBTSxNQUFNLFNBQVVwWSxDQUFDO1lBQUksT0FBT0EsRUFBRStZLG9CQUFvQjtRQUFJO1FBQ3hGQyxRQUFRLElBQUlaLFdBQVcsWUFBWTtRQUNuQ2EsUUFBUSxJQUFJYixXQUFXLFlBQVk7UUFDbkNjLFlBQVksSUFBSWQsV0FBVyxZQUFZLE1BQU0sT0FBTyxNQUFNO1FBQzFEZSxPQUFPLElBQUlmLFdBQVcsWUFBWSxPQUFPLE9BQU8sTUFBTTtJQUN4RDtJQUVBLElBQUlnQixPQUFPbFYsT0FBT3pGLFNBQVM7SUFFM0IyYSxLQUFLaFUsY0FBYyxHQUFHO1FBQ3BCLE9BQU87WUFBQ29ULE1BQU1DLE1BQU07U0FBQztJQUN2QjtJQUVBVyxLQUFLQyxVQUFVLEdBQUc7UUFDaEIsT0FBTyxJQUFJLENBQUNsVSxPQUFPLENBQUMsSUFBSSxDQUFDQSxPQUFPLENBQUMzTixNQUFNLEdBQUcsRUFBRTtJQUM5QztJQUVBNGhCLEtBQUtFLFlBQVksR0FBRyxTQUFTQyxRQUFRO1FBQ25DLElBQUkxRixTQUFTLElBQUksQ0FBQ3dGLFVBQVU7UUFDNUIsSUFBSXhGLFdBQVcyRSxNQUFNUyxNQUFNLElBQUlwRixXQUFXMkUsTUFBTVEsTUFBTSxFQUNwRDtZQUFFLE9BQU87UUFBSztRQUNoQixJQUFJTyxhQUFhdmdCLFFBQVFjLEtBQUssSUFBSytaLENBQUFBLFdBQVcyRSxNQUFNQyxNQUFNLElBQUk1RSxXQUFXMkUsTUFBTUUsTUFBTSxHQUNuRjtZQUFFLE9BQU8sQ0FBQzdFLE9BQU93RSxNQUFNO1FBQUM7UUFFMUIsZ0VBQWdFO1FBQ2hFLGlFQUFpRTtRQUNqRSxhQUFhO1FBQ2IsSUFBSWtCLGFBQWF2Z0IsUUFBUXFELE9BQU8sSUFBSWtkLGFBQWF2Z0IsUUFBUUwsSUFBSSxJQUFJLElBQUksQ0FBQzBNLFdBQVcsRUFDL0U7WUFBRSxPQUFPekgsVUFBVWpHLElBQUksQ0FBQyxJQUFJLENBQUN5SSxLQUFLLENBQUN3RSxLQUFLLENBQUMsSUFBSSxDQUFDTSxVQUFVLEVBQUUsSUFBSSxDQUFDakYsS0FBSztRQUFHO1FBQ3pFLElBQUlzWixhQUFhdmdCLFFBQVFnRCxLQUFLLElBQUl1ZCxhQUFhdmdCLFFBQVFhLElBQUksSUFBSTBmLGFBQWF2Z0IsUUFBUUssR0FBRyxJQUFJa2dCLGFBQWF2Z0IsUUFBUVcsTUFBTSxJQUFJNGYsYUFBYXZnQixRQUFRa0IsS0FBSyxFQUNsSjtZQUFFLE9BQU87UUFBSztRQUNoQixJQUFJcWYsYUFBYXZnQixRQUFRUSxNQUFNLEVBQzdCO1lBQUUsT0FBT3FhLFdBQVcyRSxNQUFNQyxNQUFNO1FBQUM7UUFDbkMsSUFBSWMsYUFBYXZnQixRQUFReUQsSUFBSSxJQUFJOGMsYUFBYXZnQixRQUFRMEQsTUFBTSxJQUFJNmMsYUFBYXZnQixRQUFRTCxJQUFJLEVBQ3ZGO1lBQUUsT0FBTztRQUFNO1FBQ2pCLE9BQU8sQ0FBQyxJQUFJLENBQUMwTSxXQUFXO0lBQzFCO0lBRUErVCxLQUFLSSxrQkFBa0IsR0FBRztRQUN4QixJQUFLLElBQUlqaUIsSUFBSSxJQUFJLENBQUM0TixPQUFPLENBQUMzTixNQUFNLEdBQUcsR0FBR0QsS0FBSyxHQUFHQSxJQUFLO1lBQ2pELElBQUk0TixVQUFVLElBQUksQ0FBQ0EsT0FBTyxDQUFDNU4sRUFBRTtZQUM3QixJQUFJNE4sUUFBUWxELEtBQUssS0FBSyxZQUNwQjtnQkFBRSxPQUFPa0QsUUFBUXhCLFNBQVM7WUFBQztRQUMvQjtRQUNBLE9BQU87SUFDVDtJQUVBeVYsS0FBSzFnQixhQUFhLEdBQUcsU0FBUzZnQixRQUFRO1FBQ3BDLElBQUl0SixRQUFRdk4sT0FBTyxJQUFJLENBQUNBLElBQUk7UUFDNUIsSUFBSUEsS0FBS3hLLE9BQU8sSUFBSXFoQixhQUFhdmdCLFFBQVFlLEdBQUcsRUFDMUM7WUFBRSxJQUFJLENBQUNzTCxXQUFXLEdBQUc7UUFBTyxPQUN6QixJQUFJNEssU0FBU3ZOLEtBQUtoSyxhQUFhLEVBQ2xDO1lBQUV1WCxPQUFPbFIsSUFBSSxDQUFDLElBQUksRUFBRXdhO1FBQVcsT0FFL0I7WUFBRSxJQUFJLENBQUNsVSxXQUFXLEdBQUczQyxLQUFLdkssVUFBVTtRQUFFO0lBQzFDO0lBRUEseUdBQXlHO0lBRXpHaWhCLEtBQUtLLGVBQWUsR0FBRyxTQUFTQyxRQUFRO1FBQ3RDLElBQUksSUFBSSxDQUFDTCxVQUFVLE9BQU9LLFVBQVU7WUFDbEMsSUFBSSxDQUFDdlUsT0FBTyxDQUFDLElBQUksQ0FBQ0EsT0FBTyxDQUFDM04sTUFBTSxHQUFHLEVBQUUsR0FBR2tpQjtRQUMxQztJQUNGO0lBRUEscUNBQXFDO0lBRXJDMWdCLFFBQVFXLE1BQU0sQ0FBQ2pCLGFBQWEsR0FBR00sUUFBUVMsTUFBTSxDQUFDZixhQUFhLEdBQUc7UUFDNUQsSUFBSSxJQUFJLENBQUN5TSxPQUFPLENBQUMzTixNQUFNLEtBQUssR0FBRztZQUM3QixJQUFJLENBQUM2TixXQUFXLEdBQUc7WUFDbkI7UUFDRjtRQUNBLElBQUlzVSxNQUFNLElBQUksQ0FBQ3hVLE9BQU8sQ0FBQ2lJLEdBQUc7UUFDMUIsSUFBSXVNLFFBQVFuQixNQUFNQyxNQUFNLElBQUksSUFBSSxDQUFDWSxVQUFVLEdBQUdwWCxLQUFLLEtBQUssWUFBWTtZQUNsRTBYLE1BQU0sSUFBSSxDQUFDeFUsT0FBTyxDQUFDaUksR0FBRztRQUN4QjtRQUNBLElBQUksQ0FBQy9ILFdBQVcsR0FBRyxDQUFDc1UsSUFBSXRCLE1BQU07SUFDaEM7SUFFQXJmLFFBQVFRLE1BQU0sQ0FBQ2QsYUFBYSxHQUFHLFNBQVM2Z0IsUUFBUTtRQUM5QyxJQUFJLENBQUNwVSxPQUFPLENBQUNqRCxJQUFJLENBQUMsSUFBSSxDQUFDb1gsWUFBWSxDQUFDQyxZQUFZZixNQUFNQyxNQUFNLEdBQUdELE1BQU1FLE1BQU07UUFDM0UsSUFBSSxDQUFDclQsV0FBVyxHQUFHO0lBQ3JCO0lBRUFyTSxRQUFRdUIsWUFBWSxDQUFDN0IsYUFBYSxHQUFHO1FBQ25DLElBQUksQ0FBQ3lNLE9BQU8sQ0FBQ2pELElBQUksQ0FBQ3NXLE1BQU1HLE1BQU07UUFDOUIsSUFBSSxDQUFDdFQsV0FBVyxHQUFHO0lBQ3JCO0lBRUFyTSxRQUFRVSxNQUFNLENBQUNoQixhQUFhLEdBQUcsU0FBUzZnQixRQUFRO1FBQzlDLElBQUlLLGtCQUFrQkwsYUFBYXZnQixRQUFRb0QsR0FBRyxJQUFJbWQsYUFBYXZnQixRQUFRa0QsSUFBSSxJQUFJcWQsYUFBYXZnQixRQUFRNEQsS0FBSyxJQUFJMmMsYUFBYXZnQixRQUFRMkQsTUFBTTtRQUN4SSxJQUFJLENBQUN3SSxPQUFPLENBQUNqRCxJQUFJLENBQUMwWCxrQkFBa0JwQixNQUFNSSxNQUFNLEdBQUdKLE1BQU1LLE1BQU07UUFDL0QsSUFBSSxDQUFDeFQsV0FBVyxHQUFHO0lBQ3JCO0lBRUFyTSxRQUFRMEIsTUFBTSxDQUFDaEMsYUFBYSxHQUFHO0lBQzdCLGlDQUFpQztJQUNuQztJQUVBTSxRQUFRbUQsU0FBUyxDQUFDekQsYUFBYSxHQUFHTSxRQUFRZ0UsTUFBTSxDQUFDdEUsYUFBYSxHQUFHLFNBQVM2Z0IsUUFBUTtRQUNoRixJQUFJQSxTQUFTcGhCLFVBQVUsSUFBSW9oQixhQUFhdmdCLFFBQVFnRCxLQUFLLElBQ2pELENBQUV1ZCxDQUFBQSxhQUFhdmdCLFFBQVFhLElBQUksSUFBSSxJQUFJLENBQUN3ZixVQUFVLE9BQU9iLE1BQU1JLE1BQU0sS0FDakUsQ0FBRVcsQ0FBQUEsYUFBYXZnQixRQUFRcUQsT0FBTyxJQUFJdUIsVUFBVWpHLElBQUksQ0FBQyxJQUFJLENBQUN5SSxLQUFLLENBQUN3RSxLQUFLLENBQUMsSUFBSSxDQUFDTSxVQUFVLEVBQUUsSUFBSSxDQUFDakYsS0FBSyxFQUFDLEtBQzlGLENBQUUsRUFBQ3NaLGFBQWF2Z0IsUUFBUWMsS0FBSyxJQUFJeWYsYUFBYXZnQixRQUFRUSxNQUFNLEtBQUssSUFBSSxDQUFDNmYsVUFBVSxPQUFPYixNQUFNQyxNQUFNLEdBQ3JHO1lBQUUsSUFBSSxDQUFDdFQsT0FBTyxDQUFDakQsSUFBSSxDQUFDc1csTUFBTVMsTUFBTTtRQUFHLE9BRW5DO1lBQUUsSUFBSSxDQUFDOVQsT0FBTyxDQUFDakQsSUFBSSxDQUFDc1csTUFBTVEsTUFBTTtRQUFHO1FBQ3JDLElBQUksQ0FBQzNULFdBQVcsR0FBRztJQUNyQjtJQUVBck0sUUFBUWMsS0FBSyxDQUFDcEIsYUFBYSxHQUFHO1FBQzVCLElBQUksSUFBSSxDQUFDMmdCLFVBQVUsR0FBR3BYLEtBQUssS0FBSyxZQUFZO1lBQUUsSUFBSSxDQUFDa0QsT0FBTyxDQUFDaUksR0FBRztRQUFJO1FBQ2xFLElBQUksQ0FBQy9ILFdBQVcsR0FBRztJQUNyQjtJQUVBck0sUUFBUXNCLFNBQVMsQ0FBQzVCLGFBQWEsR0FBRztRQUNoQyxJQUFJLElBQUksQ0FBQzJnQixVQUFVLE9BQU9iLE1BQU1NLE1BQU0sRUFDcEM7WUFBRSxJQUFJLENBQUMzVCxPQUFPLENBQUNpSSxHQUFHO1FBQUksT0FFdEI7WUFBRSxJQUFJLENBQUNqSSxPQUFPLENBQUNqRCxJQUFJLENBQUNzVyxNQUFNTSxNQUFNO1FBQUc7UUFDckMsSUFBSSxDQUFDelQsV0FBVyxHQUFHO0lBQ3JCO0lBRUFyTSxRQUFRcUMsSUFBSSxDQUFDM0MsYUFBYSxHQUFHLFNBQVM2Z0IsUUFBUTtRQUM1QyxJQUFJQSxhQUFhdmdCLFFBQVFtRCxTQUFTLEVBQUU7WUFDbEMsSUFBSXVNLFFBQVEsSUFBSSxDQUFDdkQsT0FBTyxDQUFDM04sTUFBTSxHQUFHO1lBQ2xDLElBQUksSUFBSSxDQUFDMk4sT0FBTyxDQUFDdUQsTUFBTSxLQUFLOFAsTUFBTVMsTUFBTSxFQUN0QztnQkFBRSxJQUFJLENBQUM5VCxPQUFPLENBQUN1RCxNQUFNLEdBQUc4UCxNQUFNVSxVQUFVO1lBQUUsT0FFMUM7Z0JBQUUsSUFBSSxDQUFDL1QsT0FBTyxDQUFDdUQsTUFBTSxHQUFHOFAsTUFBTVcsS0FBSztZQUFFO1FBQ3pDO1FBQ0EsSUFBSSxDQUFDOVQsV0FBVyxHQUFHO0lBQ3JCO0lBRUFyTSxRQUFRTCxJQUFJLENBQUNELGFBQWEsR0FBRyxTQUFTNmdCLFFBQVE7UUFDNUMsSUFBSU0sVUFBVTtRQUNkLElBQUksSUFBSSxDQUFDOWdCLE9BQU8sQ0FBQ3lILFdBQVcsSUFBSSxLQUFLK1ksYUFBYXZnQixRQUFRZSxHQUFHLEVBQUU7WUFDN0QsSUFBSSxJQUFJLENBQUM0SSxLQUFLLEtBQUssUUFBUSxDQUFDLElBQUksQ0FBQzBDLFdBQVcsSUFDeEMsSUFBSSxDQUFDMUMsS0FBSyxLQUFLLFdBQVcsSUFBSSxDQUFDNlcsa0JBQWtCLElBQ25EO2dCQUFFSyxVQUFVO1lBQU07UUFDdEI7UUFDQSxJQUFJLENBQUN4VSxXQUFXLEdBQUd3VTtJQUNyQjtJQUVBLG9FQUFvRTtJQUNwRSxtRUFBbUU7SUFDbkUsbUVBQW1FO0lBQ25FLG9FQUFvRTtJQUNwRSw4REFBOEQ7SUFDOUQsbUVBQW1FO0lBQ25FLGdFQUFnRTtJQUNoRSxtRUFBbUU7SUFDbkUscUNBQXFDO0lBQ3JDLEVBQUU7SUFDRixtRUFBbUU7SUFDbkUsa0VBQWtFO0lBQ2xFLDhEQUE4RDtJQUM5RCw2REFBNkQ7SUFDN0QsNkNBQTZDO0lBQzdDLEVBQUU7SUFDRixpRUFBaUU7SUFHakUsSUFBSUMsT0FBTzVWLE9BQU96RixTQUFTO0lBRTNCLHFEQUFxRDtJQUNyRCw4REFBOEQ7SUFDOUQsMkRBQTJEO0lBQzNELG9FQUFvRTtJQUVwRXFiLEtBQUtDLGNBQWMsR0FBRyxTQUFTekUsSUFBSSxFQUFFMEUsUUFBUSxFQUFFaFEsc0JBQXNCO1FBQ25FLElBQUksSUFBSSxDQUFDalIsT0FBTyxDQUFDeUgsV0FBVyxJQUFJLEtBQUs4VSxLQUFLNVMsSUFBSSxLQUFLLGlCQUNqRDtZQUFFO1FBQU87UUFDWCxJQUFJLElBQUksQ0FBQzNKLE9BQU8sQ0FBQ3lILFdBQVcsSUFBSSxLQUFNOFUsQ0FBQUEsS0FBS3pDLFFBQVEsSUFBSXlDLEtBQUsvQixNQUFNLElBQUkrQixLQUFLMkUsU0FBUyxHQUNsRjtZQUFFO1FBQU87UUFDWCxJQUFJL0gsTUFBTW9ELEtBQUtwRCxHQUFHO1FBQ2xCLElBQUl2WjtRQUNKLE9BQVF1WixJQUFJeFAsSUFBSTtZQUNoQixLQUFLO2dCQUFjL0osT0FBT3VaLElBQUl2WixJQUFJO2dCQUFFO1lBQ3BDLEtBQUs7Z0JBQVdBLE9BQU9mLE9BQU9zYSxJQUFJdlAsS0FBSztnQkFBRztZQUMxQztnQkFBUztRQUNUO1FBQ0EsSUFBSXVJLE9BQU9vSyxLQUFLcEssSUFBSTtRQUNwQixJQUFJLElBQUksQ0FBQ25TLE9BQU8sQ0FBQ3lILFdBQVcsSUFBSSxHQUFHO1lBQ2pDLElBQUk3SCxTQUFTLGVBQWV1UyxTQUFTLFFBQVE7Z0JBQzNDLElBQUk4TyxTQUFTRSxLQUFLLEVBQUU7b0JBQ2xCLElBQUlsUSx3QkFBd0I7d0JBQzFCLElBQUlBLHVCQUF1QkYsV0FBVyxHQUFHLEdBQUc7NEJBQzFDRSx1QkFBdUJGLFdBQVcsR0FBR29JLElBQUlqUyxLQUFLO3dCQUNoRDtvQkFDRixPQUFPO3dCQUNMLElBQUksQ0FBQ2dLLGdCQUFnQixDQUFDaUksSUFBSWpTLEtBQUssRUFBRTtvQkFDbkM7Z0JBQ0Y7Z0JBQ0ErWixTQUFTRSxLQUFLLEdBQUc7WUFDbkI7WUFDQTtRQUNGO1FBQ0F2aEIsT0FBTyxNQUFNQTtRQUNiLElBQUl3aEIsUUFBUUgsUUFBUSxDQUFDcmhCLEtBQUs7UUFDMUIsSUFBSXdoQixPQUFPO1lBQ1QsSUFBSUM7WUFDSixJQUFJbFAsU0FBUyxRQUFRO2dCQUNuQmtQLGVBQWUsSUFBSSxDQUFDempCLE1BQU0sSUFBSXdqQixNQUFNbk0sSUFBSSxJQUFJbU0sTUFBTS9TLEdBQUcsSUFBSStTLE1BQU05aUIsR0FBRztZQUNwRSxPQUFPO2dCQUNMK2lCLGVBQWVELE1BQU1uTSxJQUFJLElBQUltTSxLQUFLLENBQUNqUCxLQUFLO1lBQzFDO1lBQ0EsSUFBSWtQLGNBQ0Y7Z0JBQUUsSUFBSSxDQUFDblEsZ0JBQWdCLENBQUNpSSxJQUFJalMsS0FBSyxFQUFFO1lBQTZCO1FBQ3BFLE9BQU87WUFDTGthLFFBQVFILFFBQVEsQ0FBQ3JoQixLQUFLLEdBQUc7Z0JBQ3ZCcVYsTUFBTTtnQkFDTjVHLEtBQUs7Z0JBQ0wvUCxLQUFLO1lBQ1A7UUFDRjtRQUNBOGlCLEtBQUssQ0FBQ2pQLEtBQUssR0FBRztJQUNoQjtJQUVBLHlCQUF5QjtJQUV6QixrRUFBa0U7SUFDbEUsaUVBQWlFO0lBQ2pFLGtFQUFrRTtJQUNsRSxpRUFBaUU7SUFDakUsZ0VBQWdFO0lBRWhFLDhEQUE4RDtJQUM5RCxvRUFBb0U7SUFDcEUsa0VBQWtFO0lBQ2xFLCtEQUErRDtJQUMvRCw2REFBNkQ7SUFDN0QsNkNBQTZDO0lBRTdDNE8sS0FBSzdSLGVBQWUsR0FBRyxTQUFTNEksT0FBTyxFQUFFN0csc0JBQXNCO1FBQzdELElBQUk3RixXQUFXLElBQUksQ0FBQ2xFLEtBQUssRUFBRXNDLFdBQVcsSUFBSSxDQUFDQSxRQUFRO1FBQ25ELElBQUlnSSxPQUFPLElBQUksQ0FBQytGLGdCQUFnQixDQUFDTyxTQUFTN0c7UUFDMUMsSUFBSSxJQUFJLENBQUN0SCxJQUFJLEtBQUsxSixRQUFRWSxLQUFLLEVBQUU7WUFDL0IsSUFBSW9OLE9BQU8sSUFBSSxDQUFDOEwsV0FBVyxDQUFDM08sVUFBVTVCO1lBQ3RDeUUsS0FBS3FULFdBQVcsR0FBRztnQkFBQzlQO2FBQUs7WUFDekIsTUFBTyxJQUFJLENBQUMzQixHQUFHLENBQUM1UCxRQUFRWSxLQUFLLEVBQUc7Z0JBQUVvTixLQUFLcVQsV0FBVyxDQUFDblksSUFBSSxDQUFDLElBQUksQ0FBQ29PLGdCQUFnQixDQUFDTyxTQUFTN0c7WUFBMEI7WUFDakgsT0FBTyxJQUFJLENBQUNnQixVQUFVLENBQUNoRSxNQUFNO1FBQy9CO1FBQ0EsT0FBT3VEO0lBQ1Q7SUFFQSxnRUFBZ0U7SUFDaEUsdUJBQXVCO0lBRXZCdVAsS0FBS3hKLGdCQUFnQixHQUFHLFNBQVNPLE9BQU8sRUFBRTdHLHNCQUFzQixFQUFFc1EsY0FBYztRQUM5RSxJQUFJLElBQUksQ0FBQ3pSLFlBQVksQ0FBQyxVQUFVO1lBQzlCLElBQUksSUFBSSxDQUFDdEMsV0FBVyxFQUFFO2dCQUFFLE9BQU8sSUFBSSxDQUFDZ1UsVUFBVSxDQUFDMUo7WUFBUyxPQUduRDtnQkFBRSxJQUFJLENBQUN4TCxXQUFXLEdBQUc7WUFBTztRQUNuQztRQUVBLElBQUltVix5QkFBeUIsT0FBT0MsaUJBQWlCLENBQUMsR0FBR0MsbUJBQW1CLENBQUMsR0FBR0MsaUJBQWlCLENBQUM7UUFDbEcsSUFBSTNRLHdCQUF3QjtZQUMxQnlRLGlCQUFpQnpRLHVCQUF1QkosbUJBQW1CO1lBQzNEOFEsbUJBQW1CMVEsdUJBQXVCTCxhQUFhO1lBQ3ZEZ1IsaUJBQWlCM1EsdUJBQXVCRixXQUFXO1lBQ25ERSx1QkFBdUJKLG1CQUFtQixHQUFHSSx1QkFBdUJMLGFBQWEsR0FBRyxDQUFDO1FBQ3ZGLE9BQU87WUFDTEsseUJBQXlCLElBQUlQO1lBQzdCK1EseUJBQXlCO1FBQzNCO1FBRUEsSUFBSXJXLFdBQVcsSUFBSSxDQUFDbEUsS0FBSyxFQUFFc0MsV0FBVyxJQUFJLENBQUNBLFFBQVE7UUFDbkQsSUFBSSxJQUFJLENBQUNHLElBQUksS0FBSzFKLFFBQVFVLE1BQU0sSUFBSSxJQUFJLENBQUNnSixJQUFJLEtBQUsxSixRQUFRTCxJQUFJLEVBQUU7WUFDOUQsSUFBSSxDQUFDNk0sZ0JBQWdCLEdBQUcsSUFBSSxDQUFDdkYsS0FBSztZQUNsQyxJQUFJLENBQUN3Rix3QkFBd0IsR0FBR29MLFlBQVk7UUFDOUM7UUFDQSxJQUFJVCxPQUFPLElBQUksQ0FBQ3dLLHFCQUFxQixDQUFDL0osU0FBUzdHO1FBQy9DLElBQUlzUSxnQkFBZ0I7WUFBRWxLLE9BQU9rSyxlQUFldmIsSUFBSSxDQUFDLElBQUksRUFBRXFSLE1BQU1qTSxVQUFVNUI7UUFBVztRQUNsRixJQUFJLElBQUksQ0FBQ0csSUFBSSxDQUFDcEssUUFBUSxFQUFFO1lBQ3RCLElBQUkwTyxPQUFPLElBQUksQ0FBQzhMLFdBQVcsQ0FBQzNPLFVBQVU1QjtZQUN0Q3lFLEtBQUsrUCxRQUFRLEdBQUcsSUFBSSxDQUFDcFUsS0FBSztZQUMxQixJQUFJLElBQUksQ0FBQ0QsSUFBSSxLQUFLMUosUUFBUXdCLEVBQUUsRUFDMUI7Z0JBQUU0VixPQUFPLElBQUksQ0FBQ2xDLFlBQVksQ0FBQ2tDLE1BQU0sT0FBT3BHO1lBQXlCO1lBQ25FLElBQUksQ0FBQ3dRLHdCQUF3QjtnQkFDM0J4USx1QkFBdUJKLG1CQUFtQixHQUFHSSx1QkFBdUJMLGFBQWEsR0FBR0ssdUJBQXVCRixXQUFXLEdBQUcsQ0FBQztZQUM1SDtZQUNBLElBQUlFLHVCQUF1Qk4sZUFBZSxJQUFJMEcsS0FBS25RLEtBQUssRUFDdEQ7Z0JBQUUrSix1QkFBdUJOLGVBQWUsR0FBRyxDQUFDO1lBQUcsRUFBRSxxREFBcUQ7WUFDeEcsSUFBSSxJQUFJLENBQUNoSCxJQUFJLEtBQUsxSixRQUFRd0IsRUFBRSxFQUMxQjtnQkFBRSxJQUFJLENBQUMyVCxnQkFBZ0IsQ0FBQ2lDO1lBQU8sT0FFL0I7Z0JBQUUsSUFBSSxDQUFDVyxlQUFlLENBQUNYO1lBQU87WUFDaENwSixLQUFLb0osSUFBSSxHQUFHQTtZQUNaLElBQUksQ0FBQ2pTLElBQUk7WUFDVDZJLEtBQUtxSixLQUFLLEdBQUcsSUFBSSxDQUFDQyxnQkFBZ0IsQ0FBQ087WUFDbkMsSUFBSThKLGlCQUFpQixDQUFDLEdBQUc7Z0JBQUUzUSx1QkFBdUJGLFdBQVcsR0FBRzZRO1lBQWdCO1lBQ2hGLE9BQU8sSUFBSSxDQUFDM1AsVUFBVSxDQUFDaEUsTUFBTTtRQUMvQixPQUFPO1lBQ0wsSUFBSXdULHdCQUF3QjtnQkFBRSxJQUFJLENBQUNyUSxxQkFBcUIsQ0FBQ0gsd0JBQXdCO1lBQU87UUFDMUY7UUFDQSxJQUFJeVEsaUJBQWlCLENBQUMsR0FBRztZQUFFelEsdUJBQXVCSixtQkFBbUIsR0FBRzZRO1FBQWdCO1FBQ3hGLElBQUlDLG1CQUFtQixDQUFDLEdBQUc7WUFBRTFRLHVCQUF1QkwsYUFBYSxHQUFHK1E7UUFBa0I7UUFDdEYsT0FBT3RLO0lBQ1Q7SUFFQSwrQ0FBK0M7SUFFL0MwSixLQUFLYyxxQkFBcUIsR0FBRyxTQUFTL0osT0FBTyxFQUFFN0csc0JBQXNCO1FBQ25FLElBQUk3RixXQUFXLElBQUksQ0FBQ2xFLEtBQUssRUFBRXNDLFdBQVcsSUFBSSxDQUFDQSxRQUFRO1FBQ25ELElBQUlnSSxPQUFPLElBQUksQ0FBQ3NRLFlBQVksQ0FBQ2hLLFNBQVM3RztRQUN0QyxJQUFJLElBQUksQ0FBQ0cscUJBQXFCLENBQUNILHlCQUF5QjtZQUFFLE9BQU9PO1FBQUs7UUFDdEUsSUFBSSxJQUFJLENBQUMzQixHQUFHLENBQUM1UCxRQUFRZ0IsUUFBUSxHQUFHO1lBQzlCLElBQUlnTixPQUFPLElBQUksQ0FBQzhMLFdBQVcsQ0FBQzNPLFVBQVU1QjtZQUN0Q3lFLEtBQUtyUCxJQUFJLEdBQUc0UztZQUNadkQsS0FBS3lILFVBQVUsR0FBRyxJQUFJLENBQUM2QixnQkFBZ0I7WUFDdkMsSUFBSSxDQUFDL0csTUFBTSxDQUFDdlEsUUFBUWMsS0FBSztZQUN6QmtOLEtBQUswSCxTQUFTLEdBQUcsSUFBSSxDQUFDNEIsZ0JBQWdCLENBQUNPO1lBQ3ZDLE9BQU8sSUFBSSxDQUFDN0YsVUFBVSxDQUFDaEUsTUFBTTtRQUMvQjtRQUNBLE9BQU91RDtJQUNUO0lBRUEsK0JBQStCO0lBRS9CdVAsS0FBS2UsWUFBWSxHQUFHLFNBQVNoSyxPQUFPLEVBQUU3RyxzQkFBc0I7UUFDMUQsSUFBSTdGLFdBQVcsSUFBSSxDQUFDbEUsS0FBSyxFQUFFc0MsV0FBVyxJQUFJLENBQUNBLFFBQVE7UUFDbkQsSUFBSWdJLE9BQU8sSUFBSSxDQUFDdVEsZUFBZSxDQUFDOVEsd0JBQXdCLE9BQU8sT0FBTzZHO1FBQ3RFLElBQUksSUFBSSxDQUFDMUcscUJBQXFCLENBQUNILHlCQUF5QjtZQUFFLE9BQU9PO1FBQUs7UUFDdEUsT0FBT0EsS0FBS3RLLEtBQUssS0FBS2tFLFlBQVlvRyxLQUFLN0gsSUFBSSxLQUFLLDRCQUE0QjZILE9BQU8sSUFBSSxDQUFDd1EsV0FBVyxDQUFDeFEsTUFBTXBHLFVBQVU1QixVQUFVLENBQUMsR0FBR3NPO0lBQ3BJO0lBRUEsOERBQThEO0lBQzlELDJEQUEyRDtJQUMzRCxrRUFBa0U7SUFDbEUsbUVBQW1FO0lBQ25FLG1FQUFtRTtJQUVuRWlKLEtBQUtpQixXQUFXLEdBQUcsU0FBUzNLLElBQUksRUFBRTRLLFlBQVksRUFBRUMsWUFBWSxFQUFFQyxPQUFPLEVBQUVySyxPQUFPO1FBQzVFLElBQUlqWSxPQUFPLElBQUksQ0FBQzhKLElBQUksQ0FBQ2pLLEtBQUs7UUFDMUIsSUFBSUcsUUFBUSxRQUFTLEVBQUNpWSxXQUFXLElBQUksQ0FBQ25PLElBQUksS0FBSzFKLFFBQVF1RSxHQUFHLEdBQUc7WUFDM0QsSUFBSTNFLE9BQU9zaUIsU0FBUztnQkFDbEIsSUFBSUMsVUFBVSxJQUFJLENBQUN6WSxJQUFJLEtBQUsxSixRQUFRMkIsU0FBUyxJQUFJLElBQUksQ0FBQytILElBQUksS0FBSzFKLFFBQVE0QixVQUFVO2dCQUNqRixJQUFJWSxXQUFXLElBQUksQ0FBQ2tILElBQUksS0FBSzFKLFFBQVF3QyxRQUFRO2dCQUM3QyxJQUFJQSxVQUFVO29CQUNaLHVGQUF1RjtvQkFDdkYsd0dBQXdHO29CQUN4RzVDLE9BQU9JLFFBQVE0QixVQUFVLENBQUNuQyxLQUFLO2dCQUNqQztnQkFDQSxJQUFJMmlCLEtBQUssSUFBSSxDQUFDelksS0FBSztnQkFDbkIsSUFBSSxDQUFDeEUsSUFBSTtnQkFDVCxJQUFJZ0csV0FBVyxJQUFJLENBQUNsRSxLQUFLLEVBQUVzQyxXQUFXLElBQUksQ0FBQ0EsUUFBUTtnQkFDbkQsSUFBSThOLFFBQVEsSUFBSSxDQUFDMEssV0FBVyxDQUFDLElBQUksQ0FBQ0QsZUFBZSxDQUFDLE1BQU0sT0FBTyxPQUFPakssVUFBVTFNLFVBQVU1QixVQUFVM0osTUFBTWlZO2dCQUMxRyxJQUFJN0osT0FBTyxJQUFJLENBQUNxVSxXQUFXLENBQUNMLGNBQWNDLGNBQWM3SyxNQUFNQyxPQUFPK0ssSUFBSUQsV0FBVzNmO2dCQUNwRixJQUFJLFdBQVksSUFBSSxDQUFDa0gsSUFBSSxLQUFLMUosUUFBUXdDLFFBQVEsSUFBTUEsWUFBYSxLQUFJLENBQUNrSCxJQUFJLEtBQUsxSixRQUFRMkIsU0FBUyxJQUFJLElBQUksQ0FBQytILElBQUksS0FBSzFKLFFBQVE0QixVQUFVLEdBQUk7b0JBQ3RJLElBQUksQ0FBQ3FQLGdCQUFnQixDQUFDLElBQUksQ0FBQ2hLLEtBQUssRUFBRTtnQkFDcEM7Z0JBQ0EsT0FBTyxJQUFJLENBQUM4YSxXQUFXLENBQUMvVCxNQUFNZ1UsY0FBY0MsY0FBY0MsU0FBU3JLO1lBQ3JFO1FBQ0Y7UUFDQSxPQUFPVDtJQUNUO0lBRUEwSixLQUFLdUIsV0FBVyxHQUFHLFNBQVNsWCxRQUFRLEVBQUU1QixRQUFRLEVBQUU2TixJQUFJLEVBQUVDLEtBQUssRUFBRStLLEVBQUUsRUFBRUQsT0FBTztRQUN0RSxJQUFJOUssTUFBTTNOLElBQUksS0FBSyxxQkFBcUI7WUFBRSxJQUFJLENBQUM4RyxLQUFLLENBQUM2RyxNQUFNcFEsS0FBSyxFQUFFO1FBQWtFO1FBQ3BJLElBQUkrRyxPQUFPLElBQUksQ0FBQzhMLFdBQVcsQ0FBQzNPLFVBQVU1QjtRQUN0Q3lFLEtBQUtvSixJQUFJLEdBQUdBO1FBQ1pwSixLQUFLK1AsUUFBUSxHQUFHcUU7UUFDaEJwVSxLQUFLcUosS0FBSyxHQUFHQTtRQUNiLE9BQU8sSUFBSSxDQUFDckYsVUFBVSxDQUFDaEUsTUFBTW1VLFVBQVUsc0JBQXNCO0lBQy9EO0lBRUEsa0RBQWtEO0lBRWxEckIsS0FBS2dCLGVBQWUsR0FBRyxTQUFTOVEsc0JBQXNCLEVBQUVzUixRQUFRLEVBQUU1Z0IsTUFBTSxFQUFFbVcsT0FBTztRQUMvRSxJQUFJMU0sV0FBVyxJQUFJLENBQUNsRSxLQUFLLEVBQUVzQyxXQUFXLElBQUksQ0FBQ0EsUUFBUSxFQUFFZ0k7UUFDckQsSUFBSSxJQUFJLENBQUMxQixZQUFZLENBQUMsWUFBWSxJQUFJLENBQUNwQyxRQUFRLEVBQUU7WUFDL0M4RCxPQUFPLElBQUksQ0FBQ2dSLFVBQVUsQ0FBQzFLO1lBQ3ZCeUssV0FBVztRQUNiLE9BQU8sSUFBSSxJQUFJLENBQUM1WSxJQUFJLENBQUNuSyxNQUFNLEVBQUU7WUFDM0IsSUFBSXlPLE9BQU8sSUFBSSxDQUFDQyxTQUFTLElBQUlnSixTQUFTLElBQUksQ0FBQ3ZOLElBQUksS0FBSzFKLFFBQVEwQixNQUFNO1lBQ2xFc00sS0FBSytQLFFBQVEsR0FBRyxJQUFJLENBQUNwVSxLQUFLO1lBQzFCcUUsS0FBS3pPLE1BQU0sR0FBRztZQUNkLElBQUksQ0FBQzRGLElBQUk7WUFDVDZJLEtBQUsySCxRQUFRLEdBQUcsSUFBSSxDQUFDbU0sZUFBZSxDQUFDLE1BQU0sTUFBTTdLLFFBQVFZO1lBQ3pELElBQUksQ0FBQzFHLHFCQUFxQixDQUFDSCx3QkFBd0I7WUFDbkQsSUFBSWlHLFFBQVE7Z0JBQUUsSUFBSSxDQUFDYyxlQUFlLENBQUMvSixLQUFLMkgsUUFBUTtZQUFHLE9BQzlDLElBQUksSUFBSSxDQUFDaFksTUFBTSxJQUFJcVEsS0FBSytQLFFBQVEsS0FBSyxZQUFZeUUsc0JBQXNCeFUsS0FBSzJILFFBQVEsR0FDdkY7Z0JBQUUsSUFBSSxDQUFDMUUsZ0JBQWdCLENBQUNqRCxLQUFLL0csS0FBSyxFQUFFO1lBQTJDLE9BQzVFLElBQUkrRyxLQUFLK1AsUUFBUSxLQUFLLFlBQVkwRSxxQkFBcUJ6VSxLQUFLMkgsUUFBUSxHQUN2RTtnQkFBRSxJQUFJLENBQUMxRSxnQkFBZ0IsQ0FBQ2pELEtBQUsvRyxLQUFLLEVBQUU7WUFBc0MsT0FDdkU7Z0JBQUVxYixXQUFXO1lBQU07WUFDeEIvUSxPQUFPLElBQUksQ0FBQ1MsVUFBVSxDQUFDaEUsTUFBTWlKLFNBQVMscUJBQXFCO1FBQzdELE9BQU8sSUFBSSxDQUFDcUwsWUFBWSxJQUFJLENBQUM1WSxJQUFJLEtBQUsxSixRQUFRSSxTQUFTLEVBQUU7WUFDdkQsSUFBSSxDQUFDeVgsV0FBVyxJQUFJLENBQUMxSyxnQkFBZ0IsQ0FBQzNPLE1BQU0sS0FBSyxNQUFNLElBQUksQ0FBQ3VCLE9BQU8sQ0FBQ21JLGtCQUFrQixFQUFFO2dCQUFFLElBQUksQ0FBQzhILFVBQVU7WUFBSTtZQUM3R3VCLE9BQU8sSUFBSSxDQUFDOEksaUJBQWlCO1lBQzdCLDBEQUEwRDtZQUMxRCxJQUFJLElBQUksQ0FBQzNRLElBQUksS0FBSzFKLFFBQVF1RSxHQUFHLEVBQUU7Z0JBQUUsSUFBSSxDQUFDeUwsVUFBVTtZQUFJO1FBQ3RELE9BQU87WUFDTHVCLE9BQU8sSUFBSSxDQUFDMEQsbUJBQW1CLENBQUNqRSx3QkFBd0I2RztZQUN4RCxJQUFJLElBQUksQ0FBQzFHLHFCQUFxQixDQUFDSCx5QkFBeUI7Z0JBQUUsT0FBT087WUFBSztZQUN0RSxNQUFPLElBQUksQ0FBQzdILElBQUksQ0FBQ2xLLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQ3lRLGtCQUFrQixHQUFJO2dCQUN0RCxJQUFJeVMsU0FBUyxJQUFJLENBQUM1SSxXQUFXLENBQUMzTyxVQUFVNUI7Z0JBQ3hDbVosT0FBTzNFLFFBQVEsR0FBRyxJQUFJLENBQUNwVSxLQUFLO2dCQUM1QitZLE9BQU9uakIsTUFBTSxHQUFHO2dCQUNoQm1qQixPQUFPL00sUUFBUSxHQUFHcEU7Z0JBQ2xCLElBQUksQ0FBQ3dHLGVBQWUsQ0FBQ3hHO2dCQUNyQixJQUFJLENBQUNwTSxJQUFJO2dCQUNUb00sT0FBTyxJQUFJLENBQUNTLFVBQVUsQ0FBQzBRLFFBQVE7WUFDakM7UUFDRjtRQUVBLElBQUksQ0FBQ2hoQixVQUFVLElBQUksQ0FBQ2tPLEdBQUcsQ0FBQzVQLFFBQVF1QyxRQUFRLEdBQUc7WUFDekMsSUFBSStmLFVBQ0Y7Z0JBQUUsSUFBSSxDQUFDdFMsVUFBVSxDQUFDLElBQUksQ0FBQy9ELFlBQVk7WUFBRyxPQUV0QztnQkFBRSxPQUFPLElBQUksQ0FBQ29XLFdBQVcsQ0FBQ2xYLFVBQVU1QixVQUFVZ0ksTUFBTSxJQUFJLENBQUN1USxlQUFlLENBQUMsTUFBTSxPQUFPLE9BQU9qSyxVQUFVLE1BQU07WUFBTztRQUN4SCxPQUFPO1lBQ0wsT0FBT3RHO1FBQ1Q7SUFDRjtJQUVBLFNBQVNpUixzQkFBc0J4VSxJQUFJO1FBQ2pDLE9BQ0VBLEtBQUt0RSxJQUFJLEtBQUssZ0JBQ2RzRSxLQUFLdEUsSUFBSSxLQUFLLDZCQUE2QjhZLHNCQUFzQnhVLEtBQUt3RCxVQUFVO0lBRXBGO0lBRUEsU0FBU2lSLHFCQUFxQnpVLElBQUk7UUFDaEMsT0FDRUEsS0FBS3RFLElBQUksS0FBSyxzQkFBc0JzRSxLQUFLMlUsUUFBUSxDQUFDalosSUFBSSxLQUFLLHVCQUMzRHNFLEtBQUt0RSxJQUFJLEtBQUsscUJBQXFCK1kscUJBQXFCelUsS0FBS3dELFVBQVUsS0FDdkV4RCxLQUFLdEUsSUFBSSxLQUFLLDZCQUE2QitZLHFCQUFxQnpVLEtBQUt3RCxVQUFVO0lBRW5GO0lBRUEsbURBQW1EO0lBRW5Ec1AsS0FBSzdMLG1CQUFtQixHQUFHLFNBQVNqRSxzQkFBc0IsRUFBRTZHLE9BQU87UUFDakUsSUFBSTFNLFdBQVcsSUFBSSxDQUFDbEUsS0FBSyxFQUFFc0MsV0FBVyxJQUFJLENBQUNBLFFBQVE7UUFDbkQsSUFBSWdJLE9BQU8sSUFBSSxDQUFDNEosYUFBYSxDQUFDbkssd0JBQXdCNkc7UUFDdEQsSUFBSXRHLEtBQUs3SCxJQUFJLEtBQUssNkJBQTZCLElBQUksQ0FBQ3RDLEtBQUssQ0FBQ3dFLEtBQUssQ0FBQyxJQUFJLENBQUNLLFlBQVksRUFBRSxJQUFJLENBQUNDLFVBQVUsTUFBTSxLQUN0RztZQUFFLE9BQU9xRjtRQUFLO1FBQ2hCLElBQUlxUixTQUFTLElBQUksQ0FBQ0MsZUFBZSxDQUFDdFIsTUFBTXBHLFVBQVU1QixVQUFVLE9BQU9zTztRQUNuRSxJQUFJN0csMEJBQTBCNFIsT0FBT2xaLElBQUksS0FBSyxvQkFBb0I7WUFDaEUsSUFBSXNILHVCQUF1QkosbUJBQW1CLElBQUlnUyxPQUFPM2IsS0FBSyxFQUFFO2dCQUFFK0osdUJBQXVCSixtQkFBbUIsR0FBRyxDQUFDO1lBQUc7WUFDbkgsSUFBSUksdUJBQXVCSCxpQkFBaUIsSUFBSStSLE9BQU8zYixLQUFLLEVBQUU7Z0JBQUUrSix1QkFBdUJILGlCQUFpQixHQUFHLENBQUM7WUFBRztZQUMvRyxJQUFJRyx1QkFBdUJMLGFBQWEsSUFBSWlTLE9BQU8zYixLQUFLLEVBQUU7Z0JBQUUrSix1QkFBdUJMLGFBQWEsR0FBRyxDQUFDO1lBQUc7UUFDekc7UUFDQSxPQUFPaVM7SUFDVDtJQUVBOUIsS0FBSytCLGVBQWUsR0FBRyxTQUFTQyxJQUFJLEVBQUUzWCxRQUFRLEVBQUU1QixRQUFRLEVBQUV3WixPQUFPLEVBQUVsTCxPQUFPO1FBQ3hFLElBQUltTCxrQkFBa0IsSUFBSSxDQUFDampCLE9BQU8sQ0FBQ3lILFdBQVcsSUFBSSxLQUFLc2IsS0FBS3BaLElBQUksS0FBSyxnQkFBZ0JvWixLQUFLbmpCLElBQUksS0FBSyxXQUMvRixJQUFJLENBQUN1TSxVQUFVLEtBQUs0VyxLQUFLNWQsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDK0ssa0JBQWtCLE1BQU02UyxLQUFLNWQsR0FBRyxHQUFHNGQsS0FBSzdiLEtBQUssS0FBSyxLQUN4RixJQUFJLENBQUN1RixnQkFBZ0IsS0FBS3NXLEtBQUs3YixLQUFLO1FBQ3hDLElBQUlnYyxrQkFBa0I7UUFFdEIsTUFBTyxLQUFNO1lBQ1gsSUFBSWxLLFVBQVUsSUFBSSxDQUFDbUssY0FBYyxDQUFDSixNQUFNM1gsVUFBVTVCLFVBQVV3WixTQUFTQyxpQkFBaUJDLGlCQUFpQnBMO1lBRXZHLElBQUlrQixRQUFRb0ssUUFBUSxFQUFFO2dCQUFFRixrQkFBa0I7WUFBTTtZQUNoRCxJQUFJbEssWUFBWStKLFFBQVEvSixRQUFRclAsSUFBSSxLQUFLLDJCQUEyQjtnQkFDbEUsSUFBSXVaLGlCQUFpQjtvQkFDbkIsSUFBSUcsWUFBWSxJQUFJLENBQUN0SixXQUFXLENBQUMzTyxVQUFVNUI7b0JBQzNDNlosVUFBVTVSLFVBQVUsR0FBR3VIO29CQUN2QkEsVUFBVSxJQUFJLENBQUMvRyxVQUFVLENBQUNvUixXQUFXO2dCQUN2QztnQkFDQSxPQUFPcks7WUFDVDtZQUVBK0osT0FBTy9KO1FBQ1Q7SUFDRjtJQUVBK0gsS0FBS3VDLHFCQUFxQixHQUFHO1FBQzNCLE9BQU8sQ0FBQyxJQUFJLENBQUNwVCxrQkFBa0IsTUFBTSxJQUFJLENBQUNMLEdBQUcsQ0FBQzVQLFFBQVFrQixLQUFLO0lBQzdEO0lBRUE0ZixLQUFLd0Msd0JBQXdCLEdBQUcsU0FBU25ZLFFBQVEsRUFBRTVCLFFBQVEsRUFBRXlVLFFBQVEsRUFBRW5HLE9BQU87UUFDNUUsT0FBTyxJQUFJLENBQUMwTCxvQkFBb0IsQ0FBQyxJQUFJLENBQUN6SixXQUFXLENBQUMzTyxVQUFVNUIsV0FBV3lVLFVBQVUsTUFBTW5HO0lBQ3pGO0lBRUFpSixLQUFLb0MsY0FBYyxHQUFHLFNBQVNKLElBQUksRUFBRTNYLFFBQVEsRUFBRTVCLFFBQVEsRUFBRXdaLE9BQU8sRUFBRUMsZUFBZSxFQUFFQyxlQUFlLEVBQUVwTCxPQUFPO1FBQ3pHLElBQUkyTCxvQkFBb0IsSUFBSSxDQUFDempCLE9BQU8sQ0FBQ3lILFdBQVcsSUFBSTtRQUNwRCxJQUFJMmIsV0FBV0sscUJBQXFCLElBQUksQ0FBQzVULEdBQUcsQ0FBQzVQLFFBQVFpQixXQUFXO1FBQ2hFLElBQUk4aEIsV0FBV0ksVUFBVTtZQUFFLElBQUksQ0FBQzNTLEtBQUssQ0FBQyxJQUFJLENBQUN2RSxZQUFZLEVBQUU7UUFBcUU7UUFFOUgsSUFBSTROLFdBQVcsSUFBSSxDQUFDakssR0FBRyxDQUFDNVAsUUFBUU0sUUFBUTtRQUN4QyxJQUFJdVosWUFBYXNKLFlBQVksSUFBSSxDQUFDelosSUFBSSxLQUFLMUosUUFBUVUsTUFBTSxJQUFJLElBQUksQ0FBQ2dKLElBQUksS0FBSzFKLFFBQVFzQixTQUFTLElBQUssSUFBSSxDQUFDc08sR0FBRyxDQUFDNVAsUUFBUWUsR0FBRyxHQUFHO1lBQ3RILElBQUlpTixPQUFPLElBQUksQ0FBQzhMLFdBQVcsQ0FBQzNPLFVBQVU1QjtZQUN0Q3lFLEtBQUswSSxNQUFNLEdBQUdvTTtZQUNkLElBQUlqSixVQUFVO2dCQUNaN0wsS0FBSzJVLFFBQVEsR0FBRyxJQUFJLENBQUMxVCxlQUFlO2dCQUNwQyxJQUFJLENBQUNzQixNQUFNLENBQUN2USxRQUFRTyxRQUFRO1lBQzlCLE9BQU8sSUFBSSxJQUFJLENBQUNtSixJQUFJLEtBQUsxSixRQUFRSSxTQUFTLElBQUkwaUIsS0FBS3BaLElBQUksS0FBSyxTQUFTO2dCQUNuRXNFLEtBQUsyVSxRQUFRLEdBQUcsSUFBSSxDQUFDdEksaUJBQWlCO1lBQ3hDLE9BQU87Z0JBQ0xyTSxLQUFLMlUsUUFBUSxHQUFHLElBQUksQ0FBQ3pPLFVBQVUsQ0FBQyxJQUFJLENBQUNuVSxPQUFPLENBQUM2SCxhQUFhLEtBQUs7WUFDakU7WUFDQW9HLEtBQUs2TCxRQUFRLEdBQUcsQ0FBQyxDQUFDQTtZQUNsQixJQUFJMkosbUJBQW1CO2dCQUNyQnhWLEtBQUttVixRQUFRLEdBQUdBO1lBQ2xCO1lBQ0FMLE9BQU8sSUFBSSxDQUFDOVEsVUFBVSxDQUFDaEUsTUFBTTtRQUMvQixPQUFPLElBQUksQ0FBQytVLFdBQVcsSUFBSSxDQUFDblQsR0FBRyxDQUFDNVAsUUFBUVUsTUFBTSxHQUFHO1lBQy9DLElBQUlzUSx5QkFBeUIsSUFBSVAscUJBQXFCdUgsY0FBYyxJQUFJLENBQUN0TCxRQUFRLEVBQUV1TCxjQUFjLElBQUksQ0FBQ3RMLFFBQVEsRUFBRXVMLG1CQUFtQixJQUFJLENBQUN0TCxhQUFhO1lBQ3JKLElBQUksQ0FBQ0YsUUFBUSxHQUFHO1lBQ2hCLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1lBQ2hCLElBQUksQ0FBQ0MsYUFBYSxHQUFHO1lBQ3JCLElBQUlvUixXQUFXLElBQUksQ0FBQ3lGLGFBQWEsQ0FBQ3pqQixRQUFRVyxNQUFNLEVBQUUsSUFBSSxDQUFDWixPQUFPLENBQUN5SCxXQUFXLElBQUksR0FBRyxPQUFPd0o7WUFDeEYsSUFBSWdTLG1CQUFtQixDQUFDRyxZQUFZLElBQUksQ0FBQ0UscUJBQXFCLElBQUk7Z0JBQ2hFLElBQUksQ0FBQ3RTLGtCQUFrQixDQUFDQyx3QkFBd0I7Z0JBQ2hELElBQUksQ0FBQ0ssOEJBQThCO2dCQUNuQyxJQUFJLElBQUksQ0FBQ3pFLGFBQWEsR0FBRyxHQUN2QjtvQkFBRSxJQUFJLENBQUM0RCxLQUFLLENBQUMsSUFBSSxDQUFDNUQsYUFBYSxFQUFFO2dCQUE4RDtnQkFDakcsSUFBSSxDQUFDRixRQUFRLEdBQUdzTDtnQkFDaEIsSUFBSSxDQUFDckwsUUFBUSxHQUFHc0w7Z0JBQ2hCLElBQUksQ0FBQ3JMLGFBQWEsR0FBR3NMO2dCQUNyQixPQUFPLElBQUksQ0FBQ29MLHdCQUF3QixDQUFDblksVUFBVTVCLFVBQVV5VSxVQUFVbkc7WUFDckU7WUFDQSxJQUFJLENBQUMxRyxxQkFBcUIsQ0FBQ0gsd0JBQXdCO1lBQ25ELElBQUksQ0FBQ3RFLFFBQVEsR0FBR3NMLGVBQWUsSUFBSSxDQUFDdEwsUUFBUTtZQUM1QyxJQUFJLENBQUNDLFFBQVEsR0FBR3NMLGVBQWUsSUFBSSxDQUFDdEwsUUFBUTtZQUM1QyxJQUFJLENBQUNDLGFBQWEsR0FBR3NMLG9CQUFvQixJQUFJLENBQUN0TCxhQUFhO1lBQzNELElBQUk4VixTQUFTLElBQUksQ0FBQzVJLFdBQVcsQ0FBQzNPLFVBQVU1QjtZQUN4Q21aLE9BQU9nQixNQUFNLEdBQUdaO1lBQ2hCSixPQUFPN1QsU0FBUyxHQUFHbVA7WUFDbkIsSUFBSXdGLG1CQUFtQjtnQkFDckJkLE9BQU9TLFFBQVEsR0FBR0E7WUFDcEI7WUFDQUwsT0FBTyxJQUFJLENBQUM5USxVQUFVLENBQUMwUSxRQUFRO1FBQ2pDLE9BQU8sSUFBSSxJQUFJLENBQUNoWixJQUFJLEtBQUsxSixRQUFRc0IsU0FBUyxFQUFFO1lBQzFDLElBQUk2aEIsWUFBWUYsaUJBQWlCO2dCQUMvQixJQUFJLENBQUN6UyxLQUFLLENBQUMsSUFBSSxDQUFDdkosS0FBSyxFQUFFO1lBQ3pCO1lBQ0EsSUFBSTBjLFNBQVMsSUFBSSxDQUFDN0osV0FBVyxDQUFDM08sVUFBVTVCO1lBQ3hDb2EsT0FBT0MsR0FBRyxHQUFHZDtZQUNiYSxPQUFPRSxLQUFLLEdBQUcsSUFBSSxDQUFDQyxhQUFhLENBQUM7Z0JBQUNDLFVBQVU7WUFBSTtZQUNqRGpCLE9BQU8sSUFBSSxDQUFDOVEsVUFBVSxDQUFDMlIsUUFBUTtRQUNqQztRQUNBLE9BQU9iO0lBQ1Q7SUFFQSxnRUFBZ0U7SUFDaEUsb0VBQW9FO0lBQ3BFLGtFQUFrRTtJQUNsRSxXQUFXO0lBRVhoQyxLQUFLM0YsYUFBYSxHQUFHLFNBQVNuSyxzQkFBc0IsRUFBRTZHLE9BQU8sRUFBRW1NLE1BQU07UUFDbkUsZ0VBQWdFO1FBQ2hFLG9FQUFvRTtRQUNwRSxJQUFJLElBQUksQ0FBQ3RhLElBQUksS0FBSzFKLFFBQVFzQyxLQUFLLEVBQUU7WUFBRSxJQUFJLENBQUMyaEIsVUFBVTtRQUFJO1FBRXRELElBQUlqVyxNQUFNa1csYUFBYSxJQUFJLENBQUMxWCxnQkFBZ0IsS0FBSyxJQUFJLENBQUN2RixLQUFLO1FBQzNELE9BQVEsSUFBSSxDQUFDeUMsSUFBSTtZQUNqQixLQUFLMUosUUFBUStELE1BQU07Z0JBQ2pCLElBQUksQ0FBQyxJQUFJLENBQUMySixVQUFVLEVBQ2xCO29CQUFFLElBQUksQ0FBQzhDLEtBQUssQ0FBQyxJQUFJLENBQUN2SixLQUFLLEVBQUU7Z0JBQXFDO2dCQUNoRStHLE9BQU8sSUFBSSxDQUFDQyxTQUFTO2dCQUNyQixJQUFJLENBQUM5SSxJQUFJO2dCQUNULElBQUksSUFBSSxDQUFDdUUsSUFBSSxLQUFLMUosUUFBUVUsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDaU4sZ0JBQWdCLEVBQ3hEO29CQUFFLElBQUksQ0FBQzZDLEtBQUssQ0FBQ3hDLEtBQUsvRyxLQUFLLEVBQUU7Z0JBQW1EO2dCQUM5RSwyQ0FBMkM7Z0JBQzNDLGlCQUFpQjtnQkFDakIsMkJBQTJCO2dCQUMzQiw2QkFBNkI7Z0JBQzdCLGFBQWE7Z0JBQ2IsMEJBQTBCO2dCQUMxQixJQUFJLElBQUksQ0FBQ3lDLElBQUksS0FBSzFKLFFBQVFlLEdBQUcsSUFBSSxJQUFJLENBQUMySSxJQUFJLEtBQUsxSixRQUFRTSxRQUFRLElBQUksSUFBSSxDQUFDb0osSUFBSSxLQUFLMUosUUFBUVUsTUFBTSxFQUM3RjtvQkFBRSxJQUFJLENBQUNzUCxVQUFVO2dCQUFJO2dCQUN2QixPQUFPLElBQUksQ0FBQ2dDLFVBQVUsQ0FBQ2hFLE1BQU07WUFFL0IsS0FBS2hPLFFBQVE4RCxLQUFLO2dCQUNoQmtLLE9BQU8sSUFBSSxDQUFDQyxTQUFTO2dCQUNyQixJQUFJLENBQUM5SSxJQUFJO2dCQUNULE9BQU8sSUFBSSxDQUFDNk0sVUFBVSxDQUFDaEUsTUFBTTtZQUUvQixLQUFLaE8sUUFBUUwsSUFBSTtnQkFDZixJQUFJd0wsV0FBVyxJQUFJLENBQUNsRSxLQUFLLEVBQUVzQyxXQUFXLElBQUksQ0FBQ0EsUUFBUSxFQUFFaUMsY0FBYyxJQUFJLENBQUNBLFdBQVc7Z0JBQ25GLElBQUkyTCxLQUFLLElBQUksQ0FBQ2pELFVBQVUsQ0FBQztnQkFDekIsSUFBSSxJQUFJLENBQUNuVSxPQUFPLENBQUN5SCxXQUFXLElBQUksS0FBSyxDQUFDZ0UsZUFBZTJMLEdBQUd4WCxJQUFJLEtBQUssV0FBVyxDQUFDLElBQUksQ0FBQ3NRLGtCQUFrQixNQUFNLElBQUksQ0FBQ0wsR0FBRyxDQUFDNVAsUUFBUW1ELFNBQVMsR0FBRztvQkFDckksSUFBSSxDQUFDc2QsZUFBZSxDQUFDakIsTUFBTVMsTUFBTTtvQkFDakMsT0FBTyxJQUFJLENBQUMzSyxhQUFhLENBQUMsSUFBSSxDQUFDd0UsV0FBVyxDQUFDM08sVUFBVTVCLFdBQVcsR0FBRyxPQUFPLE1BQU1zTztnQkFDbEY7Z0JBQ0EsSUFBSXFNLGNBQWMsQ0FBQyxJQUFJLENBQUNqVSxrQkFBa0IsSUFBSTtvQkFDNUMsSUFBSSxJQUFJLENBQUNMLEdBQUcsQ0FBQzVQLFFBQVFrQixLQUFLLEdBQ3hCO3dCQUFFLE9BQU8sSUFBSSxDQUFDcWlCLG9CQUFvQixDQUFDLElBQUksQ0FBQ3pKLFdBQVcsQ0FBQzNPLFVBQVU1QixXQUFXOzRCQUFDNE47eUJBQUcsRUFBRSxPQUFPVTtvQkFBUztvQkFDakcsSUFBSSxJQUFJLENBQUM5WCxPQUFPLENBQUN5SCxXQUFXLElBQUksS0FBSzJQLEdBQUd4WCxJQUFJLEtBQUssV0FBVyxJQUFJLENBQUMrSixJQUFJLEtBQUsxSixRQUFRTCxJQUFJLElBQUksQ0FBQzZMLGVBQ3RGLEVBQUMsSUFBSSxDQUFDaUIsd0JBQXdCLElBQUksSUFBSSxDQUFDOUMsS0FBSyxLQUFLLFFBQVEsSUFBSSxDQUFDNkIsV0FBVyxHQUFHO3dCQUMvRTJMLEtBQUssSUFBSSxDQUFDakQsVUFBVSxDQUFDO3dCQUNyQixJQUFJLElBQUksQ0FBQ2pFLGtCQUFrQixNQUFNLENBQUMsSUFBSSxDQUFDTCxHQUFHLENBQUM1UCxRQUFRa0IsS0FBSyxHQUN0RDs0QkFBRSxJQUFJLENBQUM4TyxVQUFVO3dCQUFJO3dCQUN2QixPQUFPLElBQUksQ0FBQ3VULG9CQUFvQixDQUFDLElBQUksQ0FBQ3pKLFdBQVcsQ0FBQzNPLFVBQVU1QixXQUFXOzRCQUFDNE47eUJBQUcsRUFBRSxNQUFNVTtvQkFDckY7Z0JBQ0Y7Z0JBQ0EsT0FBT1Y7WUFFVCxLQUFLblgsUUFBUUUsTUFBTTtnQkFDakIsSUFBSXlKLFFBQVEsSUFBSSxDQUFDQSxLQUFLO2dCQUN0QnFFLE9BQU8sSUFBSSxDQUFDdVAsWUFBWSxDQUFDNVQsTUFBTUEsS0FBSztnQkFDcENxRSxLQUFLbVcsS0FBSyxHQUFHO29CQUFDQyxTQUFTemEsTUFBTXlhLE9BQU87b0JBQUU5VixPQUFPM0UsTUFBTTJFLEtBQUs7Z0JBQUE7Z0JBQ3hELE9BQU9OO1lBRVQsS0FBS2hPLFFBQVFDLEdBQUc7WUFBRSxLQUFLRCxRQUFRRyxNQUFNO2dCQUNuQyxPQUFPLElBQUksQ0FBQ29kLFlBQVksQ0FBQyxJQUFJLENBQUM1VCxLQUFLO1lBRXJDLEtBQUszSixRQUFRb0UsS0FBSztZQUFFLEtBQUtwRSxRQUFRcUUsS0FBSztZQUFFLEtBQUtyRSxRQUFRc0UsTUFBTTtnQkFDekQwSixPQUFPLElBQUksQ0FBQ0MsU0FBUztnQkFDckJELEtBQUtyRSxLQUFLLEdBQUcsSUFBSSxDQUFDRCxJQUFJLEtBQUsxSixRQUFRb0UsS0FBSyxHQUFHLE9BQU8sSUFBSSxDQUFDc0YsSUFBSSxLQUFLMUosUUFBUXFFLEtBQUs7Z0JBQzdFMkosS0FBSzJQLEdBQUcsR0FBRyxJQUFJLENBQUNqVSxJQUFJLENBQUN4SyxPQUFPO2dCQUM1QixJQUFJLENBQUNpRyxJQUFJO2dCQUNULE9BQU8sSUFBSSxDQUFDNk0sVUFBVSxDQUFDaEUsTUFBTTtZQUUvQixLQUFLaE8sUUFBUVUsTUFBTTtnQkFDakIsSUFBSXVHLFFBQVEsSUFBSSxDQUFDQSxLQUFLLEVBQUVzSyxPQUFPLElBQUksQ0FBQzhTLGtDQUFrQyxDQUFDSCxZQUFZck07Z0JBQ25GLElBQUk3Ryx3QkFBd0I7b0JBQzFCLElBQUlBLHVCQUF1QkosbUJBQW1CLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQ1Usb0JBQW9CLENBQUNDLE9BQy9FO3dCQUFFUCx1QkFBdUJKLG1CQUFtQixHQUFHM0o7b0JBQU87b0JBQ3hELElBQUkrSix1QkFBdUJILGlCQUFpQixHQUFHLEdBQzdDO3dCQUFFRyx1QkFBdUJILGlCQUFpQixHQUFHNUo7b0JBQU87Z0JBQ3hEO2dCQUNBLE9BQU9zSztZQUVULEtBQUt2UixRQUFRTSxRQUFRO2dCQUNuQjBOLE9BQU8sSUFBSSxDQUFDQyxTQUFTO2dCQUNyQixJQUFJLENBQUM5SSxJQUFJO2dCQUNUNkksS0FBS3dPLFFBQVEsR0FBRyxJQUFJLENBQUNpSCxhQUFhLENBQUN6akIsUUFBUU8sUUFBUSxFQUFFLE1BQU0sTUFBTXlRO2dCQUNqRSxPQUFPLElBQUksQ0FBQ2dCLFVBQVUsQ0FBQ2hFLE1BQU07WUFFL0IsS0FBS2hPLFFBQVFRLE1BQU07Z0JBQ2pCLElBQUksQ0FBQ2lnQixlQUFlLENBQUNqQixNQUFNRSxNQUFNO2dCQUNqQyxPQUFPLElBQUksQ0FBQ3RCLFFBQVEsQ0FBQyxPQUFPcE47WUFFOUIsS0FBS2hSLFFBQVFtRCxTQUFTO2dCQUNwQjZLLE9BQU8sSUFBSSxDQUFDQyxTQUFTO2dCQUNyQixJQUFJLENBQUM5SSxJQUFJO2dCQUNULE9BQU8sSUFBSSxDQUFDbVEsYUFBYSxDQUFDdEgsTUFBTTtZQUVsQyxLQUFLaE8sUUFBUWdFLE1BQU07Z0JBQ2pCLE9BQU8sSUFBSSxDQUFDaVAsVUFBVSxDQUFDLElBQUksQ0FBQ2hGLFNBQVMsSUFBSTtZQUUzQyxLQUFLak8sUUFBUTZELElBQUk7Z0JBQ2YsT0FBTyxJQUFJLENBQUN5Z0IsUUFBUTtZQUV0QixLQUFLdGtCLFFBQVFzQixTQUFTO2dCQUNwQixPQUFPLElBQUksQ0FBQ3dpQixhQUFhO1lBRTNCLEtBQUs5akIsUUFBUW1FLE9BQU87Z0JBQ2xCLElBQUksSUFBSSxDQUFDcEUsT0FBTyxDQUFDeUgsV0FBVyxJQUFJLElBQUk7b0JBQ2xDLE9BQU8sSUFBSSxDQUFDK2MsZUFBZSxDQUFDUDtnQkFDOUIsT0FBTztvQkFDTCxPQUFPLElBQUksQ0FBQ2hVLFVBQVU7Z0JBQ3hCO1lBRUY7Z0JBQ0UsT0FBTyxJQUFJLENBQUN3VSxvQkFBb0I7UUFDbEM7SUFDRjtJQUVBMUQsS0FBSzBELG9CQUFvQixHQUFHO1FBQzFCLElBQUksQ0FBQ3hVLFVBQVU7SUFDakI7SUFFQThRLEtBQUt5RCxlQUFlLEdBQUcsU0FBU1AsTUFBTTtRQUNwQyxJQUFJaFcsT0FBTyxJQUFJLENBQUNDLFNBQVM7UUFFekIsdURBQXVEO1FBQ3ZELDRHQUE0RztRQUM1RyxJQUFJLElBQUksQ0FBQ3pDLFdBQVcsRUFBRTtZQUFFLElBQUksQ0FBQ3lGLGdCQUFnQixDQUFDLElBQUksQ0FBQ2hLLEtBQUssRUFBRTtRQUFzQztRQUNoRyxJQUFJLENBQUM5QixJQUFJO1FBRVQsSUFBSSxJQUFJLENBQUN1RSxJQUFJLEtBQUsxSixRQUFRVSxNQUFNLElBQUksQ0FBQ3NqQixRQUFRO1lBQzNDLE9BQU8sSUFBSSxDQUFDUyxrQkFBa0IsQ0FBQ3pXO1FBQ2pDLE9BQU8sSUFBSSxJQUFJLENBQUN0RSxJQUFJLEtBQUsxSixRQUFRZSxHQUFHLEVBQUU7WUFDcEMsSUFBSTJqQixPQUFPLElBQUksQ0FBQzVLLFdBQVcsQ0FBQzlMLEtBQUsvRyxLQUFLLEVBQUUrRyxLQUFLcEUsR0FBRyxJQUFJb0UsS0FBS3BFLEdBQUcsQ0FBQzNDLEtBQUs7WUFDbEV5ZCxLQUFLL2tCLElBQUksR0FBRztZQUNacU8sS0FBSzBXLElBQUksR0FBRyxJQUFJLENBQUMxUyxVQUFVLENBQUMwUyxNQUFNO1lBQ2xDLE9BQU8sSUFBSSxDQUFDQyxlQUFlLENBQUMzVztRQUM5QixPQUFPO1lBQ0wsSUFBSSxDQUFDZ0MsVUFBVTtRQUNqQjtJQUNGO0lBRUE4USxLQUFLMkQsa0JBQWtCLEdBQUcsU0FBU3pXLElBQUk7UUFDckMsSUFBSSxDQUFDN0ksSUFBSSxJQUFJLFdBQVc7UUFFeEIscUJBQXFCO1FBQ3JCNkksS0FBS2xKLE1BQU0sR0FBRyxJQUFJLENBQUN3UyxnQkFBZ0I7UUFFbkMsSUFBSSxJQUFJLENBQUN2WCxPQUFPLENBQUN5SCxXQUFXLElBQUksSUFBSTtZQUNsQyxJQUFJLENBQUMsSUFBSSxDQUFDb0ksR0FBRyxDQUFDNVAsUUFBUVcsTUFBTSxHQUFHO2dCQUM3QixJQUFJLENBQUM0UCxNQUFNLENBQUN2USxRQUFRWSxLQUFLO2dCQUN6QixJQUFJLENBQUMsSUFBSSxDQUFDd1Asa0JBQWtCLENBQUNwUSxRQUFRVyxNQUFNLEdBQUc7b0JBQzVDcU4sS0FBS2pPLE9BQU8sR0FBRyxJQUFJLENBQUN1WCxnQkFBZ0I7b0JBQ3BDLElBQUksQ0FBQyxJQUFJLENBQUMxSCxHQUFHLENBQUM1UCxRQUFRVyxNQUFNLEdBQUc7d0JBQzdCLElBQUksQ0FBQzRQLE1BQU0sQ0FBQ3ZRLFFBQVFZLEtBQUs7d0JBQ3pCLElBQUksQ0FBQyxJQUFJLENBQUN3UCxrQkFBa0IsQ0FBQ3BRLFFBQVFXLE1BQU0sR0FBRzs0QkFDNUMsSUFBSSxDQUFDcVAsVUFBVTt3QkFDakI7b0JBQ0Y7Z0JBQ0YsT0FBTztvQkFDTGhDLEtBQUtqTyxPQUFPLEdBQUc7Z0JBQ2pCO1lBQ0YsT0FBTztnQkFDTGlPLEtBQUtqTyxPQUFPLEdBQUc7WUFDakI7UUFDRixPQUFPO1lBQ0wsaUJBQWlCO1lBQ2pCLElBQUksQ0FBQyxJQUFJLENBQUM2UCxHQUFHLENBQUM1UCxRQUFRVyxNQUFNLEdBQUc7Z0JBQzdCLElBQUlpa0IsV0FBVyxJQUFJLENBQUMzZCxLQUFLO2dCQUN6QixJQUFJLElBQUksQ0FBQzJJLEdBQUcsQ0FBQzVQLFFBQVFZLEtBQUssS0FBSyxJQUFJLENBQUNnUCxHQUFHLENBQUM1UCxRQUFRVyxNQUFNLEdBQUc7b0JBQ3ZELElBQUksQ0FBQ3NRLGdCQUFnQixDQUFDMlQsVUFBVTtnQkFDbEMsT0FBTztvQkFDTCxJQUFJLENBQUM1VSxVQUFVLENBQUM0VTtnQkFDbEI7WUFDRjtRQUNGO1FBRUEsT0FBTyxJQUFJLENBQUM1UyxVQUFVLENBQUNoRSxNQUFNO0lBQy9CO0lBRUE4UyxLQUFLNkQsZUFBZSxHQUFHLFNBQVMzVyxJQUFJO1FBQ2xDLElBQUksQ0FBQzdJLElBQUksSUFBSSxXQUFXO1FBRXhCLElBQUlxRyxjQUFjLElBQUksQ0FBQ0EsV0FBVztRQUNsQ3dDLEtBQUsyVSxRQUFRLEdBQUcsSUFBSSxDQUFDek8sVUFBVSxDQUFDO1FBRWhDLElBQUlsRyxLQUFLMlUsUUFBUSxDQUFDaGpCLElBQUksS0FBSyxRQUN6QjtZQUFFLElBQUksQ0FBQ3NSLGdCQUFnQixDQUFDakQsS0FBSzJVLFFBQVEsQ0FBQzFiLEtBQUssRUFBRTtRQUE2RDtRQUM1RyxJQUFJdUUsYUFDRjtZQUFFLElBQUksQ0FBQ3lGLGdCQUFnQixDQUFDakQsS0FBSy9HLEtBQUssRUFBRTtRQUFzRDtRQUM1RixJQUFJLElBQUksQ0FBQ2xILE9BQU8sQ0FBQzBILFVBQVUsS0FBSyxZQUFZLENBQUMsSUFBSSxDQUFDMUgsT0FBTyxDQUFDK0gsMkJBQTJCLEVBQ25GO1lBQUUsSUFBSSxDQUFDbUosZ0JBQWdCLENBQUNqRCxLQUFLL0csS0FBSyxFQUFFO1FBQThDO1FBRXBGLE9BQU8sSUFBSSxDQUFDK0ssVUFBVSxDQUFDaEUsTUFBTTtJQUMvQjtJQUVBOFMsS0FBS3ZELFlBQVksR0FBRyxTQUFTNVQsS0FBSztRQUNoQyxJQUFJcUUsT0FBTyxJQUFJLENBQUNDLFNBQVM7UUFDekJELEtBQUtyRSxLQUFLLEdBQUdBO1FBQ2JxRSxLQUFLMlAsR0FBRyxHQUFHLElBQUksQ0FBQ3ZXLEtBQUssQ0FBQ3dFLEtBQUssQ0FBQyxJQUFJLENBQUMzRSxLQUFLLEVBQUUsSUFBSSxDQUFDL0IsR0FBRztRQUNoRCxJQUFJOEksS0FBSzJQLEdBQUcsQ0FBQ3ZZLFVBQVUsQ0FBQzRJLEtBQUsyUCxHQUFHLENBQUNuZixNQUFNLEdBQUcsT0FBTyxLQUFLO1lBQUV3UCxLQUFLNlcsTUFBTSxHQUFHN1csS0FBSzJQLEdBQUcsQ0FBQy9SLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBR3RGLE9BQU8sQ0FBQyxNQUFNO1FBQUs7UUFDL0csSUFBSSxDQUFDbkIsSUFBSTtRQUNULE9BQU8sSUFBSSxDQUFDNk0sVUFBVSxDQUFDaEUsTUFBTTtJQUMvQjtJQUVBOFMsS0FBS3pNLG9CQUFvQixHQUFHO1FBQzFCLElBQUksQ0FBQzlELE1BQU0sQ0FBQ3ZRLFFBQVFVLE1BQU07UUFDMUIsSUFBSW9rQixNQUFNLElBQUksQ0FBQzdWLGVBQWU7UUFDOUIsSUFBSSxDQUFDc0IsTUFBTSxDQUFDdlEsUUFBUVcsTUFBTTtRQUMxQixPQUFPbWtCO0lBQ1Q7SUFFQWhFLEtBQUtpRSxnQkFBZ0IsR0FBRyxTQUFTL0csUUFBUTtRQUN2QyxPQUFPLENBQUMsSUFBSSxDQUFDL04sa0JBQWtCO0lBQ2pDO0lBRUE2USxLQUFLdUQsa0NBQWtDLEdBQUcsU0FBU0gsVUFBVSxFQUFFck0sT0FBTztRQUNwRSxJQUFJMU0sV0FBVyxJQUFJLENBQUNsRSxLQUFLLEVBQUVzQyxXQUFXLElBQUksQ0FBQ0EsUUFBUSxFQUFFdWIsS0FBS3ZHLHFCQUFxQixJQUFJLENBQUN4ZSxPQUFPLENBQUN5SCxXQUFXLElBQUk7UUFDM0csSUFBSSxJQUFJLENBQUN6SCxPQUFPLENBQUN5SCxXQUFXLElBQUksR0FBRztZQUNqQyxJQUFJLENBQUNyQyxJQUFJO1lBRVQsSUFBSTZmLGdCQUFnQixJQUFJLENBQUMvZCxLQUFLLEVBQUVnZSxnQkFBZ0IsSUFBSSxDQUFDMWIsUUFBUTtZQUM3RCxJQUFJeVUsV0FBVyxFQUFFLEVBQUVuQixRQUFRLE1BQU1xSSxjQUFjO1lBQy9DLElBQUlsVSx5QkFBeUIsSUFBSVAscUJBQXFCdUgsY0FBYyxJQUFJLENBQUN0TCxRQUFRLEVBQUV1TCxjQUFjLElBQUksQ0FBQ3RMLFFBQVEsRUFBRXdZO1lBQ2hILElBQUksQ0FBQ3pZLFFBQVEsR0FBRztZQUNoQixJQUFJLENBQUNDLFFBQVEsR0FBRztZQUNoQiwwRUFBMEU7WUFDMUUsTUFBTyxJQUFJLENBQUNqRCxJQUFJLEtBQUsxSixRQUFRVyxNQUFNLENBQUU7Z0JBQ25Da2MsUUFBUUEsUUFBUSxRQUFRLElBQUksQ0FBQ3RNLE1BQU0sQ0FBQ3ZRLFFBQVFZLEtBQUs7Z0JBQ2pELElBQUkyZCxzQkFBc0IsSUFBSSxDQUFDbk8sa0JBQWtCLENBQUNwUSxRQUFRVyxNQUFNLEVBQUUsT0FBTztvQkFDdkV1a0IsY0FBYztvQkFDZDtnQkFDRixPQUFPLElBQUksSUFBSSxDQUFDeGIsSUFBSSxLQUFLMUosUUFBUXFCLFFBQVEsRUFBRTtvQkFDekM4akIsY0FBYyxJQUFJLENBQUNsZSxLQUFLO29CQUN4QitXLFNBQVM5VSxJQUFJLENBQUMsSUFBSSxDQUFDa2MsY0FBYyxDQUFDLElBQUksQ0FBQ2pILGdCQUFnQjtvQkFDdkQsSUFBSSxJQUFJLENBQUN6VSxJQUFJLEtBQUsxSixRQUFRWSxLQUFLLEVBQUU7d0JBQy9CLElBQUksQ0FBQ3FRLGdCQUFnQixDQUNuQixJQUFJLENBQUNoSyxLQUFLLEVBQ1Y7b0JBRUo7b0JBQ0E7Z0JBQ0YsT0FBTztvQkFDTCtXLFNBQVM5VSxJQUFJLENBQUMsSUFBSSxDQUFDb08sZ0JBQWdCLENBQUMsT0FBT3RHLHdCQUF3QixJQUFJLENBQUNvVSxjQUFjO2dCQUN4RjtZQUNGO1lBQ0EsSUFBSUMsY0FBYyxJQUFJLENBQUNuWixVQUFVLEVBQUVvWixjQUFjLElBQUksQ0FBQ3ZaLGFBQWE7WUFDbkUsSUFBSSxDQUFDd0UsTUFBTSxDQUFDdlEsUUFBUVcsTUFBTTtZQUUxQixJQUFJdWpCLGNBQWMsSUFBSSxDQUFDYSxnQkFBZ0IsQ0FBQy9HLGFBQWEsSUFBSSxDQUFDcE8sR0FBRyxDQUFDNVAsUUFBUWtCLEtBQUssR0FBRztnQkFDNUUsSUFBSSxDQUFDNlAsa0JBQWtCLENBQUNDLHdCQUF3QjtnQkFDaEQsSUFBSSxDQUFDSyw4QkFBOEI7Z0JBQ25DLElBQUksQ0FBQzNFLFFBQVEsR0FBR3NMO2dCQUNoQixJQUFJLENBQUNyTCxRQUFRLEdBQUdzTDtnQkFDaEIsT0FBTyxJQUFJLENBQUNzTixtQkFBbUIsQ0FBQ3BhLFVBQVU1QixVQUFVeVUsVUFBVW5HO1lBQ2hFO1lBRUEsSUFBSSxDQUFDbUcsU0FBU3hmLE1BQU0sSUFBSTBtQixhQUFhO2dCQUFFLElBQUksQ0FBQ2xWLFVBQVUsQ0FBQyxJQUFJLENBQUMvRCxZQUFZO1lBQUc7WUFDM0UsSUFBSWtaLGFBQWE7Z0JBQUUsSUFBSSxDQUFDblYsVUFBVSxDQUFDbVY7WUFBYztZQUNqRCxJQUFJLENBQUNoVSxxQkFBcUIsQ0FBQ0gsd0JBQXdCO1lBQ25ELElBQUksQ0FBQ3RFLFFBQVEsR0FBR3NMLGVBQWUsSUFBSSxDQUFDdEwsUUFBUTtZQUM1QyxJQUFJLENBQUNDLFFBQVEsR0FBR3NMLGVBQWUsSUFBSSxDQUFDdEwsUUFBUTtZQUU1QyxJQUFJcVIsU0FBU3hmLE1BQU0sR0FBRyxHQUFHO2dCQUN2QnNtQixNQUFNLElBQUksQ0FBQ2hMLFdBQVcsQ0FBQ2tMLGVBQWVDO2dCQUN0Q0gsSUFBSXpELFdBQVcsR0FBR3JEO2dCQUNsQixJQUFJLENBQUN3SCxZQUFZLENBQUNWLEtBQUssc0JBQXNCTyxhQUFhQztZQUM1RCxPQUFPO2dCQUNMUixNQUFNOUcsUUFBUSxDQUFDLEVBQUU7WUFDbkI7UUFDRixPQUFPO1lBQ0w4RyxNQUFNLElBQUksQ0FBQ3pRLG9CQUFvQjtRQUNqQztRQUVBLElBQUksSUFBSSxDQUFDdFUsT0FBTyxDQUFDMEksY0FBYyxFQUFFO1lBQy9CLElBQUlnZCxNQUFNLElBQUksQ0FBQzNMLFdBQVcsQ0FBQzNPLFVBQVU1QjtZQUNyQ2tjLElBQUlqVSxVQUFVLEdBQUdzVDtZQUNqQixPQUFPLElBQUksQ0FBQzlTLFVBQVUsQ0FBQ3lULEtBQUs7UUFDOUIsT0FBTztZQUNMLE9BQU9YO1FBQ1Q7SUFDRjtJQUVBaEUsS0FBS3NFLGNBQWMsR0FBRyxTQUFTTSxJQUFJO1FBQ2pDLE9BQU9BO0lBQ1Q7SUFFQTVFLEtBQUt5RSxtQkFBbUIsR0FBRyxTQUFTcGEsUUFBUSxFQUFFNUIsUUFBUSxFQUFFeVUsUUFBUSxFQUFFbkcsT0FBTztRQUN2RSxPQUFPLElBQUksQ0FBQzBMLG9CQUFvQixDQUFDLElBQUksQ0FBQ3pKLFdBQVcsQ0FBQzNPLFVBQVU1QixXQUFXeVUsVUFBVSxPQUFPbkc7SUFDMUY7SUFFQSxxRUFBcUU7SUFDckUsb0VBQW9FO0lBQ3BFLG9FQUFvRTtJQUNwRSwrREFBK0Q7SUFDL0QsaUJBQWlCO0lBRWpCLElBQUk4TixRQUFRLEVBQUU7SUFFZDdFLEtBQUt3RCxRQUFRLEdBQUc7UUFDZCxJQUFJLElBQUksQ0FBQzlZLFdBQVcsRUFBRTtZQUFFLElBQUksQ0FBQ3lGLGdCQUFnQixDQUFDLElBQUksQ0FBQ2hLLEtBQUssRUFBRTtRQUFtQztRQUM3RixJQUFJK0csT0FBTyxJQUFJLENBQUNDLFNBQVM7UUFDekIsSUFBSSxDQUFDOUksSUFBSTtRQUNULElBQUksSUFBSSxDQUFDcEYsT0FBTyxDQUFDeUgsV0FBVyxJQUFJLEtBQUssSUFBSSxDQUFDa0MsSUFBSSxLQUFLMUosUUFBUWUsR0FBRyxFQUFFO1lBQzlELElBQUkyakIsT0FBTyxJQUFJLENBQUM1SyxXQUFXLENBQUM5TCxLQUFLL0csS0FBSyxFQUFFK0csS0FBS3BFLEdBQUcsSUFBSW9FLEtBQUtwRSxHQUFHLENBQUMzQyxLQUFLO1lBQ2xFeWQsS0FBSy9rQixJQUFJLEdBQUc7WUFDWnFPLEtBQUswVyxJQUFJLEdBQUcsSUFBSSxDQUFDMVMsVUFBVSxDQUFDMFMsTUFBTTtZQUNsQyxJQUFJLENBQUN2ZixJQUFJO1lBQ1QsSUFBSXFHLGNBQWMsSUFBSSxDQUFDQSxXQUFXO1lBQ2xDd0MsS0FBSzJVLFFBQVEsR0FBRyxJQUFJLENBQUN6TyxVQUFVLENBQUM7WUFDaEMsSUFBSWxHLEtBQUsyVSxRQUFRLENBQUNoakIsSUFBSSxLQUFLLFVBQ3pCO2dCQUFFLElBQUksQ0FBQ3NSLGdCQUFnQixDQUFDakQsS0FBSzJVLFFBQVEsQ0FBQzFiLEtBQUssRUFBRTtZQUF5RDtZQUN4RyxJQUFJdUUsYUFDRjtnQkFBRSxJQUFJLENBQUN5RixnQkFBZ0IsQ0FBQ2pELEtBQUsvRyxLQUFLLEVBQUU7WUFBcUQ7WUFDM0YsSUFBSSxDQUFDLElBQUksQ0FBQzRHLGlCQUFpQixFQUN6QjtnQkFBRSxJQUFJLENBQUNvRCxnQkFBZ0IsQ0FBQ2pELEtBQUsvRyxLQUFLLEVBQUU7WUFBc0U7WUFDNUcsT0FBTyxJQUFJLENBQUMrSyxVQUFVLENBQUNoRSxNQUFNO1FBQy9CO1FBQ0EsSUFBSTdDLFdBQVcsSUFBSSxDQUFDbEUsS0FBSyxFQUFFc0MsV0FBVyxJQUFJLENBQUNBLFFBQVE7UUFDbkR5RSxLQUFLMFYsTUFBTSxHQUFHLElBQUksQ0FBQ2IsZUFBZSxDQUFDLElBQUksQ0FBQzFILGFBQWEsQ0FBQyxNQUFNLE9BQU8sT0FBT2hRLFVBQVU1QixVQUFVLE1BQU07UUFDcEcsSUFBSSxJQUFJLENBQUNxRyxHQUFHLENBQUM1UCxRQUFRVSxNQUFNLEdBQUc7WUFBRXNOLEtBQUthLFNBQVMsR0FBRyxJQUFJLENBQUM0VSxhQUFhLENBQUN6akIsUUFBUVcsTUFBTSxFQUFFLElBQUksQ0FBQ1osT0FBTyxDQUFDeUgsV0FBVyxJQUFJLEdBQUc7UUFBUSxPQUN0SDtZQUFFd0csS0FBS2EsU0FBUyxHQUFHOFc7UUFBTztRQUMvQixPQUFPLElBQUksQ0FBQzNULFVBQVUsQ0FBQ2hFLE1BQU07SUFDL0I7SUFFQSw2QkFBNkI7SUFFN0I4UyxLQUFLOEUsb0JBQW9CLEdBQUcsU0FBU3JnQixHQUFHO1FBQ3RDLElBQUl3ZSxXQUFXeGUsSUFBSXdlLFFBQVE7UUFFM0IsSUFBSWxGLE9BQU8sSUFBSSxDQUFDNVEsU0FBUztRQUN6QixJQUFJLElBQUksQ0FBQ3ZFLElBQUksS0FBSzFKLFFBQVFvQixlQUFlLEVBQUU7WUFDekMsSUFBSSxDQUFDMmlCLFVBQVU7Z0JBQ2IsSUFBSSxDQUFDOVMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDaEssS0FBSyxFQUFFO1lBQ3BDO1lBQ0E0WCxLQUFLbFYsS0FBSyxHQUFHO2dCQUNYZ1UsS0FBSyxJQUFJLENBQUNoVSxLQUFLLENBQUNyRCxPQUFPLENBQUMsVUFBVTtnQkFDbEN1ZixRQUFRO1lBQ1Y7UUFDRixPQUFPO1lBQ0xoSCxLQUFLbFYsS0FBSyxHQUFHO2dCQUNYZ1UsS0FBSyxJQUFJLENBQUN2VyxLQUFLLENBQUN3RSxLQUFLLENBQUMsSUFBSSxDQUFDM0UsS0FBSyxFQUFFLElBQUksQ0FBQy9CLEdBQUcsRUFBRW9CLE9BQU8sQ0FBQyxVQUFVO2dCQUM5RHVmLFFBQVEsSUFBSSxDQUFDbGMsS0FBSztZQUNwQjtRQUNGO1FBQ0EsSUFBSSxDQUFDeEUsSUFBSTtRQUNUMFosS0FBS2lILElBQUksR0FBRyxJQUFJLENBQUNwYyxJQUFJLEtBQUsxSixRQUFRc0IsU0FBUztRQUMzQyxPQUFPLElBQUksQ0FBQzBRLFVBQVUsQ0FBQzZNLE1BQU07SUFDL0I7SUFFQWlDLEtBQUtnRCxhQUFhLEdBQUcsU0FBU3ZlLEdBQUc7UUFDL0IsSUFBS0EsUUFBUSxLQUFLLEdBQUlBLE1BQU0sQ0FBQztRQUM3QixJQUFJd2UsV0FBV3hlLElBQUl3ZSxRQUFRO1FBQUUsSUFBS0EsYUFBYSxLQUFLLEdBQUlBLFdBQVc7UUFFbkUsSUFBSS9WLE9BQU8sSUFBSSxDQUFDQyxTQUFTO1FBQ3pCLElBQUksQ0FBQzlJLElBQUk7UUFDVDZJLEtBQUtxVCxXQUFXLEdBQUcsRUFBRTtRQUNyQixJQUFJMEUsU0FBUyxJQUFJLENBQUNILG9CQUFvQixDQUFDO1lBQUM3QixVQUFVQTtRQUFRO1FBQzFEL1YsS0FBS2dZLE1BQU0sR0FBRztZQUFDRDtTQUFPO1FBQ3RCLE1BQU8sQ0FBQ0EsT0FBT0QsSUFBSSxDQUFFO1lBQ25CLElBQUksSUFBSSxDQUFDcGMsSUFBSSxLQUFLMUosUUFBUUssR0FBRyxFQUFFO2dCQUFFLElBQUksQ0FBQ21RLEtBQUssQ0FBQyxJQUFJLENBQUNsUyxHQUFHLEVBQUU7WUFBa0M7WUFDeEYsSUFBSSxDQUFDaVMsTUFBTSxDQUFDdlEsUUFBUXVCLFlBQVk7WUFDaEN5TSxLQUFLcVQsV0FBVyxDQUFDblksSUFBSSxDQUFDLElBQUksQ0FBQytGLGVBQWU7WUFDMUMsSUFBSSxDQUFDc0IsTUFBTSxDQUFDdlEsUUFBUVMsTUFBTTtZQUMxQnVOLEtBQUtnWSxNQUFNLENBQUM5YyxJQUFJLENBQUM2YyxTQUFTLElBQUksQ0FBQ0gsb0JBQW9CLENBQUM7Z0JBQUM3QixVQUFVQTtZQUFRO1FBQ3pFO1FBQ0EsSUFBSSxDQUFDNWUsSUFBSTtRQUNULE9BQU8sSUFBSSxDQUFDNk0sVUFBVSxDQUFDaEUsTUFBTTtJQUMvQjtJQUVBOFMsS0FBS21GLFdBQVcsR0FBRyxTQUFTM0osSUFBSTtRQUM5QixPQUFPLENBQUNBLEtBQUt6QyxRQUFRLElBQUl5QyxLQUFLcEQsR0FBRyxDQUFDeFAsSUFBSSxLQUFLLGdCQUFnQjRTLEtBQUtwRCxHQUFHLENBQUN2WixJQUFJLEtBQUssV0FDMUUsS0FBSSxDQUFDK0osSUFBSSxLQUFLMUosUUFBUUwsSUFBSSxJQUFJLElBQUksQ0FBQytKLElBQUksS0FBSzFKLFFBQVFDLEdBQUcsSUFBSSxJQUFJLENBQUN5SixJQUFJLEtBQUsxSixRQUFRRyxNQUFNLElBQUksSUFBSSxDQUFDdUosSUFBSSxLQUFLMUosUUFBUU0sUUFBUSxJQUFJLElBQUksQ0FBQ29KLElBQUksQ0FBQ3hLLE9BQU8sSUFBSyxJQUFJLENBQUNhLE9BQU8sQ0FBQ3lILFdBQVcsSUFBSSxLQUFLLElBQUksQ0FBQ2tDLElBQUksS0FBSzFKLFFBQVFxQyxJQUFJLEtBQy9NLENBQUN1QyxVQUFVakcsSUFBSSxDQUFDLElBQUksQ0FBQ3lJLEtBQUssQ0FBQ3dFLEtBQUssQ0FBQyxJQUFJLENBQUNNLFVBQVUsRUFBRSxJQUFJLENBQUNqRixLQUFLO0lBQ2hFO0lBRUEsOENBQThDO0lBRTlDNlosS0FBSzFDLFFBQVEsR0FBRyxTQUFTOEgsU0FBUyxFQUFFbFYsc0JBQXNCO1FBQ3hELElBQUloRCxPQUFPLElBQUksQ0FBQ0MsU0FBUyxJQUFJNE8sUUFBUSxNQUFNbUUsV0FBVyxDQUFDO1FBQ3ZEaFQsS0FBS3FPLFVBQVUsR0FBRyxFQUFFO1FBQ3BCLElBQUksQ0FBQ2xYLElBQUk7UUFDVCxNQUFPLENBQUMsSUFBSSxDQUFDeUssR0FBRyxDQUFDNVAsUUFBUVMsTUFBTSxFQUFHO1lBQ2hDLElBQUksQ0FBQ29jLE9BQU87Z0JBQ1YsSUFBSSxDQUFDdE0sTUFBTSxDQUFDdlEsUUFBUVksS0FBSztnQkFDekIsSUFBSSxJQUFJLENBQUNiLE9BQU8sQ0FBQ3lILFdBQVcsSUFBSSxLQUFLLElBQUksQ0FBQzRJLGtCQUFrQixDQUFDcFEsUUFBUVMsTUFBTSxHQUFHO29CQUFFO2dCQUFNO1lBQ3hGLE9BQU87Z0JBQUVvYyxRQUFRO1lBQU87WUFFeEIsSUFBSVAsT0FBTyxJQUFJLENBQUM2SixhQUFhLENBQUNELFdBQVdsVjtZQUN6QyxJQUFJLENBQUNrVixXQUFXO2dCQUFFLElBQUksQ0FBQ25GLGNBQWMsQ0FBQ3pFLE1BQU0wRSxVQUFVaFE7WUFBeUI7WUFDL0VoRCxLQUFLcU8sVUFBVSxDQUFDblQsSUFBSSxDQUFDb1Q7UUFDdkI7UUFDQSxPQUFPLElBQUksQ0FBQ3RLLFVBQVUsQ0FBQ2hFLE1BQU1rWSxZQUFZLGtCQUFrQjtJQUM3RDtJQUVBcEYsS0FBS3FGLGFBQWEsR0FBRyxTQUFTRCxTQUFTLEVBQUVsVixzQkFBc0I7UUFDN0QsSUFBSXNMLE9BQU8sSUFBSSxDQUFDck8sU0FBUyxJQUFJc0wsYUFBYW5FLFNBQVNqSyxVQUFVNUI7UUFDN0QsSUFBSSxJQUFJLENBQUN4SixPQUFPLENBQUN5SCxXQUFXLElBQUksS0FBSyxJQUFJLENBQUNvSSxHQUFHLENBQUM1UCxRQUFRcUIsUUFBUSxHQUFHO1lBQy9ELElBQUk2a0IsV0FBVztnQkFDYjVKLEtBQUszRyxRQUFRLEdBQUcsSUFBSSxDQUFDekIsVUFBVSxDQUFDO2dCQUNoQyxJQUFJLElBQUksQ0FBQ3hLLElBQUksS0FBSzFKLFFBQVFZLEtBQUssRUFBRTtvQkFDL0IsSUFBSSxDQUFDcVEsZ0JBQWdCLENBQUMsSUFBSSxDQUFDaEssS0FBSyxFQUFFO2dCQUNwQztnQkFDQSxPQUFPLElBQUksQ0FBQytLLFVBQVUsQ0FBQ3NLLE1BQU07WUFDL0I7WUFDQSxrQkFBa0I7WUFDbEJBLEtBQUszRyxRQUFRLEdBQUcsSUFBSSxDQUFDMkIsZ0JBQWdCLENBQUMsT0FBT3RHO1lBQzdDLHdEQUF3RDtZQUN4RCxJQUFJLElBQUksQ0FBQ3RILElBQUksS0FBSzFKLFFBQVFZLEtBQUssSUFBSW9RLDBCQUEwQkEsdUJBQXVCTCxhQUFhLEdBQUcsR0FBRztnQkFDckdLLHVCQUF1QkwsYUFBYSxHQUFHLElBQUksQ0FBQzFKLEtBQUs7WUFDbkQ7WUFDQSxTQUFTO1lBQ1QsT0FBTyxJQUFJLENBQUMrSyxVQUFVLENBQUNzSyxNQUFNO1FBQy9CO1FBQ0EsSUFBSSxJQUFJLENBQUN2YyxPQUFPLENBQUN5SCxXQUFXLElBQUksR0FBRztZQUNqQzhVLEtBQUsvQixNQUFNLEdBQUc7WUFDZCtCLEtBQUsyRSxTQUFTLEdBQUc7WUFDakIsSUFBSWlGLGFBQWFsVix3QkFBd0I7Z0JBQ3ZDN0YsV0FBVyxJQUFJLENBQUNsRSxLQUFLO2dCQUNyQnNDLFdBQVcsSUFBSSxDQUFDQSxRQUFRO1lBQzFCO1lBQ0EsSUFBSSxDQUFDMmMsV0FDSDtnQkFBRTNNLGNBQWMsSUFBSSxDQUFDM0osR0FBRyxDQUFDNVAsUUFBUXFDLElBQUk7WUFBRztRQUM1QztRQUNBLElBQUltSixjQUFjLElBQUksQ0FBQ0EsV0FBVztRQUNsQyxJQUFJLENBQUM4TyxpQkFBaUIsQ0FBQ2dDO1FBQ3ZCLElBQUksQ0FBQzRKLGFBQWEsQ0FBQzFhLGVBQWUsSUFBSSxDQUFDekwsT0FBTyxDQUFDeUgsV0FBVyxJQUFJLEtBQUssQ0FBQytSLGVBQWUsSUFBSSxDQUFDME0sV0FBVyxDQUFDM0osT0FBTztZQUN6R2xILFVBQVU7WUFDVm1FLGNBQWMsSUFBSSxDQUFDeFosT0FBTyxDQUFDeUgsV0FBVyxJQUFJLEtBQUssSUFBSSxDQUFDb0ksR0FBRyxDQUFDNVAsUUFBUXFDLElBQUk7WUFDcEUsSUFBSSxDQUFDaVksaUJBQWlCLENBQUNnQztRQUN6QixPQUFPO1lBQ0xsSCxVQUFVO1FBQ1o7UUFDQSxJQUFJLENBQUNnUixrQkFBa0IsQ0FBQzlKLE1BQU00SixXQUFXM00sYUFBYW5FLFNBQVNqSyxVQUFVNUIsVUFBVXlILHdCQUF3QnhGO1FBQzNHLE9BQU8sSUFBSSxDQUFDd0csVUFBVSxDQUFDc0ssTUFBTTtJQUMvQjtJQUVBd0UsS0FBS3VGLGlCQUFpQixHQUFHLFNBQVMvSixJQUFJO1FBQ3BDLElBQUlwSyxPQUFPb0ssS0FBS3BELEdBQUcsQ0FBQ3ZaLElBQUk7UUFDeEIsSUFBSSxDQUFDMmEsaUJBQWlCLENBQUNnQztRQUN2QkEsS0FBSzNTLEtBQUssR0FBRyxJQUFJLENBQUM2USxXQUFXLENBQUM7UUFDOUI4QixLQUFLcEssSUFBSSxHQUFHQTtRQUNaLElBQUlvVSxhQUFhaEssS0FBS3BLLElBQUksS0FBSyxRQUFRLElBQUk7UUFDM0MsSUFBSW9LLEtBQUszUyxLQUFLLENBQUMwTyxNQUFNLENBQUM3WixNQUFNLEtBQUs4bkIsWUFBWTtZQUMzQyxJQUFJcmYsUUFBUXFWLEtBQUszUyxLQUFLLENBQUMxQyxLQUFLO1lBQzVCLElBQUlxVixLQUFLcEssSUFBSSxLQUFLLE9BQ2hCO2dCQUFFLElBQUksQ0FBQ2pCLGdCQUFnQixDQUFDaEssT0FBTztZQUFpQyxPQUVoRTtnQkFBRSxJQUFJLENBQUNnSyxnQkFBZ0IsQ0FBQ2hLLE9BQU87WUFBeUM7UUFDNUUsT0FBTztZQUNMLElBQUlxVixLQUFLcEssSUFBSSxLQUFLLFNBQVNvSyxLQUFLM1MsS0FBSyxDQUFDME8sTUFBTSxDQUFDLEVBQUUsQ0FBQzNPLElBQUksS0FBSyxlQUN2RDtnQkFBRSxJQUFJLENBQUN1SCxnQkFBZ0IsQ0FBQ3FMLEtBQUszUyxLQUFLLENBQUMwTyxNQUFNLENBQUMsRUFBRSxDQUFDcFIsS0FBSyxFQUFFO1lBQWtDO1FBQzFGO0lBQ0Y7SUFFQTZaLEtBQUtzRixrQkFBa0IsR0FBRyxTQUFTOUosSUFBSSxFQUFFNEosU0FBUyxFQUFFM00sV0FBVyxFQUFFbkUsT0FBTyxFQUFFakssUUFBUSxFQUFFNUIsUUFBUSxFQUFFeUgsc0JBQXNCLEVBQUV4RixXQUFXO1FBQy9ILElBQUksQ0FBQytOLGVBQWVuRSxPQUFNLEtBQU0sSUFBSSxDQUFDMUwsSUFBSSxLQUFLMUosUUFBUWMsS0FBSyxFQUN6RDtZQUFFLElBQUksQ0FBQ2tQLFVBQVU7UUFBSTtRQUV2QixJQUFJLElBQUksQ0FBQ0osR0FBRyxDQUFDNVAsUUFBUWMsS0FBSyxHQUFHO1lBQzNCd2IsS0FBSzNTLEtBQUssR0FBR3VjLFlBQVksSUFBSSxDQUFDcEgsaUJBQWlCLENBQUMsSUFBSSxDQUFDN1gsS0FBSyxFQUFFLElBQUksQ0FBQ3NDLFFBQVEsSUFBSSxJQUFJLENBQUMrTixnQkFBZ0IsQ0FBQyxPQUFPdEc7WUFDMUdzTCxLQUFLcEssSUFBSSxHQUFHO1FBQ2QsT0FBTyxJQUFJLElBQUksQ0FBQ25TLE9BQU8sQ0FBQ3lILFdBQVcsSUFBSSxLQUFLLElBQUksQ0FBQ2tDLElBQUksS0FBSzFKLFFBQVFVLE1BQU0sRUFBRTtZQUN4RSxJQUFJd2xCLFdBQVc7Z0JBQUUsSUFBSSxDQUFDbFcsVUFBVTtZQUFJO1lBQ3BDc00sS0FBSy9CLE1BQU0sR0FBRztZQUNkK0IsS0FBSzNTLEtBQUssR0FBRyxJQUFJLENBQUM2USxXQUFXLENBQUNqQixhQUFhbkU7WUFDM0NrSCxLQUFLcEssSUFBSSxHQUFHO1FBQ2QsT0FBTyxJQUFJLENBQUNnVSxhQUFhLENBQUMxYSxlQUNmLElBQUksQ0FBQ3pMLE9BQU8sQ0FBQ3lILFdBQVcsSUFBSSxLQUFLLENBQUM4VSxLQUFLekMsUUFBUSxJQUFJeUMsS0FBS3BELEdBQUcsQ0FBQ3hQLElBQUksS0FBSyxnQkFDcEU0UyxDQUFBQSxLQUFLcEQsR0FBRyxDQUFDdlosSUFBSSxLQUFLLFNBQVMyYyxLQUFLcEQsR0FBRyxDQUFDdlosSUFBSSxLQUFLLEtBQUksS0FDakQsSUFBSSxDQUFDK0osSUFBSSxLQUFLMUosUUFBUVksS0FBSyxJQUFJLElBQUksQ0FBQzhJLElBQUksS0FBSzFKLFFBQVFTLE1BQU0sSUFBSSxJQUFJLENBQUNpSixJQUFJLEtBQUsxSixRQUFRd0IsRUFBRSxFQUFHO1lBQ3BHLElBQUkrWCxlQUFlbkUsU0FBUztnQkFBRSxJQUFJLENBQUNwRixVQUFVO1lBQUk7WUFDakQsSUFBSSxDQUFDcVcsaUJBQWlCLENBQUMvSjtRQUN6QixPQUFPLElBQUksSUFBSSxDQUFDdmMsT0FBTyxDQUFDeUgsV0FBVyxJQUFJLEtBQUssQ0FBQzhVLEtBQUt6QyxRQUFRLElBQUl5QyxLQUFLcEQsR0FBRyxDQUFDeFAsSUFBSSxLQUFLLGNBQWM7WUFDNUYsSUFBSTZQLGVBQWVuRSxTQUFTO2dCQUFFLElBQUksQ0FBQ3BGLFVBQVU7WUFBSTtZQUNqRCxJQUFJLENBQUM4TCxlQUFlLENBQUNRLEtBQUtwRCxHQUFHO1lBQzdCLElBQUlvRCxLQUFLcEQsR0FBRyxDQUFDdlosSUFBSSxLQUFLLFdBQVcsQ0FBQyxJQUFJLENBQUNpTixhQUFhLEVBQ2xEO2dCQUFFLElBQUksQ0FBQ0EsYUFBYSxHQUFHekI7WUFBVTtZQUNuQyxJQUFJK2EsV0FBVztnQkFDYjVKLEtBQUszUyxLQUFLLEdBQUcsSUFBSSxDQUFDbVYsaUJBQWlCLENBQUMzVCxVQUFVNUIsVUFBVSxJQUFJLENBQUNnZCxRQUFRLENBQUNqSyxLQUFLcEQsR0FBRztZQUNoRixPQUFPLElBQUksSUFBSSxDQUFDeFAsSUFBSSxLQUFLMUosUUFBUXdCLEVBQUUsSUFBSXdQLHdCQUF3QjtnQkFDN0QsSUFBSUEsdUJBQXVCTixlQUFlLEdBQUcsR0FDM0M7b0JBQUVNLHVCQUF1Qk4sZUFBZSxHQUFHLElBQUksQ0FBQ3pKLEtBQUs7Z0JBQUU7Z0JBQ3pEcVYsS0FBSzNTLEtBQUssR0FBRyxJQUFJLENBQUNtVixpQkFBaUIsQ0FBQzNULFVBQVU1QixVQUFVLElBQUksQ0FBQ2dkLFFBQVEsQ0FBQ2pLLEtBQUtwRCxHQUFHO1lBQ2hGLE9BQU87Z0JBQ0xvRCxLQUFLM1MsS0FBSyxHQUFHLElBQUksQ0FBQzRjLFFBQVEsQ0FBQ2pLLEtBQUtwRCxHQUFHO1lBQ3JDO1lBQ0FvRCxLQUFLcEssSUFBSSxHQUFHO1lBQ1pvSyxLQUFLMkUsU0FBUyxHQUFHO1FBQ25CLE9BQU87WUFBRSxJQUFJLENBQUNqUixVQUFVO1FBQUk7SUFDOUI7SUFFQThRLEtBQUt4RyxpQkFBaUIsR0FBRyxTQUFTZ0MsSUFBSTtRQUNwQyxJQUFJLElBQUksQ0FBQ3ZjLE9BQU8sQ0FBQ3lILFdBQVcsSUFBSSxHQUFHO1lBQ2pDLElBQUksSUFBSSxDQUFDb0ksR0FBRyxDQUFDNVAsUUFBUU0sUUFBUSxHQUFHO2dCQUM5QmdjLEtBQUt6QyxRQUFRLEdBQUc7Z0JBQ2hCeUMsS0FBS3BELEdBQUcsR0FBRyxJQUFJLENBQUM1QixnQkFBZ0I7Z0JBQ2hDLElBQUksQ0FBQy9HLE1BQU0sQ0FBQ3ZRLFFBQVFPLFFBQVE7Z0JBQzVCLE9BQU8rYixLQUFLcEQsR0FBRztZQUNqQixPQUFPO2dCQUNMb0QsS0FBS3pDLFFBQVEsR0FBRztZQUNsQjtRQUNGO1FBQ0EsT0FBT3lDLEtBQUtwRCxHQUFHLEdBQUcsSUFBSSxDQUFDeFAsSUFBSSxLQUFLMUosUUFBUUMsR0FBRyxJQUFJLElBQUksQ0FBQ3lKLElBQUksS0FBSzFKLFFBQVFHLE1BQU0sR0FBRyxJQUFJLENBQUNnYixhQUFhLEtBQUssSUFBSSxDQUFDakgsVUFBVSxDQUFDLElBQUksQ0FBQ25VLE9BQU8sQ0FBQzZILGFBQWEsS0FBSztJQUN0SjtJQUVBLGtDQUFrQztJQUVsQ2taLEtBQUtoSixZQUFZLEdBQUcsU0FBUzlKLElBQUk7UUFDL0JBLEtBQUttSixFQUFFLEdBQUc7UUFDVixJQUFJLElBQUksQ0FBQ3BYLE9BQU8sQ0FBQ3lILFdBQVcsSUFBSSxHQUFHO1lBQUV3RyxLQUFLckQsU0FBUyxHQUFHcUQsS0FBS3dELFVBQVUsR0FBRztRQUFPO1FBQy9FLElBQUksSUFBSSxDQUFDelIsT0FBTyxDQUFDeUgsV0FBVyxJQUFJLEdBQUc7WUFBRXdHLEtBQUt0RCxLQUFLLEdBQUc7UUFBTztJQUMzRDtJQUVBLGdDQUFnQztJQUVoQ29XLEtBQUt0RyxXQUFXLEdBQUcsU0FBU2pCLFdBQVcsRUFBRW5FLE9BQU8sRUFBRXpILGdCQUFnQjtRQUNoRSxJQUFJSyxPQUFPLElBQUksQ0FBQ0MsU0FBUyxJQUFJK0osY0FBYyxJQUFJLENBQUN0TCxRQUFRLEVBQUV1TCxjQUFjLElBQUksQ0FBQ3RMLFFBQVEsRUFBRXVMLG1CQUFtQixJQUFJLENBQUN0TCxhQUFhO1FBRTVILElBQUksQ0FBQ2tMLFlBQVksQ0FBQzlKO1FBQ2xCLElBQUksSUFBSSxDQUFDak8sT0FBTyxDQUFDeUgsV0FBVyxJQUFJLEdBQzlCO1lBQUV3RyxLQUFLckQsU0FBUyxHQUFHNE87UUFBYTtRQUNsQyxJQUFJLElBQUksQ0FBQ3haLE9BQU8sQ0FBQ3lILFdBQVcsSUFBSSxHQUM5QjtZQUFFd0csS0FBS3RELEtBQUssR0FBRyxDQUFDLENBQUMwSztRQUFTO1FBRTVCLElBQUksQ0FBQzFJLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNDLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNDLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNLLFVBQVUsQ0FBQ3hDLGNBQWMySyxTQUFTcEgsS0FBS3JELFNBQVMsSUFBSVAsY0FBZXVELENBQUFBLG1CQUFtQnRELHFCQUFxQjtRQUVoSCxJQUFJLENBQUNrRyxNQUFNLENBQUN2USxRQUFRVSxNQUFNO1FBQzFCc04sS0FBS3FLLE1BQU0sR0FBRyxJQUFJLENBQUNDLGdCQUFnQixDQUFDdFksUUFBUVcsTUFBTSxFQUFFLE9BQU8sSUFBSSxDQUFDWixPQUFPLENBQUN5SCxXQUFXLElBQUk7UUFDdkYsSUFBSSxDQUFDNkosOEJBQThCO1FBQ25DLElBQUksQ0FBQytHLGlCQUFpQixDQUFDcEssTUFBTSxPQUFPLE1BQU07UUFFMUMsSUFBSSxDQUFDdEIsUUFBUSxHQUFHc0w7UUFDaEIsSUFBSSxDQUFDckwsUUFBUSxHQUFHc0w7UUFDaEIsSUFBSSxDQUFDckwsYUFBYSxHQUFHc0w7UUFDckIsT0FBTyxJQUFJLENBQUNsRyxVQUFVLENBQUNoRSxNQUFNO0lBQy9CO0lBRUEseURBQXlEO0lBRXpEOFMsS0FBS3lDLG9CQUFvQixHQUFHLFNBQVN2VixJQUFJLEVBQUVxSyxNQUFNLEVBQUVqRCxPQUFPLEVBQUV5QyxPQUFPO1FBQ2pFLElBQUlHLGNBQWMsSUFBSSxDQUFDdEwsUUFBUSxFQUFFdUwsY0FBYyxJQUFJLENBQUN0TCxRQUFRLEVBQUV1TCxtQkFBbUIsSUFBSSxDQUFDdEwsYUFBYTtRQUVuRyxJQUFJLENBQUNLLFVBQVUsQ0FBQ3hDLGNBQWMySyxTQUFTLFNBQVNsTDtRQUNoRCxJQUFJLENBQUM0TixZQUFZLENBQUM5SjtRQUNsQixJQUFJLElBQUksQ0FBQ2pPLE9BQU8sQ0FBQ3lILFdBQVcsSUFBSSxHQUFHO1lBQUV3RyxLQUFLdEQsS0FBSyxHQUFHLENBQUMsQ0FBQzBLO1FBQVM7UUFFN0QsSUFBSSxDQUFDMUksUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsYUFBYSxHQUFHO1FBRXJCb0IsS0FBS3FLLE1BQU0sR0FBRyxJQUFJLENBQUN5RixnQkFBZ0IsQ0FBQ3pGLFFBQVE7UUFDNUMsSUFBSSxDQUFDRCxpQkFBaUIsQ0FBQ3BLLE1BQU0sTUFBTSxPQUFPNko7UUFFMUMsSUFBSSxDQUFDbkwsUUFBUSxHQUFHc0w7UUFDaEIsSUFBSSxDQUFDckwsUUFBUSxHQUFHc0w7UUFDaEIsSUFBSSxDQUFDckwsYUFBYSxHQUFHc0w7UUFDckIsT0FBTyxJQUFJLENBQUNsRyxVQUFVLENBQUNoRSxNQUFNO0lBQy9CO0lBRUEsNENBQTRDO0lBRTVDOFMsS0FBSzFJLGlCQUFpQixHQUFHLFNBQVNwSyxJQUFJLEVBQUV3WSxlQUFlLEVBQUVDLFFBQVEsRUFBRTVPLE9BQU87UUFDeEUsSUFBSTZPLGVBQWVGLG1CQUFtQixJQUFJLENBQUM5YyxJQUFJLEtBQUsxSixRQUFRUSxNQUFNO1FBQ2xFLElBQUlnWSxZQUFZLElBQUksQ0FBQzdhLE1BQU0sRUFBRWdwQixZQUFZO1FBRXpDLElBQUlELGNBQWM7WUFDaEIxWSxLQUFLMEQsSUFBSSxHQUFHLElBQUksQ0FBQzRGLGdCQUFnQixDQUFDTztZQUNsQzdKLEtBQUt3RCxVQUFVLEdBQUc7WUFDbEIsSUFBSSxDQUFDb1YsV0FBVyxDQUFDNVksTUFBTTtRQUN6QixPQUFPO1lBQ0wsSUFBSTZZLFlBQVksSUFBSSxDQUFDOW1CLE9BQU8sQ0FBQ3lILFdBQVcsSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDc2YsaUJBQWlCLENBQUM5WSxLQUFLcUssTUFBTTtZQUNwRixJQUFJLENBQUNHLGFBQWFxTyxXQUFXO2dCQUMzQkYsWUFBWSxJQUFJLENBQUNwYSxlQUFlLENBQUMsSUFBSSxDQUFDckgsR0FBRztnQkFDekMsZ0VBQWdFO2dCQUNoRSxpRUFBaUU7Z0JBQ2pFLGtCQUFrQjtnQkFDbEIsSUFBSXloQixhQUFhRSxXQUNmO29CQUFFLElBQUksQ0FBQzVWLGdCQUFnQixDQUFDakQsS0FBSy9HLEtBQUssRUFBRTtnQkFBOEU7WUFDdEg7WUFDQSwrREFBK0Q7WUFDL0QscURBQXFEO1lBQ3JELElBQUl5VCxZQUFZLElBQUksQ0FBQzdOLE1BQU07WUFDM0IsSUFBSSxDQUFDQSxNQUFNLEdBQUcsRUFBRTtZQUNoQixJQUFJOFosV0FBVztnQkFBRSxJQUFJLENBQUNocEIsTUFBTSxHQUFHO1lBQU07WUFFckMsdUVBQXVFO1lBQ3ZFLDZFQUE2RTtZQUM3RSxJQUFJLENBQUNpcEIsV0FBVyxDQUFDNVksTUFBTSxDQUFDd0ssYUFBYSxDQUFDbU8sYUFBYSxDQUFDSCxtQkFBbUIsQ0FBQ0MsWUFBWSxJQUFJLENBQUNLLGlCQUFpQixDQUFDOVksS0FBS3FLLE1BQU07WUFDdEgsb0ZBQW9GO1lBQ3BGLElBQUksSUFBSSxDQUFDMWEsTUFBTSxJQUFJcVEsS0FBS21KLEVBQUUsRUFBRTtnQkFBRSxJQUFJLENBQUNZLGVBQWUsQ0FBQy9KLEtBQUttSixFQUFFLEVBQUVsTTtZQUFlO1lBQzNFK0MsS0FBSzBELElBQUksR0FBRyxJQUFJLENBQUNnQyxVQUFVLENBQUMsT0FBT3FULFdBQVdKLGFBQWEsQ0FBQ25PO1lBQzVEeEssS0FBS3dELFVBQVUsR0FBRztZQUNsQixJQUFJLENBQUNPLHNCQUFzQixDQUFDL0QsS0FBSzBELElBQUksQ0FBQ0EsSUFBSTtZQUMxQyxJQUFJLENBQUM3RSxNQUFNLEdBQUc2TjtRQUNoQjtRQUNBLElBQUksQ0FBQzFFLFNBQVM7SUFDaEI7SUFFQThLLEtBQUtnRyxpQkFBaUIsR0FBRyxTQUFTek8sTUFBTTtRQUN0QyxJQUFLLElBQUk5WixJQUFJLEdBQUdzVCxPQUFPd0csUUFBUTlaLElBQUlzVCxLQUFLclQsTUFBTSxFQUFFRCxLQUFLLEVBQ25EO1lBQ0EsSUFBSTRYLFFBQVF0RSxJQUFJLENBQUN0VCxFQUFFO1lBRW5CLElBQUk0WCxNQUFNek0sSUFBSSxLQUFLLGNBQWM7Z0JBQUUsT0FBTztZQUM1QztRQUFFO1FBQ0YsT0FBTztJQUNUO0lBRUEsOEVBQThFO0lBQzlFLDJDQUEyQztJQUUzQ29YLEtBQUs4RixXQUFXLEdBQUcsU0FBUzVZLElBQUksRUFBRWdaLGVBQWU7UUFDL0MsSUFBSUMsV0FBV3poQixPQUFPVyxNQUFNLENBQUM7UUFDN0IsSUFBSyxJQUFJNUgsSUFBSSxHQUFHc1QsT0FBTzdELEtBQUtxSyxNQUFNLEVBQUU5WixJQUFJc1QsS0FBS3JULE1BQU0sRUFBRUQsS0FBSyxFQUN4RDtZQUNBLElBQUk0WCxRQUFRdEUsSUFBSSxDQUFDdFQsRUFBRTtZQUVuQixJQUFJLENBQUM0Z0IscUJBQXFCLENBQUNoSixPQUFPdEwsVUFBVW1jLGtCQUFrQixPQUFPQztRQUN2RTtJQUNGO0lBRUEsb0VBQW9FO0lBQ3BFLDhEQUE4RDtJQUM5RCxnRUFBZ0U7SUFDaEUsa0VBQWtFO0lBQ2xFLHVCQUF1QjtJQUV2Qm5HLEtBQUsyQyxhQUFhLEdBQUcsU0FBU3BGLEtBQUssRUFBRUUsa0JBQWtCLEVBQUVELFVBQVUsRUFBRXROLHNCQUFzQjtRQUN6RixJQUFJeU4sT0FBTyxFQUFFLEVBQUU1QixRQUFRO1FBQ3ZCLE1BQU8sQ0FBQyxJQUFJLENBQUNqTixHQUFHLENBQUN5TyxPQUFRO1lBQ3ZCLElBQUksQ0FBQ3hCLE9BQU87Z0JBQ1YsSUFBSSxDQUFDdE0sTUFBTSxDQUFDdlEsUUFBUVksS0FBSztnQkFDekIsSUFBSTJkLHNCQUFzQixJQUFJLENBQUNuTyxrQkFBa0IsQ0FBQ2lPLFFBQVE7b0JBQUU7Z0JBQU07WUFDcEUsT0FBTztnQkFBRXhCLFFBQVE7WUFBTztZQUV4QixJQUFJSixNQUFPLEtBQUs7WUFDaEIsSUFBSTZCLGNBQWMsSUFBSSxDQUFDNVUsSUFBSSxLQUFLMUosUUFBUVksS0FBSyxFQUMzQztnQkFBRTZiLE1BQU07WUFBTSxPQUNYLElBQUksSUFBSSxDQUFDL1MsSUFBSSxLQUFLMUosUUFBUXFCLFFBQVEsRUFBRTtnQkFDdkNvYixNQUFNLElBQUksQ0FBQ3lCLFdBQVcsQ0FBQ2xOO2dCQUN2QixJQUFJQSwwQkFBMEIsSUFBSSxDQUFDdEgsSUFBSSxLQUFLMUosUUFBUVksS0FBSyxJQUFJb1EsdUJBQXVCTCxhQUFhLEdBQUcsR0FDbEc7b0JBQUVLLHVCQUF1QkwsYUFBYSxHQUFHLElBQUksQ0FBQzFKLEtBQUs7Z0JBQUU7WUFDekQsT0FBTztnQkFDTHdWLE1BQU0sSUFBSSxDQUFDbkYsZ0JBQWdCLENBQUMsT0FBT3RHO1lBQ3JDO1lBQ0F5TixLQUFLdlYsSUFBSSxDQUFDdVQ7UUFDWjtRQUNBLE9BQU9nQztJQUNUO0lBRUFxQyxLQUFLaEYsZUFBZSxHQUFHLFNBQVN2VyxHQUFHO1FBQ2pDLElBQUkwQixRQUFRMUIsSUFBSTBCLEtBQUs7UUFDckIsSUFBSS9CLE1BQU1LLElBQUlMLEdBQUc7UUFDakIsSUFBSXZGLE9BQU80RixJQUFJNUYsSUFBSTtRQUVuQixJQUFJLElBQUksQ0FBQzROLFdBQVcsSUFBSTVOLFNBQVMsU0FDL0I7WUFBRSxJQUFJLENBQUNzUixnQkFBZ0IsQ0FBQ2hLLE9BQU87UUFBd0Q7UUFDekYsSUFBSSxJQUFJLENBQUN1RyxPQUFPLElBQUk3TixTQUFTLFNBQzNCO1lBQUUsSUFBSSxDQUFDc1IsZ0JBQWdCLENBQUNoSyxPQUFPO1FBQThEO1FBQy9GLElBQUksQ0FBRSxLQUFJLENBQUNzSCxnQkFBZ0IsR0FBR0QsS0FBSyxHQUFHOUQsU0FBUSxLQUFNN0ssU0FBUyxhQUMzRDtZQUFFLElBQUksQ0FBQ3NSLGdCQUFnQixDQUFDaEssT0FBTztRQUFzRDtRQUN2RixJQUFJLElBQUksQ0FBQzZHLGtCQUFrQixJQUFLbk8sQ0FBQUEsU0FBUyxlQUFlQSxTQUFTLE9BQU0sR0FDckU7WUFBRSxJQUFJLENBQUM2USxLQUFLLENBQUN2SixPQUFRLGdCQUFnQnRILE9BQU87UUFBMkM7UUFDekYsSUFBSSxJQUFJLENBQUNFLFFBQVEsQ0FBQ2xCLElBQUksQ0FBQ2dCLE9BQ3JCO1lBQUUsSUFBSSxDQUFDNlEsS0FBSyxDQUFDdkosT0FBUSx5QkFBeUJ0SCxPQUFPO1FBQU87UUFDOUQsSUFBSSxJQUFJLENBQUNJLE9BQU8sQ0FBQ3lILFdBQVcsR0FBRyxLQUM3QixJQUFJLENBQUNKLEtBQUssQ0FBQ3dFLEtBQUssQ0FBQzNFLE9BQU8vQixLQUFLNFIsT0FBTyxDQUFDLFVBQVUsQ0FBQyxHQUFHO1lBQUU7UUFBTztRQUM5RCxJQUFJb1EsS0FBSyxJQUFJLENBQUN2cEIsTUFBTSxHQUFHLElBQUksQ0FBQzJOLG1CQUFtQixHQUFHLElBQUksQ0FBQzVOLGFBQWE7UUFDcEUsSUFBSXdwQixHQUFHdm9CLElBQUksQ0FBQ2dCLE9BQU87WUFDakIsSUFBSSxDQUFDLElBQUksQ0FBQzZOLE9BQU8sSUFBSTdOLFNBQVMsU0FDNUI7Z0JBQUUsSUFBSSxDQUFDc1IsZ0JBQWdCLENBQUNoSyxPQUFPO1lBQXlEO1lBQzFGLElBQUksQ0FBQ2dLLGdCQUFnQixDQUFDaEssT0FBUSxrQkFBa0J0SCxPQUFPO1FBQ3pEO0lBQ0Y7SUFFQSxvRUFBb0U7SUFDcEUsK0RBQStEO0lBQy9ELGVBQWU7SUFFZm1oQixLQUFLNU0sVUFBVSxHQUFHLFNBQVNpVCxPQUFPO1FBQ2hDLElBQUluWixPQUFPLElBQUksQ0FBQ29aLGNBQWM7UUFDOUIsSUFBSSxDQUFDamlCLElBQUksQ0FBQyxDQUFDLENBQUNnaUI7UUFDWixJQUFJLENBQUNuVixVQUFVLENBQUNoRSxNQUFNO1FBQ3RCLElBQUksQ0FBQ21aLFNBQVM7WUFDWixJQUFJLENBQUNyTCxlQUFlLENBQUM5TjtZQUNyQixJQUFJQSxLQUFLck8sSUFBSSxLQUFLLFdBQVcsQ0FBQyxJQUFJLENBQUNpTixhQUFhLEVBQzlDO2dCQUFFLElBQUksQ0FBQ0EsYUFBYSxHQUFHb0IsS0FBSy9HLEtBQUs7WUFBRTtRQUN2QztRQUNBLE9BQU8rRztJQUNUO0lBRUE4UyxLQUFLc0csY0FBYyxHQUFHO1FBQ3BCLElBQUlwWixPQUFPLElBQUksQ0FBQ0MsU0FBUztRQUN6QixJQUFJLElBQUksQ0FBQ3ZFLElBQUksS0FBSzFKLFFBQVFMLElBQUksRUFBRTtZQUM5QnFPLEtBQUtyTyxJQUFJLEdBQUcsSUFBSSxDQUFDZ0ssS0FBSztRQUN4QixPQUFPLElBQUksSUFBSSxDQUFDRCxJQUFJLENBQUN4SyxPQUFPLEVBQUU7WUFDNUI4TyxLQUFLck8sSUFBSSxHQUFHLElBQUksQ0FBQytKLElBQUksQ0FBQ3hLLE9BQU87WUFFN0IscURBQXFEO1lBQ3JELHNFQUFzRTtZQUN0RSxpSEFBaUg7WUFDakgsb0hBQW9IO1lBQ3BILElBQUksQ0FBQzhPLEtBQUtyTyxJQUFJLEtBQUssV0FBV3FPLEtBQUtyTyxJQUFJLEtBQUssVUFBUyxLQUNsRCxLQUFJLENBQUN1TSxVQUFVLEtBQUssSUFBSSxDQUFDRCxZQUFZLEdBQUcsS0FBSyxJQUFJLENBQUM3RSxLQUFLLENBQUNoQyxVQUFVLENBQUMsSUFBSSxDQUFDNkcsWUFBWSxNQUFNLEVBQUMsR0FBSTtnQkFDaEcsSUFBSSxDQUFDRSxPQUFPLENBQUNpSSxHQUFHO1lBQ2xCO1lBQ0EsSUFBSSxDQUFDMUssSUFBSSxHQUFHMUosUUFBUUwsSUFBSTtRQUMxQixPQUFPO1lBQ0wsSUFBSSxDQUFDcVEsVUFBVTtRQUNqQjtRQUNBLE9BQU9oQztJQUNUO0lBRUE4UyxLQUFLekcsaUJBQWlCLEdBQUc7UUFDdkIsSUFBSXJNLE9BQU8sSUFBSSxDQUFDQyxTQUFTO1FBQ3pCLElBQUksSUFBSSxDQUFDdkUsSUFBSSxLQUFLMUosUUFBUUksU0FBUyxFQUFFO1lBQ25DNE4sS0FBS3JPLElBQUksR0FBRyxJQUFJLENBQUNnSyxLQUFLO1FBQ3hCLE9BQU87WUFDTCxJQUFJLENBQUNxRyxVQUFVO1FBQ2pCO1FBQ0EsSUFBSSxDQUFDN0ssSUFBSTtRQUNULElBQUksQ0FBQzZNLFVBQVUsQ0FBQ2hFLE1BQU07UUFFdEIsMkJBQTJCO1FBQzNCLElBQUksSUFBSSxDQUFDak8sT0FBTyxDQUFDbUksa0JBQWtCLEVBQUU7WUFDbkMsSUFBSSxJQUFJLENBQUNpRixnQkFBZ0IsQ0FBQzNPLE1BQU0sS0FBSyxHQUFHO2dCQUN0QyxJQUFJLENBQUNnUyxLQUFLLENBQUN4QyxLQUFLL0csS0FBSyxFQUFHLHFCQUFzQitHLEtBQUtyTyxJQUFJLEdBQUk7WUFDN0QsT0FBTztnQkFDTCxJQUFJLENBQUN3TixnQkFBZ0IsQ0FBQyxJQUFJLENBQUNBLGdCQUFnQixDQUFDM08sTUFBTSxHQUFHLEVBQUUsQ0FBQ29jLElBQUksQ0FBQzFSLElBQUksQ0FBQzhFO1lBQ3BFO1FBQ0Y7UUFFQSxPQUFPQTtJQUNUO0lBRUEsNENBQTRDO0lBRTVDOFMsS0FBS1MsVUFBVSxHQUFHLFNBQVMxSixPQUFPO1FBQ2hDLElBQUksQ0FBQyxJQUFJLENBQUNuTCxRQUFRLEVBQUU7WUFBRSxJQUFJLENBQUNBLFFBQVEsR0FBRyxJQUFJLENBQUN6RixLQUFLO1FBQUU7UUFFbEQsSUFBSStHLE9BQU8sSUFBSSxDQUFDQyxTQUFTO1FBQ3pCLElBQUksQ0FBQzlJLElBQUk7UUFDVCxJQUFJLElBQUksQ0FBQ3VFLElBQUksS0FBSzFKLFFBQVFhLElBQUksSUFBSSxJQUFJLENBQUNvUCxrQkFBa0IsTUFBTyxJQUFJLENBQUN2RyxJQUFJLEtBQUsxSixRQUFRcUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDcUgsSUFBSSxDQUFDdEssVUFBVSxFQUFHO1lBQ3BINE8sS0FBS3FaLFFBQVEsR0FBRztZQUNoQnJaLEtBQUsySCxRQUFRLEdBQUc7UUFDbEIsT0FBTztZQUNMM0gsS0FBS3FaLFFBQVEsR0FBRyxJQUFJLENBQUN6WCxHQUFHLENBQUM1UCxRQUFRcUMsSUFBSTtZQUNyQzJMLEtBQUsySCxRQUFRLEdBQUcsSUFBSSxDQUFDMkIsZ0JBQWdCLENBQUNPO1FBQ3hDO1FBQ0EsT0FBTyxJQUFJLENBQUM3RixVQUFVLENBQUNoRSxNQUFNO0lBQy9CO0lBRUE4UyxLQUFLeUIsVUFBVSxHQUFHLFNBQVMxSyxPQUFPO1FBQ2hDLElBQUksQ0FBQyxJQUFJLENBQUNsTCxRQUFRLEVBQUU7WUFBRSxJQUFJLENBQUNBLFFBQVEsR0FBRyxJQUFJLENBQUMxRixLQUFLO1FBQUU7UUFFbEQsSUFBSStHLE9BQU8sSUFBSSxDQUFDQyxTQUFTO1FBQ3pCLElBQUksQ0FBQzlJLElBQUk7UUFDVDZJLEtBQUsySCxRQUFRLEdBQUcsSUFBSSxDQUFDbU0sZUFBZSxDQUFDLE1BQU0sTUFBTSxPQUFPaks7UUFDeEQsT0FBTyxJQUFJLENBQUM3RixVQUFVLENBQUNoRSxNQUFNO0lBQy9CO0lBRUEsSUFBSXNaLE9BQU9wYyxPQUFPekYsU0FBUztJQUUzQixnRUFBZ0U7SUFDaEUsaUVBQWlFO0lBQ2pFLDhEQUE4RDtJQUM5RCxrRUFBa0U7SUFDbEUsV0FBVztJQUVYNmhCLEtBQUs5VyxLQUFLLEdBQUcsU0FBU2xTLEdBQUcsRUFBRWlwQixPQUFPO1FBQ2hDLElBQUkzZCxNQUFNekMsWUFBWSxJQUFJLENBQUNDLEtBQUssRUFBRTlJO1FBQ2xDaXBCLFdBQVcsT0FBTzNkLElBQUlsRCxJQUFJLEdBQUcsTUFBTWtELElBQUloRCxNQUFNLEdBQUc7UUFDaEQsSUFBSSxJQUFJLENBQUNNLFVBQVUsRUFBRTtZQUNuQnFnQixXQUFXLFNBQVMsSUFBSSxDQUFDcmdCLFVBQVU7UUFDckM7UUFDQSxJQUFJc2dCLE1BQU0sSUFBSUMsWUFBWUY7UUFDMUJDLElBQUlscEIsR0FBRyxHQUFHQTtRQUFLa3BCLElBQUk1ZCxHQUFHLEdBQUdBO1FBQUs0ZCxJQUFJRSxRQUFRLEdBQUcsSUFBSSxDQUFDcHBCLEdBQUc7UUFDckQsTUFBTWtwQjtJQUNSO0lBRUFGLEtBQUtyVyxnQkFBZ0IsR0FBR3FXLEtBQUs5VyxLQUFLO0lBRWxDOFcsS0FBS3hiLFdBQVcsR0FBRztRQUNqQixJQUFJLElBQUksQ0FBQy9MLE9BQU8sQ0FBQ29JLFNBQVMsRUFBRTtZQUMxQixPQUFPLElBQUkxQixTQUFTLElBQUksQ0FBQ2tGLE9BQU8sRUFBRSxJQUFJLENBQUNyTixHQUFHLEdBQUcsSUFBSSxDQUFDbU4sU0FBUztRQUM3RDtJQUNGO0lBRUEsSUFBSWtjLE9BQU96YyxPQUFPekYsU0FBUztJQUUzQixJQUFJbWlCLFFBQVEsU0FBU0EsTUFBTXRaLEtBQUs7UUFDOUIsSUFBSSxDQUFDQSxLQUFLLEdBQUdBO1FBQ2IsNERBQTREO1FBQzVELElBQUksQ0FBQ3VaLEdBQUcsR0FBRyxFQUFFO1FBQ2Isa0VBQWtFO1FBQ2xFLElBQUksQ0FBQ0MsT0FBTyxHQUFHLEVBQUU7UUFDakIsc0ZBQXNGO1FBQ3RGLElBQUksQ0FBQ0MsU0FBUyxHQUFHLEVBQUU7SUFDckI7SUFFQSxrSUFBa0k7SUFFbElKLEtBQUsxYSxVQUFVLEdBQUcsU0FBU3FCLEtBQUs7UUFDOUIsSUFBSSxDQUFDdEIsVUFBVSxDQUFDOUQsSUFBSSxDQUFDLElBQUkwZSxNQUFNdFo7SUFDakM7SUFFQXFaLEtBQUszUixTQUFTLEdBQUc7UUFDZixJQUFJLENBQUNoSixVQUFVLENBQUNvSCxHQUFHO0lBQ3JCO0lBRUEsaUJBQWlCO0lBQ2pCLHlFQUF5RTtJQUN6RSx5RUFBeUU7SUFDekV1VCxLQUFLblosMEJBQTBCLEdBQUcsU0FBU3daLEtBQUs7UUFDOUMsT0FBTyxNQUFPMVosS0FBSyxHQUFHdkUsa0JBQW1CLENBQUMsSUFBSSxDQUFDdUMsUUFBUSxJQUFLMGIsTUFBTTFaLEtBQUssR0FBR3hFO0lBQzVFO0lBRUE2ZCxLQUFLekksV0FBVyxHQUFHLFNBQVN2ZixJQUFJLEVBQUVvZixXQUFXLEVBQUV6Z0IsR0FBRztRQUNoRCxJQUFJMnBCLGFBQWE7UUFDakIsSUFBSWxKLGdCQUFnQmpVLGNBQWM7WUFDaEMsSUFBSWtkLFFBQVEsSUFBSSxDQUFDdlosWUFBWTtZQUM3QndaLGFBQWFELE1BQU1GLE9BQU8sQ0FBQ2hSLE9BQU8sQ0FBQ25YLFFBQVEsQ0FBQyxLQUFLcW9CLE1BQU1ELFNBQVMsQ0FBQ2pSLE9BQU8sQ0FBQ25YLFFBQVEsQ0FBQyxLQUFLcW9CLE1BQU1ILEdBQUcsQ0FBQy9RLE9BQU8sQ0FBQ25YLFFBQVEsQ0FBQztZQUNsSHFvQixNQUFNRixPQUFPLENBQUM1ZSxJQUFJLENBQUN2SjtZQUNuQixJQUFJLElBQUksQ0FBQzJNLFFBQVEsSUFBSzBiLE1BQU0xWixLQUFLLEdBQUd4RSxXQUNsQztnQkFBRSxPQUFPLElBQUksQ0FBQ2dELGdCQUFnQixDQUFDbk4sS0FBSztZQUFFO1FBQzFDLE9BQU8sSUFBSW9mLGdCQUFnQi9ULG1CQUFtQjtZQUM1QyxJQUFJa2QsVUFBVSxJQUFJLENBQUN6WixZQUFZO1lBQy9CeVosUUFBUUosT0FBTyxDQUFDNWUsSUFBSSxDQUFDdko7UUFDdkIsT0FBTyxJQUFJb2YsZ0JBQWdCaFUsZUFBZTtZQUN4QyxJQUFJb2QsVUFBVSxJQUFJLENBQUMxWixZQUFZO1lBQy9CLElBQUksSUFBSSxDQUFDYixtQkFBbUIsRUFDMUI7Z0JBQUVxYSxhQUFhRSxRQUFRTCxPQUFPLENBQUNoUixPQUFPLENBQUNuWCxRQUFRLENBQUM7WUFBRyxPQUVuRDtnQkFBRXNvQixhQUFhRSxRQUFRTCxPQUFPLENBQUNoUixPQUFPLENBQUNuWCxRQUFRLENBQUMsS0FBS3dvQixRQUFRTixHQUFHLENBQUMvUSxPQUFPLENBQUNuWCxRQUFRLENBQUM7WUFBRztZQUN2RndvQixRQUFRSixTQUFTLENBQUM3ZSxJQUFJLENBQUN2SjtRQUN6QixPQUFPO1lBQ0wsSUFBSyxJQUFJcEIsSUFBSSxJQUFJLENBQUN5TyxVQUFVLENBQUN4TyxNQUFNLEdBQUcsR0FBR0QsS0FBSyxHQUFHLEVBQUVBLEVBQUc7Z0JBQ3BELElBQUk2cEIsVUFBVSxJQUFJLENBQUNwYixVQUFVLENBQUN6TyxFQUFFO2dCQUNoQyxJQUFJNnBCLFFBQVFOLE9BQU8sQ0FBQ2hSLE9BQU8sQ0FBQ25YLFFBQVEsQ0FBQyxLQUFLLENBQUUsU0FBUzJPLEtBQUssR0FBR25FLHNCQUF1QmllLFFBQVFOLE9BQU8sQ0FBQyxFQUFFLEtBQUtub0IsSUFBRyxLQUMxRyxDQUFDLElBQUksQ0FBQzZPLDBCQUEwQixDQUFDNFosWUFBWUEsUUFBUUwsU0FBUyxDQUFDalIsT0FBTyxDQUFDblgsUUFBUSxDQUFDLEdBQUc7b0JBQ3JGc29CLGFBQWE7b0JBQ2I7Z0JBQ0Y7Z0JBQ0FHLFFBQVFQLEdBQUcsQ0FBQzNlLElBQUksQ0FBQ3ZKO2dCQUNqQixJQUFJLElBQUksQ0FBQzJNLFFBQVEsSUFBSzhiLFFBQVE5WixLQUFLLEdBQUd4RSxXQUNwQztvQkFBRSxPQUFPLElBQUksQ0FBQ2dELGdCQUFnQixDQUFDbk4sS0FBSztnQkFBRTtnQkFDeEMsSUFBSXlvQixRQUFROVosS0FBSyxHQUFHOUQsV0FBVztvQkFBRTtnQkFBTTtZQUN6QztRQUNGO1FBQ0EsSUFBSXlkLFlBQVk7WUFBRSxJQUFJLENBQUNoWCxnQkFBZ0IsQ0FBQzNTLEtBQU0saUJBQWlCcUIsT0FBTztRQUFpQztJQUN6RztJQUVBZ29CLEtBQUszTCxnQkFBZ0IsR0FBRyxTQUFTN0UsRUFBRTtRQUNqQyxpRUFBaUU7UUFDakUsSUFBSSxJQUFJLENBQUNuSyxVQUFVLENBQUMsRUFBRSxDQUFDOGEsT0FBTyxDQUFDaFIsT0FBTyxDQUFDSyxHQUFHeFgsSUFBSSxNQUFNLENBQUMsS0FDakQsSUFBSSxDQUFDcU4sVUFBVSxDQUFDLEVBQUUsQ0FBQzZhLEdBQUcsQ0FBQy9RLE9BQU8sQ0FBQ0ssR0FBR3hYLElBQUksTUFBTSxDQUFDLEdBQUc7WUFDbEQsSUFBSSxDQUFDbU4sZ0JBQWdCLENBQUNxSyxHQUFHeFgsSUFBSSxDQUFDLEdBQUd3WDtRQUNuQztJQUNGO0lBRUF3USxLQUFLbFosWUFBWSxHQUFHO1FBQ2xCLE9BQU8sSUFBSSxDQUFDekIsVUFBVSxDQUFDLElBQUksQ0FBQ0EsVUFBVSxDQUFDeE8sTUFBTSxHQUFHLEVBQUU7SUFDcEQ7SUFFQW1wQixLQUFLdFosZUFBZSxHQUFHO1FBQ3JCLElBQUssSUFBSTlQLElBQUksSUFBSSxDQUFDeU8sVUFBVSxDQUFDeE8sTUFBTSxHQUFHLElBQUlELElBQUs7WUFDN0MsSUFBSXlwQixRQUFRLElBQUksQ0FBQ2hiLFVBQVUsQ0FBQ3pPLEVBQUU7WUFDOUIsSUFBSXlwQixNQUFNMVosS0FBSyxHQUFJOUQsQ0FBQUEsWUFBWUQseUJBQXlCRCx3QkFBdUIsR0FBSTtnQkFBRSxPQUFPMGQ7WUFBTTtRQUNwRztJQUNGO0lBRUEsZ0dBQWdHO0lBQ2hHTCxLQUFLcFosZ0JBQWdCLEdBQUc7UUFDdEIsSUFBSyxJQUFJaFEsSUFBSSxJQUFJLENBQUN5TyxVQUFVLENBQUN4TyxNQUFNLEdBQUcsSUFBSUQsSUFBSztZQUM3QyxJQUFJeXBCLFFBQVEsSUFBSSxDQUFDaGIsVUFBVSxDQUFDek8sRUFBRTtZQUM5QixJQUFJeXBCLE1BQU0xWixLQUFLLEdBQUk5RCxDQUFBQSxZQUFZRCx5QkFBeUJELHdCQUF1QixLQUMzRSxDQUFFMGQsQ0FBQUEsTUFBTTFaLEtBQUssR0FBR3BFLFdBQVUsR0FBSTtnQkFBRSxPQUFPOGQ7WUFBTTtRQUNuRDtJQUNGO0lBRUEsSUFBSUssT0FBTyxTQUFTQSxLQUFLclosTUFBTSxFQUFFMVEsR0FBRyxFQUFFc0wsR0FBRztRQUN2QyxJQUFJLENBQUNGLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ3pDLEtBQUssR0FBRzNJO1FBQ2IsSUFBSSxDQUFDNEcsR0FBRyxHQUFHO1FBQ1gsSUFBSThKLE9BQU9qUCxPQUFPLENBQUNvSSxTQUFTLEVBQzFCO1lBQUUsSUFBSSxDQUFDeUIsR0FBRyxHQUFHLElBQUk3QyxlQUFlaUksUUFBUXBGO1FBQU07UUFDaEQsSUFBSW9GLE9BQU9qUCxPQUFPLENBQUN5SSxnQkFBZ0IsRUFDakM7WUFBRSxJQUFJLENBQUN0QixVQUFVLEdBQUc4SCxPQUFPalAsT0FBTyxDQUFDeUksZ0JBQWdCO1FBQUU7UUFDdkQsSUFBSXdHLE9BQU9qUCxPQUFPLENBQUN1SSxNQUFNLEVBQ3ZCO1lBQUUsSUFBSSxDQUFDdUIsS0FBSyxHQUFHO2dCQUFDdkw7Z0JBQUs7YUFBRTtRQUFFO0lBQzdCO0lBRUEsK0NBQStDO0lBRS9DLElBQUlncUIsT0FBT3BkLE9BQU96RixTQUFTO0lBRTNCNmlCLEtBQUtyYSxTQUFTLEdBQUc7UUFDZixPQUFPLElBQUlvYSxLQUFLLElBQUksRUFBRSxJQUFJLENBQUNwaEIsS0FBSyxFQUFFLElBQUksQ0FBQ3NDLFFBQVE7SUFDakQ7SUFFQStlLEtBQUt4TyxXQUFXLEdBQUcsU0FBU3hiLEdBQUcsRUFBRXNMLEdBQUc7UUFDbEMsT0FBTyxJQUFJeWUsS0FBSyxJQUFJLEVBQUUvcEIsS0FBS3NMO0lBQzdCO0lBRUEsMERBQTBEO0lBRTFELFNBQVM0YixhQUFheFgsSUFBSSxFQUFFdEUsSUFBSSxFQUFFcEwsR0FBRyxFQUFFc0wsR0FBRztRQUN4Q29FLEtBQUt0RSxJQUFJLEdBQUdBO1FBQ1pzRSxLQUFLOUksR0FBRyxHQUFHNUc7UUFDWCxJQUFJLElBQUksQ0FBQ3lCLE9BQU8sQ0FBQ29JLFNBQVMsRUFDeEI7WUFBRTZGLEtBQUtwRSxHQUFHLENBQUMxRSxHQUFHLEdBQUcwRTtRQUFLO1FBQ3hCLElBQUksSUFBSSxDQUFDN0osT0FBTyxDQUFDdUksTUFBTSxFQUNyQjtZQUFFMEYsS0FBS25FLEtBQUssQ0FBQyxFQUFFLEdBQUd2TDtRQUFLO1FBQ3pCLE9BQU8wUDtJQUNUO0lBRUFzYSxLQUFLdFcsVUFBVSxHQUFHLFNBQVNoRSxJQUFJLEVBQUV0RSxJQUFJO1FBQ25DLE9BQU84YixhQUFhemYsSUFBSSxDQUFDLElBQUksRUFBRWlJLE1BQU10RSxNQUFNLElBQUksQ0FBQ3dDLFVBQVUsRUFBRSxJQUFJLENBQUNILGFBQWE7SUFDaEY7SUFFQSxnQ0FBZ0M7SUFFaEN1YyxLQUFLOUMsWUFBWSxHQUFHLFNBQVN4WCxJQUFJLEVBQUV0RSxJQUFJLEVBQUVwTCxHQUFHLEVBQUVzTCxHQUFHO1FBQy9DLE9BQU80YixhQUFhemYsSUFBSSxDQUFDLElBQUksRUFBRWlJLE1BQU10RSxNQUFNcEwsS0FBS3NMO0lBQ2xEO0lBRUEwZSxLQUFLL0IsUUFBUSxHQUFHLFNBQVN2WSxJQUFJO1FBQzNCLElBQUl1YSxVQUFVLElBQUlGLEtBQUssSUFBSSxFQUFFcmEsS0FBSy9HLEtBQUssRUFBRSxJQUFJLENBQUNzQyxRQUFRO1FBQ3RELElBQUssSUFBSStTLFFBQVF0TyxLQUFNO1lBQUV1YSxPQUFPLENBQUNqTSxLQUFLLEdBQUd0TyxJQUFJLENBQUNzTyxLQUFLO1FBQUU7UUFDckQsT0FBT2lNO0lBQ1Q7SUFFQSw4RkFBOEY7SUFDOUYsSUFBSUMsNkJBQTZCO0lBRWpDLHFGQUFxRjtJQUNyRixtQ0FBbUM7SUFDbkMsc0hBQXNIO0lBRXRILG1DQUFtQztJQUNuQyxJQUFJQyx3QkFBd0I7SUFDNUIsSUFBSUMseUJBQXlCRCx3QkFBd0I7SUFDckQsSUFBSUUseUJBQXlCRDtJQUM3QixJQUFJRSx5QkFBeUJELHlCQUF5QjtJQUN0RCxJQUFJRSx5QkFBeUJEO0lBQzdCLElBQUlFLHlCQUF5QkQ7SUFFN0IsSUFBSUUsMEJBQTBCO1FBQzVCLEdBQUdOO1FBQ0gsSUFBSUM7UUFDSixJQUFJQztRQUNKLElBQUlDO1FBQ0osSUFBSUM7UUFDSixJQUFJQztJQUNOO0lBRUEsOENBQThDO0lBQzlDLElBQUlFLGtDQUFrQztJQUV0QyxJQUFJQyxtQ0FBbUM7UUFDckMsR0FBRztRQUNILElBQUk7UUFDSixJQUFJO1FBQ0osSUFBSTtRQUNKLElBQUk7UUFDSixJQUFJRDtJQUNOO0lBRUEseUNBQXlDO0lBQ3pDLElBQUlFLCtCQUErQjtJQUVuQywrQkFBK0I7SUFDL0IsSUFBSUMsb0JBQW9CO0lBQ3hCLElBQUlDLHFCQUFxQkQsb0JBQW9CO0lBQzdDLElBQUlFLHFCQUFxQkQscUJBQXFCO0lBQzlDLElBQUlFLHFCQUFxQkQscUJBQXFCO0lBQzlDLElBQUlFLHFCQUFxQkQscUJBQXFCO0lBQzlDLElBQUlFLHFCQUFxQkQscUJBQXFCLE1BQU1mO0lBRXBELElBQUlpQixzQkFBc0I7UUFDeEIsR0FBR047UUFDSCxJQUFJQztRQUNKLElBQUlDO1FBQ0osSUFBSUM7UUFDSixJQUFJQztRQUNKLElBQUlDO0lBQ047SUFFQSxJQUFJRSxPQUFPLENBQUM7SUFDWixTQUFTQyxpQkFBaUJuaUIsV0FBVztRQUNuQyxJQUFJb2lCLElBQUlGLElBQUksQ0FBQ2xpQixZQUFZLEdBQUc7WUFDMUJxaUIsUUFBUXpqQixZQUFZMmlCLHVCQUF1QixDQUFDdmhCLFlBQVksR0FBRyxNQUFNMGhCO1lBQ2pFWSxpQkFBaUIxakIsWUFBWTZpQixnQ0FBZ0MsQ0FBQ3poQixZQUFZO1lBQzFFdWlCLFdBQVc7Z0JBQ1RDLGtCQUFrQjVqQixZQUFZOGlCO2dCQUM5QmUsUUFBUTdqQixZQUFZcWpCLG1CQUFtQixDQUFDamlCLFlBQVk7WUFDdEQ7UUFDRjtRQUNBb2lCLEVBQUVHLFNBQVMsQ0FBQ0csaUJBQWlCLEdBQUdOLEVBQUVHLFNBQVMsQ0FBQ0UsTUFBTTtRQUVsREwsRUFBRUcsU0FBUyxDQUFDSSxFQUFFLEdBQUdQLEVBQUVHLFNBQVMsQ0FBQ0MsZ0JBQWdCO1FBQzdDSixFQUFFRyxTQUFTLENBQUNLLEVBQUUsR0FBR1IsRUFBRUcsU0FBUyxDQUFDRSxNQUFNO1FBQ25DTCxFQUFFRyxTQUFTLENBQUNNLEdBQUcsR0FBR1QsRUFBRUcsU0FBUyxDQUFDRyxpQkFBaUI7SUFDakQ7SUFFQSxJQUFLLElBQUkzckIsSUFBSSxHQUFHc1QsT0FBTztRQUFDO1FBQUc7UUFBSTtRQUFJO1FBQUk7UUFBSTtLQUFHLEVBQUV0VCxJQUFJc1QsS0FBS3JULE1BQU0sRUFBRUQsS0FBSyxFQUFHO1FBQ3ZFLElBQUlpSixjQUFjcUssSUFBSSxDQUFDdFQsRUFBRTtRQUV6Qm9yQixpQkFBaUJuaUI7SUFDbkI7SUFFQSxJQUFJOGlCLE9BQU9wZixPQUFPekYsU0FBUztJQUUzQiwrREFBK0Q7SUFDL0Qsb0VBQW9FO0lBQ3BFLElBQUk4a0IsV0FBVyxTQUFTQSxTQUFTMVAsTUFBTSxFQUFFaUksSUFBSTtRQUMzQyw0QkFBNEI7UUFDNUIsSUFBSSxDQUFDakksTUFBTSxHQUFHQTtRQUNkLDBDQUEwQztRQUMxQyxJQUFJLENBQUNpSSxJQUFJLEdBQUdBLFFBQVEsSUFBSTtJQUMxQjtJQUVBeUgsU0FBUzlrQixTQUFTLENBQUMra0IsYUFBYSxHQUFHLFNBQVNBLGNBQWVDLEdBQUc7UUFDNUQsNkRBQTZEO1FBQzdELG9EQUFvRDtRQUNwRCxJQUFLLElBQUlydEIsUUFBTyxJQUFJLEVBQUVBLE9BQU1BLFFBQU9BLE1BQUt5ZCxNQUFNLENBQUU7WUFDOUMsSUFBSyxJQUFJc0csUUFBUXNKLEtBQUt0SixPQUFPQSxRQUFRQSxNQUFNdEcsTUFBTSxDQUFFO2dCQUNqRCxJQUFJemQsTUFBSzBsQixJQUFJLEtBQUszQixNQUFNMkIsSUFBSSxJQUFJMWxCLFVBQVMrakIsT0FBTztvQkFBRSxPQUFPO2dCQUFLO1lBQ2hFO1FBQ0Y7UUFDQSxPQUFPO0lBQ1Q7SUFFQW9KLFNBQVM5a0IsU0FBUyxDQUFDaWxCLE9BQU8sR0FBRyxTQUFTQTtRQUNwQyxPQUFPLElBQUlILFNBQVMsSUFBSSxDQUFDMVAsTUFBTSxFQUFFLElBQUksQ0FBQ2lJLElBQUk7SUFDNUM7SUFFQSxJQUFJNkgsd0JBQXdCLFNBQVNBLHNCQUFzQjNiLE1BQU07UUFDL0QsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDNGIsVUFBVSxHQUFHLFFBQVM1YixDQUFBQSxPQUFPalAsT0FBTyxDQUFDeUgsV0FBVyxJQUFJLElBQUksT0FBTyxFQUFDLElBQU13SCxDQUFBQSxPQUFPalAsT0FBTyxDQUFDeUgsV0FBVyxJQUFJLElBQUksTUFBTSxFQUFDLElBQU13SCxDQUFBQSxPQUFPalAsT0FBTyxDQUFDeUgsV0FBVyxJQUFJLEtBQUssTUFBTSxFQUFDLElBQU13SCxDQUFBQSxPQUFPalAsT0FBTyxDQUFDeUgsV0FBVyxJQUFJLEtBQUssTUFBTSxFQUFDO1FBQ3BOLElBQUksQ0FBQ3FqQixpQkFBaUIsR0FBR25CLElBQUksQ0FBQzFhLE9BQU9qUCxPQUFPLENBQUN5SCxXQUFXLElBQUksS0FBSyxLQUFLd0gsT0FBT2pQLE9BQU8sQ0FBQ3lILFdBQVcsQ0FBQztRQUNqRyxJQUFJLENBQUMxQyxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUN3SixLQUFLLEdBQUc7UUFDYixJQUFJLENBQUNySCxLQUFLLEdBQUc7UUFDYixJQUFJLENBQUM2akIsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDQyxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNDLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQzFzQixHQUFHLEdBQUc7UUFDWCxJQUFJLENBQUMyc0IsWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0MsZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ0MsMkJBQTJCLEdBQUc7UUFDbkMsSUFBSSxDQUFDQyxrQkFBa0IsR0FBRztRQUMxQixJQUFJLENBQUNDLGdCQUFnQixHQUFHO1FBQ3hCLElBQUksQ0FBQ0MsVUFBVSxHQUFHOWxCLE9BQU9XLE1BQU0sQ0FBQztRQUNoQyxJQUFJLENBQUNvbEIsa0JBQWtCLEdBQUcsRUFBRTtRQUM1QixJQUFJLENBQUNDLFFBQVEsR0FBRztJQUNsQjtJQUVBYixzQkFBc0JsbEIsU0FBUyxDQUFDZ21CLEtBQUssR0FBRyxTQUFTQSxNQUFPeGtCLEtBQUssRUFBRW1kLE9BQU8sRUFBRTlWLEtBQUs7UUFDM0UsSUFBSW9kLGNBQWNwZCxNQUFNd0ksT0FBTyxDQUFDLFNBQVMsQ0FBQztRQUMxQyxJQUFJNlUsVUFBVXJkLE1BQU13SSxPQUFPLENBQUMsU0FBUyxDQUFDO1FBQ3RDLElBQUksQ0FBQzdQLEtBQUssR0FBR0EsUUFBUTtRQUNyQixJQUFJLENBQUNuQyxNQUFNLEdBQUdzZixVQUFVO1FBQ3hCLElBQUksQ0FBQzlWLEtBQUssR0FBR0E7UUFDYixJQUFJb2QsZUFBZSxJQUFJLENBQUMxYyxNQUFNLENBQUNqUCxPQUFPLENBQUN5SCxXQUFXLElBQUksSUFBSTtZQUN4RCxJQUFJLENBQUNzakIsT0FBTyxHQUFHO1lBQ2YsSUFBSSxDQUFDQyxPQUFPLEdBQUc7WUFDZixJQUFJLENBQUNDLE9BQU8sR0FBRztRQUNqQixPQUFPO1lBQ0wsSUFBSSxDQUFDRixPQUFPLEdBQUdhLFdBQVcsSUFBSSxDQUFDM2MsTUFBTSxDQUFDalAsT0FBTyxDQUFDeUgsV0FBVyxJQUFJO1lBQzdELElBQUksQ0FBQ3VqQixPQUFPLEdBQUc7WUFDZixJQUFJLENBQUNDLE9BQU8sR0FBR1csV0FBVyxJQUFJLENBQUMzYyxNQUFNLENBQUNqUCxPQUFPLENBQUN5SCxXQUFXLElBQUk7UUFDL0Q7SUFDRjtJQUVBbWpCLHNCQUFzQmxsQixTQUFTLENBQUMrSyxLQUFLLEdBQUcsU0FBU0EsTUFBTytXLE9BQU87UUFDN0QsSUFBSSxDQUFDdlksTUFBTSxDQUFDaUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDaEssS0FBSyxFQUFHLGtDQUFtQyxJQUFJLENBQUNuQyxNQUFNLEdBQUksUUFBUXlpQjtJQUN0RztJQUVBLCtGQUErRjtJQUMvRiwwRkFBMEY7SUFDMUZvRCxzQkFBc0JsbEIsU0FBUyxDQUFDbW1CLEVBQUUsR0FBRyxTQUFTQSxHQUFJcnRCLENBQUMsRUFBRXN0QixNQUFNO1FBQ3ZELElBQUtBLFdBQVcsS0FBSyxHQUFJQSxTQUFTO1FBRXBDLElBQUlDLElBQUksSUFBSSxDQUFDaG5CLE1BQU07UUFDbkIsSUFBSWluQixJQUFJRCxFQUFFdHRCLE1BQU07UUFDaEIsSUFBSUQsS0FBS3d0QixHQUFHO1lBQ1YsT0FBTyxDQUFDO1FBQ1Y7UUFDQSxJQUFJQyxJQUFJRixFQUFFMW1CLFVBQVUsQ0FBQzdHO1FBQ3JCLElBQUksQ0FBRXN0QixDQUFBQSxVQUFVLElBQUksQ0FBQ2YsT0FBTyxLQUFLa0IsS0FBSyxVQUFVQSxLQUFLLFVBQVV6dEIsSUFBSSxLQUFLd3RCLEdBQUc7WUFDekUsT0FBT0M7UUFDVDtRQUNBLElBQUk3bUIsT0FBTzJtQixFQUFFMW1CLFVBQVUsQ0FBQzdHLElBQUk7UUFDNUIsT0FBTzRHLFFBQVEsVUFBVUEsUUFBUSxTQUFTLENBQUM2bUIsS0FBSyxFQUFDLElBQUs3bUIsT0FBTyxZQUFZNm1CO0lBQzNFO0lBRUFyQixzQkFBc0JsbEIsU0FBUyxDQUFDd21CLFNBQVMsR0FBRyxTQUFTQSxVQUFXMXRCLENBQUMsRUFBRXN0QixNQUFNO1FBQ3JFLElBQUtBLFdBQVcsS0FBSyxHQUFJQSxTQUFTO1FBRXBDLElBQUlDLElBQUksSUFBSSxDQUFDaG5CLE1BQU07UUFDbkIsSUFBSWluQixJQUFJRCxFQUFFdHRCLE1BQU07UUFDaEIsSUFBSUQsS0FBS3d0QixHQUFHO1lBQ1YsT0FBT0E7UUFDVDtRQUNBLElBQUlDLElBQUlGLEVBQUUxbUIsVUFBVSxDQUFDN0csSUFBSTRHO1FBQ3pCLElBQUksQ0FBRTBtQixDQUFBQSxVQUFVLElBQUksQ0FBQ2YsT0FBTyxLQUFLa0IsS0FBSyxVQUFVQSxLQUFLLFVBQVV6dEIsSUFBSSxLQUFLd3RCLEtBQ3BFLENBQUM1bUIsT0FBTzJtQixFQUFFMW1CLFVBQVUsQ0FBQzdHLElBQUksRUFBQyxJQUFLLFVBQVU0RyxPQUFPLFFBQVE7WUFDMUQsT0FBTzVHLElBQUk7UUFDYjtRQUNBLE9BQU9BLElBQUk7SUFDYjtJQUVBb3NCLHNCQUFzQmxsQixTQUFTLENBQUN5bUIsT0FBTyxHQUFHLFNBQVNBLFFBQVNMLE1BQU07UUFDOUQsSUFBS0EsV0FBVyxLQUFLLEdBQUlBLFNBQVM7UUFFcEMsT0FBTyxJQUFJLENBQUNELEVBQUUsQ0FBQyxJQUFJLENBQUN0dEIsR0FBRyxFQUFFdXRCO0lBQzNCO0lBRUFsQixzQkFBc0JsbEIsU0FBUyxDQUFDMG1CLFNBQVMsR0FBRyxTQUFTQSxVQUFXTixNQUFNO1FBQ2xFLElBQUtBLFdBQVcsS0FBSyxHQUFJQSxTQUFTO1FBRXBDLE9BQU8sSUFBSSxDQUFDRCxFQUFFLENBQUMsSUFBSSxDQUFDSyxTQUFTLENBQUMsSUFBSSxDQUFDM3RCLEdBQUcsRUFBRXV0QixTQUFTQTtJQUNuRDtJQUVBbEIsc0JBQXNCbGxCLFNBQVMsQ0FBQzJtQixPQUFPLEdBQUcsU0FBU0EsUUFBU1AsTUFBTTtRQUM5RCxJQUFLQSxXQUFXLEtBQUssR0FBSUEsU0FBUztRQUVwQyxJQUFJLENBQUN2dEIsR0FBRyxHQUFHLElBQUksQ0FBQzJ0QixTQUFTLENBQUMsSUFBSSxDQUFDM3RCLEdBQUcsRUFBRXV0QjtJQUN0QztJQUVBbEIsc0JBQXNCbGxCLFNBQVMsQ0FBQ21LLEdBQUcsR0FBRyxTQUFTQSxJQUFLeWMsRUFBRSxFQUFFUixNQUFNO1FBQzFELElBQUtBLFdBQVcsS0FBSyxHQUFJQSxTQUFTO1FBRXBDLElBQUksSUFBSSxDQUFDSyxPQUFPLENBQUNMLFlBQVlRLElBQUk7WUFDL0IsSUFBSSxDQUFDRCxPQUFPLENBQUNQO1lBQ2IsT0FBTztRQUNUO1FBQ0EsT0FBTztJQUNUO0lBRUFsQixzQkFBc0JsbEIsU0FBUyxDQUFDNm1CLFFBQVEsR0FBRyxTQUFTQSxTQUFVQyxHQUFHLEVBQUVWLE1BQU07UUFDckUsSUFBS0EsV0FBVyxLQUFLLEdBQUlBLFNBQVM7UUFFcEMsSUFBSXZ0QixNQUFNLElBQUksQ0FBQ0EsR0FBRztRQUNsQixJQUFLLElBQUlDLElBQUksR0FBR3NULE9BQU8wYSxLQUFLaHVCLElBQUlzVCxLQUFLclQsTUFBTSxFQUFFRCxLQUFLLEVBQUc7WUFDbkQsSUFBSTh0QixLQUFLeGEsSUFBSSxDQUFDdFQsRUFBRTtZQUVkLElBQUkydEIsVUFBVSxJQUFJLENBQUNOLEVBQUUsQ0FBQ3R0QixLQUFLdXRCO1lBQzdCLElBQUlLLFlBQVksQ0FBQyxLQUFLQSxZQUFZRyxJQUFJO2dCQUNwQyxPQUFPO1lBQ1Q7WUFDQS90QixNQUFNLElBQUksQ0FBQzJ0QixTQUFTLENBQUMzdEIsS0FBS3V0QjtRQUM1QjtRQUNBLElBQUksQ0FBQ3Z0QixHQUFHLEdBQUdBO1FBQ1gsT0FBTztJQUNUO0lBRUE7Ozs7O0dBS0MsR0FDRGdzQixLQUFLa0MsbUJBQW1CLEdBQUcsU0FBU0MsS0FBSztRQUN2QyxJQUFJN0IsYUFBYTZCLE1BQU03QixVQUFVO1FBQ2pDLElBQUl0YyxRQUFRbWUsTUFBTW5lLEtBQUs7UUFFdkIsSUFBSW9lLElBQUk7UUFDUixJQUFJQyxJQUFJO1FBRVIsSUFBSyxJQUFJcHVCLElBQUksR0FBR0EsSUFBSStQLE1BQU05UCxNQUFNLEVBQUVELElBQUs7WUFDckMsSUFBSXF1QixPQUFPdGUsTUFBTXFCLE1BQU0sQ0FBQ3BSO1lBQ3hCLElBQUlxc0IsV0FBVzlULE9BQU8sQ0FBQzhWLFVBQVUsQ0FBQyxHQUFHO2dCQUNuQyxJQUFJLENBQUNwYyxLQUFLLENBQUNpYyxNQUFNeGxCLEtBQUssRUFBRTtZQUMxQjtZQUNBLElBQUlxSCxNQUFNd0ksT0FBTyxDQUFDOFYsTUFBTXJ1QixJQUFJLEtBQUssQ0FBQyxHQUFHO2dCQUNuQyxJQUFJLENBQUNpUyxLQUFLLENBQUNpYyxNQUFNeGxCLEtBQUssRUFBRTtZQUMxQjtZQUNBLElBQUkybEIsU0FBUyxLQUFLO2dCQUFFRixJQUFJO1lBQU07WUFDOUIsSUFBSUUsU0FBUyxLQUFLO2dCQUFFRCxJQUFJO1lBQU07UUFDaEM7UUFDQSxJQUFJLElBQUksQ0FBQzVzQixPQUFPLENBQUN5SCxXQUFXLElBQUksTUFBTWtsQixLQUFLQyxHQUFHO1lBQzVDLElBQUksQ0FBQ25jLEtBQUssQ0FBQ2ljLE1BQU14bEIsS0FBSyxFQUFFO1FBQzFCO0lBQ0Y7SUFFQSxTQUFTNGxCLFFBQVFobkIsR0FBRztRQUNsQixJQUFLLElBQUlpbkIsS0FBS2puQixJQUFLO1lBQUUsT0FBTztRQUFLO1FBQ2pDLE9BQU87SUFDVDtJQUVBOzs7OztHQUtDLEdBQ0R5a0IsS0FBS3lDLHFCQUFxQixHQUFHLFNBQVNOLEtBQUs7UUFDekMsSUFBSSxDQUFDTyxjQUFjLENBQUNQO1FBRXBCLHVFQUF1RTtRQUN2RSwrREFBK0Q7UUFDL0QsdUVBQXVFO1FBQ3ZFLDBFQUEwRTtRQUMxRSx5RUFBeUU7UUFDekUsSUFBSSxDQUFDQSxNQUFNekIsT0FBTyxJQUFJLElBQUksQ0FBQ2pyQixPQUFPLENBQUN5SCxXQUFXLElBQUksS0FBS3FsQixRQUFRSixNQUFNbkIsVUFBVSxHQUFHO1lBQ2hGbUIsTUFBTXpCLE9BQU8sR0FBRztZQUNoQixJQUFJLENBQUNnQyxjQUFjLENBQUNQO1FBQ3RCO0lBQ0Y7SUFFQSxnRUFBZ0U7SUFDaEVuQyxLQUFLMEMsY0FBYyxHQUFHLFNBQVNQLEtBQUs7UUFDbENBLE1BQU1udUIsR0FBRyxHQUFHO1FBQ1ptdUIsTUFBTXhCLFlBQVksR0FBRztRQUNyQndCLE1BQU12QixlQUFlLEdBQUc7UUFDeEJ1QixNQUFNdEIsMkJBQTJCLEdBQUc7UUFDcENzQixNQUFNckIsa0JBQWtCLEdBQUc7UUFDM0JxQixNQUFNcEIsZ0JBQWdCLEdBQUc7UUFDekJvQixNQUFNbkIsVUFBVSxHQUFHOWxCLE9BQU9XLE1BQU0sQ0FBQztRQUNqQ3NtQixNQUFNbEIsa0JBQWtCLENBQUMvc0IsTUFBTSxHQUFHO1FBQ2xDaXVCLE1BQU1qQixRQUFRLEdBQUc7UUFFakIsSUFBSSxDQUFDeUIsa0JBQWtCLENBQUNSO1FBRXhCLElBQUlBLE1BQU1udUIsR0FBRyxLQUFLbXVCLE1BQU0zbkIsTUFBTSxDQUFDdEcsTUFBTSxFQUFFO1lBQ3JDLGdDQUFnQztZQUNoQyxJQUFJaXVCLE1BQU03YyxHQUFHLENBQUMsS0FBSyxLQUFLLE1BQUs7Z0JBQzNCNmMsTUFBTWpjLEtBQUssQ0FBQztZQUNkO1lBQ0EsSUFBSWljLE1BQU03YyxHQUFHLENBQUMsS0FBSyxLQUFLLFFBQU82YyxNQUFNN2MsR0FBRyxDQUFDLEtBQUssS0FBSyxNQUFLO2dCQUN0RDZjLE1BQU1qYyxLQUFLLENBQUM7WUFDZDtRQUNGO1FBQ0EsSUFBSWljLE1BQU1wQixnQkFBZ0IsR0FBR29CLE1BQU1yQixrQkFBa0IsRUFBRTtZQUNyRHFCLE1BQU1qYyxLQUFLLENBQUM7UUFDZDtRQUNBLElBQUssSUFBSWpTLElBQUksR0FBR3NULE9BQU80YSxNQUFNbEIsa0JBQWtCLEVBQUVodEIsSUFBSXNULEtBQUtyVCxNQUFNLEVBQUVELEtBQUssRUFBRztZQUN4RSxJQUFJb0IsT0FBT2tTLElBQUksQ0FBQ3RULEVBQUU7WUFFbEIsSUFBSSxDQUFDa3VCLE1BQU1uQixVQUFVLENBQUMzckIsS0FBSyxFQUFFO2dCQUMzQjhzQixNQUFNamMsS0FBSyxDQUFDO1lBQ2Q7UUFDRjtJQUNGO0lBRUEsb0VBQW9FO0lBQ3BFOFosS0FBSzJDLGtCQUFrQixHQUFHLFNBQVNSLEtBQUs7UUFDdEMsSUFBSVMsbUJBQW1CLElBQUksQ0FBQ250QixPQUFPLENBQUN5SCxXQUFXLElBQUk7UUFDbkQsSUFBSTBsQixrQkFBa0I7WUFBRVQsTUFBTWpCLFFBQVEsR0FBRyxJQUFJakIsU0FBU2tDLE1BQU1qQixRQUFRLEVBQUU7UUFBTztRQUM3RSxJQUFJLENBQUMyQixrQkFBa0IsQ0FBQ1Y7UUFDeEIsTUFBT0EsTUFBTTdjLEdBQUcsQ0FBQyxLQUFLLEtBQUssS0FBSztZQUM5QixJQUFJc2Qsa0JBQWtCO2dCQUFFVCxNQUFNakIsUUFBUSxHQUFHaUIsTUFBTWpCLFFBQVEsQ0FBQ2QsT0FBTztZQUFJO1lBQ25FLElBQUksQ0FBQ3lDLGtCQUFrQixDQUFDVjtRQUMxQjtRQUNBLElBQUlTLGtCQUFrQjtZQUFFVCxNQUFNakIsUUFBUSxHQUFHaUIsTUFBTWpCLFFBQVEsQ0FBQzNRLE1BQU07UUFBRTtRQUVoRSwrQkFBK0I7UUFDL0IsSUFBSSxJQUFJLENBQUN1UyxvQkFBb0IsQ0FBQ1gsT0FBTyxPQUFPO1lBQzFDQSxNQUFNamMsS0FBSyxDQUFDO1FBQ2Q7UUFDQSxJQUFJaWMsTUFBTTdjLEdBQUcsQ0FBQyxLQUFLLEtBQUssTUFBSztZQUMzQjZjLE1BQU1qYyxLQUFLLENBQUM7UUFDZDtJQUNGO0lBRUEsb0VBQW9FO0lBQ3BFOFosS0FBSzZDLGtCQUFrQixHQUFHLFNBQVNWLEtBQUs7UUFDdEMsTUFBT0EsTUFBTW51QixHQUFHLEdBQUdtdUIsTUFBTTNuQixNQUFNLENBQUN0RyxNQUFNLElBQUksSUFBSSxDQUFDNnVCLGNBQWMsQ0FBQ1osT0FBUSxDQUFDO0lBQ3pFO0lBRUEsb0VBQW9FO0lBQ3BFbkMsS0FBSytDLGNBQWMsR0FBRyxTQUFTWixLQUFLO1FBQ2xDLElBQUksSUFBSSxDQUFDYSxtQkFBbUIsQ0FBQ2IsUUFBUTtZQUNuQyx5REFBeUQ7WUFDekQsMEVBQTBFO1lBQzFFLDhCQUE4QjtZQUM5QixJQUFJQSxNQUFNdEIsMkJBQTJCLElBQUksSUFBSSxDQUFDaUMsb0JBQW9CLENBQUNYLFFBQVE7Z0JBQ3pFLCtCQUErQjtnQkFDL0IsSUFBSUEsTUFBTTNCLE9BQU8sRUFBRTtvQkFDakIyQixNQUFNamMsS0FBSyxDQUFDO2dCQUNkO1lBQ0Y7WUFDQSxPQUFPO1FBQ1Q7UUFFQSxJQUFJaWMsTUFBTTNCLE9BQU8sR0FBRyxJQUFJLENBQUN5QyxjQUFjLENBQUNkLFNBQVMsSUFBSSxDQUFDZSxzQkFBc0IsQ0FBQ2YsUUFBUTtZQUNuRixJQUFJLENBQUNXLG9CQUFvQixDQUFDWDtZQUMxQixPQUFPO1FBQ1Q7UUFFQSxPQUFPO0lBQ1Q7SUFFQSx5RUFBeUU7SUFDekVuQyxLQUFLZ0QsbUJBQW1CLEdBQUcsU0FBU2IsS0FBSztRQUN2QyxJQUFJeGxCLFFBQVF3bEIsTUFBTW51QixHQUFHO1FBQ3JCbXVCLE1BQU10QiwyQkFBMkIsR0FBRztRQUVwQyxPQUFPO1FBQ1AsSUFBSXNCLE1BQU03YyxHQUFHLENBQUMsS0FBSyxLQUFLLFFBQU82YyxNQUFNN2MsR0FBRyxDQUFDLEtBQUssS0FBSyxNQUFLO1lBQ3RELE9BQU87UUFDVDtRQUVBLFFBQVE7UUFDUixJQUFJNmMsTUFBTTdjLEdBQUcsQ0FBQyxLQUFLLEtBQUssTUFBSztZQUMzQixJQUFJNmMsTUFBTTdjLEdBQUcsQ0FBQyxLQUFLLEtBQUssUUFBTzZjLE1BQU03YyxHQUFHLENBQUMsS0FBSyxLQUFLLE1BQUs7Z0JBQ3RELE9BQU87WUFDVDtZQUNBNmMsTUFBTW51QixHQUFHLEdBQUcySTtRQUNkO1FBRUEseUJBQXlCO1FBQ3pCLElBQUl3bEIsTUFBTTdjLEdBQUcsQ0FBQyxLQUFLLEtBQUssUUFBTzZjLE1BQU03YyxHQUFHLENBQUMsS0FBSyxLQUFLLE1BQUs7WUFDdEQsSUFBSTZkLGFBQWE7WUFDakIsSUFBSSxJQUFJLENBQUMxdEIsT0FBTyxDQUFDeUgsV0FBVyxJQUFJLEdBQUc7Z0JBQ2pDaW1CLGFBQWFoQixNQUFNN2MsR0FBRyxDQUFDLEtBQUssS0FBSztZQUNuQztZQUNBLElBQUk2YyxNQUFNN2MsR0FBRyxDQUFDLEtBQUssS0FBSyxRQUFPNmMsTUFBTTdjLEdBQUcsQ0FBQyxLQUFLLEtBQUssTUFBSztnQkFDdEQsSUFBSSxDQUFDcWQsa0JBQWtCLENBQUNSO2dCQUN4QixJQUFJLENBQUNBLE1BQU03YyxHQUFHLENBQUMsS0FBSyxLQUFLLE1BQUs7b0JBQzVCNmMsTUFBTWpjLEtBQUssQ0FBQztnQkFDZDtnQkFDQWljLE1BQU10QiwyQkFBMkIsR0FBRyxDQUFDc0M7Z0JBQ3JDLE9BQU87WUFDVDtRQUNGO1FBRUFoQixNQUFNbnVCLEdBQUcsR0FBRzJJO1FBQ1osT0FBTztJQUNUO0lBRUEsbUVBQW1FO0lBQ25FcWpCLEtBQUs4QyxvQkFBb0IsR0FBRyxTQUFTWCxLQUFLLEVBQUVpQixPQUFPO1FBQ2pELElBQUtBLFlBQVksS0FBSyxHQUFJQSxVQUFVO1FBRXBDLElBQUksSUFBSSxDQUFDQywwQkFBMEIsQ0FBQ2xCLE9BQU9pQixVQUFVO1lBQ25EakIsTUFBTTdjLEdBQUcsQ0FBQyxLQUFLLEtBQUs7WUFDcEIsT0FBTztRQUNUO1FBQ0EsT0FBTztJQUNUO0lBRUEseUVBQXlFO0lBQ3pFMGEsS0FBS3FELDBCQUEwQixHQUFHLFNBQVNsQixLQUFLLEVBQUVpQixPQUFPO1FBQ3ZELE9BQ0VqQixNQUFNN2MsR0FBRyxDQUFDLEtBQUssS0FBSyxRQUNwQjZjLE1BQU03YyxHQUFHLENBQUMsS0FBSyxLQUFLLFFBQ3BCNmMsTUFBTTdjLEdBQUcsQ0FBQyxLQUFLLEtBQUssUUFDcEIsSUFBSSxDQUFDZ2UsMEJBQTBCLENBQUNuQixPQUFPaUI7SUFFM0M7SUFDQXBELEtBQUtzRCwwQkFBMEIsR0FBRyxTQUFTbkIsS0FBSyxFQUFFaUIsT0FBTztRQUN2RCxJQUFJem1CLFFBQVF3bEIsTUFBTW51QixHQUFHO1FBQ3JCLElBQUltdUIsTUFBTTdjLEdBQUcsQ0FBQyxLQUFLLEtBQUssTUFBSztZQUMzQixJQUFJaWUsTUFBTSxHQUFHQyxNQUFNLENBQUM7WUFDcEIsSUFBSSxJQUFJLENBQUNDLHVCQUF1QixDQUFDdEIsUUFBUTtnQkFDdkNvQixNQUFNcEIsTUFBTXhCLFlBQVk7Z0JBQ3hCLElBQUl3QixNQUFNN2MsR0FBRyxDQUFDLEtBQUssS0FBSyxRQUFPLElBQUksQ0FBQ21lLHVCQUF1QixDQUFDdEIsUUFBUTtvQkFDbEVxQixNQUFNckIsTUFBTXhCLFlBQVk7Z0JBQzFCO2dCQUNBLElBQUl3QixNQUFNN2MsR0FBRyxDQUFDLEtBQUssS0FBSyxNQUFLO29CQUMzQiwyRUFBMkU7b0JBQzNFLElBQUlrZSxRQUFRLENBQUMsS0FBS0EsTUFBTUQsT0FBTyxDQUFDSCxTQUFTO3dCQUN2Q2pCLE1BQU1qYyxLQUFLLENBQUM7b0JBQ2Q7b0JBQ0EsT0FBTztnQkFDVDtZQUNGO1lBQ0EsSUFBSWljLE1BQU0zQixPQUFPLElBQUksQ0FBQzRDLFNBQVM7Z0JBQzdCakIsTUFBTWpjLEtBQUssQ0FBQztZQUNkO1lBQ0FpYyxNQUFNbnVCLEdBQUcsR0FBRzJJO1FBQ2Q7UUFDQSxPQUFPO0lBQ1Q7SUFFQSw2REFBNkQ7SUFDN0RxakIsS0FBS2lELGNBQWMsR0FBRyxTQUFTZCxLQUFLO1FBQ2xDLE9BQ0UsSUFBSSxDQUFDdUIsMkJBQTJCLENBQUN2QixVQUNqQ0EsTUFBTTdjLEdBQUcsQ0FBQyxLQUFLLEtBQUssUUFDcEIsSUFBSSxDQUFDcWUsa0NBQWtDLENBQUN4QixVQUN4QyxJQUFJLENBQUN5Qix3QkFBd0IsQ0FBQ3pCLFVBQzlCLElBQUksQ0FBQzBCLDBCQUEwQixDQUFDMUIsVUFDaEMsSUFBSSxDQUFDMkIsd0JBQXdCLENBQUMzQjtJQUVsQztJQUNBbkMsS0FBSzJELGtDQUFrQyxHQUFHLFNBQVN4QixLQUFLO1FBQ3RELElBQUl4bEIsUUFBUXdsQixNQUFNbnVCLEdBQUc7UUFDckIsSUFBSW11QixNQUFNN2MsR0FBRyxDQUFDLEtBQUssS0FBSyxNQUFLO1lBQzNCLElBQUksSUFBSSxDQUFDeWUsb0JBQW9CLENBQUM1QixRQUFRO2dCQUNwQyxPQUFPO1lBQ1Q7WUFDQUEsTUFBTW51QixHQUFHLEdBQUcySTtRQUNkO1FBQ0EsT0FBTztJQUNUO0lBQ0FxakIsS0FBSzZELDBCQUEwQixHQUFHLFNBQVMxQixLQUFLO1FBQzlDLElBQUl4bEIsUUFBUXdsQixNQUFNbnVCLEdBQUc7UUFDckIsSUFBSW11QixNQUFNN2MsR0FBRyxDQUFDLEtBQUssS0FBSyxNQUFLO1lBQzNCLElBQUk2YyxNQUFNN2MsR0FBRyxDQUFDLEtBQUssS0FBSyxNQUFLO2dCQUMzQixJQUFJLElBQUksQ0FBQzdQLE9BQU8sQ0FBQ3lILFdBQVcsSUFBSSxJQUFJO29CQUNsQyxJQUFJOG1CLGVBQWUsSUFBSSxDQUFDQyxtQkFBbUIsQ0FBQzlCO29CQUM1QyxJQUFJK0IsWUFBWS9CLE1BQU03YyxHQUFHLENBQUMsS0FBSyxLQUFLO29CQUNwQyxJQUFJMGUsZ0JBQWdCRSxXQUFXO3dCQUM3QixJQUFLLElBQUlqd0IsSUFBSSxHQUFHQSxJQUFJK3ZCLGFBQWE5dkIsTUFBTSxFQUFFRCxJQUFLOzRCQUM1QyxJQUFJa3dCLFdBQVdILGFBQWEzZSxNQUFNLENBQUNwUjs0QkFDbkMsSUFBSSt2QixhQUFheFgsT0FBTyxDQUFDMlgsVUFBVWx3QixJQUFJLEtBQUssQ0FBQyxHQUFHO2dDQUM5Q2t1QixNQUFNamMsS0FBSyxDQUFDOzRCQUNkO3dCQUNGO3dCQUNBLElBQUlnZSxXQUFXOzRCQUNiLElBQUlFLGtCQUFrQixJQUFJLENBQUNILG1CQUFtQixDQUFDOUI7NEJBQy9DLElBQUksQ0FBQzZCLGdCQUFnQixDQUFDSSxtQkFBbUJqQyxNQUFNUCxPQUFPLE9BQU8sS0FBSyxLQUFLLEtBQUk7Z0NBQ3pFTyxNQUFNamMsS0FBSyxDQUFDOzRCQUNkOzRCQUNBLElBQUssSUFBSW1HLE1BQU0sR0FBR0EsTUFBTStYLGdCQUFnQmx3QixNQUFNLEVBQUVtWSxNQUFPO2dDQUNyRCxJQUFJZ1ksYUFBYUQsZ0JBQWdCL2UsTUFBTSxDQUFDZ0g7Z0NBQ3hDLElBQ0UrWCxnQkFBZ0I1WCxPQUFPLENBQUM2WCxZQUFZaFksTUFBTSxLQUFLLENBQUMsS0FDaEQyWCxhQUFheFgsT0FBTyxDQUFDNlgsY0FBYyxDQUFDLEdBQ3BDO29DQUNBbEMsTUFBTWpjLEtBQUssQ0FBQztnQ0FDZDs0QkFDRjt3QkFDRjtvQkFDRjtnQkFDRjtnQkFDQSxJQUFJaWMsTUFBTTdjLEdBQUcsQ0FBQyxLQUFLLEtBQUssTUFBSztvQkFDM0IsSUFBSSxDQUFDcWQsa0JBQWtCLENBQUNSO29CQUN4QixJQUFJQSxNQUFNN2MsR0FBRyxDQUFDLEtBQUssS0FBSyxNQUFLO3dCQUMzQixPQUFPO29CQUNUO29CQUNBNmMsTUFBTWpjLEtBQUssQ0FBQztnQkFDZDtZQUNGO1lBQ0FpYyxNQUFNbnVCLEdBQUcsR0FBRzJJO1FBQ2Q7UUFDQSxPQUFPO0lBQ1Q7SUFDQXFqQixLQUFLOEQsd0JBQXdCLEdBQUcsU0FBUzNCLEtBQUs7UUFDNUMsSUFBSUEsTUFBTTdjLEdBQUcsQ0FBQyxLQUFLLEtBQUssTUFBSztZQUMzQixJQUFJLElBQUksQ0FBQzdQLE9BQU8sQ0FBQ3lILFdBQVcsSUFBSSxHQUFHO2dCQUNqQyxJQUFJLENBQUNvbkIscUJBQXFCLENBQUNuQztZQUM3QixPQUFPLElBQUlBLE1BQU1QLE9BQU8sT0FBTyxLQUFLLEtBQUssS0FBSTtnQkFDM0NPLE1BQU1qYyxLQUFLLENBQUM7WUFDZDtZQUNBLElBQUksQ0FBQ3ljLGtCQUFrQixDQUFDUjtZQUN4QixJQUFJQSxNQUFNN2MsR0FBRyxDQUFDLEtBQUssS0FBSyxNQUFLO2dCQUMzQjZjLE1BQU1yQixrQkFBa0IsSUFBSTtnQkFDNUIsT0FBTztZQUNUO1lBQ0FxQixNQUFNamMsS0FBSyxDQUFDO1FBQ2Q7UUFDQSxPQUFPO0lBQ1Q7SUFDQSxnQ0FBZ0M7SUFDaEMsWUFBWTtJQUNaLHlEQUF5RDtJQUN6RDhaLEtBQUtpRSxtQkFBbUIsR0FBRyxTQUFTOUIsS0FBSztRQUN2QyxJQUFJb0MsWUFBWTtRQUNoQixJQUFJeEMsS0FBSztRQUNULE1BQU8sQ0FBQ0EsS0FBS0ksTUFBTVAsT0FBTyxFQUFDLE1BQU8sQ0FBQyxLQUFLNEMsNEJBQTRCekMsSUFBSztZQUN2RXdDLGFBQWF0b0Isa0JBQWtCOGxCO1lBQy9CSSxNQUFNTCxPQUFPO1FBQ2Y7UUFDQSxPQUFPeUM7SUFDVDtJQUNBLHNDQUFzQztJQUN0QyxnQkFBZ0I7SUFDaEIsU0FBU0MsNEJBQTRCekMsRUFBRTtRQUNyQyxPQUFPQSxPQUFPLEtBQUssS0FBSyxPQUFNQSxPQUFPLEtBQUssS0FBSyxPQUFNQSxPQUFPLEtBQUssS0FBSztJQUN4RTtJQUVBLDRFQUE0RTtJQUM1RS9CLEtBQUtrRCxzQkFBc0IsR0FBRyxTQUFTZixLQUFLO1FBQzFDLE9BQ0VBLE1BQU03YyxHQUFHLENBQUMsS0FBSyxLQUFLLFFBQ3BCLElBQUksQ0FBQ3FlLGtDQUFrQyxDQUFDeEIsVUFDeEMsSUFBSSxDQUFDeUIsd0JBQXdCLENBQUN6QixVQUM5QixJQUFJLENBQUMwQiwwQkFBMEIsQ0FBQzFCLFVBQ2hDLElBQUksQ0FBQzJCLHdCQUF3QixDQUFDM0IsVUFDOUIsSUFBSSxDQUFDc0MsaUNBQWlDLENBQUN0QyxVQUN2QyxJQUFJLENBQUN1QyxrQ0FBa0MsQ0FBQ3ZDO0lBRTVDO0lBRUEsdUZBQXVGO0lBQ3ZGbkMsS0FBS3lFLGlDQUFpQyxHQUFHLFNBQVN0QyxLQUFLO1FBQ3JELElBQUksSUFBSSxDQUFDbUIsMEJBQTBCLENBQUNuQixPQUFPLE9BQU87WUFDaERBLE1BQU1qYyxLQUFLLENBQUM7UUFDZDtRQUNBLE9BQU87SUFDVDtJQUVBLHdFQUF3RTtJQUN4RThaLEtBQUsyRSx5QkFBeUIsR0FBRyxTQUFTeEMsS0FBSztRQUM3QyxJQUFJSixLQUFLSSxNQUFNUCxPQUFPO1FBQ3RCLElBQUlnRCxrQkFBa0I3QyxLQUFLO1lBQ3pCSSxNQUFNeEIsWUFBWSxHQUFHb0I7WUFDckJJLE1BQU1MLE9BQU87WUFDYixPQUFPO1FBQ1Q7UUFDQSxPQUFPO0lBQ1Q7SUFDQSxTQUFTOEMsa0JBQWtCN0MsRUFBRTtRQUMzQixPQUNFQSxPQUFPLEtBQUssS0FBSyxPQUNqQkEsTUFBTSxLQUFLLEtBQUssT0FBTUEsTUFBTSxLQUFLLEtBQUssT0FDdENBLE9BQU8sS0FBSyxLQUFLLE9BQ2pCQSxPQUFPLEtBQUssS0FBSyxPQUNqQkEsTUFBTSxLQUFLLEtBQUssT0FBTUEsTUFBTSxLQUFLLEtBQUssT0FDdENBLE1BQU0sS0FBSyxLQUFLLE9BQU1BLE1BQU0sS0FBSyxLQUFLO0lBRTFDO0lBRUEseUVBQXlFO0lBQ3pFLGlCQUFpQjtJQUNqQi9CLEtBQUswRCwyQkFBMkIsR0FBRyxTQUFTdkIsS0FBSztRQUMvQyxJQUFJeGxCLFFBQVF3bEIsTUFBTW51QixHQUFHO1FBQ3JCLElBQUkrdEIsS0FBSztRQUNULE1BQU8sQ0FBQ0EsS0FBS0ksTUFBTVAsT0FBTyxFQUFDLE1BQU8sQ0FBQyxLQUFLLENBQUNnRCxrQkFBa0I3QyxJQUFLO1lBQzlESSxNQUFNTCxPQUFPO1FBQ2Y7UUFDQSxPQUFPSyxNQUFNbnVCLEdBQUcsS0FBSzJJO0lBQ3ZCO0lBRUEsd0ZBQXdGO0lBQ3hGcWpCLEtBQUswRSxrQ0FBa0MsR0FBRyxTQUFTdkMsS0FBSztRQUN0RCxJQUFJSixLQUFLSSxNQUFNUCxPQUFPO1FBQ3RCLElBQ0VHLE9BQU8sQ0FBQyxLQUNSQSxPQUFPLEtBQUssS0FBSyxPQUNqQixDQUFFQSxDQUFBQSxNQUFNLEtBQUssS0FBSyxPQUFNQSxNQUFNLEtBQUssS0FBSyxHQUFQLEtBQ2pDQSxPQUFPLEtBQUssS0FBSyxPQUNqQkEsT0FBTyxLQUFLLEtBQUssT0FDakJBLE9BQU8sS0FBSyxLQUFLLE9BQ2pCQSxPQUFPLEtBQUssS0FBSyxPQUNqQkEsT0FBTyxLQUFLLEtBQUssS0FDakI7WUFDQUksTUFBTUwsT0FBTztZQUNiLE9BQU87UUFDVDtRQUNBLE9BQU87SUFDVDtJQUVBLG9CQUFvQjtJQUNwQixZQUFZO0lBQ1osa0JBQWtCO0lBQ2xCOUIsS0FBS3NFLHFCQUFxQixHQUFHLFNBQVNuQyxLQUFLO1FBQ3pDLElBQUlBLE1BQU03YyxHQUFHLENBQUMsS0FBSyxLQUFLLE1BQUs7WUFDM0IsSUFBSSxDQUFDLElBQUksQ0FBQ3VmLG1CQUFtQixDQUFDMUMsUUFBUTtnQkFBRUEsTUFBTWpjLEtBQUssQ0FBQztZQUFrQjtZQUN0RSxJQUFJMGMsbUJBQW1CLElBQUksQ0FBQ250QixPQUFPLENBQUN5SCxXQUFXLElBQUk7WUFDbkQsSUFBSTRuQixRQUFRM0MsTUFBTW5CLFVBQVUsQ0FBQ21CLE1BQU12QixlQUFlLENBQUM7WUFDbkQsSUFBSWtFLE9BQU87Z0JBQ1QsSUFBSWxDLGtCQUFrQjtvQkFDcEIsSUFBSyxJQUFJM3VCLElBQUksR0FBR3NULE9BQU91ZCxPQUFPN3dCLElBQUlzVCxLQUFLclQsTUFBTSxFQUFFRCxLQUFLLEVBQUc7d0JBQ3JELElBQUk4d0IsUUFBUXhkLElBQUksQ0FBQ3RULEVBQUU7d0JBRW5CLElBQUksQ0FBQzh3QixNQUFNN0UsYUFBYSxDQUFDaUMsTUFBTWpCLFFBQVEsR0FDckM7NEJBQUVpQixNQUFNamMsS0FBSyxDQUFDO3dCQUFpQztvQkFDbkQ7Z0JBQ0YsT0FBTztvQkFDTGljLE1BQU1qYyxLQUFLLENBQUM7Z0JBQ2Q7WUFDRjtZQUNBLElBQUkwYyxrQkFBa0I7Z0JBQ25Ca0MsQ0FBQUEsU0FBVTNDLENBQUFBLE1BQU1uQixVQUFVLENBQUNtQixNQUFNdkIsZUFBZSxDQUFDLEdBQUcsRUFBRSxHQUFHaGlCLElBQUksQ0FBQ3VqQixNQUFNakIsUUFBUTtZQUMvRSxPQUFPO2dCQUNMaUIsTUFBTW5CLFVBQVUsQ0FBQ21CLE1BQU12QixlQUFlLENBQUMsR0FBRztZQUM1QztRQUNGO0lBQ0Y7SUFFQSxlQUFlO0lBQ2YsaUNBQWlDO0lBQ2pDLDJFQUEyRTtJQUMzRVosS0FBSzZFLG1CQUFtQixHQUFHLFNBQVMxQyxLQUFLO1FBQ3ZDQSxNQUFNdkIsZUFBZSxHQUFHO1FBQ3hCLElBQUl1QixNQUFNN2MsR0FBRyxDQUFDLEtBQUssS0FBSyxNQUFLO1lBQzNCLElBQUksSUFBSSxDQUFDMGYsOEJBQThCLENBQUM3QyxVQUFVQSxNQUFNN2MsR0FBRyxDQUFDLEtBQUssS0FBSyxNQUFLO2dCQUN6RSxPQUFPO1lBQ1Q7WUFDQTZjLE1BQU1qYyxLQUFLLENBQUM7UUFDZDtRQUNBLE9BQU87SUFDVDtJQUVBLDBCQUEwQjtJQUMxQiwwQkFBMEI7SUFDMUIsOENBQThDO0lBQzlDLDJFQUEyRTtJQUMzRThaLEtBQUtnRiw4QkFBOEIsR0FBRyxTQUFTN0MsS0FBSztRQUNsREEsTUFBTXZCLGVBQWUsR0FBRztRQUN4QixJQUFJLElBQUksQ0FBQ3FFLCtCQUErQixDQUFDOUMsUUFBUTtZQUMvQ0EsTUFBTXZCLGVBQWUsSUFBSTNrQixrQkFBa0JrbUIsTUFBTXhCLFlBQVk7WUFDN0QsTUFBTyxJQUFJLENBQUN1RSw4QkFBOEIsQ0FBQy9DLE9BQVE7Z0JBQ2pEQSxNQUFNdkIsZUFBZSxJQUFJM2tCLGtCQUFrQmttQixNQUFNeEIsWUFBWTtZQUMvRDtZQUNBLE9BQU87UUFDVDtRQUNBLE9BQU87SUFDVDtJQUVBLDJCQUEyQjtJQUMzQixtQkFBbUI7SUFDbkIsUUFBUTtJQUNSLFFBQVE7SUFDUix3Q0FBd0M7SUFDeENYLEtBQUtpRiwrQkFBK0IsR0FBRyxTQUFTOUMsS0FBSztRQUNuRCxJQUFJeGxCLFFBQVF3bEIsTUFBTW51QixHQUFHO1FBQ3JCLElBQUl1dEIsU0FBUyxJQUFJLENBQUM5ckIsT0FBTyxDQUFDeUgsV0FBVyxJQUFJO1FBQ3pDLElBQUk2a0IsS0FBS0ksTUFBTVAsT0FBTyxDQUFDTDtRQUN2QlksTUFBTUwsT0FBTyxDQUFDUDtRQUVkLElBQUlRLE9BQU8sS0FBSyxLQUFLLE9BQU0sSUFBSSxDQUFDb0QscUNBQXFDLENBQUNoRCxPQUFPWixTQUFTO1lBQ3BGUSxLQUFLSSxNQUFNeEIsWUFBWTtRQUN6QjtRQUNBLElBQUl5RSx3QkFBd0JyRCxLQUFLO1lBQy9CSSxNQUFNeEIsWUFBWSxHQUFHb0I7WUFDckIsT0FBTztRQUNUO1FBRUFJLE1BQU1udUIsR0FBRyxHQUFHMkk7UUFDWixPQUFPO0lBQ1Q7SUFDQSxTQUFTeW9CLHdCQUF3QnJELEVBQUU7UUFDakMsT0FBTzV0QixrQkFBa0I0dEIsSUFBSSxTQUFTQSxPQUFPLEtBQUssS0FBSyxPQUFNQSxPQUFPLEtBQUssS0FBSztJQUNoRjtJQUVBLDBCQUEwQjtJQUMxQixzQkFBc0I7SUFDdEIsUUFBUTtJQUNSLFFBQVE7SUFDUix3Q0FBd0M7SUFDeEMsV0FBVztJQUNYLFVBQVU7SUFDVi9CLEtBQUtrRiw4QkFBOEIsR0FBRyxTQUFTL0MsS0FBSztRQUNsRCxJQUFJeGxCLFFBQVF3bEIsTUFBTW51QixHQUFHO1FBQ3JCLElBQUl1dEIsU0FBUyxJQUFJLENBQUM5ckIsT0FBTyxDQUFDeUgsV0FBVyxJQUFJO1FBQ3pDLElBQUk2a0IsS0FBS0ksTUFBTVAsT0FBTyxDQUFDTDtRQUN2QlksTUFBTUwsT0FBTyxDQUFDUDtRQUVkLElBQUlRLE9BQU8sS0FBSyxLQUFLLE9BQU0sSUFBSSxDQUFDb0QscUNBQXFDLENBQUNoRCxPQUFPWixTQUFTO1lBQ3BGUSxLQUFLSSxNQUFNeEIsWUFBWTtRQUN6QjtRQUNBLElBQUkwRSx1QkFBdUJ0RCxLQUFLO1lBQzlCSSxNQUFNeEIsWUFBWSxHQUFHb0I7WUFDckIsT0FBTztRQUNUO1FBRUFJLE1BQU1udUIsR0FBRyxHQUFHMkk7UUFDWixPQUFPO0lBQ1Q7SUFDQSxTQUFTMG9CLHVCQUF1QnRELEVBQUU7UUFDaEMsT0FBT3Z0QixpQkFBaUJ1dEIsSUFBSSxTQUFTQSxPQUFPLEtBQUssS0FBSyxPQUFNQSxPQUFPLEtBQUssS0FBSyxPQUFNQSxPQUFPLE9BQU8sVUFBVSxPQUFNQSxPQUFPLE9BQU8sU0FBUztJQUMxSTtJQUVBLDBFQUEwRTtJQUMxRS9CLEtBQUsrRCxvQkFBb0IsR0FBRyxTQUFTNUIsS0FBSztRQUN4QyxJQUNFLElBQUksQ0FBQ21ELHVCQUF1QixDQUFDbkQsVUFDN0IsSUFBSSxDQUFDb0QsOEJBQThCLENBQUNwRCxVQUNwQyxJQUFJLENBQUNxRCx5QkFBeUIsQ0FBQ3JELFVBQzlCQSxNQUFNekIsT0FBTyxJQUFJLElBQUksQ0FBQytFLG9CQUFvQixDQUFDdEQsUUFDNUM7WUFDQSxPQUFPO1FBQ1Q7UUFDQSxJQUFJQSxNQUFNM0IsT0FBTyxFQUFFO1lBQ2pCLCtCQUErQjtZQUMvQixJQUFJMkIsTUFBTVAsT0FBTyxPQUFPLEtBQUssS0FBSyxLQUFJO2dCQUNwQ08sTUFBTWpjLEtBQUssQ0FBQztZQUNkO1lBQ0FpYyxNQUFNamMsS0FBSyxDQUFDO1FBQ2Q7UUFDQSxPQUFPO0lBQ1Q7SUFDQThaLEtBQUtzRix1QkFBdUIsR0FBRyxTQUFTbkQsS0FBSztRQUMzQyxJQUFJeGxCLFFBQVF3bEIsTUFBTW51QixHQUFHO1FBQ3JCLElBQUksSUFBSSxDQUFDMHhCLHVCQUF1QixDQUFDdkQsUUFBUTtZQUN2QyxJQUFJM2xCLElBQUkybEIsTUFBTXhCLFlBQVk7WUFDMUIsSUFBSXdCLE1BQU0zQixPQUFPLEVBQUU7Z0JBQ2pCLHFGQUFxRjtnQkFDckYsSUFBSWhrQixJQUFJMmxCLE1BQU1wQixnQkFBZ0IsRUFBRTtvQkFDOUJvQixNQUFNcEIsZ0JBQWdCLEdBQUd2a0I7Z0JBQzNCO2dCQUNBLE9BQU87WUFDVDtZQUNBLElBQUlBLEtBQUsybEIsTUFBTXJCLGtCQUFrQixFQUFFO2dCQUNqQyxPQUFPO1lBQ1Q7WUFDQXFCLE1BQU1udUIsR0FBRyxHQUFHMkk7UUFDZDtRQUNBLE9BQU87SUFDVDtJQUNBcWpCLEtBQUt5RixvQkFBb0IsR0FBRyxTQUFTdEQsS0FBSztRQUN4QyxJQUFJQSxNQUFNN2MsR0FBRyxDQUFDLEtBQUssS0FBSyxNQUFLO1lBQzNCLElBQUksSUFBSSxDQUFDdWYsbUJBQW1CLENBQUMxQyxRQUFRO2dCQUNuQ0EsTUFBTWxCLGtCQUFrQixDQUFDcmlCLElBQUksQ0FBQ3VqQixNQUFNdkIsZUFBZTtnQkFDbkQsT0FBTztZQUNUO1lBQ0F1QixNQUFNamMsS0FBSyxDQUFDO1FBQ2Q7UUFDQSxPQUFPO0lBQ1Q7SUFFQSwrRUFBK0U7SUFDL0U4WixLQUFLd0YseUJBQXlCLEdBQUcsU0FBU3JELEtBQUs7UUFDN0MsT0FDRSxJQUFJLENBQUN3RCx1QkFBdUIsQ0FBQ3hELFVBQzdCLElBQUksQ0FBQ3lELHdCQUF3QixDQUFDekQsVUFDOUIsSUFBSSxDQUFDMEQsY0FBYyxDQUFDMUQsVUFDcEIsSUFBSSxDQUFDMkQsMkJBQTJCLENBQUMzRCxVQUNqQyxJQUFJLENBQUNnRCxxQ0FBcUMsQ0FBQ2hELE9BQU8sVUFDakQsQ0FBQ0EsTUFBTTNCLE9BQU8sSUFBSSxJQUFJLENBQUN1RixtQ0FBbUMsQ0FBQzVELFVBQzVELElBQUksQ0FBQzZELHdCQUF3QixDQUFDN0Q7SUFFbEM7SUFDQW5DLEtBQUs0Rix3QkFBd0IsR0FBRyxTQUFTekQsS0FBSztRQUM1QyxJQUFJeGxCLFFBQVF3bEIsTUFBTW51QixHQUFHO1FBQ3JCLElBQUltdUIsTUFBTTdjLEdBQUcsQ0FBQyxLQUFLLEtBQUssTUFBSztZQUMzQixJQUFJLElBQUksQ0FBQzJnQix1QkFBdUIsQ0FBQzlELFFBQVE7Z0JBQ3ZDLE9BQU87WUFDVDtZQUNBQSxNQUFNbnVCLEdBQUcsR0FBRzJJO1FBQ2Q7UUFDQSxPQUFPO0lBQ1Q7SUFDQXFqQixLQUFLNkYsY0FBYyxHQUFHLFNBQVMxRCxLQUFLO1FBQ2xDLElBQUlBLE1BQU1QLE9BQU8sT0FBTyxLQUFLLEtBQUssT0FBTSxDQUFDc0UsZUFBZS9ELE1BQU1OLFNBQVMsS0FBSztZQUMxRU0sTUFBTXhCLFlBQVksR0FBRztZQUNyQndCLE1BQU1MLE9BQU87WUFDYixPQUFPO1FBQ1Q7UUFDQSxPQUFPO0lBQ1Q7SUFFQSxzRUFBc0U7SUFDdEU5QixLQUFLMkYsdUJBQXVCLEdBQUcsU0FBU3hELEtBQUs7UUFDM0MsSUFBSUosS0FBS0ksTUFBTVAsT0FBTztRQUN0QixJQUFJRyxPQUFPLEtBQUssS0FBSyxLQUFJO1lBQ3ZCSSxNQUFNeEIsWUFBWSxHQUFHLE1BQU0sTUFBTTtZQUNqQ3dCLE1BQU1MLE9BQU87WUFDYixPQUFPO1FBQ1Q7UUFDQSxJQUFJQyxPQUFPLEtBQUssS0FBSyxLQUFJO1lBQ3ZCSSxNQUFNeEIsWUFBWSxHQUFHLE1BQU0sTUFBTTtZQUNqQ3dCLE1BQU1MLE9BQU87WUFDYixPQUFPO1FBQ1Q7UUFDQSxJQUFJQyxPQUFPLEtBQUssS0FBSyxLQUFJO1lBQ3ZCSSxNQUFNeEIsWUFBWSxHQUFHLE1BQU0sTUFBTTtZQUNqQ3dCLE1BQU1MLE9BQU87WUFDYixPQUFPO1FBQ1Q7UUFDQSxJQUFJQyxPQUFPLEtBQUssS0FBSyxLQUFJO1lBQ3ZCSSxNQUFNeEIsWUFBWSxHQUFHLE1BQU0sTUFBTTtZQUNqQ3dCLE1BQU1MLE9BQU87WUFDYixPQUFPO1FBQ1Q7UUFDQSxJQUFJQyxPQUFPLEtBQUssS0FBSyxLQUFJO1lBQ3ZCSSxNQUFNeEIsWUFBWSxHQUFHLE1BQU0sTUFBTTtZQUNqQ3dCLE1BQU1MLE9BQU87WUFDYixPQUFPO1FBQ1Q7UUFDQSxPQUFPO0lBQ1Q7SUFFQSxzRUFBc0U7SUFDdEU5QixLQUFLaUcsdUJBQXVCLEdBQUcsU0FBUzlELEtBQUs7UUFDM0MsSUFBSUosS0FBS0ksTUFBTVAsT0FBTztRQUN0QixJQUFJdUUsZ0JBQWdCcEUsS0FBSztZQUN2QkksTUFBTXhCLFlBQVksR0FBR29CLEtBQUs7WUFDMUJJLE1BQU1MLE9BQU87WUFDYixPQUFPO1FBQ1Q7UUFDQSxPQUFPO0lBQ1Q7SUFDQSxTQUFTcUUsZ0JBQWdCcEUsRUFBRTtRQUN6QixPQUNFLE1BQU8sS0FBSyxLQUFLLE9BQU1BLE1BQU0sS0FBSyxLQUFLLE9BQ3RDQSxNQUFNLEtBQUssS0FBSyxPQUFNQSxNQUFNLEtBQUssS0FBSztJQUUzQztJQUVBLG9GQUFvRjtJQUNwRi9CLEtBQUttRixxQ0FBcUMsR0FBRyxTQUFTaEQsS0FBSyxFQUFFWixNQUFNO1FBQ2pFLElBQUtBLFdBQVcsS0FBSyxHQUFJQSxTQUFTO1FBRWxDLElBQUk1a0IsUUFBUXdsQixNQUFNbnVCLEdBQUc7UUFDckIsSUFBSXdzQixVQUFVZSxVQUFVWSxNQUFNM0IsT0FBTztRQUVyQyxJQUFJMkIsTUFBTTdjLEdBQUcsQ0FBQyxLQUFLLEtBQUssTUFBSztZQUMzQixJQUFJLElBQUksQ0FBQzhnQix3QkFBd0IsQ0FBQ2pFLE9BQU8sSUFBSTtnQkFDM0MsSUFBSWtFLE9BQU9sRSxNQUFNeEIsWUFBWTtnQkFDN0IsSUFBSUgsV0FBVzZGLFFBQVEsVUFBVUEsUUFBUSxRQUFRO29CQUMvQyxJQUFJQyxtQkFBbUJuRSxNQUFNbnVCLEdBQUc7b0JBQ2hDLElBQUltdUIsTUFBTTdjLEdBQUcsQ0FBQyxLQUFLLEtBQUssUUFBTzZjLE1BQU03YyxHQUFHLENBQUMsS0FBSyxLQUFLLFFBQU8sSUFBSSxDQUFDOGdCLHdCQUF3QixDQUFDakUsT0FBTyxJQUFJO3dCQUNqRyxJQUFJb0UsUUFBUXBFLE1BQU14QixZQUFZO3dCQUM5QixJQUFJNEYsU0FBUyxVQUFVQSxTQUFTLFFBQVE7NEJBQ3RDcEUsTUFBTXhCLFlBQVksR0FBRyxDQUFDMEYsT0FBTyxNQUFLLElBQUssUUFBU0UsQ0FBQUEsUUFBUSxNQUFLLElBQUs7NEJBQ2xFLE9BQU87d0JBQ1Q7b0JBQ0Y7b0JBQ0FwRSxNQUFNbnVCLEdBQUcsR0FBR3N5QjtvQkFDWm5FLE1BQU14QixZQUFZLEdBQUcwRjtnQkFDdkI7Z0JBQ0EsT0FBTztZQUNUO1lBQ0EsSUFDRTdGLFdBQ0EyQixNQUFNN2MsR0FBRyxDQUFDLEtBQUssS0FBSyxRQUNwQixJQUFJLENBQUNraEIsbUJBQW1CLENBQUNyRSxVQUN6QkEsTUFBTTdjLEdBQUcsQ0FBQyxLQUFLLEtBQUssUUFDcEJtaEIsZUFBZXRFLE1BQU14QixZQUFZLEdBQ2pDO2dCQUNBLE9BQU87WUFDVDtZQUNBLElBQUlILFNBQVM7Z0JBQ1gyQixNQUFNamMsS0FBSyxDQUFDO1lBQ2Q7WUFDQWljLE1BQU1udUIsR0FBRyxHQUFHMkk7UUFDZDtRQUVBLE9BQU87SUFDVDtJQUNBLFNBQVM4cEIsZUFBZTFFLEVBQUU7UUFDeEIsT0FBT0EsTUFBTSxLQUFLQSxNQUFNO0lBQzFCO0lBRUEsOEVBQThFO0lBQzlFL0IsS0FBS2dHLHdCQUF3QixHQUFHLFNBQVM3RCxLQUFLO1FBQzVDLElBQUlBLE1BQU0zQixPQUFPLEVBQUU7WUFDakIsSUFBSSxJQUFJLENBQUNtRSx5QkFBeUIsQ0FBQ3hDLFFBQVE7Z0JBQ3pDLE9BQU87WUFDVDtZQUNBLElBQUlBLE1BQU03YyxHQUFHLENBQUMsS0FBSyxLQUFLLE1BQUs7Z0JBQzNCNmMsTUFBTXhCLFlBQVksR0FBRyxNQUFNLEtBQUs7Z0JBQ2hDLE9BQU87WUFDVDtZQUNBLE9BQU87UUFDVDtRQUVBLElBQUlvQixLQUFLSSxNQUFNUCxPQUFPO1FBQ3RCLElBQUlHLE9BQU8sS0FBSyxLQUFLLE9BQU8sRUFBQ0ksTUFBTXpCLE9BQU8sSUFBSXFCLE9BQU8sS0FBSyxLQUFLLEdBQVAsR0FBWTtZQUNsRUksTUFBTXhCLFlBQVksR0FBR29CO1lBQ3JCSSxNQUFNTCxPQUFPO1lBQ2IsT0FBTztRQUNUO1FBRUEsT0FBTztJQUNUO0lBRUEsc0VBQXNFO0lBQ3RFOUIsS0FBSzBGLHVCQUF1QixHQUFHLFNBQVN2RCxLQUFLO1FBQzNDQSxNQUFNeEIsWUFBWSxHQUFHO1FBQ3JCLElBQUlvQixLQUFLSSxNQUFNUCxPQUFPO1FBQ3RCLElBQUlHLE1BQU0sS0FBSyxLQUFLLE9BQU1BLE1BQU0sS0FBSyxLQUFLLEtBQUk7WUFDNUMsR0FBRztnQkFDREksTUFBTXhCLFlBQVksR0FBRyxLQUFLd0IsTUFBTXhCLFlBQVksR0FBSW9CLENBQUFBLEtBQUssS0FBSyxLQUFLLEdBQVA7Z0JBQ3hESSxNQUFNTCxPQUFPO1lBQ2YsUUFBUyxDQUFDQyxLQUFLSSxNQUFNUCxPQUFPLEVBQUMsS0FBTSxLQUFLLEtBQUssT0FBTUcsTUFBTSxLQUFLLEtBQUssS0FBRztZQUN0RSxPQUFPO1FBQ1Q7UUFDQSxPQUFPO0lBQ1Q7SUFFQSxpRUFBaUU7SUFDakUsa0RBQWtEO0lBQ2xELElBQUkyRSxjQUFjLEdBQUcsaUJBQWlCO0lBQ3RDLElBQUlDLFlBQVksR0FBRywyQ0FBMkM7SUFDOUQsSUFBSUMsZ0JBQWdCLEdBQUcsd0NBQXdDO0lBRS9ELDZFQUE2RTtJQUM3RTVHLEtBQUt1Riw4QkFBOEIsR0FBRyxTQUFTcEQsS0FBSztRQUNsRCxJQUFJSixLQUFLSSxNQUFNUCxPQUFPO1FBRXRCLElBQUlpRix1QkFBdUI5RSxLQUFLO1lBQzlCSSxNQUFNeEIsWUFBWSxHQUFHLENBQUM7WUFDdEJ3QixNQUFNTCxPQUFPO1lBQ2IsT0FBTzZFO1FBQ1Q7UUFFQSxJQUFJRyxTQUFTO1FBQ2IsSUFDRTNFLE1BQU0zQixPQUFPLElBQ2IsSUFBSSxDQUFDL3FCLE9BQU8sQ0FBQ3lILFdBQVcsSUFBSSxLQUMzQixFQUFDNHBCLFNBQVMvRSxPQUFPLEtBQUssS0FBSyxHQUFQLEtBQWNBLE9BQU8sS0FBSyxLQUFLLEdBQVAsR0FDN0M7WUFDQUksTUFBTXhCLFlBQVksR0FBRyxDQUFDO1lBQ3RCd0IsTUFBTUwsT0FBTztZQUNiLElBQUl4SjtZQUNKLElBQ0U2SixNQUFNN2MsR0FBRyxDQUFDLEtBQUssS0FBSyxRQUNuQmdULENBQUFBLFNBQVMsSUFBSSxDQUFDeU8sd0NBQXdDLENBQUM1RSxNQUFLLEtBQzdEQSxNQUFNN2MsR0FBRyxDQUFDLEtBQUssS0FBSyxNQUNwQjtnQkFDQSxJQUFJd2hCLFVBQVV4TyxXQUFXc08sZUFBZTtvQkFBRXpFLE1BQU1qYyxLQUFLLENBQUM7Z0JBQTBCO2dCQUNoRixPQUFPb1M7WUFDVDtZQUNBNkosTUFBTWpjLEtBQUssQ0FBQztRQUNkO1FBRUEsT0FBT3dnQjtJQUNUO0lBRUEsU0FBU0csdUJBQXVCOUUsRUFBRTtRQUNoQyxPQUNFQSxPQUFPLEtBQUssS0FBSyxPQUNqQkEsT0FBTyxLQUFLLEtBQUssT0FDakJBLE9BQU8sS0FBSyxLQUFLLE9BQ2pCQSxPQUFPLEtBQUssS0FBSyxPQUNqQkEsT0FBTyxLQUFLLEtBQUssT0FDakJBLE9BQU8sS0FBSyxLQUFLO0lBRXJCO0lBRUEsb0NBQW9DO0lBQ3BDLGlEQUFpRDtJQUNqRCxtQ0FBbUM7SUFDbkMvQixLQUFLK0csd0NBQXdDLEdBQUcsU0FBUzVFLEtBQUs7UUFDNUQsSUFBSXhsQixRQUFRd2xCLE1BQU1udUIsR0FBRztRQUVyQiwrQ0FBK0M7UUFDL0MsSUFBSSxJQUFJLENBQUNnekIsNkJBQTZCLENBQUM3RSxVQUFVQSxNQUFNN2MsR0FBRyxDQUFDLEtBQUssS0FBSyxNQUFLO1lBQ3hFLElBQUlqUSxPQUFPOHNCLE1BQU12QixlQUFlO1lBQ2hDLElBQUksSUFBSSxDQUFDcUcsOEJBQThCLENBQUM5RSxRQUFRO2dCQUM5QyxJQUFJOWlCLFFBQVE4aUIsTUFBTXZCLGVBQWU7Z0JBQ2pDLElBQUksQ0FBQ3NHLDBDQUEwQyxDQUFDL0UsT0FBTzlzQixNQUFNZ0s7Z0JBQzdELE9BQU9zbkI7WUFDVDtRQUNGO1FBQ0F4RSxNQUFNbnVCLEdBQUcsR0FBRzJJO1FBRVosaUNBQWlDO1FBQ2pDLElBQUksSUFBSSxDQUFDd3FCLHdDQUF3QyxDQUFDaEYsUUFBUTtZQUN4RCxJQUFJaUYsY0FBY2pGLE1BQU12QixlQUFlO1lBQ3ZDLE9BQU8sSUFBSSxDQUFDeUcseUNBQXlDLENBQUNsRixPQUFPaUY7UUFDL0Q7UUFDQSxPQUFPVjtJQUNUO0lBRUExRyxLQUFLa0gsMENBQTBDLEdBQUcsU0FBUy9FLEtBQUssRUFBRTlzQixJQUFJLEVBQUVnSyxLQUFLO1FBQzNFLElBQUksQ0FBQy9ELE9BQU82bUIsTUFBTTVCLGlCQUFpQixDQUFDZCxTQUFTLEVBQUVwcUIsT0FDN0M7WUFBRThzQixNQUFNamMsS0FBSyxDQUFDO1FBQTBCO1FBQzFDLElBQUksQ0FBQ2ljLE1BQU01QixpQkFBaUIsQ0FBQ2QsU0FBUyxDQUFDcHFCLEtBQUssQ0FBQ2hCLElBQUksQ0FBQ2dMLFFBQ2hEO1lBQUU4aUIsTUFBTWpjLEtBQUssQ0FBQztRQUEyQjtJQUM3QztJQUVBOFosS0FBS3FILHlDQUF5QyxHQUFHLFNBQVNsRixLQUFLLEVBQUVpRixXQUFXO1FBQzFFLElBQUlqRixNQUFNNUIsaUJBQWlCLENBQUNoQixNQUFNLENBQUNsckIsSUFBSSxDQUFDK3lCLGNBQWM7WUFBRSxPQUFPVDtRQUFVO1FBQ3pFLElBQUl4RSxNQUFNMUIsT0FBTyxJQUFJMEIsTUFBTTVCLGlCQUFpQixDQUFDZixlQUFlLENBQUNuckIsSUFBSSxDQUFDK3lCLGNBQWM7WUFBRSxPQUFPUjtRQUFjO1FBQ3ZHekUsTUFBTWpjLEtBQUssQ0FBQztJQUNkO0lBRUEseUJBQXlCO0lBQ3pCLGtDQUFrQztJQUNsQzhaLEtBQUtnSCw2QkFBNkIsR0FBRyxTQUFTN0UsS0FBSztRQUNqRCxJQUFJSixLQUFLO1FBQ1RJLE1BQU12QixlQUFlLEdBQUc7UUFDeEIsTUFBTzBHLCtCQUErQnZGLEtBQUtJLE1BQU1QLE9BQU8sSUFBSztZQUMzRE8sTUFBTXZCLGVBQWUsSUFBSTNrQixrQkFBa0I4bEI7WUFDM0NJLE1BQU1MLE9BQU87UUFDZjtRQUNBLE9BQU9LLE1BQU12QixlQUFlLEtBQUs7SUFDbkM7SUFFQSxTQUFTMEcsK0JBQStCdkYsRUFBRTtRQUN4QyxPQUFPb0UsZ0JBQWdCcEUsT0FBT0EsT0FBTyxLQUFLLEtBQUs7SUFDakQ7SUFFQSwwQkFBMEI7SUFDMUIsbUNBQW1DO0lBQ25DL0IsS0FBS2lILDhCQUE4QixHQUFHLFNBQVM5RSxLQUFLO1FBQ2xELElBQUlKLEtBQUs7UUFDVEksTUFBTXZCLGVBQWUsR0FBRztRQUN4QixNQUFPMkcsZ0NBQWdDeEYsS0FBS0ksTUFBTVAsT0FBTyxJQUFLO1lBQzVETyxNQUFNdkIsZUFBZSxJQUFJM2tCLGtCQUFrQjhsQjtZQUMzQ0ksTUFBTUwsT0FBTztRQUNmO1FBQ0EsT0FBT0ssTUFBTXZCLGVBQWUsS0FBSztJQUNuQztJQUNBLFNBQVMyRyxnQ0FBZ0N4RixFQUFFO1FBQ3pDLE9BQU91RiwrQkFBK0J2RixPQUFPbUUsZUFBZW5FO0lBQzlEO0lBRUEsb0NBQW9DO0lBQ3BDLG1DQUFtQztJQUNuQy9CLEtBQUttSCx3Q0FBd0MsR0FBRyxTQUFTaEYsS0FBSztRQUM1RCxPQUFPLElBQUksQ0FBQzhFLDhCQUE4QixDQUFDOUU7SUFDN0M7SUFFQSx1RUFBdUU7SUFDdkVuQyxLQUFLNEQsd0JBQXdCLEdBQUcsU0FBU3pCLEtBQUs7UUFDNUMsSUFBSUEsTUFBTTdjLEdBQUcsQ0FBQyxLQUFLLEtBQUssTUFBSztZQUMzQixJQUFJd2hCLFNBQVMzRSxNQUFNN2MsR0FBRyxDQUFDLEtBQUssS0FBSztZQUNqQyxJQUFJZ1QsU0FBUyxJQUFJLENBQUNrUCxvQkFBb0IsQ0FBQ3JGO1lBQ3ZDLElBQUksQ0FBQ0EsTUFBTTdjLEdBQUcsQ0FBQyxLQUFLLEtBQUssTUFDdkI7Z0JBQUU2YyxNQUFNamMsS0FBSyxDQUFDO1lBQWlDO1lBQ2pELElBQUk0Z0IsVUFBVXhPLFdBQVdzTyxlQUN2QjtnQkFBRXpFLE1BQU1qYyxLQUFLLENBQUM7WUFBZ0Q7WUFDaEUsT0FBTztRQUNUO1FBQ0EsT0FBTztJQUNUO0lBRUEsOENBQThDO0lBQzlDLG9FQUFvRTtJQUNwRThaLEtBQUt3SCxvQkFBb0IsR0FBRyxTQUFTckYsS0FBSztRQUN4QyxJQUFJQSxNQUFNUCxPQUFPLE9BQU8sS0FBSyxLQUFLLEtBQUk7WUFBRSxPQUFPK0U7UUFBVTtRQUN6RCxJQUFJeEUsTUFBTTFCLE9BQU8sRUFBRTtZQUFFLE9BQU8sSUFBSSxDQUFDZ0gseUJBQXlCLENBQUN0RjtRQUFPO1FBQ2xFLElBQUksQ0FBQ3VGLDBCQUEwQixDQUFDdkY7UUFDaEMsT0FBT3dFO0lBQ1Q7SUFFQSw0RUFBNEU7SUFDNUUsa0ZBQWtGO0lBQ2xGM0csS0FBSzBILDBCQUEwQixHQUFHLFNBQVN2RixLQUFLO1FBQzlDLE1BQU8sSUFBSSxDQUFDd0YsbUJBQW1CLENBQUN4RixPQUFRO1lBQ3RDLElBQUlyVixPQUFPcVYsTUFBTXhCLFlBQVk7WUFDN0IsSUFBSXdCLE1BQU03YyxHQUFHLENBQUMsS0FBSyxLQUFLLFFBQU8sSUFBSSxDQUFDcWlCLG1CQUFtQixDQUFDeEYsUUFBUTtnQkFDOUQsSUFBSXBWLFFBQVFvVixNQUFNeEIsWUFBWTtnQkFDOUIsSUFBSXdCLE1BQU0zQixPQUFPLElBQUsxVCxDQUFBQSxTQUFTLENBQUMsS0FBS0MsVUFBVSxDQUFDLElBQUk7b0JBQ2xEb1YsTUFBTWpjLEtBQUssQ0FBQztnQkFDZDtnQkFDQSxJQUFJNEcsU0FBUyxDQUFDLEtBQUtDLFVBQVUsQ0FBQyxLQUFLRCxPQUFPQyxPQUFPO29CQUMvQ29WLE1BQU1qYyxLQUFLLENBQUM7Z0JBQ2Q7WUFDRjtRQUNGO0lBQ0Y7SUFFQSxrRUFBa0U7SUFDbEUsd0VBQXdFO0lBQ3hFOFosS0FBSzJILG1CQUFtQixHQUFHLFNBQVN4RixLQUFLO1FBQ3ZDLElBQUl4bEIsUUFBUXdsQixNQUFNbnVCLEdBQUc7UUFFckIsSUFBSW11QixNQUFNN2MsR0FBRyxDQUFDLEtBQUssS0FBSyxNQUFLO1lBQzNCLElBQUksSUFBSSxDQUFDc2lCLHFCQUFxQixDQUFDekYsUUFBUTtnQkFDckMsT0FBTztZQUNUO1lBQ0EsSUFBSUEsTUFBTTNCLE9BQU8sRUFBRTtnQkFDakIsK0JBQStCO2dCQUMvQixJQUFJcUgsT0FBTzFGLE1BQU1QLE9BQU87Z0JBQ3hCLElBQUlpRyxTQUFTLEtBQUssS0FBSyxPQUFNQyxhQUFhRCxPQUFPO29CQUMvQzFGLE1BQU1qYyxLQUFLLENBQUM7Z0JBQ2Q7Z0JBQ0FpYyxNQUFNamMsS0FBSyxDQUFDO1lBQ2Q7WUFDQWljLE1BQU1udUIsR0FBRyxHQUFHMkk7UUFDZDtRQUVBLElBQUlvbEIsS0FBS0ksTUFBTVAsT0FBTztRQUN0QixJQUFJRyxPQUFPLEtBQUssS0FBSyxLQUFJO1lBQ3ZCSSxNQUFNeEIsWUFBWSxHQUFHb0I7WUFDckJJLE1BQU1MLE9BQU87WUFDYixPQUFPO1FBQ1Q7UUFFQSxPQUFPO0lBQ1Q7SUFFQSwyRUFBMkU7SUFDM0U5QixLQUFLNEgscUJBQXFCLEdBQUcsU0FBU3pGLEtBQUs7UUFDekMsSUFBSXhsQixRQUFRd2xCLE1BQU1udUIsR0FBRztRQUVyQixJQUFJbXVCLE1BQU03YyxHQUFHLENBQUMsS0FBSyxLQUFLLE1BQUs7WUFDM0I2YyxNQUFNeEIsWUFBWSxHQUFHLE1BQU0sUUFBUTtZQUNuQyxPQUFPO1FBQ1Q7UUFFQSxJQUFJd0IsTUFBTTNCLE9BQU8sSUFBSTJCLE1BQU03YyxHQUFHLENBQUMsS0FBSyxLQUFLLE1BQUs7WUFDNUM2YyxNQUFNeEIsWUFBWSxHQUFHLE1BQU0sS0FBSztZQUNoQyxPQUFPO1FBQ1Q7UUFFQSxJQUFJLENBQUN3QixNQUFNM0IsT0FBTyxJQUFJMkIsTUFBTTdjLEdBQUcsQ0FBQyxLQUFLLEtBQUssTUFBSztZQUM3QyxJQUFJLElBQUksQ0FBQ3lpQiw0QkFBNEIsQ0FBQzVGLFFBQVE7Z0JBQzVDLE9BQU87WUFDVDtZQUNBQSxNQUFNbnVCLEdBQUcsR0FBRzJJO1FBQ2Q7UUFFQSxPQUNFLElBQUksQ0FBQzRvQiw4QkFBOEIsQ0FBQ3BELFVBQ3BDLElBQUksQ0FBQ3FELHlCQUF5QixDQUFDckQ7SUFFbkM7SUFFQSxtREFBbUQ7SUFDbkQsMkNBQTJDO0lBQzNDLGtEQUFrRDtJQUNsRCxpREFBaUQ7SUFDakRuQyxLQUFLeUgseUJBQXlCLEdBQUcsU0FBU3RGLEtBQUs7UUFDN0MsSUFBSTdKLFNBQVNxTyxXQUFXcUI7UUFDeEIsSUFBSSxJQUFJLENBQUNDLHVCQUF1QixDQUFDOUY7YUFBZSxJQUFJNkYsWUFBWSxJQUFJLENBQUNFLHlCQUF5QixDQUFDL0YsUUFBUTtZQUNyRyxJQUFJNkYsY0FBY3BCLGVBQWU7Z0JBQUV0TyxTQUFTc087WUFBZTtZQUMzRCxrREFBa0Q7WUFDbEQsSUFBSWpxQixRQUFRd2xCLE1BQU1udUIsR0FBRztZQUNyQixNQUFPbXVCLE1BQU1ILFFBQVEsQ0FBQztnQkFBQztnQkFBTTthQUFLLEVBQVk7Z0JBQzVDLElBQ0VHLE1BQU1QLE9BQU8sT0FBTyxLQUFLLEtBQUssT0FDN0JvRyxDQUFBQSxZQUFZLElBQUksQ0FBQ0UseUJBQXlCLENBQUMvRixNQUFLLEdBQ2pEO29CQUNBLElBQUk2RixjQUFjcEIsZUFBZTt3QkFBRXRPLFNBQVNxTztvQkFBVztvQkFDdkQ7Z0JBQ0Y7Z0JBQ0F4RSxNQUFNamMsS0FBSyxDQUFDO1lBQ2Q7WUFDQSxJQUFJdkosVUFBVXdsQixNQUFNbnVCLEdBQUcsRUFBRTtnQkFBRSxPQUFPc2tCO1lBQU87WUFDekMsaURBQWlEO1lBQ2pELE1BQU82SixNQUFNSCxRQUFRLENBQUM7Z0JBQUM7Z0JBQU07YUFBSyxFQUFZO2dCQUM1QyxJQUFJLElBQUksQ0FBQ2tHLHlCQUF5QixDQUFDL0YsUUFBUTtvQkFBRTtnQkFBUztnQkFDdERBLE1BQU1qYyxLQUFLLENBQUM7WUFDZDtZQUNBLElBQUl2SixVQUFVd2xCLE1BQU1udUIsR0FBRyxFQUFFO2dCQUFFLE9BQU9za0I7WUFBTztRQUMzQyxPQUFPO1lBQ0w2SixNQUFNamMsS0FBSyxDQUFDO1FBQ2Q7UUFDQSwyQ0FBMkM7UUFDM0MsT0FBUztZQUNQLElBQUksSUFBSSxDQUFDK2hCLHVCQUF1QixDQUFDOUYsUUFBUTtnQkFBRTtZQUFTO1lBQ3BENkYsWUFBWSxJQUFJLENBQUNFLHlCQUF5QixDQUFDL0Y7WUFDM0MsSUFBSSxDQUFDNkYsV0FBVztnQkFBRSxPQUFPMVA7WUFBTztZQUNoQyxJQUFJMFAsY0FBY3BCLGVBQWU7Z0JBQUV0TyxTQUFTc087WUFBZTtRQUM3RDtJQUNGO0lBRUEsOENBQThDO0lBQzlDNUcsS0FBS2lJLHVCQUF1QixHQUFHLFNBQVM5RixLQUFLO1FBQzNDLElBQUl4bEIsUUFBUXdsQixNQUFNbnVCLEdBQUc7UUFDckIsSUFBSSxJQUFJLENBQUNtMEIsMkJBQTJCLENBQUNoRyxRQUFRO1lBQzNDLElBQUlyVixPQUFPcVYsTUFBTXhCLFlBQVk7WUFDN0IsSUFBSXdCLE1BQU03YyxHQUFHLENBQUMsS0FBSyxLQUFLLFFBQU8sSUFBSSxDQUFDNmlCLDJCQUEyQixDQUFDaEcsUUFBUTtnQkFDdEUsSUFBSXBWLFFBQVFvVixNQUFNeEIsWUFBWTtnQkFDOUIsSUFBSTdULFNBQVMsQ0FBQyxLQUFLQyxVQUFVLENBQUMsS0FBS0QsT0FBT0MsT0FBTztvQkFDL0NvVixNQUFNamMsS0FBSyxDQUFDO2dCQUNkO2dCQUNBLE9BQU87WUFDVDtZQUNBaWMsTUFBTW51QixHQUFHLEdBQUcySTtRQUNkO1FBQ0EsT0FBTztJQUNUO0lBRUEsZ0RBQWdEO0lBQ2hEcWpCLEtBQUtrSSx5QkFBeUIsR0FBRyxTQUFTL0YsS0FBSztRQUM3QyxJQUFJLElBQUksQ0FBQ2dHLDJCQUEyQixDQUFDaEcsUUFBUTtZQUFFLE9BQU93RTtRQUFVO1FBQ2hFLE9BQU8sSUFBSSxDQUFDeUIsZ0NBQWdDLENBQUNqRyxVQUFVLElBQUksQ0FBQ2tHLHFCQUFxQixDQUFDbEc7SUFDcEY7SUFFQSw0Q0FBNEM7SUFDNUNuQyxLQUFLcUkscUJBQXFCLEdBQUcsU0FBU2xHLEtBQUs7UUFDekMsSUFBSXhsQixRQUFRd2xCLE1BQU1udUIsR0FBRztRQUNyQixJQUFJbXVCLE1BQU03YyxHQUFHLENBQUMsS0FBSyxLQUFLLE1BQUs7WUFDM0IsSUFBSXdoQixTQUFTM0UsTUFBTTdjLEdBQUcsQ0FBQyxLQUFLLEtBQUs7WUFDakMsSUFBSWdULFNBQVMsSUFBSSxDQUFDa1Asb0JBQW9CLENBQUNyRjtZQUN2QyxJQUFJQSxNQUFNN2MsR0FBRyxDQUFDLEtBQUssS0FBSyxNQUFLO2dCQUMzQixJQUFJd2hCLFVBQVV4TyxXQUFXc08sZUFBZTtvQkFDdEN6RSxNQUFNamMsS0FBSyxDQUFDO2dCQUNkO2dCQUNBLE9BQU9vUztZQUNUO1lBQ0E2SixNQUFNbnVCLEdBQUcsR0FBRzJJO1FBQ2Q7UUFDQSxJQUFJd2xCLE1BQU03YyxHQUFHLENBQUMsS0FBSyxLQUFLLE1BQUs7WUFDM0IsSUFBSWdqQixXQUFXLElBQUksQ0FBQy9DLDhCQUE4QixDQUFDcEQ7WUFDbkQsSUFBSW1HLFVBQVU7Z0JBQ1osT0FBT0E7WUFDVDtZQUNBbkcsTUFBTW51QixHQUFHLEdBQUcySTtRQUNkO1FBQ0EsT0FBTztJQUNUO0lBRUEsdURBQXVEO0lBQ3ZEcWpCLEtBQUtvSSxnQ0FBZ0MsR0FBRyxTQUFTakcsS0FBSztRQUNwRCxJQUFJeGxCLFFBQVF3bEIsTUFBTW51QixHQUFHO1FBQ3JCLElBQUltdUIsTUFBTUgsUUFBUSxDQUFDO1lBQUM7WUFBTTtTQUFLLEdBQVk7WUFDekMsSUFBSUcsTUFBTTdjLEdBQUcsQ0FBQyxLQUFLLEtBQUssTUFBSztnQkFDM0IsSUFBSWdULFNBQVMsSUFBSSxDQUFDaVEscUNBQXFDLENBQUNwRztnQkFDeEQsSUFBSUEsTUFBTTdjLEdBQUcsQ0FBQyxLQUFLLEtBQUssTUFBSztvQkFDM0IsT0FBT2dUO2dCQUNUO1lBQ0YsT0FBTztnQkFDTCwrQkFBK0I7Z0JBQy9CNkosTUFBTWpjLEtBQUssQ0FBQztZQUNkO1lBQ0FpYyxNQUFNbnVCLEdBQUcsR0FBRzJJO1FBQ2Q7UUFDQSxPQUFPO0lBQ1Q7SUFFQSwrREFBK0Q7SUFDL0RxakIsS0FBS3VJLHFDQUFxQyxHQUFHLFNBQVNwRyxLQUFLO1FBQ3pELElBQUk3SixTQUFTLElBQUksQ0FBQ2tRLGtCQUFrQixDQUFDckc7UUFDckMsTUFBT0EsTUFBTTdjLEdBQUcsQ0FBQyxLQUFLLEtBQUssS0FBSztZQUM5QixJQUFJLElBQUksQ0FBQ2tqQixrQkFBa0IsQ0FBQ3JHLFdBQVd5RSxlQUFlO2dCQUFFdE8sU0FBU3NPO1lBQWU7UUFDbEY7UUFDQSxPQUFPdE87SUFDVDtJQUVBLDRDQUE0QztJQUM1QyxvREFBb0Q7SUFDcEQwSCxLQUFLd0ksa0JBQWtCLEdBQUcsU0FBU3JHLEtBQUs7UUFDdEMsSUFBSXNHLFFBQVE7UUFDWixNQUFPLElBQUksQ0FBQ04sMkJBQTJCLENBQUNoRyxPQUFRO1lBQUVzRztRQUFTO1FBQzNELE9BQU9BLFVBQVUsSUFBSTlCLFlBQVlDO0lBQ25DO0lBRUEsa0RBQWtEO0lBQ2xENUcsS0FBS21JLDJCQUEyQixHQUFHLFNBQVNoRyxLQUFLO1FBQy9DLElBQUl4bEIsUUFBUXdsQixNQUFNbnVCLEdBQUc7UUFDckIsSUFBSW11QixNQUFNN2MsR0FBRyxDQUFDLEtBQUssS0FBSyxNQUFLO1lBQzNCLElBQ0UsSUFBSSxDQUFDa2dCLHlCQUF5QixDQUFDckQsVUFDL0IsSUFBSSxDQUFDdUcsb0NBQW9DLENBQUN2RyxRQUMxQztnQkFDQSxPQUFPO1lBQ1Q7WUFDQSxJQUFJQSxNQUFNN2MsR0FBRyxDQUFDLEtBQUssS0FBSyxNQUFLO2dCQUMzQjZjLE1BQU14QixZQUFZLEdBQUcsTUFBTSxRQUFRO2dCQUNuQyxPQUFPO1lBQ1Q7WUFDQXdCLE1BQU1udUIsR0FBRyxHQUFHMkk7WUFDWixPQUFPO1FBQ1Q7UUFDQSxJQUFJb2xCLEtBQUtJLE1BQU1QLE9BQU87UUFDdEIsSUFBSUcsS0FBSyxLQUFLQSxPQUFPSSxNQUFNTixTQUFTLE1BQU04Ryw0Q0FBNEM1RyxLQUFLO1lBQUUsT0FBTztRQUFNO1FBQzFHLElBQUk2RywwQkFBMEI3RyxLQUFLO1lBQUUsT0FBTztRQUFNO1FBQ2xESSxNQUFNTCxPQUFPO1FBQ2JLLE1BQU14QixZQUFZLEdBQUdvQjtRQUNyQixPQUFPO0lBQ1Q7SUFFQSxpRUFBaUU7SUFDakUsU0FBUzRHLDRDQUE0QzVHLEVBQUU7UUFDckQsT0FDRUEsT0FBTyxLQUFLLEtBQUssT0FDakJBLE1BQU0sS0FBSyxLQUFLLE9BQU1BLE1BQU0sS0FBSyxLQUFLLE9BQ3RDQSxNQUFNLEtBQUssS0FBSyxPQUFNQSxNQUFNLEtBQUssS0FBSyxPQUN0Q0EsT0FBTyxLQUFLLEtBQUssT0FDakJBLE1BQU0sS0FBSyxLQUFLLE9BQU1BLE1BQU0sS0FBSyxLQUFLLE9BQ3RDQSxPQUFPLEtBQUssS0FBSyxPQUNqQkEsT0FBTyxLQUFLLEtBQUssT0FDakJBLE9BQU8sS0FBSyxLQUFLO0lBRXJCO0lBRUEsd0RBQXdEO0lBQ3hELFNBQVM2RywwQkFBMEI3RyxFQUFFO1FBQ25DLE9BQ0VBLE9BQU8sS0FBSyxLQUFLLE9BQ2pCQSxPQUFPLEtBQUssS0FBSyxPQUNqQkEsT0FBTyxLQUFLLEtBQUssT0FDakJBLE9BQU8sS0FBSyxLQUFLLE9BQ2pCQSxNQUFNLEtBQUssS0FBSyxPQUFNQSxNQUFNLEtBQUssS0FBSyxPQUN0Q0EsTUFBTSxLQUFLLEtBQUssT0FBTUEsTUFBTSxLQUFLLEtBQUs7SUFFMUM7SUFFQSwyREFBMkQ7SUFDM0QvQixLQUFLMEksb0NBQW9DLEdBQUcsU0FBU3ZHLEtBQUs7UUFDeEQsSUFBSUosS0FBS0ksTUFBTVAsT0FBTztRQUN0QixJQUFJaUgsNkJBQTZCOUcsS0FBSztZQUNwQ0ksTUFBTXhCLFlBQVksR0FBR29CO1lBQ3JCSSxNQUFNTCxPQUFPO1lBQ2IsT0FBTztRQUNUO1FBQ0EsT0FBTztJQUNUO0lBRUEsMkRBQTJEO0lBQzNELFNBQVMrRyw2QkFBNkI5RyxFQUFFO1FBQ3RDLE9BQ0VBLE9BQU8sS0FBSyxLQUFLLE9BQ2pCQSxPQUFPLEtBQUssS0FBSyxPQUNqQkEsT0FBTyxLQUFLLEtBQUssT0FDakJBLE9BQU8sS0FBSyxLQUFLLE9BQ2pCQSxPQUFPLEtBQUssS0FBSyxPQUNqQkEsT0FBTyxLQUFLLEtBQUssT0FDakJBLE1BQU0sS0FBSyxLQUFLLE9BQU1BLE1BQU0sS0FBSyxLQUFLLE9BQ3RDQSxPQUFPLEtBQUssS0FBSyxPQUNqQkEsT0FBTyxLQUFLLEtBQUssT0FDakJBLE9BQU8sS0FBSyxLQUFLO0lBRXJCO0lBRUEsa0ZBQWtGO0lBQ2xGL0IsS0FBSytILDRCQUE0QixHQUFHLFNBQVM1RixLQUFLO1FBQ2hELElBQUlKLEtBQUtJLE1BQU1QLE9BQU87UUFDdEIsSUFBSXNFLGVBQWVuRSxPQUFPQSxPQUFPLEtBQUssS0FBSyxLQUFJO1lBQzdDSSxNQUFNeEIsWUFBWSxHQUFHb0IsS0FBSztZQUMxQkksTUFBTUwsT0FBTztZQUNiLE9BQU87UUFDVDtRQUNBLE9BQU87SUFDVDtJQUVBLDBFQUEwRTtJQUMxRTlCLEtBQUs4RiwyQkFBMkIsR0FBRyxTQUFTM0QsS0FBSztRQUMvQyxJQUFJeGxCLFFBQVF3bEIsTUFBTW51QixHQUFHO1FBQ3JCLElBQUltdUIsTUFBTTdjLEdBQUcsQ0FBQyxLQUFLLEtBQUssTUFBSztZQUMzQixJQUFJLElBQUksQ0FBQzhnQix3QkFBd0IsQ0FBQ2pFLE9BQU8sSUFBSTtnQkFDM0MsT0FBTztZQUNUO1lBQ0EsSUFBSUEsTUFBTTNCLE9BQU8sRUFBRTtnQkFDakIyQixNQUFNamMsS0FBSyxDQUFDO1lBQ2Q7WUFDQWljLE1BQU1udUIsR0FBRyxHQUFHMkk7UUFDZDtRQUNBLE9BQU87SUFDVDtJQUVBLHNFQUFzRTtJQUN0RXFqQixLQUFLeUQsdUJBQXVCLEdBQUcsU0FBU3RCLEtBQUs7UUFDM0MsSUFBSXhsQixRQUFRd2xCLE1BQU1udUIsR0FBRztRQUNyQixJQUFJK3RCLEtBQUs7UUFDVEksTUFBTXhCLFlBQVksR0FBRztRQUNyQixNQUFPdUYsZUFBZW5FLEtBQUtJLE1BQU1QLE9BQU8sSUFBSztZQUMzQ08sTUFBTXhCLFlBQVksR0FBRyxLQUFLd0IsTUFBTXhCLFlBQVksR0FBSW9CLENBQUFBLEtBQUssS0FBSyxLQUFLLEdBQVA7WUFDeERJLE1BQU1MLE9BQU87UUFDZjtRQUNBLE9BQU9LLE1BQU1udUIsR0FBRyxLQUFLMkk7SUFDdkI7SUFDQSxTQUFTdXBCLGVBQWVuRSxFQUFFO1FBQ3hCLE9BQU9BLE1BQU0sS0FBSyxLQUFLLE9BQU1BLE1BQU0sS0FBSyxLQUFLO0lBQy9DO0lBRUEsa0VBQWtFO0lBQ2xFL0IsS0FBS3dHLG1CQUFtQixHQUFHLFNBQVNyRSxLQUFLO1FBQ3ZDLElBQUl4bEIsUUFBUXdsQixNQUFNbnVCLEdBQUc7UUFDckIsSUFBSSt0QixLQUFLO1FBQ1RJLE1BQU14QixZQUFZLEdBQUc7UUFDckIsTUFBT21JLFdBQVcvRyxLQUFLSSxNQUFNUCxPQUFPLElBQUs7WUFDdkNPLE1BQU14QixZQUFZLEdBQUcsS0FBS3dCLE1BQU14QixZQUFZLEdBQUdvSSxTQUFTaEg7WUFDeERJLE1BQU1MLE9BQU87UUFDZjtRQUNBLE9BQU9LLE1BQU1udUIsR0FBRyxLQUFLMkk7SUFDdkI7SUFDQSxTQUFTbXNCLFdBQVcvRyxFQUFFO1FBQ3BCLE9BQ0UsTUFBTyxLQUFLLEtBQUssT0FBTUEsTUFBTSxLQUFLLEtBQUssT0FDdENBLE1BQU0sS0FBSyxLQUFLLE9BQU1BLE1BQU0sS0FBSyxLQUFLLE9BQ3RDQSxNQUFNLEtBQUssS0FBSyxPQUFNQSxNQUFNLEtBQUssS0FBSztJQUUzQztJQUNBLFNBQVNnSCxTQUFTaEgsRUFBRTtRQUNsQixJQUFJQSxNQUFNLEtBQUssS0FBSyxPQUFNQSxNQUFNLEtBQUssS0FBSyxLQUFJO1lBQzVDLE9BQU8sS0FBTUEsQ0FBQUEsS0FBSyxLQUFLLEtBQUssR0FBUDtRQUN2QjtRQUNBLElBQUlBLE1BQU0sS0FBSyxLQUFLLE9BQU1BLE1BQU0sS0FBSyxLQUFLLEtBQUk7WUFDNUMsT0FBTyxLQUFNQSxDQUFBQSxLQUFLLEtBQUssS0FBSyxHQUFQO1FBQ3ZCO1FBQ0EsT0FBT0EsS0FBSyxLQUFLLEtBQUs7SUFDeEI7SUFFQSx5RkFBeUY7SUFDekYsZ0RBQWdEO0lBQ2hEL0IsS0FBSytGLG1DQUFtQyxHQUFHLFNBQVM1RCxLQUFLO1FBQ3ZELElBQUksSUFBSSxDQUFDNkcsb0JBQW9CLENBQUM3RyxRQUFRO1lBQ3BDLElBQUk4RyxLQUFLOUcsTUFBTXhCLFlBQVk7WUFDM0IsSUFBSSxJQUFJLENBQUNxSSxvQkFBb0IsQ0FBQzdHLFFBQVE7Z0JBQ3BDLElBQUkrRyxLQUFLL0csTUFBTXhCLFlBQVk7Z0JBQzNCLElBQUlzSSxNQUFNLEtBQUssSUFBSSxDQUFDRCxvQkFBb0IsQ0FBQzdHLFFBQVE7b0JBQy9DQSxNQUFNeEIsWUFBWSxHQUFHc0ksS0FBSyxLQUFLQyxLQUFLLElBQUkvRyxNQUFNeEIsWUFBWTtnQkFDNUQsT0FBTztvQkFDTHdCLE1BQU14QixZQUFZLEdBQUdzSSxLQUFLLElBQUlDO2dCQUNoQztZQUNGLE9BQU87Z0JBQ0wvRyxNQUFNeEIsWUFBWSxHQUFHc0k7WUFDdkI7WUFDQSxPQUFPO1FBQ1Q7UUFDQSxPQUFPO0lBQ1Q7SUFFQSxtRUFBbUU7SUFDbkVqSixLQUFLZ0osb0JBQW9CLEdBQUcsU0FBUzdHLEtBQUs7UUFDeEMsSUFBSUosS0FBS0ksTUFBTVAsT0FBTztRQUN0QixJQUFJa0csYUFBYS9GLEtBQUs7WUFDcEJJLE1BQU14QixZQUFZLEdBQUdvQixLQUFLLE1BQU0sS0FBSztZQUNyQ0ksTUFBTUwsT0FBTztZQUNiLE9BQU87UUFDVDtRQUNBSyxNQUFNeEIsWUFBWSxHQUFHO1FBQ3JCLE9BQU87SUFDVDtJQUNBLFNBQVNtSCxhQUFhL0YsRUFBRTtRQUN0QixPQUFPQSxNQUFNLEtBQUssS0FBSyxPQUFNQSxNQUFNLEtBQUssS0FBSztJQUMvQztJQUVBLG1FQUFtRTtJQUNuRSxpRUFBaUU7SUFDakUsbUdBQW1HO0lBQ25HL0IsS0FBS29HLHdCQUF3QixHQUFHLFNBQVNqRSxLQUFLLEVBQUVqdUIsTUFBTTtRQUNwRCxJQUFJeUksUUFBUXdsQixNQUFNbnVCLEdBQUc7UUFDckJtdUIsTUFBTXhCLFlBQVksR0FBRztRQUNyQixJQUFLLElBQUkxc0IsSUFBSSxHQUFHQSxJQUFJQyxRQUFRLEVBQUVELEVBQUc7WUFDL0IsSUFBSTh0QixLQUFLSSxNQUFNUCxPQUFPO1lBQ3RCLElBQUksQ0FBQ2tILFdBQVcvRyxLQUFLO2dCQUNuQkksTUFBTW51QixHQUFHLEdBQUcySTtnQkFDWixPQUFPO1lBQ1Q7WUFDQXdsQixNQUFNeEIsWUFBWSxHQUFHLEtBQUt3QixNQUFNeEIsWUFBWSxHQUFHb0ksU0FBU2hIO1lBQ3hESSxNQUFNTCxPQUFPO1FBQ2Y7UUFDQSxPQUFPO0lBQ1Q7SUFFQSxtRUFBbUU7SUFDbkUsZ0VBQWdFO0lBQ2hFLDREQUE0RDtJQUU1RCxJQUFJcUgsUUFBUSxTQUFTQSxNQUFNenNCLENBQUM7UUFDMUIsSUFBSSxDQUFDMEMsSUFBSSxHQUFHMUMsRUFBRTBDLElBQUk7UUFDbEIsSUFBSSxDQUFDQyxLQUFLLEdBQUczQyxFQUFFMkMsS0FBSztRQUNwQixJQUFJLENBQUMxQyxLQUFLLEdBQUdELEVBQUVDLEtBQUs7UUFDcEIsSUFBSSxDQUFDL0IsR0FBRyxHQUFHOEIsRUFBRTlCLEdBQUc7UUFDaEIsSUFBSThCLEVBQUVqSCxPQUFPLENBQUNvSSxTQUFTLEVBQ3JCO1lBQUUsSUFBSSxDQUFDeUIsR0FBRyxHQUFHLElBQUk3QyxlQUFlQyxHQUFHQSxFQUFFdUMsUUFBUSxFQUFFdkMsRUFBRXdDLE1BQU07UUFBRztRQUM1RCxJQUFJeEMsRUFBRWpILE9BQU8sQ0FBQ3VJLE1BQU0sRUFDbEI7WUFBRSxJQUFJLENBQUN1QixLQUFLLEdBQUc7Z0JBQUM3QyxFQUFFQyxLQUFLO2dCQUFFRCxFQUFFOUIsR0FBRzthQUFDO1FBQUU7SUFDckM7SUFFQSxlQUFlO0lBRWYsSUFBSXd1QixLQUFLeG9CLE9BQU96RixTQUFTO0lBRXpCLHlCQUF5QjtJQUV6Qml1QixHQUFHdnVCLElBQUksR0FBRyxTQUFTd3VCLDZCQUE2QjtRQUM5QyxJQUFJLENBQUNBLGlDQUFpQyxJQUFJLENBQUNqcUIsSUFBSSxDQUFDeEssT0FBTyxJQUFJLElBQUksQ0FBQ3NNLFdBQVcsRUFDekU7WUFBRSxJQUFJLENBQUN5RixnQkFBZ0IsQ0FBQyxJQUFJLENBQUNoSyxLQUFLLEVBQUUsZ0NBQWdDLElBQUksQ0FBQ3lDLElBQUksQ0FBQ3hLLE9BQU87UUFBRztRQUMxRixJQUFJLElBQUksQ0FBQ2EsT0FBTyxDQUFDcUksT0FBTyxFQUN0QjtZQUFFLElBQUksQ0FBQ3JJLE9BQU8sQ0FBQ3FJLE9BQU8sQ0FBQyxJQUFJcXJCLE1BQU0sSUFBSTtRQUFJO1FBRTNDLElBQUksQ0FBQ3ZuQixVQUFVLEdBQUcsSUFBSSxDQUFDaEgsR0FBRztRQUMxQixJQUFJLENBQUMrRyxZQUFZLEdBQUcsSUFBSSxDQUFDaEYsS0FBSztRQUM5QixJQUFJLENBQUM4RSxhQUFhLEdBQUcsSUFBSSxDQUFDdkMsTUFBTTtRQUNoQyxJQUFJLENBQUN3QyxlQUFlLEdBQUcsSUFBSSxDQUFDekMsUUFBUTtRQUNwQyxJQUFJLENBQUMyRSxTQUFTO0lBQ2hCO0lBRUF3bEIsR0FBR0UsUUFBUSxHQUFHO1FBQ1osSUFBSSxDQUFDenVCLElBQUk7UUFDVCxPQUFPLElBQUlzdUIsTUFBTSxJQUFJO0lBQ3ZCO0lBRUEsd0RBQXdEO0lBQ3hELElBQUksT0FBT0ksV0FBVyxhQUNwQjtRQUFFSCxFQUFFLENBQUNHLE9BQU9DLFFBQVEsQ0FBQyxHQUFHO1lBQ3RCLElBQUlDLFdBQVcsSUFBSTtZQUVuQixPQUFPO2dCQUNMNXVCLE1BQU07b0JBQ0osSUFBSThELFFBQVE4cUIsU0FBU0gsUUFBUTtvQkFDN0IsT0FBTzt3QkFDTEksTUFBTS9xQixNQUFNUyxJQUFJLEtBQUsxSixRQUFRSyxHQUFHO3dCQUNoQ3NKLE9BQU9WO29CQUNUO2dCQUNGO1lBQ0Y7UUFDRjtJQUFHO0lBRUwsbUVBQW1FO0lBQ25FLHFEQUFxRDtJQUVyRCxrRUFBa0U7SUFDbEUsY0FBYztJQUVkeXFCLEdBQUd4bEIsU0FBUyxHQUFHO1FBQ2IsSUFBSW1TLGFBQWEsSUFBSSxDQUFDQSxVQUFVO1FBQ2hDLElBQUksQ0FBQ0EsY0FBYyxDQUFDQSxXQUFXZixhQUFhLEVBQUU7WUFBRSxJQUFJLENBQUMyVSxTQUFTO1FBQUk7UUFFbEUsSUFBSSxDQUFDaHRCLEtBQUssR0FBRyxJQUFJLENBQUMzSSxHQUFHO1FBQ3JCLElBQUksSUFBSSxDQUFDeUIsT0FBTyxDQUFDb0ksU0FBUyxFQUFFO1lBQUUsSUFBSSxDQUFDb0IsUUFBUSxHQUFHLElBQUksQ0FBQ3VDLFdBQVc7UUFBSTtRQUNsRSxJQUFJLElBQUksQ0FBQ3hOLEdBQUcsSUFBSSxJQUFJLENBQUM4SSxLQUFLLENBQUM1SSxNQUFNLEVBQUU7WUFBRSxPQUFPLElBQUksQ0FBQzAxQixXQUFXLENBQUNsMEIsUUFBUUssR0FBRztRQUFFO1FBRTFFLElBQUlnZ0IsV0FBV2QsUUFBUSxFQUFFO1lBQUUsT0FBT2MsV0FBV2QsUUFBUSxDQUFDLElBQUk7UUFBRSxPQUN2RDtZQUFFLElBQUksQ0FBQzRVLFNBQVMsQ0FBQyxJQUFJLENBQUNDLGlCQUFpQjtRQUFLO0lBQ25EO0lBRUFWLEdBQUdTLFNBQVMsR0FBRyxTQUFTLzFCLElBQUk7UUFDMUIsMkRBQTJEO1FBQzNELCtDQUErQztRQUMvQyxJQUFJSyxrQkFBa0JMLE1BQU0sSUFBSSxDQUFDMkIsT0FBTyxDQUFDeUgsV0FBVyxJQUFJLE1BQU1wSixTQUFTLEdBQUcsT0FBTyxLQUMvRTtZQUFFLE9BQU8sSUFBSSxDQUFDaTJCLFFBQVE7UUFBRztRQUUzQixPQUFPLElBQUksQ0FBQ0MsZ0JBQWdCLENBQUNsMkI7SUFDL0I7SUFFQXMxQixHQUFHVSxpQkFBaUIsR0FBRztRQUNyQixJQUFJaDJCLE9BQU8sSUFBSSxDQUFDZ0osS0FBSyxDQUFDaEMsVUFBVSxDQUFDLElBQUksQ0FBQzlHLEdBQUc7UUFDekMsSUFBSUYsUUFBUSxVQUFVQSxRQUFRLFFBQVE7WUFBRSxPQUFPQTtRQUFLO1FBQ3BELElBQUkrRyxPQUFPLElBQUksQ0FBQ2lDLEtBQUssQ0FBQ2hDLFVBQVUsQ0FBQyxJQUFJLENBQUM5RyxHQUFHLEdBQUc7UUFDNUMsT0FBTzZHLFFBQVEsVUFBVUEsUUFBUSxTQUFTL0csT0FBTyxDQUFDQSxRQUFRLEVBQUMsSUFBSytHLE9BQU87SUFDekU7SUFFQXV1QixHQUFHYSxnQkFBZ0IsR0FBRztRQUNwQixJQUFJaHJCLFdBQVcsSUFBSSxDQUFDeEosT0FBTyxDQUFDc0ksU0FBUyxJQUFJLElBQUksQ0FBQ3lELFdBQVc7UUFDekQsSUFBSTdFLFFBQVEsSUFBSSxDQUFDM0ksR0FBRyxFQUFFNEcsTUFBTSxJQUFJLENBQUNrQyxLQUFLLENBQUMwUCxPQUFPLENBQUMsTUFBTSxJQUFJLENBQUN4WSxHQUFHLElBQUk7UUFDakUsSUFBSTRHLFFBQVEsQ0FBQyxHQUFHO1lBQUUsSUFBSSxDQUFDc0wsS0FBSyxDQUFDLElBQUksQ0FBQ2xTLEdBQUcsR0FBRyxHQUFHO1FBQXlCO1FBQ3BFLElBQUksQ0FBQ0EsR0FBRyxHQUFHNEcsTUFBTTtRQUNqQixJQUFJLElBQUksQ0FBQ25GLE9BQU8sQ0FBQ29JLFNBQVMsRUFBRTtZQUMxQixJQUFLLElBQUliLFlBQWEsS0FBSyxHQUFJaEosTUFBTTJJLE9BQU8sQ0FBQ0ssWUFBWXRDLGNBQWMsSUFBSSxDQUFDb0MsS0FBSyxFQUFFOUksS0FBSyxJQUFJLENBQUNBLEdBQUcsS0FBSyxDQUFDLEdBQUk7Z0JBQ3hHLEVBQUUsSUFBSSxDQUFDcU4sT0FBTztnQkFDZHJOLE1BQU0sSUFBSSxDQUFDbU4sU0FBUyxHQUFHbkU7WUFDekI7UUFDRjtRQUNBLElBQUksSUFBSSxDQUFDdkgsT0FBTyxDQUFDc0ksU0FBUyxFQUN4QjtZQUFFLElBQUksQ0FBQ3RJLE9BQU8sQ0FBQ3NJLFNBQVMsQ0FBQyxNQUFNLElBQUksQ0FBQ2pCLEtBQUssQ0FBQ3dFLEtBQUssQ0FBQzNFLFFBQVEsR0FBRy9CLE1BQU0rQixPQUFPLElBQUksQ0FBQzNJLEdBQUcsRUFDekRpTCxVQUFVLElBQUksQ0FBQ3VDLFdBQVc7UUFBSztJQUMxRDtJQUVBNG5CLEdBQUczbUIsZUFBZSxHQUFHLFNBQVN5bkIsU0FBUztRQUNyQyxJQUFJdnRCLFFBQVEsSUFBSSxDQUFDM0ksR0FBRztRQUNwQixJQUFJaUwsV0FBVyxJQUFJLENBQUN4SixPQUFPLENBQUNzSSxTQUFTLElBQUksSUFBSSxDQUFDeUQsV0FBVztRQUN6RCxJQUFJdWdCLEtBQUssSUFBSSxDQUFDamxCLEtBQUssQ0FBQ2hDLFVBQVUsQ0FBQyxJQUFJLENBQUM5RyxHQUFHLElBQUlrMkI7UUFDM0MsTUFBTyxJQUFJLENBQUNsMkIsR0FBRyxHQUFHLElBQUksQ0FBQzhJLEtBQUssQ0FBQzVJLE1BQU0sSUFBSSxDQUFDdUcsVUFBVXNuQixJQUFLO1lBQ3JEQSxLQUFLLElBQUksQ0FBQ2psQixLQUFLLENBQUNoQyxVQUFVLENBQUMsRUFBRSxJQUFJLENBQUM5RyxHQUFHO1FBQ3ZDO1FBQ0EsSUFBSSxJQUFJLENBQUN5QixPQUFPLENBQUNzSSxTQUFTLEVBQ3hCO1lBQUUsSUFBSSxDQUFDdEksT0FBTyxDQUFDc0ksU0FBUyxDQUFDLE9BQU8sSUFBSSxDQUFDakIsS0FBSyxDQUFDd0UsS0FBSyxDQUFDM0UsUUFBUXV0QixXQUFXLElBQUksQ0FBQ2wyQixHQUFHLEdBQUcySSxPQUFPLElBQUksQ0FBQzNJLEdBQUcsRUFDdkVpTCxVQUFVLElBQUksQ0FBQ3VDLFdBQVc7UUFBSztJQUMxRDtJQUVBLGdFQUFnRTtJQUNoRSxnQ0FBZ0M7SUFFaEM0bkIsR0FBR08sU0FBUyxHQUFHO1FBQ2JRLE1BQU0sTUFBTyxJQUFJLENBQUNuMkIsR0FBRyxHQUFHLElBQUksQ0FBQzhJLEtBQUssQ0FBQzVJLE1BQU0sQ0FBRTtZQUN6QyxJQUFJNnRCLEtBQUssSUFBSSxDQUFDamxCLEtBQUssQ0FBQ2hDLFVBQVUsQ0FBQyxJQUFJLENBQUM5RyxHQUFHO1lBQ3ZDLE9BQVErdEI7Z0JBQ1IsS0FBSztnQkFBSSxLQUFLO29CQUNaLEVBQUUsSUFBSSxDQUFDL3RCLEdBQUc7b0JBQ1Y7Z0JBQ0YsS0FBSztvQkFDSCxJQUFJLElBQUksQ0FBQzhJLEtBQUssQ0FBQ2hDLFVBQVUsQ0FBQyxJQUFJLENBQUM5RyxHQUFHLEdBQUcsT0FBTyxJQUFJO3dCQUM5QyxFQUFFLElBQUksQ0FBQ0EsR0FBRztvQkFDWjtnQkFDRixLQUFLO2dCQUFJLEtBQUs7Z0JBQU0sS0FBSztvQkFDdkIsRUFBRSxJQUFJLENBQUNBLEdBQUc7b0JBQ1YsSUFBSSxJQUFJLENBQUN5QixPQUFPLENBQUNvSSxTQUFTLEVBQUU7d0JBQzFCLEVBQUUsSUFBSSxDQUFDd0QsT0FBTzt3QkFDZCxJQUFJLENBQUNGLFNBQVMsR0FBRyxJQUFJLENBQUNuTixHQUFHO29CQUMzQjtvQkFDQTtnQkFDRixLQUFLO29CQUNILE9BQVEsSUFBSSxDQUFDOEksS0FBSyxDQUFDaEMsVUFBVSxDQUFDLElBQUksQ0FBQzlHLEdBQUcsR0FBRzt3QkFDekMsS0FBSzs0QkFDSCxJQUFJLENBQUNpMkIsZ0JBQWdCOzRCQUNyQjt3QkFDRixLQUFLOzRCQUNILElBQUksQ0FBQ3huQixlQUFlLENBQUM7NEJBQ3JCO3dCQUNGOzRCQUNFLE1BQU0wbkI7b0JBQ1I7b0JBQ0E7Z0JBQ0Y7b0JBQ0UsSUFBSXBJLEtBQUssS0FBS0EsS0FBSyxNQUFNQSxNQUFNLFFBQVFobkIsbUJBQW1CMUcsSUFBSSxDQUFDQyxPQUFPQyxZQUFZLENBQUN3dEIsTUFBTTt3QkFDdkYsRUFBRSxJQUFJLENBQUMvdEIsR0FBRztvQkFDWixPQUFPO3dCQUNMLE1BQU1tMkI7b0JBQ1I7WUFDRjtRQUNGO0lBQ0Y7SUFFQSwyREFBMkQ7SUFDM0QsbUVBQW1FO0lBQ25FLDhEQUE4RDtJQUM5RCxrQkFBa0I7SUFFbEJmLEdBQUdRLFdBQVcsR0FBRyxTQUFTeHFCLElBQUksRUFBRW9iLEdBQUc7UUFDakMsSUFBSSxDQUFDNWYsR0FBRyxHQUFHLElBQUksQ0FBQzVHLEdBQUc7UUFDbkIsSUFBSSxJQUFJLENBQUN5QixPQUFPLENBQUNvSSxTQUFTLEVBQUU7WUFBRSxJQUFJLENBQUNxQixNQUFNLEdBQUcsSUFBSSxDQUFDc0MsV0FBVztRQUFJO1FBQ2hFLElBQUl5VSxXQUFXLElBQUksQ0FBQzdXLElBQUk7UUFDeEIsSUFBSSxDQUFDQSxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDQyxLQUFLLEdBQUdtYjtRQUViLElBQUksQ0FBQ3BsQixhQUFhLENBQUM2Z0I7SUFDckI7SUFFQSxvQkFBb0I7SUFFcEIsa0VBQWtFO0lBQ2xFLGtFQUFrRTtJQUNsRSxpRUFBaUU7SUFDakUsV0FBVztJQUNYLEVBQUU7SUFDRiw0QkFBNEI7SUFDNUIsRUFBRTtJQUNGbVQsR0FBR2dCLGFBQWEsR0FBRztRQUNqQixJQUFJdnZCLE9BQU8sSUFBSSxDQUFDaUMsS0FBSyxDQUFDaEMsVUFBVSxDQUFDLElBQUksQ0FBQzlHLEdBQUcsR0FBRztRQUM1QyxJQUFJNkcsUUFBUSxNQUFNQSxRQUFRLElBQUk7WUFBRSxPQUFPLElBQUksQ0FBQ3d2QixVQUFVLENBQUM7UUFBTTtRQUM3RCxJQUFJQyxRQUFRLElBQUksQ0FBQ3h0QixLQUFLLENBQUNoQyxVQUFVLENBQUMsSUFBSSxDQUFDOUcsR0FBRyxHQUFHO1FBQzdDLElBQUksSUFBSSxDQUFDeUIsT0FBTyxDQUFDeUgsV0FBVyxJQUFJLEtBQUtyQyxTQUFTLE1BQU15dkIsVUFBVSxJQUFJO1lBQ2hFLElBQUksQ0FBQ3QyQixHQUFHLElBQUk7WUFDWixPQUFPLElBQUksQ0FBQzQxQixXQUFXLENBQUNsMEIsUUFBUXFCLFFBQVE7UUFDMUMsT0FBTztZQUNMLEVBQUUsSUFBSSxDQUFDL0MsR0FBRztZQUNWLE9BQU8sSUFBSSxDQUFDNDFCLFdBQVcsQ0FBQ2wwQixRQUFRZSxHQUFHO1FBQ3JDO0lBQ0Y7SUFFQTJ5QixHQUFHbUIsZUFBZSxHQUFHO1FBQ25CLElBQUkxdkIsT0FBTyxJQUFJLENBQUNpQyxLQUFLLENBQUNoQyxVQUFVLENBQUMsSUFBSSxDQUFDOUcsR0FBRyxHQUFHO1FBQzVDLElBQUksSUFBSSxDQUFDK04sV0FBVyxFQUFFO1lBQUUsRUFBRSxJQUFJLENBQUMvTixHQUFHO1lBQUUsT0FBTyxJQUFJLENBQUMybEIsVUFBVTtRQUFHO1FBQzdELElBQUk5ZSxTQUFTLElBQUk7WUFBRSxPQUFPLElBQUksQ0FBQzJ2QixRQUFRLENBQUM5MEIsUUFBUXlCLE1BQU0sRUFBRTtRQUFHO1FBQzNELE9BQU8sSUFBSSxDQUFDcXpCLFFBQVEsQ0FBQzkwQixRQUFRc0MsS0FBSyxFQUFFO0lBQ3RDO0lBRUFveEIsR0FBR3FCLHlCQUF5QixHQUFHLFNBQVMzMkIsSUFBSTtRQUMxQyxJQUFJK0csT0FBTyxJQUFJLENBQUNpQyxLQUFLLENBQUNoQyxVQUFVLENBQUMsSUFBSSxDQUFDOUcsR0FBRyxHQUFHO1FBQzVDLElBQUkwMkIsT0FBTztRQUNYLElBQUlDLFlBQVk3MkIsU0FBUyxLQUFLNEIsUUFBUXFDLElBQUksR0FBR3JDLFFBQVFvQyxNQUFNO1FBRTNELHFDQUFxQztRQUNyQyxJQUFJLElBQUksQ0FBQ3JDLE9BQU8sQ0FBQ3lILFdBQVcsSUFBSSxLQUFLcEosU0FBUyxNQUFNK0csU0FBUyxJQUFJO1lBQy9ELEVBQUU2dkI7WUFDRkMsWUFBWWoxQixRQUFRdUMsUUFBUTtZQUM1QjRDLE9BQU8sSUFBSSxDQUFDaUMsS0FBSyxDQUFDaEMsVUFBVSxDQUFDLElBQUksQ0FBQzlHLEdBQUcsR0FBRztRQUMxQztRQUVBLElBQUk2RyxTQUFTLElBQUk7WUFBRSxPQUFPLElBQUksQ0FBQzJ2QixRQUFRLENBQUM5MEIsUUFBUXlCLE1BQU0sRUFBRXV6QixPQUFPO1FBQUc7UUFDbEUsT0FBTyxJQUFJLENBQUNGLFFBQVEsQ0FBQ0csV0FBV0Q7SUFDbEM7SUFFQXRCLEdBQUd3QixrQkFBa0IsR0FBRyxTQUFTOTJCLElBQUk7UUFDbkMsSUFBSStHLE9BQU8sSUFBSSxDQUFDaUMsS0FBSyxDQUFDaEMsVUFBVSxDQUFDLElBQUksQ0FBQzlHLEdBQUcsR0FBRztRQUM1QyxJQUFJNkcsU0FBUy9HLE1BQU07WUFDakIsSUFBSSxJQUFJLENBQUMyQixPQUFPLENBQUN5SCxXQUFXLElBQUksSUFBSTtnQkFDbEMsSUFBSW90QixRQUFRLElBQUksQ0FBQ3h0QixLQUFLLENBQUNoQyxVQUFVLENBQUMsSUFBSSxDQUFDOUcsR0FBRyxHQUFHO2dCQUM3QyxJQUFJczJCLFVBQVUsSUFBSTtvQkFBRSxPQUFPLElBQUksQ0FBQ0UsUUFBUSxDQUFDOTBCLFFBQVF5QixNQUFNLEVBQUU7Z0JBQUc7WUFDOUQ7WUFDQSxPQUFPLElBQUksQ0FBQ3F6QixRQUFRLENBQUMxMkIsU0FBUyxNQUFNNEIsUUFBUTJCLFNBQVMsR0FBRzNCLFFBQVE0QixVQUFVLEVBQUU7UUFDOUU7UUFDQSxJQUFJdUQsU0FBUyxJQUFJO1lBQUUsT0FBTyxJQUFJLENBQUMydkIsUUFBUSxDQUFDOTBCLFFBQVF5QixNQUFNLEVBQUU7UUFBRztRQUMzRCxPQUFPLElBQUksQ0FBQ3F6QixRQUFRLENBQUMxMkIsU0FBUyxNQUFNNEIsUUFBUTZCLFNBQVMsR0FBRzdCLFFBQVErQixVQUFVLEVBQUU7SUFDOUU7SUFFQTJ4QixHQUFHeUIsZUFBZSxHQUFHO1FBQ25CLElBQUlod0IsT0FBTyxJQUFJLENBQUNpQyxLQUFLLENBQUNoQyxVQUFVLENBQUMsSUFBSSxDQUFDOUcsR0FBRyxHQUFHO1FBQzVDLElBQUk2RyxTQUFTLElBQUk7WUFBRSxPQUFPLElBQUksQ0FBQzJ2QixRQUFRLENBQUM5MEIsUUFBUXlCLE1BQU0sRUFBRTtRQUFHO1FBQzNELE9BQU8sSUFBSSxDQUFDcXpCLFFBQVEsQ0FBQzkwQixRQUFROEIsVUFBVSxFQUFFO0lBQzNDO0lBRUE0eEIsR0FBRzBCLGtCQUFrQixHQUFHLFNBQVNoM0IsSUFBSTtRQUNuQyxJQUFJK0csT0FBTyxJQUFJLENBQUNpQyxLQUFLLENBQUNoQyxVQUFVLENBQUMsSUFBSSxDQUFDOUcsR0FBRyxHQUFHO1FBQzVDLElBQUk2RyxTQUFTL0csTUFBTTtZQUNqQixJQUFJK0csU0FBUyxNQUFNLENBQUMsSUFBSSxDQUFDbUgsUUFBUSxJQUFJLElBQUksQ0FBQ2xGLEtBQUssQ0FBQ2hDLFVBQVUsQ0FBQyxJQUFJLENBQUM5RyxHQUFHLEdBQUcsT0FBTyxNQUN4RSxLQUFJLENBQUM0TixVQUFVLEtBQUssS0FBS3RILFVBQVVqRyxJQUFJLENBQUMsSUFBSSxDQUFDeUksS0FBSyxDQUFDd0UsS0FBSyxDQUFDLElBQUksQ0FBQ00sVUFBVSxFQUFFLElBQUksQ0FBQzVOLEdBQUcsRUFBQyxHQUFJO2dCQUMxRix1QkFBdUI7Z0JBQ3ZCLElBQUksQ0FBQ3lPLGVBQWUsQ0FBQztnQkFDckIsSUFBSSxDQUFDa25CLFNBQVM7Z0JBQ2QsT0FBTyxJQUFJLENBQUMvbEIsU0FBUztZQUN2QjtZQUNBLE9BQU8sSUFBSSxDQUFDNG1CLFFBQVEsQ0FBQzkwQixRQUFRMEIsTUFBTSxFQUFFO1FBQ3ZDO1FBQ0EsSUFBSXlELFNBQVMsSUFBSTtZQUFFLE9BQU8sSUFBSSxDQUFDMnZCLFFBQVEsQ0FBQzkwQixRQUFReUIsTUFBTSxFQUFFO1FBQUc7UUFDM0QsT0FBTyxJQUFJLENBQUNxekIsUUFBUSxDQUFDOTBCLFFBQVFtQyxPQUFPLEVBQUU7SUFDeEM7SUFFQXV4QixHQUFHMkIsZUFBZSxHQUFHLFNBQVNqM0IsSUFBSTtRQUNoQyxJQUFJK0csT0FBTyxJQUFJLENBQUNpQyxLQUFLLENBQUNoQyxVQUFVLENBQUMsSUFBSSxDQUFDOUcsR0FBRyxHQUFHO1FBQzVDLElBQUkwMkIsT0FBTztRQUNYLElBQUk3dkIsU0FBUy9HLE1BQU07WUFDakI0MkIsT0FBTzUyQixTQUFTLE1BQU0sSUFBSSxDQUFDZ0osS0FBSyxDQUFDaEMsVUFBVSxDQUFDLElBQUksQ0FBQzlHLEdBQUcsR0FBRyxPQUFPLEtBQUssSUFBSTtZQUN2RSxJQUFJLElBQUksQ0FBQzhJLEtBQUssQ0FBQ2hDLFVBQVUsQ0FBQyxJQUFJLENBQUM5RyxHQUFHLEdBQUcwMkIsVUFBVSxJQUFJO2dCQUFFLE9BQU8sSUFBSSxDQUFDRixRQUFRLENBQUM5MEIsUUFBUXlCLE1BQU0sRUFBRXV6QixPQUFPO1lBQUc7WUFDcEcsT0FBTyxJQUFJLENBQUNGLFFBQVEsQ0FBQzkwQixRQUFRa0MsUUFBUSxFQUFFOHlCO1FBQ3pDO1FBQ0EsSUFBSTd2QixTQUFTLE1BQU0vRyxTQUFTLE1BQU0sQ0FBQyxJQUFJLENBQUNrTyxRQUFRLElBQUksSUFBSSxDQUFDbEYsS0FBSyxDQUFDaEMsVUFBVSxDQUFDLElBQUksQ0FBQzlHLEdBQUcsR0FBRyxPQUFPLE1BQ3hGLElBQUksQ0FBQzhJLEtBQUssQ0FBQ2hDLFVBQVUsQ0FBQyxJQUFJLENBQUM5RyxHQUFHLEdBQUcsT0FBTyxJQUFJO1lBQzlDLDRFQUE0RTtZQUM1RSxJQUFJLENBQUN5TyxlQUFlLENBQUM7WUFDckIsSUFBSSxDQUFDa25CLFNBQVM7WUFDZCxPQUFPLElBQUksQ0FBQy9sQixTQUFTO1FBQ3ZCO1FBQ0EsSUFBSS9JLFNBQVMsSUFBSTtZQUFFNnZCLE9BQU87UUFBRztRQUM3QixPQUFPLElBQUksQ0FBQ0YsUUFBUSxDQUFDOTBCLFFBQVFpQyxVQUFVLEVBQUUreUI7SUFDM0M7SUFFQXRCLEdBQUc0QixpQkFBaUIsR0FBRyxTQUFTbDNCLElBQUk7UUFDbEMsSUFBSStHLE9BQU8sSUFBSSxDQUFDaUMsS0FBSyxDQUFDaEMsVUFBVSxDQUFDLElBQUksQ0FBQzlHLEdBQUcsR0FBRztRQUM1QyxJQUFJNkcsU0FBUyxJQUFJO1lBQUUsT0FBTyxJQUFJLENBQUMydkIsUUFBUSxDQUFDOTBCLFFBQVFnQyxRQUFRLEVBQUUsSUFBSSxDQUFDb0YsS0FBSyxDQUFDaEMsVUFBVSxDQUFDLElBQUksQ0FBQzlHLEdBQUcsR0FBRyxPQUFPLEtBQUssSUFBSTtRQUFHO1FBQzlHLElBQUlGLFNBQVMsTUFBTStHLFNBQVMsTUFBTSxJQUFJLENBQUNwRixPQUFPLENBQUN5SCxXQUFXLElBQUksR0FBRztZQUMvRCxJQUFJLENBQUNsSixHQUFHLElBQUk7WUFDWixPQUFPLElBQUksQ0FBQzQxQixXQUFXLENBQUNsMEIsUUFBUWtCLEtBQUs7UUFDdkM7UUFDQSxPQUFPLElBQUksQ0FBQzR6QixRQUFRLENBQUMxMkIsU0FBUyxLQUFLNEIsUUFBUXdCLEVBQUUsR0FBR3hCLFFBQVFULE1BQU0sRUFBRTtJQUNsRTtJQUVBbTBCLEdBQUc2QixrQkFBa0IsR0FBRztRQUN0QixJQUFJL3RCLGNBQWMsSUFBSSxDQUFDekgsT0FBTyxDQUFDeUgsV0FBVztRQUMxQyxJQUFJQSxlQUFlLElBQUk7WUFDckIsSUFBSXJDLE9BQU8sSUFBSSxDQUFDaUMsS0FBSyxDQUFDaEMsVUFBVSxDQUFDLElBQUksQ0FBQzlHLEdBQUcsR0FBRztZQUM1QyxJQUFJNkcsU0FBUyxJQUFJO2dCQUNmLElBQUl5dkIsUUFBUSxJQUFJLENBQUN4dEIsS0FBSyxDQUFDaEMsVUFBVSxDQUFDLElBQUksQ0FBQzlHLEdBQUcsR0FBRztnQkFDN0MsSUFBSXMyQixRQUFRLE1BQU1BLFFBQVEsSUFBSTtvQkFBRSxPQUFPLElBQUksQ0FBQ0UsUUFBUSxDQUFDOTBCLFFBQVFpQixXQUFXLEVBQUU7Z0JBQUc7WUFDL0U7WUFDQSxJQUFJa0UsU0FBUyxJQUFJO2dCQUNmLElBQUlxQyxlQUFlLElBQUk7b0JBQ3JCLElBQUlndUIsVUFBVSxJQUFJLENBQUNwdUIsS0FBSyxDQUFDaEMsVUFBVSxDQUFDLElBQUksQ0FBQzlHLEdBQUcsR0FBRztvQkFDL0MsSUFBSWszQixZQUFZLElBQUk7d0JBQUUsT0FBTyxJQUFJLENBQUNWLFFBQVEsQ0FBQzkwQixRQUFReUIsTUFBTSxFQUFFO29CQUFHO2dCQUNoRTtnQkFDQSxPQUFPLElBQUksQ0FBQ3F6QixRQUFRLENBQUM5MEIsUUFBUXdDLFFBQVEsRUFBRTtZQUN6QztRQUNGO1FBQ0EsT0FBTyxJQUFJLENBQUNzeUIsUUFBUSxDQUFDOTBCLFFBQVFnQixRQUFRLEVBQUU7SUFDekM7SUFFQTB5QixHQUFHK0Isb0JBQW9CLEdBQUc7UUFDeEIsSUFBSWp1QixjQUFjLElBQUksQ0FBQ3pILE9BQU8sQ0FBQ3lILFdBQVc7UUFDMUMsSUFBSXBKLE9BQU8sSUFBSSxNQUFNO1FBQ3JCLElBQUlvSixlQUFlLElBQUk7WUFDckIsRUFBRSxJQUFJLENBQUNsSixHQUFHO1lBQ1ZGLE9BQU8sSUFBSSxDQUFDZzJCLGlCQUFpQjtZQUM3QixJQUFJMzFCLGtCQUFrQkwsTUFBTSxTQUFTQSxTQUFTLEdBQUcsT0FBTyxLQUFJO2dCQUMxRCxPQUFPLElBQUksQ0FBQzgxQixXQUFXLENBQUNsMEIsUUFBUUksU0FBUyxFQUFFLElBQUksQ0FBQ3MxQixTQUFTO1lBQzNEO1FBQ0Y7UUFFQSxJQUFJLENBQUNsbEIsS0FBSyxDQUFDLElBQUksQ0FBQ2xTLEdBQUcsRUFBRSwyQkFBMkJpSSxrQkFBa0JuSSxRQUFRO0lBQzVFO0lBRUFzMUIsR0FBR1ksZ0JBQWdCLEdBQUcsU0FBU2wyQixJQUFJO1FBQ2pDLE9BQVFBO1lBQ1IsZ0VBQWdFO1lBQ2hFLGtDQUFrQztZQUNsQyxLQUFLO2dCQUNILE9BQU8sSUFBSSxDQUFDczJCLGFBQWE7WUFFM0Isc0JBQXNCO1lBQ3RCLEtBQUs7Z0JBQUksRUFBRSxJQUFJLENBQUNwMkIsR0FBRztnQkFBRSxPQUFPLElBQUksQ0FBQzQxQixXQUFXLENBQUNsMEIsUUFBUVUsTUFBTTtZQUMzRCxLQUFLO2dCQUFJLEVBQUUsSUFBSSxDQUFDcEMsR0FBRztnQkFBRSxPQUFPLElBQUksQ0FBQzQxQixXQUFXLENBQUNsMEIsUUFBUVcsTUFBTTtZQUMzRCxLQUFLO2dCQUFJLEVBQUUsSUFBSSxDQUFDckMsR0FBRztnQkFBRSxPQUFPLElBQUksQ0FBQzQxQixXQUFXLENBQUNsMEIsUUFBUWEsSUFBSTtZQUN6RCxLQUFLO2dCQUFJLEVBQUUsSUFBSSxDQUFDdkMsR0FBRztnQkFBRSxPQUFPLElBQUksQ0FBQzQxQixXQUFXLENBQUNsMEIsUUFBUVksS0FBSztZQUMxRCxLQUFLO2dCQUFJLEVBQUUsSUFBSSxDQUFDdEMsR0FBRztnQkFBRSxPQUFPLElBQUksQ0FBQzQxQixXQUFXLENBQUNsMEIsUUFBUU0sUUFBUTtZQUM3RCxLQUFLO2dCQUFJLEVBQUUsSUFBSSxDQUFDaEMsR0FBRztnQkFBRSxPQUFPLElBQUksQ0FBQzQxQixXQUFXLENBQUNsMEIsUUFBUU8sUUFBUTtZQUM3RCxLQUFLO2dCQUFLLEVBQUUsSUFBSSxDQUFDakMsR0FBRztnQkFBRSxPQUFPLElBQUksQ0FBQzQxQixXQUFXLENBQUNsMEIsUUFBUVEsTUFBTTtZQUM1RCxLQUFLO2dCQUFLLEVBQUUsSUFBSSxDQUFDbEMsR0FBRztnQkFBRSxPQUFPLElBQUksQ0FBQzQxQixXQUFXLENBQUNsMEIsUUFBUVMsTUFBTTtZQUM1RCxLQUFLO2dCQUFJLEVBQUUsSUFBSSxDQUFDbkMsR0FBRztnQkFBRSxPQUFPLElBQUksQ0FBQzQxQixXQUFXLENBQUNsMEIsUUFBUWMsS0FBSztZQUUxRCxLQUFLO2dCQUNILElBQUksSUFBSSxDQUFDZixPQUFPLENBQUN5SCxXQUFXLEdBQUcsR0FBRztvQkFBRTtnQkFBTTtnQkFDMUMsRUFBRSxJQUFJLENBQUNsSixHQUFHO2dCQUNWLE9BQU8sSUFBSSxDQUFDNDFCLFdBQVcsQ0FBQ2wwQixRQUFRc0IsU0FBUztZQUUzQyxLQUFLO2dCQUNILElBQUk2RCxPQUFPLElBQUksQ0FBQ2lDLEtBQUssQ0FBQ2hDLFVBQVUsQ0FBQyxJQUFJLENBQUM5RyxHQUFHLEdBQUc7Z0JBQzVDLElBQUk2RyxTQUFTLE9BQU9BLFNBQVMsSUFBSTtvQkFBRSxPQUFPLElBQUksQ0FBQ3d3QixlQUFlLENBQUM7Z0JBQUksRUFBRSwwQkFBMEI7Z0JBQy9GLElBQUksSUFBSSxDQUFDNTFCLE9BQU8sQ0FBQ3lILFdBQVcsSUFBSSxHQUFHO29CQUNqQyxJQUFJckMsU0FBUyxPQUFPQSxTQUFTLElBQUk7d0JBQUUsT0FBTyxJQUFJLENBQUN3d0IsZUFBZSxDQUFDO29CQUFHLEVBQUUsNEJBQTRCO29CQUNoRyxJQUFJeHdCLFNBQVMsTUFBTUEsU0FBUyxJQUFJO3dCQUFFLE9BQU8sSUFBSSxDQUFDd3dCLGVBQWUsQ0FBQztvQkFBRyxFQUFFLDZCQUE2QjtnQkFDbEc7WUFFRiw0REFBNEQ7WUFDNUQsb0JBQW9CO1lBQ3BCLEtBQUs7WUFBSSxLQUFLO1lBQUksS0FBSztZQUFJLEtBQUs7WUFBSSxLQUFLO1lBQUksS0FBSztZQUFJLEtBQUs7WUFBSSxLQUFLO1lBQUksS0FBSztnQkFDM0UsT0FBTyxJQUFJLENBQUNoQixVQUFVLENBQUM7WUFFekIsMEJBQTBCO1lBQzFCLEtBQUs7WUFBSSxLQUFLO2dCQUNaLE9BQU8sSUFBSSxDQUFDaUIsVUFBVSxDQUFDeDNCO1lBRXpCLGtFQUFrRTtZQUNsRSwyREFBMkQ7WUFDM0QsaUVBQWlFO1lBQ2pFLDJDQUEyQztZQUMzQyxLQUFLO2dCQUNILE9BQU8sSUFBSSxDQUFDeTJCLGVBQWU7WUFFN0IsS0FBSztZQUFJLEtBQUs7Z0JBQ1osT0FBTyxJQUFJLENBQUNFLHlCQUF5QixDQUFDMzJCO1lBRXhDLEtBQUs7WUFBSyxLQUFLO2dCQUNiLE9BQU8sSUFBSSxDQUFDODJCLGtCQUFrQixDQUFDOTJCO1lBRWpDLEtBQUs7Z0JBQ0gsT0FBTyxJQUFJLENBQUMrMkIsZUFBZTtZQUU3QixLQUFLO1lBQUksS0FBSztnQkFDWixPQUFPLElBQUksQ0FBQ0Msa0JBQWtCLENBQUNoM0I7WUFFakMsS0FBSztZQUFJLEtBQUs7Z0JBQ1osT0FBTyxJQUFJLENBQUNpM0IsZUFBZSxDQUFDajNCO1lBRTlCLEtBQUs7WUFBSSxLQUFLO2dCQUNaLE9BQU8sSUFBSSxDQUFDazNCLGlCQUFpQixDQUFDbDNCO1lBRWhDLEtBQUs7Z0JBQ0gsT0FBTyxJQUFJLENBQUNtM0Isa0JBQWtCO1lBRWhDLEtBQUs7Z0JBQ0gsT0FBTyxJQUFJLENBQUNULFFBQVEsQ0FBQzkwQixRQUFRVCxNQUFNLEVBQUU7WUFFdkMsS0FBSztnQkFDSCxPQUFPLElBQUksQ0FBQ2syQixvQkFBb0I7UUFDbEM7UUFFQSxJQUFJLENBQUNqbEIsS0FBSyxDQUFDLElBQUksQ0FBQ2xTLEdBQUcsRUFBRSwyQkFBMkJpSSxrQkFBa0JuSSxRQUFRO0lBQzVFO0lBRUFzMUIsR0FBR29CLFFBQVEsR0FBRyxTQUFTcHJCLElBQUksRUFBRXNyQixJQUFJO1FBQy9CLElBQUlhLE1BQU0sSUFBSSxDQUFDenVCLEtBQUssQ0FBQ3dFLEtBQUssQ0FBQyxJQUFJLENBQUN0TixHQUFHLEVBQUUsSUFBSSxDQUFDQSxHQUFHLEdBQUcwMkI7UUFDaEQsSUFBSSxDQUFDMTJCLEdBQUcsSUFBSTAyQjtRQUNaLE9BQU8sSUFBSSxDQUFDZCxXQUFXLENBQUN4cUIsTUFBTW1zQjtJQUNoQztJQUVBbkMsR0FBR3pQLFVBQVUsR0FBRztRQUNkLElBQUk2UixTQUFTQyxTQUFTOXVCLFFBQVEsSUFBSSxDQUFDM0ksR0FBRztRQUN0QyxPQUFTO1lBQ1AsSUFBSSxJQUFJLENBQUNBLEdBQUcsSUFBSSxJQUFJLENBQUM4SSxLQUFLLENBQUM1SSxNQUFNLEVBQUU7Z0JBQUUsSUFBSSxDQUFDZ1MsS0FBSyxDQUFDdkosT0FBTztZQUFvQztZQUMzRixJQUFJb2xCLEtBQUssSUFBSSxDQUFDamxCLEtBQUssQ0FBQ3VJLE1BQU0sQ0FBQyxJQUFJLENBQUNyUixHQUFHO1lBQ25DLElBQUlzRyxVQUFVakcsSUFBSSxDQUFDMHRCLEtBQUs7Z0JBQUUsSUFBSSxDQUFDN2IsS0FBSyxDQUFDdkosT0FBTztZQUFvQztZQUNoRixJQUFJLENBQUM2dUIsU0FBUztnQkFDWixJQUFJekosT0FBTyxLQUFLO29CQUFFMEosVUFBVTtnQkFBTSxPQUM3QixJQUFJMUosT0FBTyxPQUFPMEosU0FBUztvQkFBRUEsVUFBVTtnQkFBTyxPQUM5QyxJQUFJMUosT0FBTyxPQUFPLENBQUMwSixTQUFTO29CQUFFO2dCQUFNO2dCQUN6Q0QsVUFBVXpKLE9BQU87WUFDbkIsT0FBTztnQkFBRXlKLFVBQVU7WUFBTztZQUMxQixFQUFFLElBQUksQ0FBQ3gzQixHQUFHO1FBQ1o7UUFDQSxJQUFJOGxCLFVBQVUsSUFBSSxDQUFDaGQsS0FBSyxDQUFDd0UsS0FBSyxDQUFDM0UsT0FBTyxJQUFJLENBQUMzSSxHQUFHO1FBQzlDLEVBQUUsSUFBSSxDQUFDQSxHQUFHO1FBQ1YsSUFBSTAzQixhQUFhLElBQUksQ0FBQzEzQixHQUFHO1FBQ3pCLElBQUlnUSxRQUFRLElBQUksQ0FBQ29uQixTQUFTO1FBQzFCLElBQUksSUFBSSxDQUFDbHFCLFdBQVcsRUFBRTtZQUFFLElBQUksQ0FBQ3dFLFVBQVUsQ0FBQ2dtQjtRQUFhO1FBRXJELG1CQUFtQjtRQUNuQixJQUFJdkosUUFBUSxJQUFJLENBQUN2ZixXQUFXLElBQUssS0FBSSxDQUFDQSxXQUFXLEdBQUcsSUFBSXlkLHNCQUFzQixJQUFJO1FBQ2xGOEIsTUFBTWhCLEtBQUssQ0FBQ3hrQixPQUFPbWQsU0FBUzlWO1FBQzVCLElBQUksQ0FBQ2tlLG1CQUFtQixDQUFDQztRQUN6QixJQUFJLENBQUNNLHFCQUFxQixDQUFDTjtRQUUzQix1Q0FBdUM7UUFDdkMsSUFBSTlpQixRQUFRO1FBQ1osSUFBSTtZQUNGQSxRQUFRLElBQUkxTCxPQUFPbW1CLFNBQVM5VjtRQUM5QixFQUFFLE9BQU8ybkIsR0FBRztRQUNWLGtFQUFrRTtRQUNsRSxzR0FBc0c7UUFDeEc7UUFFQSxPQUFPLElBQUksQ0FBQy9CLFdBQVcsQ0FBQ2wwQixRQUFRRSxNQUFNLEVBQUU7WUFBQ2trQixTQUFTQTtZQUFTOVYsT0FBT0E7WUFBTzNFLE9BQU9BO1FBQUs7SUFDdkY7SUFFQSxpRUFBaUU7SUFDakUsb0VBQW9FO0lBQ3BFLGtFQUFrRTtJQUVsRStwQixHQUFHd0MsT0FBTyxHQUFHLFNBQVNDLEtBQUssRUFBRXZuQixHQUFHLEVBQUV3bkIsOEJBQThCO1FBQzlELG1GQUFtRjtRQUNuRixJQUFJQyxrQkFBa0IsSUFBSSxDQUFDdDJCLE9BQU8sQ0FBQ3lILFdBQVcsSUFBSSxNQUFNb0gsUUFBUW1ZO1FBRWhFLGdGQUFnRjtRQUNoRiw4RUFBOEU7UUFDOUUsb0NBQW9DO1FBQ3BDLElBQUl1UCw4QkFBOEJGLGtDQUFrQyxJQUFJLENBQUNodkIsS0FBSyxDQUFDaEMsVUFBVSxDQUFDLElBQUksQ0FBQzlHLEdBQUcsTUFBTTtRQUV4RyxJQUFJMkksUUFBUSxJQUFJLENBQUMzSSxHQUFHLEVBQUVpNEIsUUFBUSxHQUFHQyxXQUFXO1FBQzVDLElBQUssSUFBSWo0QixJQUFJLEdBQUcwM0IsSUFBSXJuQixPQUFPLE9BQU82bkIsV0FBVzduQixLQUFLclEsSUFBSTAzQixHQUFHLEVBQUUxM0IsR0FBRyxFQUFFLElBQUksQ0FBQ0QsR0FBRyxDQUFFO1lBQ3hFLElBQUlGLE9BQU8sSUFBSSxDQUFDZ0osS0FBSyxDQUFDaEMsVUFBVSxDQUFDLElBQUksQ0FBQzlHLEdBQUcsR0FBR3dtQixNQUFPLEtBQUs7WUFFeEQsSUFBSXVSLG1CQUFtQmo0QixTQUFTLElBQUk7Z0JBQ2xDLElBQUlrNEIsNkJBQTZCO29CQUFFLElBQUksQ0FBQ3JsQixnQkFBZ0IsQ0FBQyxJQUFJLENBQUMzUyxHQUFHLEVBQUU7Z0JBQXNFO2dCQUN6SSxJQUFJazRCLGFBQWEsSUFBSTtvQkFBRSxJQUFJLENBQUN2bEIsZ0JBQWdCLENBQUMsSUFBSSxDQUFDM1MsR0FBRyxFQUFFO2dCQUFxRDtnQkFDNUcsSUFBSUMsTUFBTSxHQUFHO29CQUFFLElBQUksQ0FBQzBTLGdCQUFnQixDQUFDLElBQUksQ0FBQzNTLEdBQUcsRUFBRTtnQkFBNEQ7Z0JBQzNHazRCLFdBQVdwNEI7Z0JBQ1g7WUFDRjtZQUVBLElBQUlBLFFBQVEsSUFBSTtnQkFBRTBtQixNQUFNMW1CLE9BQU8sS0FBSztZQUFJLE9BQ25DLElBQUlBLFFBQVEsSUFBSTtnQkFBRTBtQixNQUFNMW1CLE9BQU8sS0FBSztZQUFJLE9BQ3hDLElBQUlBLFFBQVEsTUFBTUEsUUFBUSxJQUFJO2dCQUFFMG1CLE1BQU0xbUIsT0FBTztZQUFJLE9BQ2pEO2dCQUFFMG1CLE1BQU0yUjtZQUFVO1lBQ3ZCLElBQUkzUixPQUFPcVIsT0FBTztnQkFBRTtZQUFNO1lBQzFCSyxXQUFXcDRCO1lBQ1htNEIsUUFBUUEsUUFBUUosUUFBUXJSO1FBQzFCO1FBRUEsSUFBSXVSLG1CQUFtQkcsYUFBYSxJQUFJO1lBQUUsSUFBSSxDQUFDdmxCLGdCQUFnQixDQUFDLElBQUksQ0FBQzNTLEdBQUcsR0FBRyxHQUFHO1FBQTJEO1FBQ3pJLElBQUksSUFBSSxDQUFDQSxHQUFHLEtBQUsySSxTQUFTMkgsT0FBTyxRQUFRLElBQUksQ0FBQ3RRLEdBQUcsR0FBRzJJLFVBQVUySCxLQUFLO1lBQUUsT0FBTztRQUFLO1FBRWpGLE9BQU8ybkI7SUFDVDtJQUVBLFNBQVNHLGVBQWViLEdBQUcsRUFBRVMsMkJBQTJCO1FBQ3RELElBQUlBLDZCQUE2QjtZQUMvQixPQUFPSyxTQUFTZCxLQUFLO1FBQ3ZCO1FBRUEsK0ZBQStGO1FBQy9GLE9BQU9lLFdBQVdmLElBQUl2dkIsT0FBTyxDQUFDLE1BQU07SUFDdEM7SUFFQSxTQUFTdXdCLGVBQWVoQixHQUFHO1FBQ3pCLElBQUksT0FBT2lCLFdBQVcsWUFBWTtZQUNoQyxPQUFPO1FBQ1Q7UUFFQSxpRkFBaUY7UUFDakYsT0FBT0EsT0FBT2pCLElBQUl2dkIsT0FBTyxDQUFDLE1BQU07SUFDbEM7SUFFQW90QixHQUFHaUMsZUFBZSxHQUFHLFNBQVNRLEtBQUs7UUFDakMsSUFBSWx2QixRQUFRLElBQUksQ0FBQzNJLEdBQUc7UUFDcEIsSUFBSSxDQUFDQSxHQUFHLElBQUksR0FBRyxLQUFLO1FBQ3BCLElBQUl3bUIsTUFBTSxJQUFJLENBQUNvUixPQUFPLENBQUNDO1FBQ3ZCLElBQUlyUixPQUFPLE1BQU07WUFBRSxJQUFJLENBQUN0VSxLQUFLLENBQUMsSUFBSSxDQUFDdkosS0FBSyxHQUFHLEdBQUcsOEJBQThCa3ZCO1FBQVE7UUFDcEYsSUFBSSxJQUFJLENBQUNwMkIsT0FBTyxDQUFDeUgsV0FBVyxJQUFJLE1BQU0sSUFBSSxDQUFDSixLQUFLLENBQUNoQyxVQUFVLENBQUMsSUFBSSxDQUFDOUcsR0FBRyxNQUFNLEtBQUs7WUFDN0V3bUIsTUFBTStSLGVBQWUsSUFBSSxDQUFDenZCLEtBQUssQ0FBQ3dFLEtBQUssQ0FBQzNFLE9BQU8sSUFBSSxDQUFDM0ksR0FBRztZQUNyRCxFQUFFLElBQUksQ0FBQ0EsR0FBRztRQUNaLE9BQU8sSUFBSUcsa0JBQWtCLElBQUksQ0FBQzIxQixpQkFBaUIsS0FBSztZQUFFLElBQUksQ0FBQzVqQixLQUFLLENBQUMsSUFBSSxDQUFDbFMsR0FBRyxFQUFFO1FBQXFDO1FBQ3BILE9BQU8sSUFBSSxDQUFDNDFCLFdBQVcsQ0FBQ2wwQixRQUFRQyxHQUFHLEVBQUU2a0I7SUFDdkM7SUFFQSw0REFBNEQ7SUFFNUQ0TyxHQUFHaUIsVUFBVSxHQUFHLFNBQVNvQyxhQUFhO1FBQ3BDLElBQUk5dkIsUUFBUSxJQUFJLENBQUMzSSxHQUFHO1FBQ3BCLElBQUksQ0FBQ3k0QixpQkFBaUIsSUFBSSxDQUFDYixPQUFPLENBQUMsSUFBSW5QLFdBQVcsVUFBVSxNQUFNO1lBQUUsSUFBSSxDQUFDdlcsS0FBSyxDQUFDdkosT0FBTztRQUFtQjtRQUN6RyxJQUFJK3ZCLFFBQVEsSUFBSSxDQUFDMTRCLEdBQUcsR0FBRzJJLFNBQVMsS0FBSyxJQUFJLENBQUNHLEtBQUssQ0FBQ2hDLFVBQVUsQ0FBQzZCLFdBQVc7UUFDdEUsSUFBSSt2QixTQUFTLElBQUksQ0FBQ3I1QixNQUFNLEVBQUU7WUFBRSxJQUFJLENBQUM2UyxLQUFLLENBQUN2SixPQUFPO1FBQW1CO1FBQ2pFLElBQUk5QixPQUFPLElBQUksQ0FBQ2lDLEtBQUssQ0FBQ2hDLFVBQVUsQ0FBQyxJQUFJLENBQUM5RyxHQUFHO1FBQ3pDLElBQUksQ0FBQzA0QixTQUFTLENBQUNELGlCQUFpQixJQUFJLENBQUNoM0IsT0FBTyxDQUFDeUgsV0FBVyxJQUFJLE1BQU1yQyxTQUFTLEtBQUs7WUFDOUUsSUFBSTh4QixRQUFRSixlQUFlLElBQUksQ0FBQ3p2QixLQUFLLENBQUN3RSxLQUFLLENBQUMzRSxPQUFPLElBQUksQ0FBQzNJLEdBQUc7WUFDM0QsRUFBRSxJQUFJLENBQUNBLEdBQUc7WUFDVixJQUFJRyxrQkFBa0IsSUFBSSxDQUFDMjFCLGlCQUFpQixLQUFLO2dCQUFFLElBQUksQ0FBQzVqQixLQUFLLENBQUMsSUFBSSxDQUFDbFMsR0FBRyxFQUFFO1lBQXFDO1lBQzdHLE9BQU8sSUFBSSxDQUFDNDFCLFdBQVcsQ0FBQ2wwQixRQUFRQyxHQUFHLEVBQUVnM0I7UUFDdkM7UUFDQSxJQUFJRCxTQUFTLE9BQU9yNEIsSUFBSSxDQUFDLElBQUksQ0FBQ3lJLEtBQUssQ0FBQ3dFLEtBQUssQ0FBQzNFLE9BQU8sSUFBSSxDQUFDM0ksR0FBRyxJQUFJO1lBQUUwNEIsUUFBUTtRQUFPO1FBQzlFLElBQUk3eEIsU0FBUyxNQUFNLENBQUM2eEIsT0FBTztZQUN6QixFQUFFLElBQUksQ0FBQzE0QixHQUFHO1lBQ1YsSUFBSSxDQUFDNDNCLE9BQU8sQ0FBQztZQUNiL3dCLE9BQU8sSUFBSSxDQUFDaUMsS0FBSyxDQUFDaEMsVUFBVSxDQUFDLElBQUksQ0FBQzlHLEdBQUc7UUFDdkM7UUFDQSxJQUFJLENBQUM2RyxTQUFTLE1BQU1BLFNBQVMsR0FBRSxLQUFNLENBQUM2eEIsT0FBTztZQUMzQzd4QixPQUFPLElBQUksQ0FBQ2lDLEtBQUssQ0FBQ2hDLFVBQVUsQ0FBQyxFQUFFLElBQUksQ0FBQzlHLEdBQUc7WUFDdkMsSUFBSTZHLFNBQVMsTUFBTUEsU0FBUyxJQUFJO2dCQUFFLEVBQUUsSUFBSSxDQUFDN0csR0FBRztZQUFFLEVBQUUsT0FBTztZQUN2RCxJQUFJLElBQUksQ0FBQzQzQixPQUFPLENBQUMsUUFBUSxNQUFNO2dCQUFFLElBQUksQ0FBQzFsQixLQUFLLENBQUN2SixPQUFPO1lBQW1CO1FBQ3hFO1FBQ0EsSUFBSXhJLGtCQUFrQixJQUFJLENBQUMyMUIsaUJBQWlCLEtBQUs7WUFBRSxJQUFJLENBQUM1akIsS0FBSyxDQUFDLElBQUksQ0FBQ2xTLEdBQUcsRUFBRTtRQUFxQztRQUU3RyxJQUFJd21CLE1BQU00UixlQUFlLElBQUksQ0FBQ3R2QixLQUFLLENBQUN3RSxLQUFLLENBQUMzRSxPQUFPLElBQUksQ0FBQzNJLEdBQUcsR0FBRzA0QjtRQUM1RCxPQUFPLElBQUksQ0FBQzlDLFdBQVcsQ0FBQ2wwQixRQUFRQyxHQUFHLEVBQUU2a0I7SUFDdkM7SUFFQSx1REFBdUQ7SUFFdkQ0TyxHQUFHd0QsYUFBYSxHQUFHO1FBQ2pCLElBQUk3SyxLQUFLLElBQUksQ0FBQ2psQixLQUFLLENBQUNoQyxVQUFVLENBQUMsSUFBSSxDQUFDOUcsR0FBRyxHQUFHRjtRQUUxQyxJQUFJaXVCLE9BQU8sS0FBSztZQUNkLElBQUksSUFBSSxDQUFDdHNCLE9BQU8sQ0FBQ3lILFdBQVcsR0FBRyxHQUFHO2dCQUFFLElBQUksQ0FBQ3dJLFVBQVU7WUFBSTtZQUN2RCxJQUFJbW5CLFVBQVUsRUFBRSxJQUFJLENBQUM3NEIsR0FBRztZQUN4QkYsT0FBTyxJQUFJLENBQUNnNUIsV0FBVyxDQUFDLElBQUksQ0FBQ2h3QixLQUFLLENBQUMwUCxPQUFPLENBQUMsS0FBSyxJQUFJLENBQUN4WSxHQUFHLElBQUksSUFBSSxDQUFDQSxHQUFHO1lBQ3BFLEVBQUUsSUFBSSxDQUFDQSxHQUFHO1lBQ1YsSUFBSUYsT0FBTyxVQUFVO2dCQUFFLElBQUksQ0FBQ2k1QixrQkFBa0IsQ0FBQ0YsU0FBUztZQUE2QjtRQUN2RixPQUFPO1lBQ0wvNEIsT0FBTyxJQUFJLENBQUNnNUIsV0FBVyxDQUFDO1FBQzFCO1FBQ0EsT0FBT2g1QjtJQUNUO0lBRUFzMUIsR0FBR2tDLFVBQVUsR0FBRyxTQUFTMEIsS0FBSztRQUM1QixJQUFJM1csTUFBTSxJQUFJNFcsYUFBYSxFQUFFLElBQUksQ0FBQ2o1QixHQUFHO1FBQ3JDLE9BQVM7WUFDUCxJQUFJLElBQUksQ0FBQ0EsR0FBRyxJQUFJLElBQUksQ0FBQzhJLEtBQUssQ0FBQzVJLE1BQU0sRUFBRTtnQkFBRSxJQUFJLENBQUNnUyxLQUFLLENBQUMsSUFBSSxDQUFDdkosS0FBSyxFQUFFO1lBQWlDO1lBQzdGLElBQUlvbEIsS0FBSyxJQUFJLENBQUNqbEIsS0FBSyxDQUFDaEMsVUFBVSxDQUFDLElBQUksQ0FBQzlHLEdBQUc7WUFDdkMsSUFBSSt0QixPQUFPaUwsT0FBTztnQkFBRTtZQUFNO1lBQzFCLElBQUlqTCxPQUFPLElBQUk7Z0JBQ2IxTCxPQUFPLElBQUksQ0FBQ3ZaLEtBQUssQ0FBQ3dFLEtBQUssQ0FBQzJyQixZQUFZLElBQUksQ0FBQ2o1QixHQUFHO2dCQUM1Q3FpQixPQUFPLElBQUksQ0FBQzZXLGVBQWUsQ0FBQztnQkFDNUJELGFBQWEsSUFBSSxDQUFDajVCLEdBQUc7WUFDdkIsT0FBTyxJQUFJK3RCLE9BQU8sVUFBVUEsT0FBTyxRQUFRO2dCQUN6QyxJQUFJLElBQUksQ0FBQ3RzQixPQUFPLENBQUN5SCxXQUFXLEdBQUcsSUFBSTtvQkFBRSxJQUFJLENBQUNnSixLQUFLLENBQUMsSUFBSSxDQUFDdkosS0FBSyxFQUFFO2dCQUFpQztnQkFDN0YsRUFBRSxJQUFJLENBQUMzSSxHQUFHO2dCQUNWLElBQUksSUFBSSxDQUFDeUIsT0FBTyxDQUFDb0ksU0FBUyxFQUFFO29CQUMxQixJQUFJLENBQUN3RCxPQUFPO29CQUNaLElBQUksQ0FBQ0YsU0FBUyxHQUFHLElBQUksQ0FBQ25OLEdBQUc7Z0JBQzNCO1lBQ0YsT0FBTztnQkFDTCxJQUFJeUcsVUFBVXNuQixLQUFLO29CQUFFLElBQUksQ0FBQzdiLEtBQUssQ0FBQyxJQUFJLENBQUN2SixLQUFLLEVBQUU7Z0JBQWlDO2dCQUM3RSxFQUFFLElBQUksQ0FBQzNJLEdBQUc7WUFDWjtRQUNGO1FBQ0FxaUIsT0FBTyxJQUFJLENBQUN2WixLQUFLLENBQUN3RSxLQUFLLENBQUMyckIsWUFBWSxJQUFJLENBQUNqNUIsR0FBRztRQUM1QyxPQUFPLElBQUksQ0FBQzQxQixXQUFXLENBQUNsMEIsUUFBUUcsTUFBTSxFQUFFd2dCO0lBQzFDO0lBRUEsZ0NBQWdDO0lBRWhDLElBQUk4VyxnQ0FBZ0MsQ0FBQztJQUVyQy9ELEdBQUczVCxvQkFBb0IsR0FBRztRQUN4QixJQUFJLENBQUMyWCxpQkFBaUIsR0FBRztRQUN6QixJQUFJO1lBQ0YsSUFBSSxDQUFDQyxhQUFhO1FBQ3BCLEVBQUUsT0FBT25RLEtBQUs7WUFDWixJQUFJQSxRQUFRaVEsK0JBQStCO2dCQUN6QyxJQUFJLENBQUNHLHdCQUF3QjtZQUMvQixPQUFPO2dCQUNMLE1BQU1wUTtZQUNSO1FBQ0Y7UUFFQSxJQUFJLENBQUNrUSxpQkFBaUIsR0FBRztJQUMzQjtJQUVBaEUsR0FBRzJELGtCQUFrQixHQUFHLFNBQVNRLFFBQVEsRUFBRXRRLE9BQU87UUFDaEQsSUFBSSxJQUFJLENBQUNtUSxpQkFBaUIsSUFBSSxJQUFJLENBQUMzM0IsT0FBTyxDQUFDeUgsV0FBVyxJQUFJLEdBQUc7WUFDM0QsTUFBTWl3QjtRQUNSLE9BQU87WUFDTCxJQUFJLENBQUNqbkIsS0FBSyxDQUFDcW5CLFVBQVV0UTtRQUN2QjtJQUNGO0lBRUFtTSxHQUFHaUUsYUFBYSxHQUFHO1FBQ2pCLElBQUloWCxNQUFNLElBQUk0VyxhQUFhLElBQUksQ0FBQ2o1QixHQUFHO1FBQ25DLE9BQVM7WUFDUCxJQUFJLElBQUksQ0FBQ0EsR0FBRyxJQUFJLElBQUksQ0FBQzhJLEtBQUssQ0FBQzVJLE1BQU0sRUFBRTtnQkFBRSxJQUFJLENBQUNnUyxLQUFLLENBQUMsSUFBSSxDQUFDdkosS0FBSyxFQUFFO1lBQTBCO1lBQ3RGLElBQUlvbEIsS0FBSyxJQUFJLENBQUNqbEIsS0FBSyxDQUFDaEMsVUFBVSxDQUFDLElBQUksQ0FBQzlHLEdBQUc7WUFDdkMsSUFBSSt0QixPQUFPLE1BQU1BLE9BQU8sTUFBTSxJQUFJLENBQUNqbEIsS0FBSyxDQUFDaEMsVUFBVSxDQUFDLElBQUksQ0FBQzlHLEdBQUcsR0FBRyxPQUFPLEtBQUs7Z0JBQ3pFLElBQUksSUFBSSxDQUFDQSxHQUFHLEtBQUssSUFBSSxDQUFDMkksS0FBSyxJQUFLLEtBQUksQ0FBQ3lDLElBQUksS0FBSzFKLFFBQVFtQixRQUFRLElBQUksSUFBSSxDQUFDdUksSUFBSSxLQUFLMUosUUFBUW9CLGVBQWUsR0FBRztvQkFDeEcsSUFBSWlyQixPQUFPLElBQUk7d0JBQ2IsSUFBSSxDQUFDL3RCLEdBQUcsSUFBSTt3QkFDWixPQUFPLElBQUksQ0FBQzQxQixXQUFXLENBQUNsMEIsUUFBUXVCLFlBQVk7b0JBQzlDLE9BQU87d0JBQ0wsRUFBRSxJQUFJLENBQUNqRCxHQUFHO3dCQUNWLE9BQU8sSUFBSSxDQUFDNDFCLFdBQVcsQ0FBQ2wwQixRQUFRc0IsU0FBUztvQkFDM0M7Z0JBQ0Y7Z0JBQ0FxZixPQUFPLElBQUksQ0FBQ3ZaLEtBQUssQ0FBQ3dFLEtBQUssQ0FBQzJyQixZQUFZLElBQUksQ0FBQ2o1QixHQUFHO2dCQUM1QyxPQUFPLElBQUksQ0FBQzQxQixXQUFXLENBQUNsMEIsUUFBUW1CLFFBQVEsRUFBRXdmO1lBQzVDO1lBQ0EsSUFBSTBMLE9BQU8sSUFBSTtnQkFDYjFMLE9BQU8sSUFBSSxDQUFDdlosS0FBSyxDQUFDd0UsS0FBSyxDQUFDMnJCLFlBQVksSUFBSSxDQUFDajVCLEdBQUc7Z0JBQzVDcWlCLE9BQU8sSUFBSSxDQUFDNlcsZUFBZSxDQUFDO2dCQUM1QkQsYUFBYSxJQUFJLENBQUNqNUIsR0FBRztZQUN2QixPQUFPLElBQUl5RyxVQUFVc25CLEtBQUs7Z0JBQ3hCMUwsT0FBTyxJQUFJLENBQUN2WixLQUFLLENBQUN3RSxLQUFLLENBQUMyckIsWUFBWSxJQUFJLENBQUNqNUIsR0FBRztnQkFDNUMsRUFBRSxJQUFJLENBQUNBLEdBQUc7Z0JBQ1YsT0FBUSt0QjtvQkFDUixLQUFLO3dCQUNILElBQUksSUFBSSxDQUFDamxCLEtBQUssQ0FBQ2hDLFVBQVUsQ0FBQyxJQUFJLENBQUM5RyxHQUFHLE1BQU0sSUFBSTs0QkFBRSxFQUFFLElBQUksQ0FBQ0EsR0FBRzt3QkFBRTtvQkFDNUQsS0FBSzt3QkFDSHFpQixPQUFPO3dCQUNQO29CQUNGO3dCQUNFQSxPQUFPL2hCLE9BQU9DLFlBQVksQ0FBQ3d0Qjt3QkFDM0I7Z0JBQ0Y7Z0JBQ0EsSUFBSSxJQUFJLENBQUN0c0IsT0FBTyxDQUFDb0ksU0FBUyxFQUFFO29CQUMxQixFQUFFLElBQUksQ0FBQ3dELE9BQU87b0JBQ2QsSUFBSSxDQUFDRixTQUFTLEdBQUcsSUFBSSxDQUFDbk4sR0FBRztnQkFDM0I7Z0JBQ0FpNUIsYUFBYSxJQUFJLENBQUNqNUIsR0FBRztZQUN2QixPQUFPO2dCQUNMLEVBQUUsSUFBSSxDQUFDQSxHQUFHO1lBQ1o7UUFDRjtJQUNGO0lBRUEsd0ZBQXdGO0lBQ3hGbzFCLEdBQUdrRSx3QkFBd0IsR0FBRztRQUM1QixNQUFPLElBQUksQ0FBQ3Q1QixHQUFHLEdBQUcsSUFBSSxDQUFDOEksS0FBSyxDQUFDNUksTUFBTSxFQUFFLElBQUksQ0FBQ0YsR0FBRyxHQUFJO1lBQy9DLE9BQVEsSUFBSSxDQUFDOEksS0FBSyxDQUFDLElBQUksQ0FBQzlJLEdBQUcsQ0FBQztnQkFDNUIsS0FBSztvQkFDSCxFQUFFLElBQUksQ0FBQ0EsR0FBRztvQkFDVjtnQkFFRixLQUFLO29CQUNILElBQUksSUFBSSxDQUFDOEksS0FBSyxDQUFDLElBQUksQ0FBQzlJLEdBQUcsR0FBRyxFQUFFLEtBQUssS0FBSzt3QkFBRTtvQkFBTTtnQkFDOUMsZUFBZTtnQkFDakIsS0FBSztvQkFDSCxPQUFPLElBQUksQ0FBQzQxQixXQUFXLENBQUNsMEIsUUFBUW9CLGVBQWUsRUFBRSxJQUFJLENBQUNnRyxLQUFLLENBQUN3RSxLQUFLLENBQUMsSUFBSSxDQUFDM0UsS0FBSyxFQUFFLElBQUksQ0FBQzNJLEdBQUc7Z0JBRXhGLEtBQUs7b0JBQ0gsSUFBSSxJQUFJLENBQUM4SSxLQUFLLENBQUMsSUFBSSxDQUFDOUksR0FBRyxHQUFHLEVBQUUsS0FBSyxNQUFNO3dCQUFFLEVBQUUsSUFBSSxDQUFDQSxHQUFHO29CQUFFO2dCQUNyRCxlQUFlO2dCQUNqQixLQUFLO2dCQUFNLEtBQUs7Z0JBQVUsS0FBSztvQkFDN0IsRUFBRSxJQUFJLENBQUNxTixPQUFPO29CQUNkLElBQUksQ0FBQ0YsU0FBUyxHQUFHLElBQUksQ0FBQ25OLEdBQUcsR0FBRztvQkFDNUI7WUFDRjtRQUNGO1FBQ0EsSUFBSSxDQUFDa1MsS0FBSyxDQUFDLElBQUksQ0FBQ3ZKLEtBQUssRUFBRTtJQUN6QjtJQUVBLGtDQUFrQztJQUVsQ3lzQixHQUFHOEQsZUFBZSxHQUFHLFNBQVNNLFVBQVU7UUFDdEMsSUFBSXpMLEtBQUssSUFBSSxDQUFDamxCLEtBQUssQ0FBQ2hDLFVBQVUsQ0FBQyxFQUFFLElBQUksQ0FBQzlHLEdBQUc7UUFDekMsRUFBRSxJQUFJLENBQUNBLEdBQUc7UUFDVixPQUFRK3RCO1lBQ1IsS0FBSztnQkFBSyxPQUFPLEtBQUssY0FBYzs7WUFDcEMsS0FBSztnQkFBSyxPQUFPLEtBQUssY0FBYzs7WUFDcEMsS0FBSztnQkFBSyxPQUFPenRCLE9BQU9DLFlBQVksQ0FBQyxJQUFJLENBQUN1NEIsV0FBVyxDQUFDLElBQUksTUFBTTs7WUFDaEUsS0FBSztnQkFBSyxPQUFPN3dCLGtCQUFrQixJQUFJLENBQUMyd0IsYUFBYSxJQUFJLE1BQU07O1lBQy9ELEtBQUs7Z0JBQUssT0FBTyxJQUFLLGNBQWM7O1lBQ3BDLEtBQUs7Z0JBQUksT0FBTyxLQUFLLGNBQWM7O1lBQ25DLEtBQUs7Z0JBQUssT0FBTyxLQUFTLGtCQUFrQjs7WUFDNUMsS0FBSztnQkFBSyxPQUFPLEtBQUssY0FBYzs7WUFDcEMsS0FBSztnQkFBSSxJQUFJLElBQUksQ0FBQzl2QixLQUFLLENBQUNoQyxVQUFVLENBQUMsSUFBSSxDQUFDOUcsR0FBRyxNQUFNLElBQUk7b0JBQUUsRUFBRSxJQUFJLENBQUNBLEdBQUc7Z0JBQUUsRUFBRSxTQUFTO1lBQzlFLEtBQUs7Z0JBQ0gsSUFBSSxJQUFJLENBQUN5QixPQUFPLENBQUNvSSxTQUFTLEVBQUU7b0JBQUUsSUFBSSxDQUFDc0QsU0FBUyxHQUFHLElBQUksQ0FBQ25OLEdBQUc7b0JBQUUsRUFBRSxJQUFJLENBQUNxTixPQUFPO2dCQUFFO2dCQUN6RSxPQUFPO1lBQ1QsS0FBSztZQUNMLEtBQUs7Z0JBQ0gsSUFBSSxJQUFJLENBQUNoTyxNQUFNLEVBQUU7b0JBQ2YsSUFBSSxDQUFDMDVCLGtCQUFrQixDQUNyQixJQUFJLENBQUMvNEIsR0FBRyxHQUFHLEdBQ1g7Z0JBRUo7Z0JBQ0EsSUFBSXc1QixZQUFZO29CQUNkLElBQUlYLFVBQVUsSUFBSSxDQUFDNzRCLEdBQUcsR0FBRztvQkFFekIsSUFBSSxDQUFDKzRCLGtCQUFrQixDQUNyQkYsU0FDQTtnQkFFSjtZQUNGO2dCQUNFLElBQUk5SyxNQUFNLE1BQU1BLE1BQU0sSUFBSTtvQkFDeEIsSUFBSTBMLFdBQVcsSUFBSSxDQUFDM3dCLEtBQUssQ0FBQzR3QixNQUFNLENBQUMsSUFBSSxDQUFDMTVCLEdBQUcsR0FBRyxHQUFHLEdBQUdrUixLQUFLLENBQUMsVUFBVSxDQUFDLEVBQUU7b0JBQ3JFLElBQUl3bkIsUUFBUUwsU0FBU29CLFVBQVU7b0JBQy9CLElBQUlmLFFBQVEsS0FBSzt3QkFDZmUsV0FBV0EsU0FBU25zQixLQUFLLENBQUMsR0FBRyxDQUFDO3dCQUM5Qm9yQixRQUFRTCxTQUFTb0IsVUFBVTtvQkFDN0I7b0JBQ0EsSUFBSSxDQUFDejVCLEdBQUcsSUFBSXk1QixTQUFTdjVCLE1BQU0sR0FBRztvQkFDOUI2dEIsS0FBSyxJQUFJLENBQUNqbEIsS0FBSyxDQUFDaEMsVUFBVSxDQUFDLElBQUksQ0FBQzlHLEdBQUc7b0JBQ25DLElBQUksQ0FBQ3k1QixhQUFhLE9BQU8xTCxPQUFPLE1BQU1BLE9BQU8sRUFBQyxLQUFPLEtBQUksQ0FBQzF1QixNQUFNLElBQUltNkIsVUFBUyxHQUFJO3dCQUMvRSxJQUFJLENBQUNULGtCQUFrQixDQUNyQixJQUFJLENBQUMvNEIsR0FBRyxHQUFHLElBQUl5NUIsU0FBU3Y1QixNQUFNLEVBQzlCczVCLGFBQ0kscUNBQ0E7b0JBRVI7b0JBQ0EsT0FBT2w1QixPQUFPQyxZQUFZLENBQUNtNEI7Z0JBQzdCO2dCQUNBLElBQUlqeUIsVUFBVXNuQixLQUFLO29CQUNqQixzRUFBc0U7b0JBQ3RFLGdDQUFnQztvQkFDaEMsSUFBSSxJQUFJLENBQUN0c0IsT0FBTyxDQUFDb0ksU0FBUyxFQUFFO3dCQUFFLElBQUksQ0FBQ3NELFNBQVMsR0FBRyxJQUFJLENBQUNuTixHQUFHO3dCQUFFLEVBQUUsSUFBSSxDQUFDcU4sT0FBTztvQkFBRTtvQkFDekUsT0FBTztnQkFDVDtnQkFDQSxPQUFPL00sT0FBT0MsWUFBWSxDQUFDd3RCO1FBQzdCO0lBQ0Y7SUFFQSw4REFBOEQ7SUFFOURxSCxHQUFHMEQsV0FBVyxHQUFHLFNBQVN4b0IsR0FBRztRQUMzQixJQUFJdW9CLFVBQVUsSUFBSSxDQUFDNzRCLEdBQUc7UUFDdEIsSUFBSXdJLElBQUksSUFBSSxDQUFDb3ZCLE9BQU8sQ0FBQyxJQUFJdG5CO1FBQ3pCLElBQUk5SCxNQUFNLE1BQU07WUFBRSxJQUFJLENBQUN1d0Isa0JBQWtCLENBQUNGLFNBQVM7UUFBa0M7UUFDckYsT0FBT3J3QjtJQUNUO0lBRUEseUVBQXlFO0lBQ3pFLCtDQUErQztJQUMvQyxFQUFFO0lBQ0YsbUVBQW1FO0lBQ25FLDJCQUEyQjtJQUUzQjRzQixHQUFHZ0MsU0FBUyxHQUFHO1FBQ2IsSUFBSSxDQUFDbHFCLFdBQVcsR0FBRztRQUNuQixJQUFJeXNCLE9BQU8sSUFBSXBiLFFBQVEsTUFBTTBhLGFBQWEsSUFBSSxDQUFDajVCLEdBQUc7UUFDbEQsSUFBSUksU0FBUyxJQUFJLENBQUNxQixPQUFPLENBQUN5SCxXQUFXLElBQUk7UUFDekMsTUFBTyxJQUFJLENBQUNsSixHQUFHLEdBQUcsSUFBSSxDQUFDOEksS0FBSyxDQUFDNUksTUFBTSxDQUFFO1lBQ25DLElBQUk2dEIsS0FBSyxJQUFJLENBQUMrSCxpQkFBaUI7WUFDL0IsSUFBSXQxQixpQkFBaUJ1dEIsSUFBSTN0QixTQUFTO2dCQUNoQyxJQUFJLENBQUNKLEdBQUcsSUFBSSt0QixNQUFNLFNBQVMsSUFBSTtZQUNqQyxPQUFPLElBQUlBLE9BQU8sSUFBSTtnQkFDcEIsSUFBSSxDQUFDN2dCLFdBQVcsR0FBRztnQkFDbkJ5c0IsUUFBUSxJQUFJLENBQUM3d0IsS0FBSyxDQUFDd0UsS0FBSyxDQUFDMnJCLFlBQVksSUFBSSxDQUFDajVCLEdBQUc7Z0JBQzdDLElBQUk0NUIsV0FBVyxJQUFJLENBQUM1NUIsR0FBRztnQkFDdkIsSUFBSSxJQUFJLENBQUM4SSxLQUFLLENBQUNoQyxVQUFVLENBQUMsRUFBRSxJQUFJLENBQUM5RyxHQUFHLE1BQU0sS0FDeEM7b0JBQUUsSUFBSSxDQUFDKzRCLGtCQUFrQixDQUFDLElBQUksQ0FBQy80QixHQUFHLEVBQUU7Z0JBQThDO2dCQUNwRixFQUFFLElBQUksQ0FBQ0EsR0FBRztnQkFDVixJQUFJNjVCLE1BQU0sSUFBSSxDQUFDakIsYUFBYTtnQkFDNUIsSUFBSSxDQUFDLENBQUNyYSxRQUFRcGUsb0JBQW9CSyxnQkFBZSxFQUFHcTVCLEtBQUt6NUIsU0FDdkQ7b0JBQUUsSUFBSSxDQUFDMjRCLGtCQUFrQixDQUFDYSxVQUFVO2dCQUEyQjtnQkFDakVELFFBQVExeEIsa0JBQWtCNHhCO2dCQUMxQlosYUFBYSxJQUFJLENBQUNqNUIsR0FBRztZQUN2QixPQUFPO2dCQUNMO1lBQ0Y7WUFDQXVlLFFBQVE7UUFDVjtRQUNBLE9BQU9vYixPQUFPLElBQUksQ0FBQzd3QixLQUFLLENBQUN3RSxLQUFLLENBQUMyckIsWUFBWSxJQUFJLENBQUNqNUIsR0FBRztJQUNyRDtJQUVBLCtEQUErRDtJQUMvRCx3QkFBd0I7SUFFeEJvMUIsR0FBR1csUUFBUSxHQUFHO1FBQ1osSUFBSTRELE9BQU8sSUFBSSxDQUFDdkMsU0FBUztRQUN6QixJQUFJaHNCLE9BQU8xSixRQUFRTCxJQUFJO1FBQ3ZCLElBQUksSUFBSSxDQUFDRSxRQUFRLENBQUNsQixJQUFJLENBQUNzNUIsT0FBTztZQUM1QnZ1QixPQUFPN0osUUFBUSxDQUFDbzRCLEtBQUs7UUFDdkI7UUFDQSxPQUFPLElBQUksQ0FBQy9ELFdBQVcsQ0FBQ3hxQixNQUFNdXVCO0lBQ2hDO0lBRUEsaUVBQWlFO0lBQ2pFLEVBQUU7SUFDRiwrREFBK0Q7SUFDL0QsMERBQTBEO0lBQzFELEVBQUU7SUFDRiw4Q0FBOEM7SUFDOUMsRUFBRTtJQUNGLDBDQUEwQztJQUMxQywyQ0FBMkM7SUFDM0MsRUFBRTtJQUNGLDhEQUE4RDtJQUM5RCxFQUFFO0lBQ0Ysa0RBQWtEO0lBQ2xELEVBQUU7SUFDRix1QkFBdUI7SUFHdkIsSUFBSUcsVUFBVTtJQUVkbHRCLE9BQU83TixLQUFLLEdBQUc7UUFDYjZOLFFBQVFBO1FBQ1JrdEIsU0FBU0E7UUFDVDd3QixnQkFBZ0JBO1FBQ2hCZCxVQUFVQTtRQUNWTSxnQkFBZ0JBO1FBQ2hCSSxhQUFhQTtRQUNia2hCLE1BQU1BO1FBQ050cEIsV0FBV0E7UUFDWHM1QixVQUFVcjRCO1FBQ1ZzNEIsY0FBY3o0QjtRQUNkdWYsWUFBWUE7UUFDWm1aLGFBQWEvWTtRQUNiMWdCLGtCQUFrQkE7UUFDbEJMLG1CQUFtQkE7UUFDbkJnMUIsT0FBT0E7UUFDUDF1QixXQUFXQTtRQUNYSCxXQUFXQTtRQUNYQyxZQUFZQTtRQUNaUSxvQkFBb0JBO0lBQ3RCO0lBRUEsOERBQThEO0lBQzlELHNFQUFzRTtJQUN0RSxxRUFBcUU7SUFDckUsRUFBRTtJQUNGLDZDQUE2QztJQUU3QyxTQUFTMEksTUFBTTNHLEtBQUssRUFBRXJILE9BQU87UUFDM0IsT0FBT21MLE9BQU82QyxLQUFLLENBQUMzRyxPQUFPckg7SUFDN0I7SUFFQSw4REFBOEQ7SUFDOUQsZ0VBQWdFO0lBQ2hFLHFDQUFxQztJQUVyQyxTQUFTZ1Asa0JBQWtCM0gsS0FBSyxFQUFFOUksR0FBRyxFQUFFeUIsT0FBTztRQUM1QyxPQUFPbUwsT0FBTzZELGlCQUFpQixDQUFDM0gsT0FBTzlJLEtBQUt5QjtJQUM5QztJQUVBLG9FQUFvRTtJQUNwRSxpRUFBaUU7SUFFakUsU0FBU21QLFVBQVU5SCxLQUFLLEVBQUVySCxPQUFPO1FBQy9CLE9BQU9tTCxPQUFPZ0UsU0FBUyxDQUFDOUgsT0FBT3JIO0lBQ2pDO0lBRUFoRCxTQUFRc3JCLElBQUksR0FBR0E7SUFDZnRyQixTQUFRbU8sTUFBTSxHQUFHQTtJQUNqQm5PLFNBQVEwSixRQUFRLEdBQUdBO0lBQ25CMUosU0FBUWdLLGNBQWMsR0FBR0E7SUFDekJoSyxTQUFRcWlCLFVBQVUsR0FBR0E7SUFDckJyaUIsU0FBUTAyQixLQUFLLEdBQUdBO0lBQ2hCMTJCLFNBQVFnQyxTQUFTLEdBQUdBO0lBQ3BCaEMsU0FBUXdLLGNBQWMsR0FBR0E7SUFDekJ4SyxTQUFRb0ssV0FBVyxHQUFHQTtJQUN0QnBLLFNBQVErQixnQkFBZ0IsR0FBR0E7SUFDM0IvQixTQUFRMEIsaUJBQWlCLEdBQUdBO0lBQzVCMUIsU0FBUWdJLFNBQVMsR0FBR0E7SUFDcEJoSSxTQUFRdTdCLFlBQVksR0FBR3o0QjtJQUN2QjlDLFNBQVE2SCxTQUFTLEdBQUdBO0lBQ3BCN0gsU0FBUThILFVBQVUsR0FBR0E7SUFDckI5SCxTQUFRc0ksa0JBQWtCLEdBQUdBO0lBQzdCdEksU0FBUWdSLEtBQUssR0FBR0E7SUFDaEJoUixTQUFRZ1MsaUJBQWlCLEdBQUdBO0lBQzVCaFMsU0FBUXc3QixXQUFXLEdBQUcvWTtJQUN0QnppQixTQUFRczdCLFFBQVEsR0FBR3I0QjtJQUNuQmpELFNBQVFtUyxTQUFTLEdBQUdBO0lBQ3BCblMsU0FBUXE3QixPQUFPLEdBQUdBO0FBRXBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc29sYW5hLWxpcXVpZGl0eS1wb29sLy4vbm9kZV9tb2R1bGVzL2Fjb3JuL2Rpc3QvYWNvcm4uanM/ODZjMCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmFjb3JuID0ge30pKTtcbn0pKHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQuIERvIG5vdCBtb2RpZnkgbWFudWFsbHkhXG4gIHZhciBhc3RyYWxJZGVudGlmaWVyQ29kZXMgPSBbNTA5LCAwLCAyMjcsIDAsIDE1MCwgNCwgMjk0LCA5LCAxMzY4LCAyLCAyLCAxLCA2LCAzLCA0MSwgMiwgNSwgMCwgMTY2LCAxLCA1NzQsIDMsIDksIDksIDcsIDksIDMyLCA0LCAzMTgsIDEsIDgwLCAzLCA3MSwgMTAsIDUwLCAzLCAxMjMsIDIsIDU0LCAxNCwgMzIsIDEwLCAzLCAxLCAxMSwgMywgNDYsIDEwLCA4LCAwLCA0NiwgOSwgNywgMiwgMzcsIDEzLCAyLCA5LCA2LCAxLCA0NSwgMCwgMTMsIDIsIDQ5LCAxMywgOSwgMywgMiwgMTEsIDgzLCAxMSwgNywgMCwgMywgMCwgMTU4LCAxMSwgNiwgOSwgNywgMywgNTYsIDEsIDIsIDYsIDMsIDEsIDMsIDIsIDEwLCAwLCAxMSwgMSwgMywgNiwgNCwgNCwgNjgsIDgsIDIsIDAsIDMsIDAsIDIsIDMsIDIsIDQsIDIsIDAsIDE1LCAxLCA4MywgMTcsIDEwLCA5LCA1LCAwLCA4MiwgMTksIDEzLCA5LCAyMTQsIDYsIDMsIDgsIDI4LCAxLCA4MywgMTYsIDE2LCA5LCA4MiwgMTIsIDksIDksIDcsIDE5LCA1OCwgMTQsIDUsIDksIDI0MywgMTQsIDE2NiwgOSwgNzEsIDUsIDIsIDEsIDMsIDMsIDIsIDAsIDIsIDEsIDEzLCA5LCAxMjAsIDYsIDMsIDYsIDQsIDAsIDI5LCA5LCA0MSwgNiwgMiwgMywgOSwgMCwgMTAsIDEwLCA0NywgMTUsIDM0MywgOSwgNTQsIDcsIDIsIDcsIDE3LCA5LCA1NywgMjEsIDIsIDEzLCAxMjMsIDUsIDQsIDAsIDIsIDEsIDIsIDYsIDIsIDAsIDksIDksIDQ5LCA0LCAyLCAxLCAyLCA0LCA5LCA5LCAzMzAsIDMsIDEwLCAxLCAyLCAwLCA0OSwgNiwgNCwgNCwgMTQsIDEwLCA1MzUwLCAwLCA3LCAxNCwgMTE0NjUsIDI3LCAyMzQzLCA5LCA4NywgOSwgMzksIDQsIDYwLCA2LCAyNiwgOSwgNTM1LCA5LCA0NzAsIDAsIDIsIDU0LCA4LCAzLCA4MiwgMCwgMTIsIDEsIDE5NjI4LCAxLCA0MTc4LCA5LCA1MTksIDQ1LCAzLCAyMiwgNTQzLCA0LCA0LCA1LCA5LCA3LCAzLCA2LCAzMSwgMywgMTQ5LCAyLCAxNDE4LCA0OSwgNTEzLCA1NCwgNSwgNDksIDksIDAsIDE1LCAwLCAyMywgNCwgMiwgMTQsIDEzNjEsIDYsIDIsIDE2LCAzLCA2LCAyLCAxLCAyLCA0LCAxMDEsIDAsIDE2MSwgNiwgMTAsIDksIDM1NywgMCwgNjIsIDEzLCA0OTksIDEzLCAyNDUsIDEsIDIsIDksIDcyNiwgNiwgMTEwLCA2LCA2LCA5LCA0NzU5LCA5LCA3ODc3MTksIDIzOV07XG5cbiAgLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQuIERvIG5vdCBtb2RpZnkgbWFudWFsbHkhXG4gIHZhciBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcyA9IFswLCAxMSwgMiwgMjUsIDIsIDE4LCAyLCAxLCAyLCAxNCwgMywgMTMsIDM1LCAxMjIsIDcwLCA1MiwgMjY4LCAyOCwgNCwgNDgsIDQ4LCAzMSwgMTQsIDI5LCA2LCAzNywgMTEsIDI5LCAzLCAzNSwgNSwgNywgMiwgNCwgNDMsIDE1NywgMTksIDM1LCA1LCAzNSwgNSwgMzksIDksIDUxLCAxMywgMTAsIDIsIDE0LCAyLCA2LCAyLCAxLCAyLCAxMCwgMiwgMTQsIDIsIDYsIDIsIDEsIDQsIDUxLCAxMywgMzEwLCAxMCwgMjEsIDExLCA3LCAyNSwgNSwgMiwgNDEsIDIsIDgsIDcwLCA1LCAzLCAwLCAyLCA0MywgMiwgMSwgNCwgMCwgMywgMjIsIDExLCAyMiwgMTAsIDMwLCA2NiwgMTgsIDIsIDEsIDExLCAyMSwgMTEsIDI1LCA3MSwgNTUsIDcsIDEsIDY1LCAwLCAxNiwgMywgMiwgMiwgMiwgMjgsIDQzLCAyOCwgNCwgMjgsIDM2LCA3LCAyLCAyNywgMjgsIDUzLCAxMSwgMjEsIDExLCAxOCwgMTQsIDE3LCAxMTEsIDcyLCA1NiwgNTAsIDE0LCA1MCwgMTQsIDM1LCAzOSwgMjcsIDEwLCAyMiwgMjUxLCA0MSwgNywgMSwgMTcsIDIsIDYwLCAyOCwgMTEsIDAsIDksIDIxLCA0MywgMTcsIDQ3LCAyMCwgMjgsIDIyLCAxMywgNTIsIDU4LCAxLCAzLCAwLCAxNCwgNDQsIDMzLCAyNCwgMjcsIDM1LCAzMCwgMCwgMywgMCwgOSwgMzQsIDQsIDAsIDEzLCA0NywgMTUsIDMsIDIyLCAwLCAyLCAwLCAzNiwgMTcsIDIsIDI0LCAyMCwgMSwgNjQsIDYsIDIsIDAsIDIsIDMsIDIsIDE0LCAyLCA5LCA4LCA0NiwgMzksIDcsIDMsIDEsIDMsIDIxLCAyLCA2LCAyLCAxLCAyLCA0LCA0LCAwLCAxOSwgMCwgMTMsIDQsIDMxLCA5LCAyLCAwLCAzLCAwLCAyLCAzNywgMiwgMCwgMjYsIDAsIDIsIDAsIDQ1LCA1MiwgMTksIDMsIDIxLCAyLCAzMSwgNDcsIDIxLCAxLCAyLCAwLCAxODUsIDQ2LCA0MiwgMywgMzcsIDQ3LCAyMSwgMCwgNjAsIDQyLCAxNCwgMCwgNzIsIDI2LCAzOCwgNiwgMTg2LCA0MywgMTE3LCA2MywgMzIsIDcsIDMsIDAsIDMsIDcsIDIsIDEsIDIsIDIzLCAxNiwgMCwgMiwgMCwgOTUsIDcsIDMsIDM4LCAxNywgMCwgMiwgMCwgMjksIDAsIDExLCAzOSwgOCwgMCwgMjIsIDAsIDEyLCA0NSwgMjAsIDAsIDE5LCA3MiwgMjAwLCAzMiwgMzIsIDgsIDIsIDM2LCAxOCwgMCwgNTAsIDI5LCAxMTMsIDYsIDIsIDEsIDIsIDM3LCAyMiwgMCwgMjYsIDUsIDIsIDEsIDIsIDMxLCAxNSwgMCwgMzI4LCAxOCwgMTYsIDAsIDIsIDEyLCAyLCAzMywgMTI1LCAwLCA4MCwgOTIxLCAxMDMsIDExMCwgMTgsIDE5NSwgMjYzNywgOTYsIDE2LCAxMDcxLCAxOCwgNSwgMjYsIDM5OTQsIDYsIDU4MiwgNjg0MiwgMjksIDE3NjMsIDU2OCwgOCwgMzAsIDE4LCA3OCwgMTgsIDI5LCAxOSwgNDcsIDE3LCAzLCAzMiwgMjAsIDYsIDE4LCA0MzMsIDQ0LCAyMTIsIDYzLCAxMjksIDc0LCA2LCAwLCA2NywgMTIsIDY1LCAxLCAyLCAwLCAyOSwgNjEzNSwgOSwgMTIzNywgNDIsIDksIDg5MzYsIDMsIDIsIDYsIDIsIDEsIDIsIDI5MCwgMTYsIDAsIDMwLCAyLCAzLCAwLCAxNSwgMywgOSwgMzk1LCAyMzA5LCAxMDYsIDYsIDEyLCA0LCA4LCA4LCA5LCA1OTkxLCA4NCwgMiwgNzAsIDIsIDEsIDMsIDAsIDMsIDEsIDMsIDMsIDIsIDExLCAyLCAwLCAyLCA2LCAyLCA2NCwgMiwgMywgMywgNywgMiwgNiwgMiwgMjcsIDIsIDMsIDIsIDQsIDIsIDAsIDQsIDYsIDIsIDMzOSwgMywgMjQsIDIsIDI0LCAyLCAzMCwgMiwgMjQsIDIsIDMwLCAyLCAyNCwgMiwgMzAsIDIsIDI0LCAyLCAzMCwgMiwgMjQsIDIsIDcsIDE4NDUsIDMwLCA3LCA1LCAyNjIsIDYxLCAxNDcsIDQ0LCAxMSwgNiwgMTcsIDAsIDMyMiwgMjksIDE5LCA0MywgNDg1LCAyNywgMjI5LCAyOSwgMywgMCwgNDk2LCA2LCAyLCAzLCAyLCAxLCAyLCAxNCwgMiwgMTk2LCA2MCwgNjcsIDgsIDAsIDEyMDUsIDMsIDIsIDI2LCAyLCAxLCAyLCAwLCAzLCAwLCAyLCA5LCAyLCAzLCAyLCAwLCAyLCAwLCA3LCAwLCA1LCAwLCAyLCAwLCAyLCAwLCAyLCAyLCAyLCAxLCAyLCAwLCAzLCAwLCAyLCAwLCAyLCAwLCAyLCAwLCAyLCAwLCAyLCAxLCAyLCAwLCAzLCAzLCAyLCA2LCAyLCAzLCAyLCAzLCAyLCAwLCAyLCA5LCAyLCAxNiwgNiwgMiwgMiwgNCwgMiwgMTYsIDQ0MjEsIDQyNzE5LCAzMywgNDE1MywgNywgMjIxLCAzLCA1NzYxLCAxNSwgNzQ3MiwgMTYsIDYyMSwgMjQ2NywgNTQxLCAxNTA3LCA0OTM4LCA2LCA0MTkxXTtcblxuICAvLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZC4gRG8gbm90IG1vZGlmeSBtYW51YWxseSFcbiAgdmFyIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gXCJcXHUyMDBjXFx1MjAwZFxceGI3XFx1MDMwMC1cXHUwMzZmXFx1MDM4N1xcdTA0ODMtXFx1MDQ4N1xcdTA1OTEtXFx1MDViZFxcdTA1YmZcXHUwNWMxXFx1MDVjMlxcdTA1YzRcXHUwNWM1XFx1MDVjN1xcdTA2MTAtXFx1MDYxYVxcdTA2NGItXFx1MDY2OVxcdTA2NzBcXHUwNmQ2LVxcdTA2ZGNcXHUwNmRmLVxcdTA2ZTRcXHUwNmU3XFx1MDZlOFxcdTA2ZWEtXFx1MDZlZFxcdTA2ZjAtXFx1MDZmOVxcdTA3MTFcXHUwNzMwLVxcdTA3NGFcXHUwN2E2LVxcdTA3YjBcXHUwN2MwLVxcdTA3YzlcXHUwN2ViLVxcdTA3ZjNcXHUwN2ZkXFx1MDgxNi1cXHUwODE5XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDg1OS1cXHUwODViXFx1MDg5Ny1cXHUwODlmXFx1MDhjYS1cXHUwOGUxXFx1MDhlMy1cXHUwOTAzXFx1MDkzYS1cXHUwOTNjXFx1MDkzZS1cXHUwOTRmXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTY2LVxcdTA5NmZcXHUwOTgxLVxcdTA5ODNcXHUwOWJjXFx1MDliZS1cXHUwOWM0XFx1MDljN1xcdTA5YzhcXHUwOWNiLVxcdTA5Y2RcXHUwOWQ3XFx1MDllMlxcdTA5ZTNcXHUwOWU2LVxcdTA5ZWZcXHUwOWZlXFx1MGEwMS1cXHUwYTAzXFx1MGEzY1xcdTBhM2UtXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNjYtXFx1MGE3MVxcdTBhNzVcXHUwYTgxLVxcdTBhODNcXHUwYWJjXFx1MGFiZS1cXHUwYWM1XFx1MGFjNy1cXHUwYWM5XFx1MGFjYi1cXHUwYWNkXFx1MGFlMlxcdTBhZTNcXHUwYWU2LVxcdTBhZWZcXHUwYWZhLVxcdTBhZmZcXHUwYjAxLVxcdTBiMDNcXHUwYjNjXFx1MGIzZS1cXHUwYjQ0XFx1MGI0N1xcdTBiNDhcXHUwYjRiLVxcdTBiNGRcXHUwYjU1LVxcdTBiNTdcXHUwYjYyXFx1MGI2M1xcdTBiNjYtXFx1MGI2ZlxcdTBiODJcXHUwYmJlLVxcdTBiYzJcXHUwYmM2LVxcdTBiYzhcXHUwYmNhLVxcdTBiY2RcXHUwYmQ3XFx1MGJlNi1cXHUwYmVmXFx1MGMwMC1cXHUwYzA0XFx1MGMzY1xcdTBjM2UtXFx1MGM0NFxcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM2MlxcdTBjNjNcXHUwYzY2LVxcdTBjNmZcXHUwYzgxLVxcdTBjODNcXHUwY2JjXFx1MGNiZS1cXHUwY2M0XFx1MGNjNi1cXHUwY2M4XFx1MGNjYS1cXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2UyXFx1MGNlM1xcdTBjZTYtXFx1MGNlZlxcdTBjZjNcXHUwZDAwLVxcdTBkMDNcXHUwZDNiXFx1MGQzY1xcdTBkM2UtXFx1MGQ0NFxcdTBkNDYtXFx1MGQ0OFxcdTBkNGEtXFx1MGQ0ZFxcdTBkNTdcXHUwZDYyXFx1MGQ2M1xcdTBkNjYtXFx1MGQ2ZlxcdTBkODEtXFx1MGQ4M1xcdTBkY2FcXHUwZGNmLVxcdTBkZDRcXHUwZGQ2XFx1MGRkOC1cXHUwZGRmXFx1MGRlNi1cXHUwZGVmXFx1MGRmMlxcdTBkZjNcXHUwZTMxXFx1MGUzNC1cXHUwZTNhXFx1MGU0Ny1cXHUwZTRlXFx1MGU1MC1cXHUwZTU5XFx1MGViMVxcdTBlYjQtXFx1MGViY1xcdTBlYzgtXFx1MGVjZVxcdTBlZDAtXFx1MGVkOVxcdTBmMThcXHUwZjE5XFx1MGYyMC1cXHUwZjI5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGYzZVxcdTBmM2ZcXHUwZjcxLVxcdTBmODRcXHUwZjg2XFx1MGY4N1xcdTBmOGQtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDJiLVxcdTEwM2VcXHUxMDQwLVxcdTEwNDlcXHUxMDU2LVxcdTEwNTlcXHUxMDVlLVxcdTEwNjBcXHUxMDYyLVxcdTEwNjRcXHUxMDY3LVxcdTEwNmRcXHUxMDcxLVxcdTEwNzRcXHUxMDgyLVxcdTEwOGRcXHUxMDhmLVxcdTEwOWRcXHUxMzVkLVxcdTEzNWZcXHUxMzY5LVxcdTEzNzFcXHUxNzEyLVxcdTE3MTVcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdiNC1cXHUxN2QzXFx1MTdkZFxcdTE3ZTAtXFx1MTdlOVxcdTE4MGItXFx1MTgwZFxcdTE4MGYtXFx1MTgxOVxcdTE4YTlcXHUxOTIwLVxcdTE5MmJcXHUxOTMwLVxcdTE5M2JcXHUxOTQ2LVxcdTE5NGZcXHUxOWQwLVxcdTE5ZGFcXHUxYTE3LVxcdTFhMWJcXHUxYTU1LVxcdTFhNWVcXHUxYTYwLVxcdTFhN2NcXHUxYTdmLVxcdTFhODlcXHUxYTkwLVxcdTFhOTlcXHUxYWIwLVxcdTFhYmRcXHUxYWJmLVxcdTFhY2VcXHUxYjAwLVxcdTFiMDRcXHUxYjM0LVxcdTFiNDRcXHUxYjUwLVxcdTFiNTlcXHUxYjZiLVxcdTFiNzNcXHUxYjgwLVxcdTFiODJcXHUxYmExLVxcdTFiYWRcXHUxYmIwLVxcdTFiYjlcXHUxYmU2LVxcdTFiZjNcXHUxYzI0LVxcdTFjMzdcXHUxYzQwLVxcdTFjNDlcXHUxYzUwLVxcdTFjNTlcXHUxY2QwLVxcdTFjZDJcXHUxY2Q0LVxcdTFjZThcXHUxY2VkXFx1MWNmNFxcdTFjZjctXFx1MWNmOVxcdTFkYzAtXFx1MWRmZlxcdTIwMGNcXHUyMDBkXFx1MjAzZlxcdTIwNDBcXHUyMDU0XFx1MjBkMC1cXHUyMGRjXFx1MjBlMVxcdTIwZTUtXFx1MjBmMFxcdTJjZWYtXFx1MmNmMVxcdTJkN2ZcXHUyZGUwLVxcdTJkZmZcXHUzMDJhLVxcdTMwMmZcXHUzMDk5XFx1MzA5YVxcdTMwZmJcXHVhNjIwLVxcdWE2MjlcXHVhNjZmXFx1YTY3NC1cXHVhNjdkXFx1YTY5ZVxcdWE2OWZcXHVhNmYwXFx1YTZmMVxcdWE4MDJcXHVhODA2XFx1YTgwYlxcdWE4MjMtXFx1YTgyN1xcdWE4MmNcXHVhODgwXFx1YTg4MVxcdWE4YjQtXFx1YThjNVxcdWE4ZDAtXFx1YThkOVxcdWE4ZTAtXFx1YThmMVxcdWE4ZmYtXFx1YTkwOVxcdWE5MjYtXFx1YTkyZFxcdWE5NDctXFx1YTk1M1xcdWE5ODAtXFx1YTk4M1xcdWE5YjMtXFx1YTljMFxcdWE5ZDAtXFx1YTlkOVxcdWE5ZTVcXHVhOWYwLVxcdWE5ZjlcXHVhYTI5LVxcdWFhMzZcXHVhYTQzXFx1YWE0Y1xcdWFhNGRcXHVhYTUwLVxcdWFhNTlcXHVhYTdiLVxcdWFhN2RcXHVhYWIwXFx1YWFiMi1cXHVhYWI0XFx1YWFiN1xcdWFhYjhcXHVhYWJlXFx1YWFiZlxcdWFhYzFcXHVhYWViLVxcdWFhZWZcXHVhYWY1XFx1YWFmNlxcdWFiZTMtXFx1YWJlYVxcdWFiZWNcXHVhYmVkXFx1YWJmMC1cXHVhYmY5XFx1ZmIxZVxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyZlxcdWZlMzNcXHVmZTM0XFx1ZmU0ZC1cXHVmZTRmXFx1ZmYxMC1cXHVmZjE5XFx1ZmYzZlxcdWZmNjVcIjtcblxuICAvLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZC4gRG8gbm90IG1vZGlmeSBtYW51YWxseSFcbiAgdmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgPSBcIlxceGFhXFx4YjVcXHhiYVxceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMmMxXFx1MDJjNi1cXHUwMmQxXFx1MDJlMC1cXHUwMmU0XFx1MDJlY1xcdTAyZWVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN2EtXFx1MDM3ZFxcdTAzN2ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhhXFx1MDM4Y1xcdTAzOGUtXFx1MDNhMVxcdTAzYTMtXFx1MDNmNVxcdTAzZjctXFx1MDQ4MVxcdTA0OGEtXFx1MDUyZlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYwLVxcdTA1ODhcXHUwNWQwLVxcdTA1ZWFcXHUwNWVmLVxcdTA1ZjJcXHUwNjIwLVxcdTA2NGFcXHUwNjZlXFx1MDY2ZlxcdTA2NzEtXFx1MDZkM1xcdTA2ZDVcXHUwNmU1XFx1MDZlNlxcdTA2ZWVcXHUwNmVmXFx1MDZmYS1cXHUwNmZjXFx1MDZmZlxcdTA3MTBcXHUwNzEyLVxcdTA3MmZcXHUwNzRkLVxcdTA3YTVcXHUwN2IxXFx1MDdjYS1cXHUwN2VhXFx1MDdmNFxcdTA3ZjVcXHUwN2ZhXFx1MDgwMC1cXHUwODE1XFx1MDgxYVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDg2MC1cXHUwODZhXFx1MDg3MC1cXHUwODg3XFx1MDg4OS1cXHUwODhlXFx1MDhhMC1cXHUwOGM5XFx1MDkwNC1cXHUwOTM5XFx1MDkzZFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5ODBcXHUwOTg1LVxcdTA5OGNcXHUwOThmXFx1MDk5MFxcdTA5OTMtXFx1MDlhOFxcdTA5YWEtXFx1MDliMFxcdTA5YjJcXHUwOWI2LVxcdTA5YjlcXHUwOWJkXFx1MDljZVxcdTA5ZGNcXHUwOWRkXFx1MDlkZi1cXHUwOWUxXFx1MDlmMFxcdTA5ZjFcXHUwOWZjXFx1MGEwNS1cXHUwYTBhXFx1MGEwZlxcdTBhMTBcXHUwYTEzLVxcdTBhMjhcXHUwYTJhLVxcdTBhMzBcXHUwYTMyXFx1MGEzM1xcdTBhMzVcXHUwYTM2XFx1MGEzOFxcdTBhMzlcXHUwYTU5LVxcdTBhNWNcXHUwYTVlXFx1MGE3Mi1cXHUwYTc0XFx1MGE4NS1cXHUwYThkXFx1MGE4Zi1cXHUwYTkxXFx1MGE5My1cXHUwYWE4XFx1MGFhYS1cXHUwYWIwXFx1MGFiMlxcdTBhYjNcXHUwYWI1LVxcdTBhYjlcXHUwYWJkXFx1MGFkMFxcdTBhZTBcXHUwYWUxXFx1MGFmOVxcdTBiMDUtXFx1MGIwY1xcdTBiMGZcXHUwYjEwXFx1MGIxMy1cXHUwYjI4XFx1MGIyYS1cXHUwYjMwXFx1MGIzMlxcdTBiMzNcXHUwYjM1LVxcdTBiMzlcXHUwYjNkXFx1MGI1Y1xcdTBiNWRcXHUwYjVmLVxcdTBiNjFcXHUwYjcxXFx1MGI4M1xcdTBiODUtXFx1MGI4YVxcdTBiOGUtXFx1MGI5MFxcdTBiOTItXFx1MGI5NVxcdTBiOTlcXHUwYjlhXFx1MGI5Y1xcdTBiOWVcXHUwYjlmXFx1MGJhM1xcdTBiYTRcXHUwYmE4LVxcdTBiYWFcXHUwYmFlLVxcdTBiYjlcXHUwYmQwXFx1MGMwNS1cXHUwYzBjXFx1MGMwZS1cXHUwYzEwXFx1MGMxMi1cXHUwYzI4XFx1MGMyYS1cXHUwYzM5XFx1MGMzZFxcdTBjNTgtXFx1MGM1YVxcdTBjNWRcXHUwYzYwXFx1MGM2MVxcdTBjODBcXHUwYzg1LVxcdTBjOGNcXHUwYzhlLVxcdTBjOTBcXHUwYzkyLVxcdTBjYThcXHUwY2FhLVxcdTBjYjNcXHUwY2I1LVxcdTBjYjlcXHUwY2JkXFx1MGNkZFxcdTBjZGVcXHUwY2UwXFx1MGNlMVxcdTBjZjFcXHUwY2YyXFx1MGQwNC1cXHUwZDBjXFx1MGQwZS1cXHUwZDEwXFx1MGQxMi1cXHUwZDNhXFx1MGQzZFxcdTBkNGVcXHUwZDU0LVxcdTBkNTZcXHUwZDVmLVxcdTBkNjFcXHUwZDdhLVxcdTBkN2ZcXHUwZDg1LVxcdTBkOTZcXHUwZDlhLVxcdTBkYjFcXHUwZGIzLVxcdTBkYmJcXHUwZGJkXFx1MGRjMC1cXHUwZGM2XFx1MGUwMS1cXHUwZTMwXFx1MGUzMlxcdTBlMzNcXHUwZTQwLVxcdTBlNDZcXHUwZTgxXFx1MGU4MlxcdTBlODRcXHUwZTg2LVxcdTBlOGFcXHUwZThjLVxcdTBlYTNcXHUwZWE1XFx1MGVhNy1cXHUwZWIwXFx1MGViMlxcdTBlYjNcXHUwZWJkXFx1MGVjMC1cXHUwZWM0XFx1MGVjNlxcdTBlZGMtXFx1MGVkZlxcdTBmMDBcXHUwZjQwLVxcdTBmNDdcXHUwZjQ5LVxcdTBmNmNcXHUwZjg4LVxcdTBmOGNcXHUxMDAwLVxcdTEwMmFcXHUxMDNmXFx1MTA1MC1cXHUxMDU1XFx1MTA1YS1cXHUxMDVkXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2ZS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4ZVxcdTEwYTAtXFx1MTBjNVxcdTEwYzdcXHUxMGNkXFx1MTBkMC1cXHUxMGZhXFx1MTBmYy1cXHUxMjQ4XFx1MTI0YS1cXHUxMjRkXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNWEtXFx1MTI1ZFxcdTEyNjAtXFx1MTI4OFxcdTEyOGEtXFx1MTI4ZFxcdTEyOTAtXFx1MTJiMFxcdTEyYjItXFx1MTJiNVxcdTEyYjgtXFx1MTJiZVxcdTEyYzBcXHUxMmMyLVxcdTEyYzVcXHUxMmM4LVxcdTEyZDZcXHUxMmQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNWFcXHUxMzgwLVxcdTEzOGZcXHUxM2EwLVxcdTEzZjVcXHUxM2Y4LVxcdTEzZmRcXHUxNDAxLVxcdTE2NmNcXHUxNjZmLVxcdTE2N2ZcXHUxNjgxLVxcdTE2OWFcXHUxNmEwLVxcdTE2ZWFcXHUxNmVlLVxcdTE2ZjhcXHUxNzAwLVxcdTE3MTFcXHUxNzFmLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NmNcXHUxNzZlLVxcdTE3NzBcXHUxNzgwLVxcdTE3YjNcXHUxN2Q3XFx1MTdkY1xcdTE4MjAtXFx1MTg3OFxcdTE4ODAtXFx1MThhOFxcdTE4YWFcXHUxOGIwLVxcdTE4ZjVcXHUxOTAwLVxcdTE5MWVcXHUxOTUwLVxcdTE5NmRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5YWJcXHUxOWIwLVxcdTE5YzlcXHUxYTAwLVxcdTFhMTZcXHUxYTIwLVxcdTFhNTRcXHUxYWE3XFx1MWIwNS1cXHUxYjMzXFx1MWI0NS1cXHUxYjRjXFx1MWI4My1cXHUxYmEwXFx1MWJhZVxcdTFiYWZcXHUxYmJhLVxcdTFiZTVcXHUxYzAwLVxcdTFjMjNcXHUxYzRkLVxcdTFjNGZcXHUxYzVhLVxcdTFjN2RcXHUxYzgwLVxcdTFjOGFcXHUxYzkwLVxcdTFjYmFcXHUxY2JkLVxcdTFjYmZcXHUxY2U5LVxcdTFjZWNcXHUxY2VlLVxcdTFjZjNcXHUxY2Y1XFx1MWNmNlxcdTFjZmFcXHUxZDAwLVxcdTFkYmZcXHUxZTAwLVxcdTFmMTVcXHUxZjE4LVxcdTFmMWRcXHUxZjIwLVxcdTFmNDVcXHUxZjQ4LVxcdTFmNGRcXHUxZjUwLVxcdTFmNTdcXHUxZjU5XFx1MWY1YlxcdTFmNWRcXHUxZjVmLVxcdTFmN2RcXHUxZjgwLVxcdTFmYjRcXHUxZmI2LVxcdTFmYmNcXHUxZmJlXFx1MWZjMi1cXHUxZmM0XFx1MWZjNi1cXHUxZmNjXFx1MWZkMC1cXHUxZmQzXFx1MWZkNi1cXHUxZmRiXFx1MWZlMC1cXHUxZmVjXFx1MWZmMi1cXHUxZmY0XFx1MWZmNi1cXHUxZmZjXFx1MjA3MVxcdTIwN2ZcXHUyMDkwLVxcdTIwOWNcXHUyMTAyXFx1MjEwN1xcdTIxMGEtXFx1MjExM1xcdTIxMTVcXHUyMTE4LVxcdTIxMWRcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJhLVxcdTIxMzlcXHUyMTNjLVxcdTIxM2ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRlXFx1MjE2MC1cXHUyMTg4XFx1MmMwMC1cXHUyY2U0XFx1MmNlYi1cXHUyY2VlXFx1MmNmMlxcdTJjZjNcXHUyZDAwLVxcdTJkMjVcXHUyZDI3XFx1MmQyZFxcdTJkMzAtXFx1MmQ2N1xcdTJkNmZcXHUyZDgwLVxcdTJkOTZcXHUyZGEwLVxcdTJkYTZcXHUyZGE4LVxcdTJkYWVcXHUyZGIwLVxcdTJkYjZcXHUyZGI4LVxcdTJkYmVcXHUyZGMwLVxcdTJkYzZcXHUyZGM4LVxcdTJkY2VcXHUyZGQwLVxcdTJkZDZcXHUyZGQ4LVxcdTJkZGVcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM2NcXHUzMDQxLVxcdTMwOTZcXHUzMDliLVxcdTMwOWZcXHUzMGExLVxcdTMwZmFcXHUzMGZjLVxcdTMwZmZcXHUzMTA1LVxcdTMxMmZcXHUzMTMxLVxcdTMxOGVcXHUzMWEwLVxcdTMxYmZcXHUzMWYwLVxcdTMxZmZcXHUzNDAwLVxcdTRkYmZcXHU0ZTAwLVxcdWE0OGNcXHVhNGQwLVxcdWE0ZmRcXHVhNTAwLVxcdWE2MGNcXHVhNjEwLVxcdWE2MWZcXHVhNjJhXFx1YTYyYlxcdWE2NDAtXFx1YTY2ZVxcdWE2N2YtXFx1YTY5ZFxcdWE2YTAtXFx1YTZlZlxcdWE3MTctXFx1YTcxZlxcdWE3MjItXFx1YTc4OFxcdWE3OGItXFx1YTdjZFxcdWE3ZDBcXHVhN2QxXFx1YTdkM1xcdWE3ZDUtXFx1YTdkY1xcdWE3ZjItXFx1YTgwMVxcdWE4MDMtXFx1YTgwNVxcdWE4MDctXFx1YTgwYVxcdWE4MGMtXFx1YTgyMlxcdWE4NDAtXFx1YTg3M1xcdWE4ODItXFx1YThiM1xcdWE4ZjItXFx1YThmN1xcdWE4ZmJcXHVhOGZkXFx1YThmZVxcdWE5MGEtXFx1YTkyNVxcdWE5MzAtXFx1YTk0NlxcdWE5NjAtXFx1YTk3Y1xcdWE5ODQtXFx1YTliMlxcdWE5Y2ZcXHVhOWUwLVxcdWE5ZTRcXHVhOWU2LVxcdWE5ZWZcXHVhOWZhLVxcdWE5ZmVcXHVhYTAwLVxcdWFhMjhcXHVhYTQwLVxcdWFhNDJcXHVhYTQ0LVxcdWFhNGJcXHVhYTYwLVxcdWFhNzZcXHVhYTdhXFx1YWE3ZS1cXHVhYWFmXFx1YWFiMVxcdWFhYjVcXHVhYWI2XFx1YWFiOS1cXHVhYWJkXFx1YWFjMFxcdWFhYzJcXHVhYWRiLVxcdWFhZGRcXHVhYWUwLVxcdWFhZWFcXHVhYWYyLVxcdWFhZjRcXHVhYjAxLVxcdWFiMDZcXHVhYjA5LVxcdWFiMGVcXHVhYjExLVxcdWFiMTZcXHVhYjIwLVxcdWFiMjZcXHVhYjI4LVxcdWFiMmVcXHVhYjMwLVxcdWFiNWFcXHVhYjVjLVxcdWFiNjlcXHVhYjcwLVxcdWFiZTJcXHVhYzAwLVxcdWQ3YTNcXHVkN2IwLVxcdWQ3YzZcXHVkN2NiLVxcdWQ3ZmJcXHVmOTAwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjAwLVxcdWZiMDZcXHVmYjEzLVxcdWZiMTdcXHVmYjFkXFx1ZmIxZi1cXHVmYjI4XFx1ZmIyYS1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDBcXHVmYjQxXFx1ZmI0M1xcdWZiNDRcXHVmYjQ2LVxcdWZiYjFcXHVmYmQzLVxcdWZkM2RcXHVmZDUwLVxcdWZkOGZcXHVmZDkyLVxcdWZkYzdcXHVmZGYwLVxcdWZkZmJcXHVmZTcwLVxcdWZlNzRcXHVmZTc2LVxcdWZlZmNcXHVmZjIxLVxcdWZmM2FcXHVmZjQxLVxcdWZmNWFcXHVmZjY2LVxcdWZmYmVcXHVmZmMyLVxcdWZmYzdcXHVmZmNhLVxcdWZmY2ZcXHVmZmQyLVxcdWZmZDdcXHVmZmRhLVxcdWZmZGNcIjtcblxuICAvLyBUaGVzZSBhcmUgYSBydW4tbGVuZ3RoIGFuZCBvZmZzZXQgZW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGVcbiAgLy8gPjB4ZmZmZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBhIHZhbGlkIHBhcnQgb2YgaWRlbnRpZmllcnMuIFRoZVxuICAvLyBvZmZzZXQgc3RhcnRzIGF0IDB4MTAwMDAsIGFuZCBlYWNoIHBhaXIgb2YgbnVtYmVycyByZXByZXNlbnRzIGFuXG4gIC8vIG9mZnNldCB0byB0aGUgbmV4dCByYW5nZSwgYW5kIHRoZW4gYSBzaXplIG9mIHRoZSByYW5nZS5cblxuICAvLyBSZXNlcnZlZCB3b3JkIGxpc3RzIGZvciB2YXJpb3VzIGRpYWxlY3RzIG9mIHRoZSBsYW5ndWFnZVxuXG4gIHZhciByZXNlcnZlZFdvcmRzID0ge1xuICAgIDM6IFwiYWJzdHJhY3QgYm9vbGVhbiBieXRlIGNoYXIgY2xhc3MgZG91YmxlIGVudW0gZXhwb3J0IGV4dGVuZHMgZmluYWwgZmxvYXQgZ290byBpbXBsZW1lbnRzIGltcG9ydCBpbnQgaW50ZXJmYWNlIGxvbmcgbmF0aXZlIHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIHNob3J0IHN0YXRpYyBzdXBlciBzeW5jaHJvbml6ZWQgdGhyb3dzIHRyYW5zaWVudCB2b2xhdGlsZVwiLFxuICAgIDU6IFwiY2xhc3MgZW51bSBleHRlbmRzIHN1cGVyIGNvbnN0IGV4cG9ydCBpbXBvcnRcIixcbiAgICA2OiBcImVudW1cIixcbiAgICBzdHJpY3Q6IFwiaW1wbGVtZW50cyBpbnRlcmZhY2UgbGV0IHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIHN0YXRpYyB5aWVsZFwiLFxuICAgIHN0cmljdEJpbmQ6IFwiZXZhbCBhcmd1bWVudHNcIlxuICB9O1xuXG4gIC8vIEFuZCB0aGUga2V5d29yZHNcblxuICB2YXIgZWNtYTVBbmRMZXNzS2V5d29yZHMgPSBcImJyZWFrIGNhc2UgY2F0Y2ggY29udGludWUgZGVidWdnZXIgZGVmYXVsdCBkbyBlbHNlIGZpbmFsbHkgZm9yIGZ1bmN0aW9uIGlmIHJldHVybiBzd2l0Y2ggdGhyb3cgdHJ5IHZhciB3aGlsZSB3aXRoIG51bGwgdHJ1ZSBmYWxzZSBpbnN0YW5jZW9mIHR5cGVvZiB2b2lkIGRlbGV0ZSBuZXcgaW4gdGhpc1wiO1xuXG4gIHZhciBrZXl3b3JkcyQxID0ge1xuICAgIDU6IGVjbWE1QW5kTGVzc0tleXdvcmRzLFxuICAgIFwiNW1vZHVsZVwiOiBlY21hNUFuZExlc3NLZXl3b3JkcyArIFwiIGV4cG9ydCBpbXBvcnRcIixcbiAgICA2OiBlY21hNUFuZExlc3NLZXl3b3JkcyArIFwiIGNvbnN0IGNsYXNzIGV4dGVuZHMgZXhwb3J0IGltcG9ydCBzdXBlclwiXG4gIH07XG5cbiAgdmFyIGtleXdvcmRSZWxhdGlvbmFsT3BlcmF0b3IgPSAvXmluKHN0YW5jZW9mKT8kLztcblxuICAvLyAjIyBDaGFyYWN0ZXIgY2F0ZWdvcmllc1xuXG4gIHZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydCA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgXCJdXCIpO1xuICB2YXIgbm9uQVNDSUlpZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJDaGFycyArIFwiXVwiKTtcblxuICAvLyBUaGlzIGhhcyBhIGNvbXBsZXhpdHkgbGluZWFyIHRvIHRoZSB2YWx1ZSBvZiB0aGUgY29kZS4gVGhlXG4gIC8vIGFzc3VtcHRpb24gaXMgdGhhdCBsb29raW5nIHVwIGFzdHJhbCBpZGVudGlmaWVyIGNoYXJhY3RlcnMgaXNcbiAgLy8gcmFyZS5cbiAgZnVuY3Rpb24gaXNJbkFzdHJhbFNldChjb2RlLCBzZXQpIHtcbiAgICB2YXIgcG9zID0gMHgxMDAwMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgcG9zICs9IHNldFtpXTtcbiAgICAgIGlmIChwb3MgPiBjb2RlKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICBwb3MgKz0gc2V0W2kgKyAxXTtcbiAgICAgIGlmIChwb3MgPj0gY29kZSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gY2hhcmFjdGVyIGNvZGUgc3RhcnRzIGFuIGlkZW50aWZpZXIuXG5cbiAgZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnQoY29kZSwgYXN0cmFsKSB7XG4gICAgaWYgKGNvZGUgPCA2NSkgeyByZXR1cm4gY29kZSA9PT0gMzYgfVxuICAgIGlmIChjb2RlIDwgOTEpIHsgcmV0dXJuIHRydWUgfVxuICAgIGlmIChjb2RlIDwgOTcpIHsgcmV0dXJuIGNvZGUgPT09IDk1IH1cbiAgICBpZiAoY29kZSA8IDEyMykgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKGNvZGUgPD0gMHhmZmZmKSB7IHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKSB9XG4gICAgaWYgKGFzdHJhbCA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICByZXR1cm4gaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcylcbiAgfVxuXG4gIC8vIFRlc3Qgd2hldGhlciBhIGdpdmVuIGNoYXJhY3RlciBpcyBwYXJ0IG9mIGFuIGlkZW50aWZpZXIuXG5cbiAgZnVuY3Rpb24gaXNJZGVudGlmaWVyQ2hhcihjb2RlLCBhc3RyYWwpIHtcbiAgICBpZiAoY29kZSA8IDQ4KSB7IHJldHVybiBjb2RlID09PSAzNiB9XG4gICAgaWYgKGNvZGUgPCA1OCkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKGNvZGUgPCA2NSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmIChjb2RlIDwgOTEpIHsgcmV0dXJuIHRydWUgfVxuICAgIGlmIChjb2RlIDwgOTcpIHsgcmV0dXJuIGNvZGUgPT09IDk1IH1cbiAgICBpZiAoY29kZSA8IDEyMykgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKGNvZGUgPD0gMHhmZmZmKSB7IHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSkgfVxuICAgIGlmIChhc3RyYWwgPT09IGZhbHNlKSB7IHJldHVybiBmYWxzZSB9XG4gICAgcmV0dXJuIGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMpIHx8IGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllckNvZGVzKVxuICB9XG5cbiAgLy8gIyMgVG9rZW4gdHlwZXNcblxuICAvLyBUaGUgYXNzaWdubWVudCBvZiBmaW5lLWdyYWluZWQsIGluZm9ybWF0aW9uLWNhcnJ5aW5nIHR5cGUgb2JqZWN0c1xuICAvLyBhbGxvd3MgdGhlIHRva2VuaXplciB0byBzdG9yZSB0aGUgaW5mb3JtYXRpb24gaXQgaGFzIGFib3V0IGFcbiAgLy8gdG9rZW4gaW4gYSB3YXkgdGhhdCBpcyB2ZXJ5IGNoZWFwIGZvciB0aGUgcGFyc2VyIHRvIGxvb2sgdXAuXG5cbiAgLy8gQWxsIHRva2VuIHR5cGUgdmFyaWFibGVzIHN0YXJ0IHdpdGggYW4gdW5kZXJzY29yZSwgdG8gbWFrZSB0aGVtXG4gIC8vIGVhc3kgdG8gcmVjb2duaXplLlxuXG4gIC8vIFRoZSBgYmVmb3JlRXhwcmAgcHJvcGVydHkgaXMgdXNlZCB0byBkaXNhbWJpZ3VhdGUgYmV0d2VlbiByZWd1bGFyXG4gIC8vIGV4cHJlc3Npb25zIGFuZCBkaXZpc2lvbnMuIEl0IGlzIHNldCBvbiBhbGwgdG9rZW4gdHlwZXMgdGhhdCBjYW5cbiAgLy8gYmUgZm9sbG93ZWQgYnkgYW4gZXhwcmVzc2lvbiAodGh1cywgYSBzbGFzaCBhZnRlciB0aGVtIHdvdWxkIGJlIGFcbiAgLy8gcmVndWxhciBleHByZXNzaW9uKS5cbiAgLy9cbiAgLy8gVGhlIGBzdGFydHNFeHByYCBwcm9wZXJ0eSBpcyB1c2VkIHRvIGNoZWNrIGlmIHRoZSB0b2tlbiBlbmRzIGFcbiAgLy8gYHlpZWxkYCBleHByZXNzaW9uLiBJdCBpcyBzZXQgb24gYWxsIHRva2VuIHR5cGVzIHRoYXQgZWl0aGVyIGNhblxuICAvLyBkaXJlY3RseSBzdGFydCBhbiBleHByZXNzaW9uIChsaWtlIGEgcXVvdGF0aW9uIG1hcmspIG9yIGNhblxuICAvLyBjb250aW51ZSBhbiBleHByZXNzaW9uIChsaWtlIHRoZSBib2R5IG9mIGEgc3RyaW5nKS5cbiAgLy9cbiAgLy8gYGlzTG9vcGAgbWFya3MgYSBrZXl3b3JkIGFzIHN0YXJ0aW5nIGEgbG9vcCwgd2hpY2ggaXMgaW1wb3J0YW50XG4gIC8vIHRvIGtub3cgd2hlbiBwYXJzaW5nIGEgbGFiZWwsIGluIG9yZGVyIHRvIGFsbG93IG9yIGRpc2FsbG93XG4gIC8vIGNvbnRpbnVlIGp1bXBzIHRvIHRoYXQgbGFiZWwuXG5cbiAgdmFyIFRva2VuVHlwZSA9IGZ1bmN0aW9uIFRva2VuVHlwZShsYWJlbCwgY29uZikge1xuICAgIGlmICggY29uZiA9PT0gdm9pZCAwICkgY29uZiA9IHt9O1xuXG4gICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgIHRoaXMua2V5d29yZCA9IGNvbmYua2V5d29yZDtcbiAgICB0aGlzLmJlZm9yZUV4cHIgPSAhIWNvbmYuYmVmb3JlRXhwcjtcbiAgICB0aGlzLnN0YXJ0c0V4cHIgPSAhIWNvbmYuc3RhcnRzRXhwcjtcbiAgICB0aGlzLmlzTG9vcCA9ICEhY29uZi5pc0xvb3A7XG4gICAgdGhpcy5pc0Fzc2lnbiA9ICEhY29uZi5pc0Fzc2lnbjtcbiAgICB0aGlzLnByZWZpeCA9ICEhY29uZi5wcmVmaXg7XG4gICAgdGhpcy5wb3N0Zml4ID0gISFjb25mLnBvc3RmaXg7XG4gICAgdGhpcy5iaW5vcCA9IGNvbmYuYmlub3AgfHwgbnVsbDtcbiAgICB0aGlzLnVwZGF0ZUNvbnRleHQgPSBudWxsO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGJpbm9wKG5hbWUsIHByZWMpIHtcbiAgICByZXR1cm4gbmV3IFRva2VuVHlwZShuYW1lLCB7YmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IHByZWN9KVxuICB9XG4gIHZhciBiZWZvcmVFeHByID0ge2JlZm9yZUV4cHI6IHRydWV9LCBzdGFydHNFeHByID0ge3N0YXJ0c0V4cHI6IHRydWV9O1xuXG4gIC8vIE1hcCBrZXl3b3JkIG5hbWVzIHRvIHRva2VuIHR5cGVzLlxuXG4gIHZhciBrZXl3b3JkcyA9IHt9O1xuXG4gIC8vIFN1Y2NpbmN0IGRlZmluaXRpb25zIG9mIGtleXdvcmQgdG9rZW4gdHlwZXNcbiAgZnVuY3Rpb24ga3cobmFtZSwgb3B0aW9ucykge1xuICAgIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gICAgb3B0aW9ucy5rZXl3b3JkID0gbmFtZTtcbiAgICByZXR1cm4ga2V5d29yZHNbbmFtZV0gPSBuZXcgVG9rZW5UeXBlKG5hbWUsIG9wdGlvbnMpXG4gIH1cblxuICB2YXIgdHlwZXMkMSA9IHtcbiAgICBudW06IG5ldyBUb2tlblR5cGUoXCJudW1cIiwgc3RhcnRzRXhwciksXG4gICAgcmVnZXhwOiBuZXcgVG9rZW5UeXBlKFwicmVnZXhwXCIsIHN0YXJ0c0V4cHIpLFxuICAgIHN0cmluZzogbmV3IFRva2VuVHlwZShcInN0cmluZ1wiLCBzdGFydHNFeHByKSxcbiAgICBuYW1lOiBuZXcgVG9rZW5UeXBlKFwibmFtZVwiLCBzdGFydHNFeHByKSxcbiAgICBwcml2YXRlSWQ6IG5ldyBUb2tlblR5cGUoXCJwcml2YXRlSWRcIiwgc3RhcnRzRXhwciksXG4gICAgZW9mOiBuZXcgVG9rZW5UeXBlKFwiZW9mXCIpLFxuXG4gICAgLy8gUHVuY3R1YXRpb24gdG9rZW4gdHlwZXMuXG4gICAgYnJhY2tldEw6IG5ldyBUb2tlblR5cGUoXCJbXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgYnJhY2tldFI6IG5ldyBUb2tlblR5cGUoXCJdXCIpLFxuICAgIGJyYWNlTDogbmV3IFRva2VuVHlwZShcIntcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBicmFjZVI6IG5ldyBUb2tlblR5cGUoXCJ9XCIpLFxuICAgIHBhcmVuTDogbmV3IFRva2VuVHlwZShcIihcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBwYXJlblI6IG5ldyBUb2tlblR5cGUoXCIpXCIpLFxuICAgIGNvbW1hOiBuZXcgVG9rZW5UeXBlKFwiLFwiLCBiZWZvcmVFeHByKSxcbiAgICBzZW1pOiBuZXcgVG9rZW5UeXBlKFwiO1wiLCBiZWZvcmVFeHByKSxcbiAgICBjb2xvbjogbmV3IFRva2VuVHlwZShcIjpcIiwgYmVmb3JlRXhwciksXG4gICAgZG90OiBuZXcgVG9rZW5UeXBlKFwiLlwiKSxcbiAgICBxdWVzdGlvbjogbmV3IFRva2VuVHlwZShcIj9cIiwgYmVmb3JlRXhwciksXG4gICAgcXVlc3Rpb25Eb3Q6IG5ldyBUb2tlblR5cGUoXCI/LlwiKSxcbiAgICBhcnJvdzogbmV3IFRva2VuVHlwZShcIj0+XCIsIGJlZm9yZUV4cHIpLFxuICAgIHRlbXBsYXRlOiBuZXcgVG9rZW5UeXBlKFwidGVtcGxhdGVcIiksXG4gICAgaW52YWxpZFRlbXBsYXRlOiBuZXcgVG9rZW5UeXBlKFwiaW52YWxpZFRlbXBsYXRlXCIpLFxuICAgIGVsbGlwc2lzOiBuZXcgVG9rZW5UeXBlKFwiLi4uXCIsIGJlZm9yZUV4cHIpLFxuICAgIGJhY2tRdW90ZTogbmV3IFRva2VuVHlwZShcImBcIiwgc3RhcnRzRXhwciksXG4gICAgZG9sbGFyQnJhY2VMOiBuZXcgVG9rZW5UeXBlKFwiJHtcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcblxuICAgIC8vIE9wZXJhdG9ycy4gVGhlc2UgY2Fycnkgc2V2ZXJhbCBraW5kcyBvZiBwcm9wZXJ0aWVzIHRvIGhlbHAgdGhlXG4gICAgLy8gcGFyc2VyIHVzZSB0aGVtIHByb3Blcmx5ICh0aGUgcHJlc2VuY2Ugb2YgdGhlc2UgcHJvcGVydGllcyBpc1xuICAgIC8vIHdoYXQgY2F0ZWdvcml6ZXMgdGhlbSBhcyBvcGVyYXRvcnMpLlxuICAgIC8vXG4gICAgLy8gYGJpbm9wYCwgd2hlbiBwcmVzZW50LCBzcGVjaWZpZXMgdGhhdCB0aGlzIG9wZXJhdG9yIGlzIGEgYmluYXJ5XG4gICAgLy8gb3BlcmF0b3IsIGFuZCB3aWxsIHJlZmVyIHRvIGl0cyBwcmVjZWRlbmNlLlxuICAgIC8vXG4gICAgLy8gYHByZWZpeGAgYW5kIGBwb3N0Zml4YCBtYXJrIHRoZSBvcGVyYXRvciBhcyBhIHByZWZpeCBvciBwb3N0Zml4XG4gICAgLy8gdW5hcnkgb3BlcmF0b3IuXG4gICAgLy9cbiAgICAvLyBgaXNBc3NpZ25gIG1hcmtzIGFsbCBvZiBgPWAsIGArPWAsIGAtPWAgZXRjZXRlcmEsIHdoaWNoIGFjdCBhc1xuICAgIC8vIGJpbmFyeSBvcGVyYXRvcnMgd2l0aCBhIHZlcnkgbG93IHByZWNlZGVuY2UsIHRoYXQgc2hvdWxkIHJlc3VsdFxuICAgIC8vIGluIEFzc2lnbm1lbnRFeHByZXNzaW9uIG5vZGVzLlxuXG4gICAgZXE6IG5ldyBUb2tlblR5cGUoXCI9XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBpc0Fzc2lnbjogdHJ1ZX0pLFxuICAgIGFzc2lnbjogbmV3IFRva2VuVHlwZShcIl89XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBpc0Fzc2lnbjogdHJ1ZX0pLFxuICAgIGluY0RlYzogbmV3IFRva2VuVHlwZShcIisrLy0tXCIsIHtwcmVmaXg6IHRydWUsIHBvc3RmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBwcmVmaXg6IG5ldyBUb2tlblR5cGUoXCIhL35cIiwge2JlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIGxvZ2ljYWxPUjogYmlub3AoXCJ8fFwiLCAxKSxcbiAgICBsb2dpY2FsQU5EOiBiaW5vcChcIiYmXCIsIDIpLFxuICAgIGJpdHdpc2VPUjogYmlub3AoXCJ8XCIsIDMpLFxuICAgIGJpdHdpc2VYT1I6IGJpbm9wKFwiXlwiLCA0KSxcbiAgICBiaXR3aXNlQU5EOiBiaW5vcChcIiZcIiwgNSksXG4gICAgZXF1YWxpdHk6IGJpbm9wKFwiPT0vIT0vPT09LyE9PVwiLCA2KSxcbiAgICByZWxhdGlvbmFsOiBiaW5vcChcIjwvPi88PS8+PVwiLCA3KSxcbiAgICBiaXRTaGlmdDogYmlub3AoXCI8PC8+Pi8+Pj5cIiwgOCksXG4gICAgcGx1c01pbjogbmV3IFRva2VuVHlwZShcIisvLVwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IDksIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIG1vZHVsbzogYmlub3AoXCIlXCIsIDEwKSxcbiAgICBzdGFyOiBiaW5vcChcIipcIiwgMTApLFxuICAgIHNsYXNoOiBiaW5vcChcIi9cIiwgMTApLFxuICAgIHN0YXJzdGFyOiBuZXcgVG9rZW5UeXBlKFwiKipcIiwge2JlZm9yZUV4cHI6IHRydWV9KSxcbiAgICBjb2FsZXNjZTogYmlub3AoXCI/P1wiLCAxKSxcblxuICAgIC8vIEtleXdvcmQgdG9rZW4gdHlwZXMuXG4gICAgX2JyZWFrOiBrdyhcImJyZWFrXCIpLFxuICAgIF9jYXNlOiBrdyhcImNhc2VcIiwgYmVmb3JlRXhwciksXG4gICAgX2NhdGNoOiBrdyhcImNhdGNoXCIpLFxuICAgIF9jb250aW51ZToga3coXCJjb250aW51ZVwiKSxcbiAgICBfZGVidWdnZXI6IGt3KFwiZGVidWdnZXJcIiksXG4gICAgX2RlZmF1bHQ6IGt3KFwiZGVmYXVsdFwiLCBiZWZvcmVFeHByKSxcbiAgICBfZG86IGt3KFwiZG9cIiwge2lzTG9vcDogdHJ1ZSwgYmVmb3JlRXhwcjogdHJ1ZX0pLFxuICAgIF9lbHNlOiBrdyhcImVsc2VcIiwgYmVmb3JlRXhwciksXG4gICAgX2ZpbmFsbHk6IGt3KFwiZmluYWxseVwiKSxcbiAgICBfZm9yOiBrdyhcImZvclwiLCB7aXNMb29wOiB0cnVlfSksXG4gICAgX2Z1bmN0aW9uOiBrdyhcImZ1bmN0aW9uXCIsIHN0YXJ0c0V4cHIpLFxuICAgIF9pZjoga3coXCJpZlwiKSxcbiAgICBfcmV0dXJuOiBrdyhcInJldHVyblwiLCBiZWZvcmVFeHByKSxcbiAgICBfc3dpdGNoOiBrdyhcInN3aXRjaFwiKSxcbiAgICBfdGhyb3c6IGt3KFwidGhyb3dcIiwgYmVmb3JlRXhwciksXG4gICAgX3RyeToga3coXCJ0cnlcIiksXG4gICAgX3Zhcjoga3coXCJ2YXJcIiksXG4gICAgX2NvbnN0OiBrdyhcImNvbnN0XCIpLFxuICAgIF93aGlsZToga3coXCJ3aGlsZVwiLCB7aXNMb29wOiB0cnVlfSksXG4gICAgX3dpdGg6IGt3KFwid2l0aFwiKSxcbiAgICBfbmV3OiBrdyhcIm5ld1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIF90aGlzOiBrdyhcInRoaXNcIiwgc3RhcnRzRXhwciksXG4gICAgX3N1cGVyOiBrdyhcInN1cGVyXCIsIHN0YXJ0c0V4cHIpLFxuICAgIF9jbGFzczoga3coXCJjbGFzc1wiLCBzdGFydHNFeHByKSxcbiAgICBfZXh0ZW5kczoga3coXCJleHRlbmRzXCIsIGJlZm9yZUV4cHIpLFxuICAgIF9leHBvcnQ6IGt3KFwiZXhwb3J0XCIpLFxuICAgIF9pbXBvcnQ6IGt3KFwiaW1wb3J0XCIsIHN0YXJ0c0V4cHIpLFxuICAgIF9udWxsOiBrdyhcIm51bGxcIiwgc3RhcnRzRXhwciksXG4gICAgX3RydWU6IGt3KFwidHJ1ZVwiLCBzdGFydHNFeHByKSxcbiAgICBfZmFsc2U6IGt3KFwiZmFsc2VcIiwgc3RhcnRzRXhwciksXG4gICAgX2luOiBrdyhcImluXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogN30pLFxuICAgIF9pbnN0YW5jZW9mOiBrdyhcImluc3RhbmNlb2ZcIiwge2JlZm9yZUV4cHI6IHRydWUsIGJpbm9wOiA3fSksXG4gICAgX3R5cGVvZjoga3coXCJ0eXBlb2ZcIiwge2JlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIF92b2lkOiBrdyhcInZvaWRcIiwge2JlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIF9kZWxldGU6IGt3KFwiZGVsZXRlXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KVxuICB9O1xuXG4gIC8vIE1hdGNoZXMgYSB3aG9sZSBsaW5lIGJyZWFrICh3aGVyZSBDUkxGIGlzIGNvbnNpZGVyZWQgYSBzaW5nbGVcbiAgLy8gbGluZSBicmVhaykuIFVzZWQgdG8gY291bnQgbGluZXMuXG5cbiAgdmFyIGxpbmVCcmVhayA9IC9cXHJcXG4/fFxcbnxcXHUyMDI4fFxcdTIwMjkvO1xuICB2YXIgbGluZUJyZWFrRyA9IG5ldyBSZWdFeHAobGluZUJyZWFrLnNvdXJjZSwgXCJnXCIpO1xuXG4gIGZ1bmN0aW9uIGlzTmV3TGluZShjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPT09IDEwIHx8IGNvZGUgPT09IDEzIHx8IGNvZGUgPT09IDB4MjAyOCB8fCBjb2RlID09PSAweDIwMjlcbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHRMaW5lQnJlYWsoY29kZSwgZnJvbSwgZW5kKSB7XG4gICAgaWYgKCBlbmQgPT09IHZvaWQgMCApIGVuZCA9IGNvZGUubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IGZyb207IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdmFyIG5leHQgPSBjb2RlLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoaXNOZXdMaW5lKG5leHQpKVxuICAgICAgICB7IHJldHVybiBpIDwgZW5kIC0gMSAmJiBuZXh0ID09PSAxMyAmJiBjb2RlLmNoYXJDb2RlQXQoaSArIDEpID09PSAxMCA/IGkgKyAyIDogaSArIDEgfVxuICAgIH1cbiAgICByZXR1cm4gLTFcbiAgfVxuXG4gIHZhciBub25BU0NJSXdoaXRlc3BhY2UgPSAvW1xcdTE2ODBcXHUyMDAwLVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVmZWZmXS87XG5cbiAgdmFyIHNraXBXaGl0ZVNwYWNlID0gLyg/Olxcc3xcXC9cXC8uKnxcXC9cXCpbXl0qP1xcKlxcLykqL2c7XG5cbiAgdmFyIHJlZiA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IHJlZi5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHRvU3RyaW5nID0gcmVmLnRvU3RyaW5nO1xuXG4gIHZhciBoYXNPd24gPSBPYmplY3QuaGFzT3duIHx8IChmdW5jdGlvbiAob2JqLCBwcm9wTmFtZSkgeyByZXR1cm4gKFxuICAgIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wTmFtZSlcbiAgKTsgfSk7XG5cbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IChmdW5jdGlvbiAob2JqKSB7IHJldHVybiAoXG4gICAgdG9TdHJpbmcuY2FsbChvYmopID09PSBcIltvYmplY3QgQXJyYXldXCJcbiAgKTsgfSk7XG5cbiAgdmFyIHJlZ2V4cENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmdW5jdGlvbiB3b3Jkc1JlZ2V4cCh3b3Jkcykge1xuICAgIHJldHVybiByZWdleHBDYWNoZVt3b3Jkc10gfHwgKHJlZ2V4cENhY2hlW3dvcmRzXSA9IG5ldyBSZWdFeHAoXCJeKD86XCIgKyB3b3Jkcy5yZXBsYWNlKC8gL2csIFwifFwiKSArIFwiKSRcIikpXG4gIH1cblxuICBmdW5jdGlvbiBjb2RlUG9pbnRUb1N0cmluZyhjb2RlKSB7XG4gICAgLy8gVVRGLTE2IERlY29kaW5nXG4gICAgaWYgKGNvZGUgPD0gMHhGRkZGKSB7IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpIH1cbiAgICBjb2RlIC09IDB4MTAwMDA7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKGNvZGUgPj4gMTApICsgMHhEODAwLCAoY29kZSAmIDEwMjMpICsgMHhEQzAwKVxuICB9XG5cbiAgdmFyIGxvbmVTdXJyb2dhdGUgPSAvKD86W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0pLztcblxuICAvLyBUaGVzZSBhcmUgdXNlZCB3aGVuIGBvcHRpb25zLmxvY2F0aW9uc2AgaXMgb24sIGZvciB0aGVcbiAgLy8gYHN0YXJ0TG9jYCBhbmQgYGVuZExvY2AgcHJvcGVydGllcy5cblxuICB2YXIgUG9zaXRpb24gPSBmdW5jdGlvbiBQb3NpdGlvbihsaW5lLCBjb2wpIHtcbiAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgIHRoaXMuY29sdW1uID0gY29sO1xuICB9O1xuXG4gIFBvc2l0aW9uLnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbiBvZmZzZXQgKG4pIHtcbiAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHRoaXMubGluZSwgdGhpcy5jb2x1bW4gKyBuKVxuICB9O1xuXG4gIHZhciBTb3VyY2VMb2NhdGlvbiA9IGZ1bmN0aW9uIFNvdXJjZUxvY2F0aW9uKHAsIHN0YXJ0LCBlbmQpIHtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgaWYgKHAuc291cmNlRmlsZSAhPT0gbnVsbCkgeyB0aGlzLnNvdXJjZSA9IHAuc291cmNlRmlsZTsgfVxuICB9O1xuXG4gIC8vIFRoZSBgZ2V0TGluZUluZm9gIGZ1bmN0aW9uIGlzIG1vc3RseSB1c2VmdWwgd2hlbiB0aGVcbiAgLy8gYGxvY2F0aW9uc2Agb3B0aW9uIGlzIG9mZiAoZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMpIGFuZCB5b3VcbiAgLy8gd2FudCB0byBmaW5kIHRoZSBsaW5lL2NvbHVtbiBwb3NpdGlvbiBmb3IgYSBnaXZlbiBjaGFyYWN0ZXJcbiAgLy8gb2Zmc2V0LiBgaW5wdXRgIHNob3VsZCBiZSB0aGUgY29kZSBzdHJpbmcgdGhhdCB0aGUgb2Zmc2V0IHJlZmVyc1xuICAvLyBpbnRvLlxuXG4gIGZ1bmN0aW9uIGdldExpbmVJbmZvKGlucHV0LCBvZmZzZXQpIHtcbiAgICBmb3IgKHZhciBsaW5lID0gMSwgY3VyID0gMDs7KSB7XG4gICAgICB2YXIgbmV4dEJyZWFrID0gbmV4dExpbmVCcmVhayhpbnB1dCwgY3VyLCBvZmZzZXQpO1xuICAgICAgaWYgKG5leHRCcmVhayA8IDApIHsgcmV0dXJuIG5ldyBQb3NpdGlvbihsaW5lLCBvZmZzZXQgLSBjdXIpIH1cbiAgICAgICsrbGluZTtcbiAgICAgIGN1ciA9IG5leHRCcmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBBIHNlY29uZCBhcmd1bWVudCBtdXN0IGJlIGdpdmVuIHRvIGNvbmZpZ3VyZSB0aGUgcGFyc2VyIHByb2Nlc3MuXG4gIC8vIFRoZXNlIG9wdGlvbnMgYXJlIHJlY29nbml6ZWQgKG9ubHkgYGVjbWFWZXJzaW9uYCBpcyByZXF1aXJlZCk6XG5cbiAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgIC8vIGBlY21hVmVyc2lvbmAgaW5kaWNhdGVzIHRoZSBFQ01BU2NyaXB0IHZlcnNpb24gdG8gcGFyc2UuIE11c3QgYmVcbiAgICAvLyBlaXRoZXIgMywgNSwgNiAob3IgMjAxNSksIDcgKDIwMTYpLCA4ICgyMDE3KSwgOSAoMjAxOCksIDEwXG4gICAgLy8gKDIwMTkpLCAxMSAoMjAyMCksIDEyICgyMDIxKSwgMTMgKDIwMjIpLCAxNCAoMjAyMyksIG9yIGBcImxhdGVzdFwiYFxuICAgIC8vICh0aGUgbGF0ZXN0IHZlcnNpb24gdGhlIGxpYnJhcnkgc3VwcG9ydHMpLiBUaGlzIGluZmx1ZW5jZXNcbiAgICAvLyBzdXBwb3J0IGZvciBzdHJpY3QgbW9kZSwgdGhlIHNldCBvZiByZXNlcnZlZCB3b3JkcywgYW5kIHN1cHBvcnRcbiAgICAvLyBmb3IgbmV3IHN5bnRheCBmZWF0dXJlcy5cbiAgICBlY21hVmVyc2lvbjogbnVsbCxcbiAgICAvLyBgc291cmNlVHlwZWAgaW5kaWNhdGVzIHRoZSBtb2RlIHRoZSBjb2RlIHNob3VsZCBiZSBwYXJzZWQgaW4uXG4gICAgLy8gQ2FuIGJlIGVpdGhlciBgXCJzY3JpcHRcImAgb3IgYFwibW9kdWxlXCJgLiBUaGlzIGluZmx1ZW5jZXMgZ2xvYmFsXG4gICAgLy8gc3RyaWN0IG1vZGUgYW5kIHBhcnNpbmcgb2YgYGltcG9ydGAgYW5kIGBleHBvcnRgIGRlY2xhcmF0aW9ucy5cbiAgICBzb3VyY2VUeXBlOiBcInNjcmlwdFwiLFxuICAgIC8vIGBvbkluc2VydGVkU2VtaWNvbG9uYCBjYW4gYmUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgICAvLyBhIHNlbWljb2xvbiBpcyBhdXRvbWF0aWNhbGx5IGluc2VydGVkLiBJdCB3aWxsIGJlIHBhc3NlZCB0aGVcbiAgICAvLyBwb3NpdGlvbiBvZiB0aGUgaW5zZXJ0ZWQgc2VtaWNvbG9uIGFzIGFuIG9mZnNldCwgYW5kIGlmXG4gICAgLy8gYGxvY2F0aW9uc2AgaXMgZW5hYmxlZCwgaXQgaXMgZ2l2ZW4gdGhlIGxvY2F0aW9uIGFzIGEgYHtsaW5lLFxuICAgIC8vIGNvbHVtbn1gIG9iamVjdCBhcyBzZWNvbmQgYXJndW1lbnQuXG4gICAgb25JbnNlcnRlZFNlbWljb2xvbjogbnVsbCxcbiAgICAvLyBgb25UcmFpbGluZ0NvbW1hYCBpcyBzaW1pbGFyIHRvIGBvbkluc2VydGVkU2VtaWNvbG9uYCwgYnV0IGZvclxuICAgIC8vIHRyYWlsaW5nIGNvbW1hcy5cbiAgICBvblRyYWlsaW5nQ29tbWE6IG51bGwsXG4gICAgLy8gQnkgZGVmYXVsdCwgcmVzZXJ2ZWQgd29yZHMgYXJlIG9ubHkgZW5mb3JjZWQgaWYgZWNtYVZlcnNpb24gPj0gNS5cbiAgICAvLyBTZXQgYGFsbG93UmVzZXJ2ZWRgIHRvIGEgYm9vbGVhbiB2YWx1ZSB0byBleHBsaWNpdGx5IHR1cm4gdGhpcyBvblxuICAgIC8vIGFuIG9mZi4gV2hlbiB0aGlzIG9wdGlvbiBoYXMgdGhlIHZhbHVlIFwibmV2ZXJcIiwgcmVzZXJ2ZWQgd29yZHNcbiAgICAvLyBhbmQga2V5d29yZHMgY2FuIGFsc28gbm90IGJlIHVzZWQgYXMgcHJvcGVydHkgbmFtZXMuXG4gICAgYWxsb3dSZXNlcnZlZDogbnVsbCxcbiAgICAvLyBXaGVuIGVuYWJsZWQsIGEgcmV0dXJuIGF0IHRoZSB0b3AgbGV2ZWwgaXMgbm90IGNvbnNpZGVyZWQgYW5cbiAgICAvLyBlcnJvci5cbiAgICBhbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbjogZmFsc2UsXG4gICAgLy8gV2hlbiBlbmFibGVkLCBpbXBvcnQvZXhwb3J0IHN0YXRlbWVudHMgYXJlIG5vdCBjb25zdHJhaW5lZCB0b1xuICAgIC8vIGFwcGVhcmluZyBhdCB0aGUgdG9wIG9mIHRoZSBwcm9ncmFtLCBhbmQgYW4gaW1wb3J0Lm1ldGEgZXhwcmVzc2lvblxuICAgIC8vIGluIGEgc2NyaXB0IGlzbid0IGNvbnNpZGVyZWQgYW4gZXJyb3IuXG4gICAgYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlOiBmYWxzZSxcbiAgICAvLyBCeSBkZWZhdWx0LCBhd2FpdCBpZGVudGlmaWVycyBhcmUgYWxsb3dlZCB0byBhcHBlYXIgYXQgdGhlIHRvcC1sZXZlbCBzY29wZSBvbmx5IGlmIGVjbWFWZXJzaW9uID49IDIwMjIuXG4gICAgLy8gV2hlbiBlbmFibGVkLCBhd2FpdCBpZGVudGlmaWVycyBhcmUgYWxsb3dlZCB0byBhcHBlYXIgYXQgdGhlIHRvcC1sZXZlbCBzY29wZSxcbiAgICAvLyBidXQgdGhleSBhcmUgc3RpbGwgbm90IGFsbG93ZWQgaW4gbm9uLWFzeW5jIGZ1bmN0aW9ucy5cbiAgICBhbGxvd0F3YWl0T3V0c2lkZUZ1bmN0aW9uOiBudWxsLFxuICAgIC8vIFdoZW4gZW5hYmxlZCwgc3VwZXIgaWRlbnRpZmllcnMgYXJlIG5vdCBjb25zdHJhaW5lZCB0b1xuICAgIC8vIGFwcGVhcmluZyBpbiBtZXRob2RzIGFuZCBkbyBub3QgcmFpc2UgYW4gZXJyb3Igd2hlbiB0aGV5IGFwcGVhciBlbHNld2hlcmUuXG4gICAgYWxsb3dTdXBlck91dHNpZGVNZXRob2Q6IG51bGwsXG4gICAgLy8gV2hlbiBlbmFibGVkLCBoYXNoYmFuZyBkaXJlY3RpdmUgaW4gdGhlIGJlZ2lubmluZyBvZiBmaWxlIGlzXG4gICAgLy8gYWxsb3dlZCBhbmQgdHJlYXRlZCBhcyBhIGxpbmUgY29tbWVudC4gRW5hYmxlZCBieSBkZWZhdWx0IHdoZW5cbiAgICAvLyBgZWNtYVZlcnNpb25gID49IDIwMjMuXG4gICAgYWxsb3dIYXNoQmFuZzogZmFsc2UsXG4gICAgLy8gQnkgZGVmYXVsdCwgdGhlIHBhcnNlciB3aWxsIHZlcmlmeSB0aGF0IHByaXZhdGUgcHJvcGVydGllcyBhcmVcbiAgICAvLyBvbmx5IHVzZWQgaW4gcGxhY2VzIHdoZXJlIHRoZXkgYXJlIHZhbGlkIGFuZCBoYXZlIGJlZW4gZGVjbGFyZWQuXG4gICAgLy8gU2V0IHRoaXMgdG8gZmFsc2UgdG8gdHVybiBzdWNoIGNoZWNrcyBvZmYuXG4gICAgY2hlY2tQcml2YXRlRmllbGRzOiB0cnVlLFxuICAgIC8vIFdoZW4gYGxvY2F0aW9uc2AgaXMgb24sIGBsb2NgIHByb3BlcnRpZXMgaG9sZGluZyBvYmplY3RzIHdpdGhcbiAgICAvLyBgc3RhcnRgIGFuZCBgZW5kYCBwcm9wZXJ0aWVzIGluIGB7bGluZSwgY29sdW1ufWAgZm9ybSAod2l0aFxuICAgIC8vIGxpbmUgYmVpbmcgMS1iYXNlZCBhbmQgY29sdW1uIDAtYmFzZWQpIHdpbGwgYmUgYXR0YWNoZWQgdG8gdGhlXG4gICAgLy8gbm9kZXMuXG4gICAgbG9jYXRpb25zOiBmYWxzZSxcbiAgICAvLyBBIGZ1bmN0aW9uIGNhbiBiZSBwYXNzZWQgYXMgYG9uVG9rZW5gIG9wdGlvbiwgd2hpY2ggd2lsbFxuICAgIC8vIGNhdXNlIEFjb3JuIHRvIGNhbGwgdGhhdCBmdW5jdGlvbiB3aXRoIG9iamVjdCBpbiB0aGUgc2FtZVxuICAgIC8vIGZvcm1hdCBhcyB0b2tlbnMgcmV0dXJuZWQgZnJvbSBgdG9rZW5pemVyKCkuZ2V0VG9rZW4oKWAuIE5vdGVcbiAgICAvLyB0aGF0IHlvdSBhcmUgbm90IGFsbG93ZWQgdG8gY2FsbCB0aGUgcGFyc2VyIGZyb20gdGhlXG4gICAgLy8gY2FsbGJhY2vigJR0aGF0IHdpbGwgY29ycnVwdCBpdHMgaW50ZXJuYWwgc3RhdGUuXG4gICAgb25Ub2tlbjogbnVsbCxcbiAgICAvLyBBIGZ1bmN0aW9uIGNhbiBiZSBwYXNzZWQgYXMgYG9uQ29tbWVudGAgb3B0aW9uLCB3aGljaCB3aWxsXG4gICAgLy8gY2F1c2UgQWNvcm4gdG8gY2FsbCB0aGF0IGZ1bmN0aW9uIHdpdGggYChibG9jaywgdGV4dCwgc3RhcnQsXG4gICAgLy8gZW5kKWAgcGFyYW1ldGVycyB3aGVuZXZlciBhIGNvbW1lbnQgaXMgc2tpcHBlZC4gYGJsb2NrYCBpcyBhXG4gICAgLy8gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBpcyBhIGJsb2NrIChgLyogKi9gKSBjb21tZW50LFxuICAgIC8vIGB0ZXh0YCBpcyB0aGUgY29udGVudCBvZiB0aGUgY29tbWVudCwgYW5kIGBzdGFydGAgYW5kIGBlbmRgIGFyZVxuICAgIC8vIGNoYXJhY3RlciBvZmZzZXRzIHRoYXQgZGVub3RlIHRoZSBzdGFydCBhbmQgZW5kIG9mIHRoZSBjb21tZW50LlxuICAgIC8vIFdoZW4gdGhlIGBsb2NhdGlvbnNgIG9wdGlvbiBpcyBvbiwgdHdvIG1vcmUgcGFyYW1ldGVycyBhcmVcbiAgICAvLyBwYXNzZWQsIHRoZSBmdWxsIGB7bGluZSwgY29sdW1ufWAgbG9jYXRpb25zIG9mIHRoZSBzdGFydCBhbmRcbiAgICAvLyBlbmQgb2YgdGhlIGNvbW1lbnRzLiBOb3RlIHRoYXQgeW91IGFyZSBub3QgYWxsb3dlZCB0byBjYWxsIHRoZVxuICAgIC8vIHBhcnNlciBmcm9tIHRoZSBjYWxsYmFja+KAlHRoYXQgd2lsbCBjb3JydXB0IGl0cyBpbnRlcm5hbCBzdGF0ZS5cbiAgICAvLyBXaGVuIHRoaXMgb3B0aW9uIGhhcyBhbiBhcnJheSBhcyB2YWx1ZSwgb2JqZWN0cyByZXByZXNlbnRpbmcgdGhlXG4gICAgLy8gY29tbWVudHMgYXJlIHB1c2hlZCB0byBpdC5cbiAgICBvbkNvbW1lbnQ6IG51bGwsXG4gICAgLy8gTm9kZXMgaGF2ZSB0aGVpciBzdGFydCBhbmQgZW5kIGNoYXJhY3RlcnMgb2Zmc2V0cyByZWNvcmRlZCBpblxuICAgIC8vIGBzdGFydGAgYW5kIGBlbmRgIHByb3BlcnRpZXMgKGRpcmVjdGx5IG9uIHRoZSBub2RlLCByYXRoZXIgdGhhblxuICAgIC8vIHRoZSBgbG9jYCBvYmplY3QsIHdoaWNoIGhvbGRzIGxpbmUvY29sdW1uIGRhdGEuIFRvIGFsc28gYWRkIGFcbiAgICAvLyBbc2VtaS1zdGFuZGFyZGl6ZWRdW3JhbmdlXSBgcmFuZ2VgIHByb3BlcnR5IGhvbGRpbmcgYSBgW3N0YXJ0LFxuICAgIC8vIGVuZF1gIGFycmF5IHdpdGggdGhlIHNhbWUgbnVtYmVycywgc2V0IHRoZSBgcmFuZ2VzYCBvcHRpb24gdG9cbiAgICAvLyBgdHJ1ZWAuXG4gICAgLy9cbiAgICAvLyBbcmFuZ2VdOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD03NDU2NzhcbiAgICByYW5nZXM6IGZhbHNlLFxuICAgIC8vIEl0IGlzIHBvc3NpYmxlIHRvIHBhcnNlIG11bHRpcGxlIGZpbGVzIGludG8gYSBzaW5nbGUgQVNUIGJ5XG4gICAgLy8gcGFzc2luZyB0aGUgdHJlZSBwcm9kdWNlZCBieSBwYXJzaW5nIHRoZSBmaXJzdCBmaWxlIGFzXG4gICAgLy8gYHByb2dyYW1gIG9wdGlvbiBpbiBzdWJzZXF1ZW50IHBhcnNlcy4gVGhpcyB3aWxsIGFkZCB0aGVcbiAgICAvLyB0b3BsZXZlbCBmb3JtcyBvZiB0aGUgcGFyc2VkIGZpbGUgdG8gdGhlIGBQcm9ncmFtYCAodG9wKSBub2RlXG4gICAgLy8gb2YgYW4gZXhpc3RpbmcgcGFyc2UgdHJlZS5cbiAgICBwcm9ncmFtOiBudWxsLFxuICAgIC8vIFdoZW4gYGxvY2F0aW9uc2AgaXMgb24sIHlvdSBjYW4gcGFzcyB0aGlzIHRvIHJlY29yZCB0aGUgc291cmNlXG4gICAgLy8gZmlsZSBpbiBldmVyeSBub2RlJ3MgYGxvY2Agb2JqZWN0LlxuICAgIHNvdXJjZUZpbGU6IG51bGwsXG4gICAgLy8gVGhpcyB2YWx1ZSwgaWYgZ2l2ZW4sIGlzIHN0b3JlZCBpbiBldmVyeSBub2RlLCB3aGV0aGVyXG4gICAgLy8gYGxvY2F0aW9uc2AgaXMgb24gb3Igb2ZmLlxuICAgIGRpcmVjdFNvdXJjZUZpbGU6IG51bGwsXG4gICAgLy8gV2hlbiBlbmFibGVkLCBwYXJlbnRoZXNpemVkIGV4cHJlc3Npb25zIGFyZSByZXByZXNlbnRlZCBieVxuICAgIC8vIChub24tc3RhbmRhcmQpIFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uIG5vZGVzXG4gICAgcHJlc2VydmVQYXJlbnM6IGZhbHNlXG4gIH07XG5cbiAgLy8gSW50ZXJwcmV0IGFuZCBkZWZhdWx0IGFuIG9wdGlvbnMgb2JqZWN0XG5cbiAgdmFyIHdhcm5lZEFib3V0RWNtYVZlcnNpb24gPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnZXRPcHRpb25zKG9wdHMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuXG4gICAgZm9yICh2YXIgb3B0IGluIGRlZmF1bHRPcHRpb25zKVxuICAgICAgeyBvcHRpb25zW29wdF0gPSBvcHRzICYmIGhhc093bihvcHRzLCBvcHQpID8gb3B0c1tvcHRdIDogZGVmYXVsdE9wdGlvbnNbb3B0XTsgfVxuXG4gICAgaWYgKG9wdGlvbnMuZWNtYVZlcnNpb24gPT09IFwibGF0ZXN0XCIpIHtcbiAgICAgIG9wdGlvbnMuZWNtYVZlcnNpb24gPSAxZTg7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmVjbWFWZXJzaW9uID09IG51bGwpIHtcbiAgICAgIGlmICghd2FybmVkQWJvdXRFY21hVmVyc2lvbiAmJiB0eXBlb2YgY29uc29sZSA9PT0gXCJvYmplY3RcIiAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgd2FybmVkQWJvdXRFY21hVmVyc2lvbiA9IHRydWU7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlNpbmNlIEFjb3JuIDguMC4wLCBvcHRpb25zLmVjbWFWZXJzaW9uIGlzIHJlcXVpcmVkLlxcbkRlZmF1bHRpbmcgdG8gMjAyMCwgYnV0IHRoaXMgd2lsbCBzdG9wIHdvcmtpbmcgaW4gdGhlIGZ1dHVyZS5cIik7XG4gICAgICB9XG4gICAgICBvcHRpb25zLmVjbWFWZXJzaW9uID0gMTE7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmVjbWFWZXJzaW9uID49IDIwMTUpIHtcbiAgICAgIG9wdGlvbnMuZWNtYVZlcnNpb24gLT0gMjAwOTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5hbGxvd1Jlc2VydmVkID09IG51bGwpXG4gICAgICB7IG9wdGlvbnMuYWxsb3dSZXNlcnZlZCA9IG9wdGlvbnMuZWNtYVZlcnNpb24gPCA1OyB9XG5cbiAgICBpZiAoIW9wdHMgfHwgb3B0cy5hbGxvd0hhc2hCYW5nID09IG51bGwpXG4gICAgICB7IG9wdGlvbnMuYWxsb3dIYXNoQmFuZyA9IG9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTQ7IH1cblxuICAgIGlmIChpc0FycmF5KG9wdGlvbnMub25Ub2tlbikpIHtcbiAgICAgIHZhciB0b2tlbnMgPSBvcHRpb25zLm9uVG9rZW47XG4gICAgICBvcHRpb25zLm9uVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHRva2Vucy5wdXNoKHRva2VuKTsgfTtcbiAgICB9XG4gICAgaWYgKGlzQXJyYXkob3B0aW9ucy5vbkNvbW1lbnQpKVxuICAgICAgeyBvcHRpb25zLm9uQ29tbWVudCA9IHB1c2hDb21tZW50KG9wdGlvbnMsIG9wdGlvbnMub25Db21tZW50KTsgfVxuXG4gICAgcmV0dXJuIG9wdGlvbnNcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hDb21tZW50KG9wdGlvbnMsIGFycmF5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGJsb2NrLCB0ZXh0LCBzdGFydCwgZW5kLCBzdGFydExvYywgZW5kTG9jKSB7XG4gICAgICB2YXIgY29tbWVudCA9IHtcbiAgICAgICAgdHlwZTogYmxvY2sgPyBcIkJsb2NrXCIgOiBcIkxpbmVcIixcbiAgICAgICAgdmFsdWU6IHRleHQsXG4gICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgZW5kOiBlbmRcbiAgICAgIH07XG4gICAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgICAgIHsgY29tbWVudC5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24odGhpcywgc3RhcnRMb2MsIGVuZExvYyk7IH1cbiAgICAgIGlmIChvcHRpb25zLnJhbmdlcylcbiAgICAgICAgeyBjb21tZW50LnJhbmdlID0gW3N0YXJ0LCBlbmRdOyB9XG4gICAgICBhcnJheS5wdXNoKGNvbW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEVhY2ggc2NvcGUgZ2V0cyBhIGJpdHNldCB0aGF0IG1heSBjb250YWluIHRoZXNlIGZsYWdzXG4gIHZhclxuICAgICAgU0NPUEVfVE9QID0gMSxcbiAgICAgIFNDT1BFX0ZVTkNUSU9OID0gMixcbiAgICAgIFNDT1BFX0FTWU5DID0gNCxcbiAgICAgIFNDT1BFX0dFTkVSQVRPUiA9IDgsXG4gICAgICBTQ09QRV9BUlJPVyA9IDE2LFxuICAgICAgU0NPUEVfU0lNUExFX0NBVENIID0gMzIsXG4gICAgICBTQ09QRV9TVVBFUiA9IDY0LFxuICAgICAgU0NPUEVfRElSRUNUX1NVUEVSID0gMTI4LFxuICAgICAgU0NPUEVfQ0xBU1NfU1RBVElDX0JMT0NLID0gMjU2LFxuICAgICAgU0NPUEVfQ0xBU1NfRklFTERfSU5JVCA9IDUxMixcbiAgICAgIFNDT1BFX1ZBUiA9IFNDT1BFX1RPUCB8IFNDT1BFX0ZVTkNUSU9OIHwgU0NPUEVfQ0xBU1NfU1RBVElDX0JMT0NLO1xuXG4gIGZ1bmN0aW9uIGZ1bmN0aW9uRmxhZ3MoYXN5bmMsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBTQ09QRV9GVU5DVElPTiB8IChhc3luYyA/IFNDT1BFX0FTWU5DIDogMCkgfCAoZ2VuZXJhdG9yID8gU0NPUEVfR0VORVJBVE9SIDogMClcbiAgfVxuXG4gIC8vIFVzZWQgaW4gY2hlY2tMVmFsKiBhbmQgZGVjbGFyZU5hbWUgdG8gZGV0ZXJtaW5lIHRoZSB0eXBlIG9mIGEgYmluZGluZ1xuICB2YXJcbiAgICAgIEJJTkRfTk9ORSA9IDAsIC8vIE5vdCBhIGJpbmRpbmdcbiAgICAgIEJJTkRfVkFSID0gMSwgLy8gVmFyLXN0eWxlIGJpbmRpbmdcbiAgICAgIEJJTkRfTEVYSUNBTCA9IDIsIC8vIExldC0gb3IgY29uc3Qtc3R5bGUgYmluZGluZ1xuICAgICAgQklORF9GVU5DVElPTiA9IDMsIC8vIEZ1bmN0aW9uIGRlY2xhcmF0aW9uXG4gICAgICBCSU5EX1NJTVBMRV9DQVRDSCA9IDQsIC8vIFNpbXBsZSAoaWRlbnRpZmllciBwYXR0ZXJuKSBjYXRjaCBiaW5kaW5nXG4gICAgICBCSU5EX09VVFNJREUgPSA1OyAvLyBTcGVjaWFsIGNhc2UgZm9yIGZ1bmN0aW9uIG5hbWVzIGFzIGJvdW5kIGluc2lkZSB0aGUgZnVuY3Rpb25cblxuICB2YXIgUGFyc2VyID0gZnVuY3Rpb24gUGFyc2VyKG9wdGlvbnMsIGlucHV0LCBzdGFydFBvcykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgPSBnZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMuc291cmNlRmlsZSA9IG9wdGlvbnMuc291cmNlRmlsZTtcbiAgICB0aGlzLmtleXdvcmRzID0gd29yZHNSZWdleHAoa2V5d29yZHMkMVtvcHRpb25zLmVjbWFWZXJzaW9uID49IDYgPyA2IDogb3B0aW9ucy5zb3VyY2VUeXBlID09PSBcIm1vZHVsZVwiID8gXCI1bW9kdWxlXCIgOiA1XSk7XG4gICAgdmFyIHJlc2VydmVkID0gXCJcIjtcbiAgICBpZiAob3B0aW9ucy5hbGxvd1Jlc2VydmVkICE9PSB0cnVlKSB7XG4gICAgICByZXNlcnZlZCA9IHJlc2VydmVkV29yZHNbb3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ID8gNiA6IG9wdGlvbnMuZWNtYVZlcnNpb24gPT09IDUgPyA1IDogM107XG4gICAgICBpZiAob3B0aW9ucy5zb3VyY2VUeXBlID09PSBcIm1vZHVsZVwiKSB7IHJlc2VydmVkICs9IFwiIGF3YWl0XCI7IH1cbiAgICB9XG4gICAgdGhpcy5yZXNlcnZlZFdvcmRzID0gd29yZHNSZWdleHAocmVzZXJ2ZWQpO1xuICAgIHZhciByZXNlcnZlZFN0cmljdCA9IChyZXNlcnZlZCA/IHJlc2VydmVkICsgXCIgXCIgOiBcIlwiKSArIHJlc2VydmVkV29yZHMuc3RyaWN0O1xuICAgIHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdCA9IHdvcmRzUmVnZXhwKHJlc2VydmVkU3RyaWN0KTtcbiAgICB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3RCaW5kID0gd29yZHNSZWdleHAocmVzZXJ2ZWRTdHJpY3QgKyBcIiBcIiArIHJlc2VydmVkV29yZHMuc3RyaWN0QmluZCk7XG4gICAgdGhpcy5pbnB1dCA9IFN0cmluZyhpbnB1dCk7XG5cbiAgICAvLyBVc2VkIHRvIHNpZ25hbCB0byBjYWxsZXJzIG9mIGByZWFkV29yZDFgIHdoZXRoZXIgdGhlIHdvcmRcbiAgICAvLyBjb250YWluZWQgYW55IGVzY2FwZSBzZXF1ZW5jZXMuIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2Ugd29yZHMgd2l0aFxuICAgIC8vIGVzY2FwZSBzZXF1ZW5jZXMgbXVzdCBub3QgYmUgaW50ZXJwcmV0ZWQgYXMga2V5d29yZHMuXG4gICAgdGhpcy5jb250YWluc0VzYyA9IGZhbHNlO1xuXG4gICAgLy8gU2V0IHVwIHRva2VuIHN0YXRlXG5cbiAgICAvLyBUaGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgdG9rZW5pemVyIGluIHRoZSBpbnB1dC5cbiAgICBpZiAoc3RhcnRQb3MpIHtcbiAgICAgIHRoaXMucG9zID0gc3RhcnRQb3M7XG4gICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMuaW5wdXQubGFzdEluZGV4T2YoXCJcXG5cIiwgc3RhcnRQb3MgLSAxKSArIDE7XG4gICAgICB0aGlzLmN1ckxpbmUgPSB0aGlzLmlucHV0LnNsaWNlKDAsIHRoaXMubGluZVN0YXJ0KS5zcGxpdChsaW5lQnJlYWspLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wb3MgPSB0aGlzLmxpbmVTdGFydCA9IDA7XG4gICAgICB0aGlzLmN1ckxpbmUgPSAxO1xuICAgIH1cblxuICAgIC8vIFByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgdG9rZW46XG4gICAgLy8gSXRzIHR5cGVcbiAgICB0aGlzLnR5cGUgPSB0eXBlcyQxLmVvZjtcbiAgICAvLyBGb3IgdG9rZW5zIHRoYXQgaW5jbHVkZSBtb3JlIGluZm9ybWF0aW9uIHRoYW4gdGhlaXIgdHlwZSwgdGhlIHZhbHVlXG4gICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgLy8gSXRzIHN0YXJ0IGFuZCBlbmQgb2Zmc2V0XG4gICAgdGhpcy5zdGFydCA9IHRoaXMuZW5kID0gdGhpcy5wb3M7XG4gICAgLy8gQW5kLCBpZiBsb2NhdGlvbnMgYXJlIHVzZWQsIHRoZSB7bGluZSwgY29sdW1ufSBvYmplY3RcbiAgICAvLyBjb3JyZXNwb25kaW5nIHRvIHRob3NlIG9mZnNldHNcbiAgICB0aGlzLnN0YXJ0TG9jID0gdGhpcy5lbmRMb2MgPSB0aGlzLmN1clBvc2l0aW9uKCk7XG5cbiAgICAvLyBQb3NpdGlvbiBpbmZvcm1hdGlvbiBmb3IgdGhlIHByZXZpb3VzIHRva2VuXG4gICAgdGhpcy5sYXN0VG9rRW5kTG9jID0gdGhpcy5sYXN0VG9rU3RhcnRMb2MgPSBudWxsO1xuICAgIHRoaXMubGFzdFRva1N0YXJ0ID0gdGhpcy5sYXN0VG9rRW5kID0gdGhpcy5wb3M7XG5cbiAgICAvLyBUaGUgY29udGV4dCBzdGFjayBpcyB1c2VkIHRvIHN1cGVyZmljaWFsbHkgdHJhY2sgc3ludGFjdGljXG4gICAgLy8gY29udGV4dCB0byBwcmVkaWN0IHdoZXRoZXIgYSByZWd1bGFyIGV4cHJlc3Npb24gaXMgYWxsb3dlZCBpbiBhXG4gICAgLy8gZ2l2ZW4gcG9zaXRpb24uXG4gICAgdGhpcy5jb250ZXh0ID0gdGhpcy5pbml0aWFsQ29udGV4dCgpO1xuICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuXG4gICAgLy8gRmlndXJlIG91dCBpZiBpdCdzIGEgbW9kdWxlIGNvZGUuXG4gICAgdGhpcy5pbk1vZHVsZSA9IG9wdGlvbnMuc291cmNlVHlwZSA9PT0gXCJtb2R1bGVcIjtcbiAgICB0aGlzLnN0cmljdCA9IHRoaXMuaW5Nb2R1bGUgfHwgdGhpcy5zdHJpY3REaXJlY3RpdmUodGhpcy5wb3MpO1xuXG4gICAgLy8gVXNlZCB0byBzaWduaWZ5IHRoZSBzdGFydCBvZiBhIHBvdGVudGlhbCBhcnJvdyBmdW5jdGlvblxuICAgIHRoaXMucG90ZW50aWFsQXJyb3dBdCA9IC0xO1xuICAgIHRoaXMucG90ZW50aWFsQXJyb3dJbkZvckF3YWl0ID0gZmFsc2U7XG5cbiAgICAvLyBQb3NpdGlvbnMgdG8gZGVsYXllZC1jaGVjayB0aGF0IHlpZWxkL2F3YWl0IGRvZXMgbm90IGV4aXN0IGluIGRlZmF1bHQgcGFyYW1ldGVycy5cbiAgICB0aGlzLnlpZWxkUG9zID0gdGhpcy5hd2FpdFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG4gICAgLy8gTGFiZWxzIGluIHNjb3BlLlxuICAgIHRoaXMubGFiZWxzID0gW107XG4gICAgLy8gVGh1cy1mYXIgdW5kZWZpbmVkIGV4cG9ydHMuXG4gICAgdGhpcy51bmRlZmluZWRFeHBvcnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIC8vIElmIGVuYWJsZWQsIHNraXAgbGVhZGluZyBoYXNoYmFuZyBsaW5lLlxuICAgIGlmICh0aGlzLnBvcyA9PT0gMCAmJiBvcHRpb25zLmFsbG93SGFzaEJhbmcgJiYgdGhpcy5pbnB1dC5zbGljZSgwLCAyKSA9PT0gXCIjIVwiKVxuICAgICAgeyB0aGlzLnNraXBMaW5lQ29tbWVudCgyKTsgfVxuXG4gICAgLy8gU2NvcGUgdHJhY2tpbmcgZm9yIGR1cGxpY2F0ZSB2YXJpYWJsZSBuYW1lcyAoc2VlIHNjb3BlLmpzKVxuICAgIHRoaXMuc2NvcGVTdGFjayA9IFtdO1xuICAgIHRoaXMuZW50ZXJTY29wZShTQ09QRV9UT1ApO1xuXG4gICAgLy8gRm9yIFJlZ0V4cCB2YWxpZGF0aW9uXG4gICAgdGhpcy5yZWdleHBTdGF0ZSA9IG51bGw7XG5cbiAgICAvLyBUaGUgc3RhY2sgb2YgcHJpdmF0ZSBuYW1lcy5cbiAgICAvLyBFYWNoIGVsZW1lbnQgaGFzIHR3byBwcm9wZXJ0aWVzOiAnZGVjbGFyZWQnIGFuZCAndXNlZCcuXG4gICAgLy8gV2hlbiBpdCBleGl0ZWQgZnJvbSB0aGUgb3V0ZXJtb3N0IGNsYXNzIGRlZmluaXRpb24sIGFsbCB1c2VkIHByaXZhdGUgbmFtZXMgbXVzdCBiZSBkZWNsYXJlZC5cbiAgICB0aGlzLnByaXZhdGVOYW1lU3RhY2sgPSBbXTtcbiAgfTtcblxuICB2YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBpbkZ1bmN0aW9uOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGluR2VuZXJhdG9yOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGluQXN5bmM6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sY2FuQXdhaXQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sYWxsb3dTdXBlcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxhbGxvd0RpcmVjdFN1cGVyOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LHRyZWF0RnVuY3Rpb25zQXNWYXI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sYWxsb3dOZXdEb3RUYXJnZXQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0saW5DbGFzc1N0YXRpY0Jsb2NrOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbiAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlICgpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMub3B0aW9ucy5wcm9ncmFtIHx8IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0VG9rZW4oKTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVRvcExldmVsKG5vZGUpXG4gIH07XG5cbiAgcHJvdG90eXBlQWNjZXNzb3JzLmluRnVuY3Rpb24uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFZhclNjb3BlKCkuZmxhZ3MgJiBTQ09QRV9GVU5DVElPTikgPiAwIH07XG5cbiAgcHJvdG90eXBlQWNjZXNzb3JzLmluR2VuZXJhdG9yLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRWYXJTY29wZSgpLmZsYWdzICYgU0NPUEVfR0VORVJBVE9SKSA+IDAgfTtcblxuICBwcm90b3R5cGVBY2Nlc3NvcnMuaW5Bc3luYy5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VmFyU2NvcGUoKS5mbGFncyAmIFNDT1BFX0FTWU5DKSA+IDAgfTtcblxuICBwcm90b3R5cGVBY2Nlc3NvcnMuY2FuQXdhaXQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciByZWYgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgICAgIHZhciBmbGFncyA9IHJlZi5mbGFncztcbiAgICAgIGlmIChmbGFncyAmIChTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0sgfCBTQ09QRV9DTEFTU19GSUVMRF9JTklUKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgaWYgKGZsYWdzICYgU0NPUEVfRlVOQ1RJT04pIHsgcmV0dXJuIChmbGFncyAmIFNDT1BFX0FTWU5DKSA+IDAgfVxuICAgIH1cbiAgICByZXR1cm4gKHRoaXMuaW5Nb2R1bGUgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDEzKSB8fCB0aGlzLm9wdGlvbnMuYWxsb3dBd2FpdE91dHNpZGVGdW5jdGlvblxuICB9O1xuXG4gIHByb3RvdHlwZUFjY2Vzc29ycy5hbGxvd1N1cGVyLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVmID0gdGhpcy5jdXJyZW50VGhpc1Njb3BlKCk7XG4gICAgICB2YXIgZmxhZ3MgPSByZWYuZmxhZ3M7XG4gICAgcmV0dXJuIChmbGFncyAmIFNDT1BFX1NVUEVSKSA+IDAgfHwgdGhpcy5vcHRpb25zLmFsbG93U3VwZXJPdXRzaWRlTWV0aG9kXG4gIH07XG5cbiAgcHJvdG90eXBlQWNjZXNzb3JzLmFsbG93RGlyZWN0U3VwZXIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFRoaXNTY29wZSgpLmZsYWdzICYgU0NPUEVfRElSRUNUX1NVUEVSKSA+IDAgfTtcblxuICBwcm90b3R5cGVBY2Nlc3NvcnMudHJlYXRGdW5jdGlvbnNBc1Zhci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXJJblNjb3BlKHRoaXMuY3VycmVudFNjb3BlKCkpIH07XG5cbiAgcHJvdG90eXBlQWNjZXNzb3JzLmFsbG93TmV3RG90VGFyZ2V0LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgcmVmID0gdGhpcy5zY29wZVN0YWNrW2ldO1xuICAgICAgICB2YXIgZmxhZ3MgPSByZWYuZmxhZ3M7XG4gICAgICBpZiAoZmxhZ3MgJiAoU0NPUEVfQ0xBU1NfU1RBVElDX0JMT0NLIHwgU0NPUEVfQ0xBU1NfRklFTERfSU5JVCkgfHxcbiAgICAgICAgICAoKGZsYWdzICYgU0NPUEVfRlVOQ1RJT04pICYmICEoZmxhZ3MgJiBTQ09QRV9BUlJPVykpKSB7IHJldHVybiB0cnVlIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHJvdG90eXBlQWNjZXNzb3JzLmluQ2xhc3NTdGF0aWNCbG9jay5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLmN1cnJlbnRWYXJTY29wZSgpLmZsYWdzICYgU0NPUEVfQ0xBU1NfU1RBVElDX0JMT0NLKSA+IDBcbiAgfTtcblxuICBQYXJzZXIuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kICgpIHtcbiAgICAgIHZhciBwbHVnaW5zID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoIGxlbi0tICkgcGx1Z2luc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgdmFyIGNscyA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7IGNscyA9IHBsdWdpbnNbaV0oY2xzKTsgfVxuICAgIHJldHVybiBjbHNcbiAgfTtcblxuICBQYXJzZXIucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMob3B0aW9ucywgaW5wdXQpLnBhcnNlKClcbiAgfTtcblxuICBQYXJzZXIucGFyc2VFeHByZXNzaW9uQXQgPSBmdW5jdGlvbiBwYXJzZUV4cHJlc3Npb25BdCAoaW5wdXQsIHBvcywgb3B0aW9ucykge1xuICAgIHZhciBwYXJzZXIgPSBuZXcgdGhpcyhvcHRpb25zLCBpbnB1dCwgcG9zKTtcbiAgICBwYXJzZXIubmV4dFRva2VuKCk7XG4gICAgcmV0dXJuIHBhcnNlci5wYXJzZUV4cHJlc3Npb24oKVxuICB9O1xuXG4gIFBhcnNlci50b2tlbml6ZXIgPSBmdW5jdGlvbiB0b2tlbml6ZXIgKGlucHV0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKG9wdGlvbnMsIGlucHV0KVxuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBQYXJzZXIucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxuICB2YXIgcHAkOSA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgLy8gIyMgUGFyc2VyIHV0aWxpdGllc1xuXG4gIHZhciBsaXRlcmFsID0gL14oPzonKCg/OlxcXFxbXl18W14nXFxcXF0pKj8pJ3xcIigoPzpcXFxcW15dfFteXCJcXFxcXSkqPylcIikvO1xuICBwcCQ5LnN0cmljdERpcmVjdGl2ZSA9IGZ1bmN0aW9uKHN0YXJ0KSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBmb3IgKDs7KSB7XG4gICAgICAvLyBUcnkgdG8gZmluZCBzdHJpbmcgbGl0ZXJhbC5cbiAgICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHN0YXJ0O1xuICAgICAgc3RhcnQgKz0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KVswXS5sZW5ndGg7XG4gICAgICB2YXIgbWF0Y2ggPSBsaXRlcmFsLmV4ZWModGhpcy5pbnB1dC5zbGljZShzdGFydCkpO1xuICAgICAgaWYgKCFtYXRjaCkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgaWYgKChtYXRjaFsxXSB8fCBtYXRjaFsyXSkgPT09IFwidXNlIHN0cmljdFwiKSB7XG4gICAgICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHN0YXJ0ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICB2YXIgc3BhY2VBZnRlciA9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dCksIGVuZCA9IHNwYWNlQWZ0ZXIuaW5kZXggKyBzcGFjZUFmdGVyWzBdLmxlbmd0aDtcbiAgICAgICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJBdChlbmQpO1xuICAgICAgICByZXR1cm4gbmV4dCA9PT0gXCI7XCIgfHwgbmV4dCA9PT0gXCJ9XCIgfHxcbiAgICAgICAgICAobGluZUJyZWFrLnRlc3Qoc3BhY2VBZnRlclswXSkgJiZcbiAgICAgICAgICAgISgvWyhgLlsrXFwtLyolPD49LD9eJl0vLnRlc3QobmV4dCkgfHwgbmV4dCA9PT0gXCIhXCIgJiYgdGhpcy5pbnB1dC5jaGFyQXQoZW5kICsgMSkgPT09IFwiPVwiKSlcbiAgICAgIH1cbiAgICAgIHN0YXJ0ICs9IG1hdGNoWzBdLmxlbmd0aDtcblxuICAgICAgLy8gU2tpcCBzZW1pY29sb24sIGlmIGFueS5cbiAgICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHN0YXJ0O1xuICAgICAgc3RhcnQgKz0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KVswXS5sZW5ndGg7XG4gICAgICBpZiAodGhpcy5pbnB1dFtzdGFydF0gPT09IFwiO1wiKVxuICAgICAgICB7IHN0YXJ0Kys7IH1cbiAgICB9XG4gIH07XG5cbiAgLy8gUHJlZGljYXRlIHRoYXQgdGVzdHMgd2hldGhlciB0aGUgbmV4dCB0b2tlbiBpcyBvZiB0aGUgZ2l2ZW5cbiAgLy8gdHlwZSwgYW5kIGlmIHllcywgY29uc3VtZXMgaXQgYXMgYSBzaWRlIGVmZmVjdC5cblxuICBwcCQ5LmVhdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfTtcblxuICAvLyBUZXN0cyB3aGV0aGVyIHBhcnNlZCB0b2tlbiBpcyBhIGNvbnRleHR1YWwga2V5d29yZC5cblxuICBwcCQ5LmlzQ29udGV4dHVhbCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSB0eXBlcyQxLm5hbWUgJiYgdGhpcy52YWx1ZSA9PT0gbmFtZSAmJiAhdGhpcy5jb250YWluc0VzY1xuICB9O1xuXG4gIC8vIENvbnN1bWVzIGNvbnRleHR1YWwga2V5d29yZCBpZiBwb3NzaWJsZS5cblxuICBwcCQ5LmVhdENvbnRleHR1YWwgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKCF0aGlzLmlzQ29udGV4dHVhbChuYW1lKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0cnVlXG4gIH07XG5cbiAgLy8gQXNzZXJ0cyB0aGF0IGZvbGxvd2luZyB0b2tlbiBpcyBnaXZlbiBjb250ZXh0dWFsIGtleXdvcmQuXG5cbiAgcHAkOS5leHBlY3RDb250ZXh0dWFsID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGlmICghdGhpcy5lYXRDb250ZXh0dWFsKG5hbWUpKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gIH07XG5cbiAgLy8gVGVzdCB3aGV0aGVyIGEgc2VtaWNvbG9uIGNhbiBiZSBpbnNlcnRlZCBhdCB0aGUgY3VycmVudCBwb3NpdGlvbi5cblxuICBwcCQ5LmNhbkluc2VydFNlbWljb2xvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09IHR5cGVzJDEuZW9mIHx8XG4gICAgICB0aGlzLnR5cGUgPT09IHR5cGVzJDEuYnJhY2VSIHx8XG4gICAgICBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpXG4gIH07XG5cbiAgcHAkOS5pbnNlcnRTZW1pY29sb24gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vbkluc2VydGVkU2VtaWNvbG9uKVxuICAgICAgICB7IHRoaXMub3B0aW9ucy5vbkluc2VydGVkU2VtaWNvbG9uKHRoaXMubGFzdFRva0VuZCwgdGhpcy5sYXN0VG9rRW5kTG9jKTsgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH07XG5cbiAgLy8gQ29uc3VtZSBhIHNlbWljb2xvbiwgb3IsIGZhaWxpbmcgdGhhdCwgc2VlIGlmIHdlIGFyZSBhbGxvd2VkIHRvXG4gIC8vIHByZXRlbmQgdGhhdCB0aGVyZSBpcyBhIHNlbWljb2xvbiBhdCB0aGlzIHBvc2l0aW9uLlxuXG4gIHBwJDkuc2VtaWNvbG9uID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmVhdCh0eXBlcyQxLnNlbWkpICYmICF0aGlzLmluc2VydFNlbWljb2xvbigpKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gIH07XG5cbiAgcHAkOS5hZnRlclRyYWlsaW5nQ29tbWEgPSBmdW5jdGlvbih0b2tUeXBlLCBub3ROZXh0KSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdG9rVHlwZSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vblRyYWlsaW5nQ29tbWEpXG4gICAgICAgIHsgdGhpcy5vcHRpb25zLm9uVHJhaWxpbmdDb21tYSh0aGlzLmxhc3RUb2tTdGFydCwgdGhpcy5sYXN0VG9rU3RhcnRMb2MpOyB9XG4gICAgICBpZiAoIW5vdE5leHQpXG4gICAgICAgIHsgdGhpcy5uZXh0KCk7IH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9O1xuXG4gIC8vIEV4cGVjdCBhIHRva2VuIG9mIGEgZ2l2ZW4gdHlwZS4gSWYgZm91bmQsIGNvbnN1bWUgaXQsIG90aGVyd2lzZSxcbiAgLy8gcmFpc2UgYW4gdW5leHBlY3RlZCB0b2tlbiBlcnJvci5cblxuICBwcCQ5LmV4cGVjdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICB0aGlzLmVhdCh0eXBlKSB8fCB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfTtcblxuICAvLyBSYWlzZSBhbiB1bmV4cGVjdGVkIHRva2VuIGVycm9yLlxuXG4gIHBwJDkudW5leHBlY3RlZCA9IGZ1bmN0aW9uKHBvcykge1xuICAgIHRoaXMucmFpc2UocG9zICE9IG51bGwgPyBwb3MgOiB0aGlzLnN0YXJ0LCBcIlVuZXhwZWN0ZWQgdG9rZW5cIik7XG4gIH07XG5cbiAgdmFyIERlc3RydWN0dXJpbmdFcnJvcnMgPSBmdW5jdGlvbiBEZXN0cnVjdHVyaW5nRXJyb3JzKCkge1xuICAgIHRoaXMuc2hvcnRoYW5kQXNzaWduID1cbiAgICB0aGlzLnRyYWlsaW5nQ29tbWEgPVxuICAgIHRoaXMucGFyZW50aGVzaXplZEFzc2lnbiA9XG4gICAgdGhpcy5wYXJlbnRoZXNpemVkQmluZCA9XG4gICAgdGhpcy5kb3VibGVQcm90byA9XG4gICAgICAtMTtcbiAgfTtcblxuICBwcCQ5LmNoZWNrUGF0dGVybkVycm9ycyA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGlzQXNzaWduKSB7XG4gICAgaWYgKCFyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHJldHVybiB9XG4gICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA+IC0xKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hLCBcIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiKTsgfVxuICAgIHZhciBwYXJlbnMgPSBpc0Fzc2lnbiA/IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA6IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQ7XG4gICAgaWYgKHBhcmVucyA+IC0xKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShwYXJlbnMsIGlzQXNzaWduID8gXCJBc3NpZ25pbmcgdG8gcnZhbHVlXCIgOiBcIlBhcmVudGhlc2l6ZWQgcGF0dGVyblwiKTsgfVxuICB9O1xuXG4gIHBwJDkuY2hlY2tFeHByZXNzaW9uRXJyb3JzID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgYW5kVGhyb3cpIHtcbiAgICBpZiAoIXJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB2YXIgc2hvcnRoYW5kQXNzaWduID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ247XG4gICAgdmFyIGRvdWJsZVByb3RvID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5kb3VibGVQcm90bztcbiAgICBpZiAoIWFuZFRocm93KSB7IHJldHVybiBzaG9ydGhhbmRBc3NpZ24gPj0gMCB8fCBkb3VibGVQcm90byA+PSAwIH1cbiAgICBpZiAoc2hvcnRoYW5kQXNzaWduID49IDApXG4gICAgICB7IHRoaXMucmFpc2Uoc2hvcnRoYW5kQXNzaWduLCBcIlNob3J0aGFuZCBwcm9wZXJ0eSBhc3NpZ25tZW50cyBhcmUgdmFsaWQgb25seSBpbiBkZXN0cnVjdHVyaW5nIHBhdHRlcm5zXCIpOyB9XG4gICAgaWYgKGRvdWJsZVByb3RvID49IDApXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShkb3VibGVQcm90bywgXCJSZWRlZmluaXRpb24gb2YgX19wcm90b19fIHByb3BlcnR5XCIpOyB9XG4gIH07XG5cbiAgcHAkOS5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy55aWVsZFBvcyAmJiAoIXRoaXMuYXdhaXRQb3MgfHwgdGhpcy55aWVsZFBvcyA8IHRoaXMuYXdhaXRQb3MpKVxuICAgICAgeyB0aGlzLnJhaXNlKHRoaXMueWllbGRQb3MsIFwiWWllbGQgZXhwcmVzc2lvbiBjYW5ub3QgYmUgYSBkZWZhdWx0IHZhbHVlXCIpOyB9XG4gICAgaWYgKHRoaXMuYXdhaXRQb3MpXG4gICAgICB7IHRoaXMucmFpc2UodGhpcy5hd2FpdFBvcywgXCJBd2FpdCBleHByZXNzaW9uIGNhbm5vdCBiZSBhIGRlZmF1bHQgdmFsdWVcIik7IH1cbiAgfTtcblxuICBwcCQ5LmlzU2ltcGxlQXNzaWduVGFyZ2V0ID0gZnVuY3Rpb24oZXhwcikge1xuICAgIGlmIChleHByLnR5cGUgPT09IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIilcbiAgICAgIHsgcmV0dXJuIHRoaXMuaXNTaW1wbGVBc3NpZ25UYXJnZXQoZXhwci5leHByZXNzaW9uKSB9XG4gICAgcmV0dXJuIGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgfHwgZXhwci50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIlxuICB9O1xuXG4gIHZhciBwcCQ4ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICAvLyAjIyMgU3RhdGVtZW50IHBhcnNpbmdcblxuICAvLyBQYXJzZSBhIHByb2dyYW0uIEluaXRpYWxpemVzIHRoZSBwYXJzZXIsIHJlYWRzIGFueSBudW1iZXIgb2ZcbiAgLy8gc3RhdGVtZW50cywgYW5kIHdyYXBzIHRoZW0gaW4gYSBQcm9ncmFtIG5vZGUuICBPcHRpb25hbGx5IHRha2VzIGFcbiAgLy8gYHByb2dyYW1gIGFyZ3VtZW50LiAgSWYgcHJlc2VudCwgdGhlIHN0YXRlbWVudHMgd2lsbCBiZSBhcHBlbmRlZFxuICAvLyB0byBpdHMgYm9keSBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgbmV3IG5vZGUuXG5cbiAgcHAkOC5wYXJzZVRvcExldmVsID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHZhciBleHBvcnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBpZiAoIW5vZGUuYm9keSkgeyBub2RlLmJvZHkgPSBbXTsgfVxuICAgIHdoaWxlICh0aGlzLnR5cGUgIT09IHR5cGVzJDEuZW9mKSB7XG4gICAgICB2YXIgc3RtdCA9IHRoaXMucGFyc2VTdGF0ZW1lbnQobnVsbCwgdHJ1ZSwgZXhwb3J0cyk7XG4gICAgICBub2RlLmJvZHkucHVzaChzdG10KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaW5Nb2R1bGUpXG4gICAgICB7IGZvciAodmFyIGkgPSAwLCBsaXN0ID0gT2JqZWN0LmtleXModGhpcy51bmRlZmluZWRFeHBvcnRzKTsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IGxpc3RbaV07XG5cbiAgICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy51bmRlZmluZWRFeHBvcnRzW25hbWVdLnN0YXJ0LCAoXCJFeHBvcnQgJ1wiICsgbmFtZSArIFwiJyBpcyBub3QgZGVmaW5lZFwiKSk7XG4gICAgICAgIH0gfVxuICAgIHRoaXMuYWRhcHREaXJlY3RpdmVQcm9sb2d1ZShub2RlLmJvZHkpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuc291cmNlVHlwZSA9IHRoaXMub3B0aW9ucy5zb3VyY2VUeXBlO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJQcm9ncmFtXCIpXG4gIH07XG5cbiAgdmFyIGxvb3BMYWJlbCA9IHtraW5kOiBcImxvb3BcIn0sIHN3aXRjaExhYmVsID0ge2tpbmQ6IFwic3dpdGNoXCJ9O1xuXG4gIHBwJDguaXNMZXQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYgfHwgIXRoaXMuaXNDb250ZXh0dWFsKFwibGV0XCIpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gdGhpcy5wb3M7XG4gICAgdmFyIHNraXAgPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpO1xuICAgIHZhciBuZXh0ID0gdGhpcy5wb3MgKyBza2lwWzBdLmxlbmd0aCwgbmV4dENoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KG5leHQpO1xuICAgIC8vIEZvciBhbWJpZ3VvdXMgY2FzZXMsIGRldGVybWluZSBpZiBhIExleGljYWxEZWNsYXJhdGlvbiAob3Igb25seSBhXG4gICAgLy8gU3RhdGVtZW50KSBpcyBhbGxvd2VkIGhlcmUuIElmIGNvbnRleHQgaXMgbm90IGVtcHR5IHRoZW4gb25seSBhIFN0YXRlbWVudFxuICAgIC8vIGlzIGFsbG93ZWQuIEhvd2V2ZXIsIGBsZXQgW2AgaXMgYW4gZXhwbGljaXQgbmVnYXRpdmUgbG9va2FoZWFkIGZvclxuICAgIC8vIEV4cHJlc3Npb25TdGF0ZW1lbnQsIHNvIHNwZWNpYWwtY2FzZSBpdCBmaXJzdC5cbiAgICBpZiAobmV4dENoID09PSA5MSB8fCBuZXh0Q2ggPT09IDkyKSB7IHJldHVybiB0cnVlIH0gLy8gJ1snLCAnXFwnXG4gICAgaWYgKGNvbnRleHQpIHsgcmV0dXJuIGZhbHNlIH1cblxuICAgIGlmIChuZXh0Q2ggPT09IDEyMyB8fCBuZXh0Q2ggPiAweGQ3ZmYgJiYgbmV4dENoIDwgMHhkYzAwKSB7IHJldHVybiB0cnVlIH0gLy8gJ3snLCBhc3RyYWxcbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQobmV4dENoLCB0cnVlKSkge1xuICAgICAgdmFyIHBvcyA9IG5leHQgKyAxO1xuICAgICAgd2hpbGUgKGlzSWRlbnRpZmllckNoYXIobmV4dENoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcyksIHRydWUpKSB7ICsrcG9zOyB9XG4gICAgICBpZiAobmV4dENoID09PSA5MiB8fCBuZXh0Q2ggPiAweGQ3ZmYgJiYgbmV4dENoIDwgMHhkYzAwKSB7IHJldHVybiB0cnVlIH1cbiAgICAgIHZhciBpZGVudCA9IHRoaXMuaW5wdXQuc2xpY2UobmV4dCwgcG9zKTtcbiAgICAgIGlmICgha2V5d29yZFJlbGF0aW9uYWxPcGVyYXRvci50ZXN0KGlkZW50KSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGNoZWNrICdhc3luYyBbbm8gTGluZVRlcm1pbmF0b3IgaGVyZV0gZnVuY3Rpb24nXG4gIC8vIC0gJ2FzeW5jIC8qZm9vKi8gZnVuY3Rpb24nIGlzIE9LLlxuICAvLyAtICdhc3luYyAvKlxcbiovIGZ1bmN0aW9uJyBpcyBpbnZhbGlkLlxuICBwcCQ4LmlzQXN5bmNGdW5jdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA4IHx8ICF0aGlzLmlzQ29udGV4dHVhbChcImFzeW5jXCIpKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gdGhpcy5wb3M7XG4gICAgdmFyIHNraXAgPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpO1xuICAgIHZhciBuZXh0ID0gdGhpcy5wb3MgKyBza2lwWzBdLmxlbmd0aCwgYWZ0ZXI7XG4gICAgcmV0dXJuICFsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMucG9zLCBuZXh0KSkgJiZcbiAgICAgIHRoaXMuaW5wdXQuc2xpY2UobmV4dCwgbmV4dCArIDgpID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgIChuZXh0ICsgOCA9PT0gdGhpcy5pbnB1dC5sZW5ndGggfHxcbiAgICAgICAhKGlzSWRlbnRpZmllckNoYXIoYWZ0ZXIgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQobmV4dCArIDgpKSB8fCBhZnRlciA+IDB4ZDdmZiAmJiBhZnRlciA8IDB4ZGMwMCkpXG4gIH07XG5cbiAgLy8gUGFyc2UgYSBzaW5nbGUgc3RhdGVtZW50LlxuICAvL1xuICAvLyBJZiBleHBlY3RpbmcgYSBzdGF0ZW1lbnQgYW5kIGZpbmRpbmcgYSBzbGFzaCBvcGVyYXRvciwgcGFyc2UgYVxuICAvLyByZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbC4gVGhpcyBpcyB0byBoYW5kbGUgY2FzZXMgbGlrZVxuICAvLyBgaWYgKGZvbykgL2JsYWgvLmV4ZWMoZm9vKWAsIHdoZXJlIGxvb2tpbmcgYXQgdGhlIHByZXZpb3VzIHRva2VuXG4gIC8vIGRvZXMgbm90IGhlbHAuXG5cbiAgcHAkOC5wYXJzZVN0YXRlbWVudCA9IGZ1bmN0aW9uKGNvbnRleHQsIHRvcExldmVsLCBleHBvcnRzKSB7XG4gICAgdmFyIHN0YXJ0dHlwZSA9IHRoaXMudHlwZSwgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIGtpbmQ7XG5cbiAgICBpZiAodGhpcy5pc0xldChjb250ZXh0KSkge1xuICAgICAgc3RhcnR0eXBlID0gdHlwZXMkMS5fdmFyO1xuICAgICAga2luZCA9IFwibGV0XCI7XG4gICAgfVxuXG4gICAgLy8gTW9zdCB0eXBlcyBvZiBzdGF0ZW1lbnRzIGFyZSByZWNvZ25pemVkIGJ5IHRoZSBrZXl3b3JkIHRoZXlcbiAgICAvLyBzdGFydCB3aXRoLiBNYW55IGFyZSB0cml2aWFsIHRvIHBhcnNlLCBzb21lIHJlcXVpcmUgYSBiaXQgb2ZcbiAgICAvLyBjb21wbGV4aXR5LlxuXG4gICAgc3dpdGNoIChzdGFydHR5cGUpIHtcbiAgICBjYXNlIHR5cGVzJDEuX2JyZWFrOiBjYXNlIHR5cGVzJDEuX2NvbnRpbnVlOiByZXR1cm4gdGhpcy5wYXJzZUJyZWFrQ29udGludWVTdGF0ZW1lbnQobm9kZSwgc3RhcnR0eXBlLmtleXdvcmQpXG4gICAgY2FzZSB0eXBlcyQxLl9kZWJ1Z2dlcjogcmV0dXJuIHRoaXMucGFyc2VEZWJ1Z2dlclN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMkMS5fZG86IHJldHVybiB0aGlzLnBhcnNlRG9TdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzJDEuX2ZvcjogcmV0dXJuIHRoaXMucGFyc2VGb3JTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzJDEuX2Z1bmN0aW9uOlxuICAgICAgLy8gRnVuY3Rpb24gYXMgc29sZSBib2R5IG9mIGVpdGhlciBhbiBpZiBzdGF0ZW1lbnQgb3IgYSBsYWJlbGVkIHN0YXRlbWVudFxuICAgICAgLy8gd29ya3MsIGJ1dCBub3Qgd2hlbiBpdCBpcyBwYXJ0IG9mIGEgbGFiZWxlZCBzdGF0ZW1lbnQgdGhhdCBpcyB0aGUgc29sZVxuICAgICAgLy8gYm9keSBvZiBhbiBpZiBzdGF0ZW1lbnQuXG4gICAgICBpZiAoKGNvbnRleHQgJiYgKHRoaXMuc3RyaWN0IHx8IGNvbnRleHQgIT09IFwiaWZcIiAmJiBjb250ZXh0ICE9PSBcImxhYmVsXCIpKSAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlLCBmYWxzZSwgIWNvbnRleHQpXG4gICAgY2FzZSB0eXBlcyQxLl9jbGFzczpcbiAgICAgIGlmIChjb250ZXh0KSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKG5vZGUsIHRydWUpXG4gICAgY2FzZSB0eXBlcyQxLl9pZjogcmV0dXJuIHRoaXMucGFyc2VJZlN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMkMS5fcmV0dXJuOiByZXR1cm4gdGhpcy5wYXJzZVJldHVyblN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMkMS5fc3dpdGNoOiByZXR1cm4gdGhpcy5wYXJzZVN3aXRjaFN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMkMS5fdGhyb3c6IHJldHVybiB0aGlzLnBhcnNlVGhyb3dTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzJDEuX3RyeTogcmV0dXJuIHRoaXMucGFyc2VUcnlTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzJDEuX2NvbnN0OiBjYXNlIHR5cGVzJDEuX3ZhcjpcbiAgICAgIGtpbmQgPSBraW5kIHx8IHRoaXMudmFsdWU7XG4gICAgICBpZiAoY29udGV4dCAmJiBraW5kICE9PSBcInZhclwiKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVZhclN0YXRlbWVudChub2RlLCBraW5kKVxuICAgIGNhc2UgdHlwZXMkMS5fd2hpbGU6IHJldHVybiB0aGlzLnBhcnNlV2hpbGVTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzJDEuX3dpdGg6IHJldHVybiB0aGlzLnBhcnNlV2l0aFN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMkMS5icmFjZUw6IHJldHVybiB0aGlzLnBhcnNlQmxvY2sodHJ1ZSwgbm9kZSlcbiAgICBjYXNlIHR5cGVzJDEuc2VtaTogcmV0dXJuIHRoaXMucGFyc2VFbXB0eVN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMkMS5fZXhwb3J0OlxuICAgIGNhc2UgdHlwZXMkMS5faW1wb3J0OlxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+IDEwICYmIHN0YXJ0dHlwZSA9PT0gdHlwZXMkMS5faW1wb3J0KSB7XG4gICAgICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHRoaXMucG9zO1xuICAgICAgICB2YXIgc2tpcCA9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dCk7XG4gICAgICAgIHZhciBuZXh0ID0gdGhpcy5wb3MgKyBza2lwWzBdLmxlbmd0aCwgbmV4dENoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KG5leHQpO1xuICAgICAgICBpZiAobmV4dENoID09PSA0MCB8fCBuZXh0Q2ggPT09IDQ2KSAvLyAnKCcgb3IgJy4nXG4gICAgICAgICAgeyByZXR1cm4gdGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgdGhpcy5wYXJzZUV4cHJlc3Npb24oKSkgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5hbGxvd0ltcG9ydEV4cG9ydEV2ZXJ5d2hlcmUpIHtcbiAgICAgICAgaWYgKCF0b3BMZXZlbClcbiAgICAgICAgICB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInaW1wb3J0JyBhbmQgJ2V4cG9ydCcgbWF5IG9ubHkgYXBwZWFyIGF0IHRoZSB0b3AgbGV2ZWxcIik7IH1cbiAgICAgICAgaWYgKCF0aGlzLmluTW9kdWxlKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIidpbXBvcnQnIGFuZCAnZXhwb3J0JyBtYXkgYXBwZWFyIG9ubHkgd2l0aCAnc291cmNlVHlwZTogbW9kdWxlJ1wiKTsgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXJ0dHlwZSA9PT0gdHlwZXMkMS5faW1wb3J0ID8gdGhpcy5wYXJzZUltcG9ydChub2RlKSA6IHRoaXMucGFyc2VFeHBvcnQobm9kZSwgZXhwb3J0cylcblxuICAgICAgLy8gSWYgdGhlIHN0YXRlbWVudCBkb2VzIG5vdCBzdGFydCB3aXRoIGEgc3RhdGVtZW50IGtleXdvcmQgb3IgYVxuICAgICAgLy8gYnJhY2UsIGl0J3MgYW4gRXhwcmVzc2lvblN0YXRlbWVudCBvciBMYWJlbGVkU3RhdGVtZW50LiBXZVxuICAgICAgLy8gc2ltcGx5IHN0YXJ0IHBhcnNpbmcgYW4gZXhwcmVzc2lvbiwgYW5kIGFmdGVyd2FyZHMsIGlmIHRoZVxuICAgICAgLy8gbmV4dCB0b2tlbiBpcyBhIGNvbG9uIGFuZCB0aGUgZXhwcmVzc2lvbiB3YXMgYSBzaW1wbGVcbiAgICAgIC8vIElkZW50aWZpZXIgbm9kZSwgd2Ugc3dpdGNoIHRvIGludGVycHJldGluZyBpdCBhcyBhIGxhYmVsLlxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodGhpcy5pc0FzeW5jRnVuY3Rpb24oKSkge1xuICAgICAgICBpZiAoY29udGV4dCkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlLCB0cnVlLCAhY29udGV4dClcbiAgICAgIH1cblxuICAgICAgdmFyIG1heWJlTmFtZSA9IHRoaXMudmFsdWUsIGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgaWYgKHN0YXJ0dHlwZSA9PT0gdHlwZXMkMS5uYW1lICYmIGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgdGhpcy5lYXQodHlwZXMkMS5jb2xvbikpXG4gICAgICAgIHsgcmV0dXJuIHRoaXMucGFyc2VMYWJlbGVkU3RhdGVtZW50KG5vZGUsIG1heWJlTmFtZSwgZXhwciwgY29udGV4dCkgfVxuICAgICAgZWxzZSB7IHJldHVybiB0aGlzLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCBleHByKSB9XG4gICAgfVxuICB9O1xuXG4gIHBwJDgucGFyc2VCcmVha0NvbnRpbnVlU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwga2V5d29yZCkge1xuICAgIHZhciBpc0JyZWFrID0ga2V5d29yZCA9PT0gXCJicmVha1wiO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLnNlbWkpIHx8IHRoaXMuaW5zZXJ0U2VtaWNvbG9uKCkpIHsgbm9kZS5sYWJlbCA9IG51bGw7IH1cbiAgICBlbHNlIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzJDEubmFtZSkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIGVsc2Uge1xuICAgICAgbm9kZS5sYWJlbCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICB9XG5cbiAgICAvLyBWZXJpZnkgdGhhdCB0aGVyZSBpcyBhbiBhY3R1YWwgZGVzdGluYXRpb24gdG8gYnJlYWsgb3JcbiAgICAvLyBjb250aW51ZSB0by5cbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICg7IGkgPCB0aGlzLmxhYmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGxhYiA9IHRoaXMubGFiZWxzW2ldO1xuICAgICAgaWYgKG5vZGUubGFiZWwgPT0gbnVsbCB8fCBsYWIubmFtZSA9PT0gbm9kZS5sYWJlbC5uYW1lKSB7XG4gICAgICAgIGlmIChsYWIua2luZCAhPSBudWxsICYmIChpc0JyZWFrIHx8IGxhYi5raW5kID09PSBcImxvb3BcIikpIHsgYnJlYWsgfVxuICAgICAgICBpZiAobm9kZS5sYWJlbCAmJiBpc0JyZWFrKSB7IGJyZWFrIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgPT09IHRoaXMubGFiZWxzLmxlbmd0aCkgeyB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiVW5zeW50YWN0aWMgXCIgKyBrZXl3b3JkKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNCcmVhayA/IFwiQnJlYWtTdGF0ZW1lbnRcIiA6IFwiQ29udGludWVTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQ4LnBhcnNlRGVidWdnZXJTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVidWdnZXJTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQ4LnBhcnNlRG9TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJkb1wiKTtcbiAgICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLl93aGlsZSk7XG4gICAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNilcbiAgICAgIHsgdGhpcy5lYXQodHlwZXMkMS5zZW1pKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgdGhpcy5zZW1pY29sb24oKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEb1doaWxlU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgLy8gRGlzYW1iaWd1YXRpbmcgYmV0d2VlbiBhIGBmb3JgIGFuZCBhIGBmb3JgL2BpbmAgb3IgYGZvcmAvYG9mYFxuICAvLyBsb29wIGlzIG5vbi10cml2aWFsLiBCYXNpY2FsbHksIHdlIGhhdmUgdG8gcGFyc2UgdGhlIGluaXQgYHZhcmBcbiAgLy8gc3RhdGVtZW50IG9yIGV4cHJlc3Npb24sIGRpc2FsbG93aW5nIHRoZSBgaW5gIG9wZXJhdG9yIChzZWVcbiAgLy8gdGhlIHNlY29uZCBwYXJhbWV0ZXIgdG8gYHBhcnNlRXhwcmVzc2lvbmApLCBhbmQgdGhlbiBjaGVja1xuICAvLyB3aGV0aGVyIHRoZSBuZXh0IHRva2VuIGlzIGBpbmAgb3IgYG9mYC4gV2hlbiB0aGVyZSBpcyBubyBpbml0XG4gIC8vIHBhcnQgKHNlbWljb2xvbiBpbW1lZGlhdGVseSBhZnRlciB0aGUgb3BlbmluZyBwYXJlbnRoZXNpcyksIGl0XG4gIC8vIGlzIGEgcmVndWxhciBgZm9yYCBsb29wLlxuXG4gIHBwJDgucGFyc2VGb3JTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdmFyIGF3YWl0QXQgPSAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy5jYW5Bd2FpdCAmJiB0aGlzLmVhdENvbnRleHR1YWwoXCJhd2FpdFwiKSkgPyB0aGlzLmxhc3RUb2tTdGFydCA6IC0xO1xuICAgIHRoaXMubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgICB0aGlzLmVudGVyU2NvcGUoMCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMkMS5wYXJlbkwpO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuc2VtaSkge1xuICAgICAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIG51bGwpXG4gICAgfVxuICAgIHZhciBpc0xldCA9IHRoaXMuaXNMZXQoKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLl92YXIgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLl9jb25zdCB8fCBpc0xldCkge1xuICAgICAgdmFyIGluaXQkMSA9IHRoaXMuc3RhcnROb2RlKCksIGtpbmQgPSBpc0xldCA/IFwibGV0XCIgOiB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLnBhcnNlVmFyKGluaXQkMSwgdHJ1ZSwga2luZCk7XG4gICAgICB0aGlzLmZpbmlzaE5vZGUoaW5pdCQxLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIik7XG4gICAgICBpZiAoKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5faW4gfHwgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpKSAmJiBpbml0JDEuZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLl9pbikge1xuICAgICAgICAgICAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgICAgICAgICB9IGVsc2UgeyBub2RlLmF3YWl0ID0gYXdhaXRBdCA+IC0xOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3JJbihub2RlLCBpbml0JDEpXG4gICAgICB9XG4gICAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgaW5pdCQxKVxuICAgIH1cbiAgICB2YXIgc3RhcnRzV2l0aExldCA9IHRoaXMuaXNDb250ZXh0dWFsKFwibGV0XCIpLCBpc0Zvck9mID0gZmFsc2U7XG4gICAgdmFyIGNvbnRhaW5zRXNjID0gdGhpcy5jb250YWluc0VzYztcbiAgICB2YXIgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzO1xuICAgIHZhciBpbml0UG9zID0gdGhpcy5zdGFydDtcbiAgICB2YXIgaW5pdCA9IGF3YWl0QXQgPiAtMVxuICAgICAgPyB0aGlzLnBhcnNlRXhwclN1YnNjcmlwdHMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgXCJhd2FpdFwiKVxuICAgICAgOiB0aGlzLnBhcnNlRXhwcmVzc2lvbih0cnVlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLl9pbiB8fCAoaXNGb3JPZiA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpKSB7XG4gICAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IC8vIGltcGxpZXMgYGVjbWFWZXJzaW9uID49IDlgIChzZWUgZGVjbGFyYXRpb24gb2YgYXdhaXRBdClcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5faW4pIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gICAgICAgIG5vZGUuYXdhaXQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChpc0Zvck9mICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KSB7XG4gICAgICAgIGlmIChpbml0LnN0YXJ0ID09PSBpbml0UG9zICYmICFjb250YWluc0VzYyAmJiBpbml0LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGluaXQubmFtZSA9PT0gXCJhc3luY1wiKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7IG5vZGUuYXdhaXQgPSBmYWxzZTsgfVxuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0c1dpdGhMZXQgJiYgaXNGb3JPZikgeyB0aGlzLnJhaXNlKGluaXQuc3RhcnQsIFwiVGhlIGxlZnQtaGFuZCBzaWRlIG9mIGEgZm9yLW9mIGxvb3AgbWF5IG5vdCBzdGFydCB3aXRoICdsZXQnLlwiKTsgfVxuICAgICAgdGhpcy50b0Fzc2lnbmFibGUoaW5pdCwgZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgdGhpcy5jaGVja0xWYWxQYXR0ZXJuKGluaXQpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3JJbihub2RlLCBpbml0KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUZvcihub2RlLCBpbml0KVxuICB9O1xuXG4gIHBwJDgucGFyc2VGdW5jdGlvblN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGlzQXN5bmMsIGRlY2xhcmF0aW9uUG9zaXRpb24pIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKG5vZGUsIEZVTkNfU1RBVEVNRU5UIHwgKGRlY2xhcmF0aW9uUG9zaXRpb24gPyAwIDogRlVOQ19IQU5HSU5HX1NUQVRFTUVOVCksIGZhbHNlLCBpc0FzeW5jKVxuICB9O1xuXG4gIHBwJDgucGFyc2VJZlN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gICAgLy8gYWxsb3cgZnVuY3Rpb24gZGVjbGFyYXRpb25zIGluIGJyYW5jaGVzLCBidXQgb25seSBpbiBub24tc3RyaWN0IG1vZGVcbiAgICBub2RlLmNvbnNlcXVlbnQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwiaWZcIik7XG4gICAgbm9kZS5hbHRlcm5hdGUgPSB0aGlzLmVhdCh0eXBlcyQxLl9lbHNlKSA/IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJpZlwiKSA6IG51bGw7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIklmU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZVJldHVyblN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAoIXRoaXMuaW5GdW5jdGlvbiAmJiAhdGhpcy5vcHRpb25zLmFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uKVxuICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ3JldHVybicgb3V0c2lkZSBvZiBmdW5jdGlvblwiKTsgfVxuICAgIHRoaXMubmV4dCgpO1xuXG4gICAgLy8gSW4gYHJldHVybmAgKGFuZCBgYnJlYWtgL2Bjb250aW51ZWApLCB0aGUga2V5d29yZHMgd2l0aFxuICAgIC8vIG9wdGlvbmFsIGFyZ3VtZW50cywgd2UgZWFnZXJseSBsb29rIGZvciBhIHNlbWljb2xvbiBvciB0aGVcbiAgICAvLyBwb3NzaWJpbGl0eSB0byBpbnNlcnQgb25lLlxuXG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzJDEuc2VtaSkgfHwgdGhpcy5pbnNlcnRTZW1pY29sb24oKSkgeyBub2RlLmFyZ3VtZW50ID0gbnVsbDsgfVxuICAgIGVsc2UgeyBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTsgdGhpcy5zZW1pY29sb24oKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJSZXR1cm5TdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQ4LnBhcnNlU3dpdGNoU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuZGlzY3JpbWluYW50ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgIG5vZGUuY2FzZXMgPSBbXTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmJyYWNlTCk7XG4gICAgdGhpcy5sYWJlbHMucHVzaChzd2l0Y2hMYWJlbCk7XG4gICAgdGhpcy5lbnRlclNjb3BlKDApO1xuXG4gICAgLy8gU3RhdGVtZW50cyB1bmRlciBtdXN0IGJlIGdyb3VwZWQgKGJ5IGxhYmVsKSBpbiBTd2l0Y2hDYXNlXG4gICAgLy8gbm9kZXMuIGBjdXJgIGlzIHVzZWQgdG8ga2VlcCB0aGUgbm9kZSB0aGF0IHdlIGFyZSBjdXJyZW50bHlcbiAgICAvLyBhZGRpbmcgc3RhdGVtZW50cyB0by5cblxuICAgIHZhciBjdXI7XG4gICAgZm9yICh2YXIgc2F3RGVmYXVsdCA9IGZhbHNlOyB0aGlzLnR5cGUgIT09IHR5cGVzJDEuYnJhY2VSOykge1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5fY2FzZSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2RlZmF1bHQpIHtcbiAgICAgICAgdmFyIGlzQ2FzZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5fY2FzZTtcbiAgICAgICAgaWYgKGN1cikgeyB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7IH1cbiAgICAgICAgbm9kZS5jYXNlcy5wdXNoKGN1ciA9IHRoaXMuc3RhcnROb2RlKCkpO1xuICAgICAgICBjdXIuY29uc2VxdWVudCA9IFtdO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKGlzQ2FzZSkge1xuICAgICAgICAgIGN1ci50ZXN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2F3RGVmYXVsdCkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5sYXN0VG9rU3RhcnQsIFwiTXVsdGlwbGUgZGVmYXVsdCBjbGF1c2VzXCIpOyB9XG4gICAgICAgICAgc2F3RGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgY3VyLnRlc3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuY29sb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFjdXIpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgICAgY3VyLmNvbnNlcXVlbnQucHVzaCh0aGlzLnBhcnNlU3RhdGVtZW50KG51bGwpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5leGl0U2NvcGUoKTtcbiAgICBpZiAoY3VyKSB7IHRoaXMuZmluaXNoTm9kZShjdXIsIFwiU3dpdGNoQ2FzZVwiKTsgfVxuICAgIHRoaXMubmV4dCgpOyAvLyBDbG9zaW5nIGJyYWNlXG4gICAgdGhpcy5sYWJlbHMucG9wKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlN3aXRjaFN0YXRlbWVudFwiKVxuICB9O1xuXG4gIHBwJDgucGFyc2VUaHJvd1N0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAobGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKSlcbiAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLmxhc3RUb2tFbmQsIFwiSWxsZWdhbCBuZXdsaW5lIGFmdGVyIHRocm93XCIpOyB9XG4gICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGhyb3dTdGF0ZW1lbnRcIilcbiAgfTtcblxuICAvLyBSZXVzZWQgZW1wdHkgYXJyYXkgYWRkZWQgZm9yIG5vZGUgZmllbGRzIHRoYXQgYXJlIGFsd2F5cyBlbXB0eS5cblxuICB2YXIgZW1wdHkkMSA9IFtdO1xuXG4gIHBwJDgucGFyc2VDYXRjaENsYXVzZVBhcmFtID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBhcmFtID0gdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gICAgdmFyIHNpbXBsZSA9IHBhcmFtLnR5cGUgPT09IFwiSWRlbnRpZmllclwiO1xuICAgIHRoaXMuZW50ZXJTY29wZShzaW1wbGUgPyBTQ09QRV9TSU1QTEVfQ0FUQ0ggOiAwKTtcbiAgICB0aGlzLmNoZWNrTFZhbFBhdHRlcm4ocGFyYW0sIHNpbXBsZSA/IEJJTkRfU0lNUExFX0NBVENIIDogQklORF9MRVhJQ0FMKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLnBhcmVuUik7XG5cbiAgICByZXR1cm4gcGFyYW1cbiAgfTtcblxuICBwcCQ4LnBhcnNlVHJ5U3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuYmxvY2sgPSB0aGlzLnBhcnNlQmxvY2soKTtcbiAgICBub2RlLmhhbmRsZXIgPSBudWxsO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2NhdGNoKSB7XG4gICAgICB2YXIgY2xhdXNlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzJDEucGFyZW5MKSkge1xuICAgICAgICBjbGF1c2UucGFyYW0gPSB0aGlzLnBhcnNlQ2F0Y2hDbGF1c2VQYXJhbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDEwKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICAgIGNsYXVzZS5wYXJhbSA9IG51bGw7XG4gICAgICAgIHRoaXMuZW50ZXJTY29wZSgwKTtcbiAgICAgIH1cbiAgICAgIGNsYXVzZS5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKGZhbHNlKTtcbiAgICAgIHRoaXMuZXhpdFNjb3BlKCk7XG4gICAgICBub2RlLmhhbmRsZXIgPSB0aGlzLmZpbmlzaE5vZGUoY2xhdXNlLCBcIkNhdGNoQ2xhdXNlXCIpO1xuICAgIH1cbiAgICBub2RlLmZpbmFsaXplciA9IHRoaXMuZWF0KHR5cGVzJDEuX2ZpbmFsbHkpID8gdGhpcy5wYXJzZUJsb2NrKCkgOiBudWxsO1xuICAgIGlmICghbm9kZS5oYW5kbGVyICYmICFub2RlLmZpbmFsaXplcilcbiAgICAgIHsgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIk1pc3NpbmcgY2F0Y2ggb3IgZmluYWxseSBjbGF1c2VcIik7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHJ5U3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZVZhclN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGtpbmQsIGFsbG93TWlzc2luZ0luaXRpYWxpemVyKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5wYXJzZVZhcihub2RlLCBmYWxzZSwga2luZCwgYWxsb3dNaXNzaW5nSW5pdGlhbGl6ZXIpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIilcbiAgfTtcblxuICBwcCQ4LnBhcnNlV2hpbGVTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgIHRoaXMubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwid2hpbGVcIik7XG4gICAgdGhpcy5sYWJlbHMucG9wKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIldoaWxlU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZVdpdGhTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKHRoaXMuc3RyaWN0KSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInd2l0aCcgaW4gc3RyaWN0IG1vZGVcIik7IH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLm9iamVjdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwid2l0aFwiKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiV2l0aFN0YXRlbWVudFwiKVxuICB9O1xuXG4gIHBwJDgucGFyc2VFbXB0eVN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW1wdHlTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQ4LnBhcnNlTGFiZWxlZFN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIG1heWJlTmFtZSwgZXhwciwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkkMSA9IDAsIGxpc3QgPSB0aGlzLmxhYmVsczsgaSQxIDwgbGlzdC5sZW5ndGg7IGkkMSArPSAxKVxuICAgICAge1xuICAgICAgdmFyIGxhYmVsID0gbGlzdFtpJDFdO1xuXG4gICAgICBpZiAobGFiZWwubmFtZSA9PT0gbWF5YmVOYW1lKVxuICAgICAgICB7IHRoaXMucmFpc2UoZXhwci5zdGFydCwgXCJMYWJlbCAnXCIgKyBtYXliZU5hbWUgKyBcIicgaXMgYWxyZWFkeSBkZWNsYXJlZFwiKTtcbiAgICB9IH1cbiAgICB2YXIga2luZCA9IHRoaXMudHlwZS5pc0xvb3AgPyBcImxvb3BcIiA6IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5fc3dpdGNoID8gXCJzd2l0Y2hcIiA6IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGFiZWxzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgbGFiZWwkMSA9IHRoaXMubGFiZWxzW2ldO1xuICAgICAgaWYgKGxhYmVsJDEuc3RhdGVtZW50U3RhcnQgPT09IG5vZGUuc3RhcnQpIHtcbiAgICAgICAgLy8gVXBkYXRlIGluZm9ybWF0aW9uIGFib3V0IHByZXZpb3VzIGxhYmVscyBvbiB0aGlzIG5vZGVcbiAgICAgICAgbGFiZWwkMS5zdGF0ZW1lbnRTdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIGxhYmVsJDEua2luZCA9IGtpbmQ7XG4gICAgICB9IGVsc2UgeyBicmVhayB9XG4gICAgfVxuICAgIHRoaXMubGFiZWxzLnB1c2goe25hbWU6IG1heWJlTmFtZSwga2luZDoga2luZCwgc3RhdGVtZW50U3RhcnQ6IHRoaXMuc3RhcnR9KTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KGNvbnRleHQgPyBjb250ZXh0LmluZGV4T2YoXCJsYWJlbFwiKSA9PT0gLTEgPyBjb250ZXh0ICsgXCJsYWJlbFwiIDogY29udGV4dCA6IFwibGFiZWxcIik7XG4gICAgdGhpcy5sYWJlbHMucG9wKCk7XG4gICAgbm9kZS5sYWJlbCA9IGV4cHI7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkxhYmVsZWRTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQ4LnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGV4cHIpIHtcbiAgICBub2RlLmV4cHJlc3Npb24gPSBleHByO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIilcbiAgfTtcblxuICAvLyBQYXJzZSBhIHNlbWljb2xvbi1lbmNsb3NlZCBibG9jayBvZiBzdGF0ZW1lbnRzLCBoYW5kbGluZyBgXCJ1c2VcbiAgLy8gc3RyaWN0XCJgIGRlY2xhcmF0aW9ucyB3aGVuIGBhbGxvd1N0cmljdGAgaXMgdHJ1ZSAodXNlZCBmb3JcbiAgLy8gZnVuY3Rpb24gYm9kaWVzKS5cblxuICBwcCQ4LnBhcnNlQmxvY2sgPSBmdW5jdGlvbihjcmVhdGVOZXdMZXhpY2FsU2NvcGUsIG5vZGUsIGV4aXRTdHJpY3QpIHtcbiAgICBpZiAoIGNyZWF0ZU5ld0xleGljYWxTY29wZSA9PT0gdm9pZCAwICkgY3JlYXRlTmV3TGV4aWNhbFNjb3BlID0gdHJ1ZTtcbiAgICBpZiAoIG5vZGUgPT09IHZvaWQgMCApIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuXG4gICAgbm9kZS5ib2R5ID0gW107XG4gICAgdGhpcy5leHBlY3QodHlwZXMkMS5icmFjZUwpO1xuICAgIGlmIChjcmVhdGVOZXdMZXhpY2FsU2NvcGUpIHsgdGhpcy5lbnRlclNjb3BlKDApOyB9XG4gICAgd2hpbGUgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5icmFjZVIpIHtcbiAgICAgIHZhciBzdG10ID0gdGhpcy5wYXJzZVN0YXRlbWVudChudWxsKTtcbiAgICAgIG5vZGUuYm9keS5wdXNoKHN0bXQpO1xuICAgIH1cbiAgICBpZiAoZXhpdFN0cmljdCkgeyB0aGlzLnN0cmljdCA9IGZhbHNlOyB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKGNyZWF0ZU5ld0xleGljYWxTY29wZSkgeyB0aGlzLmV4aXRTY29wZSgpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkJsb2NrU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgLy8gUGFyc2UgYSByZWd1bGFyIGBmb3JgIGxvb3AuIFRoZSBkaXNhbWJpZ3VhdGlvbiBjb2RlIGluXG4gIC8vIGBwYXJzZVN0YXRlbWVudGAgd2lsbCBhbHJlYWR5IGhhdmUgcGFyc2VkIHRoZSBpbml0IHN0YXRlbWVudCBvclxuICAvLyBleHByZXNzaW9uLlxuXG4gIHBwJDgucGFyc2VGb3IgPSBmdW5jdGlvbihub2RlLCBpbml0KSB7XG4gICAgbm9kZS5pbml0ID0gaW5pdDtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLnNlbWkpO1xuICAgIG5vZGUudGVzdCA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zZW1pID8gbnVsbCA6IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMkMS5zZW1pKTtcbiAgICBub2RlLnVwZGF0ZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5wYXJlblIgPyBudWxsIDogdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLnBhcmVuUik7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcImZvclwiKTtcbiAgICB0aGlzLmV4aXRTY29wZSgpO1xuICAgIHRoaXMubGFiZWxzLnBvcCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJGb3JTdGF0ZW1lbnRcIilcbiAgfTtcblxuICAvLyBQYXJzZSBhIGBmb3JgL2BpbmAgYW5kIGBmb3JgL2BvZmAgbG9vcCwgd2hpY2ggYXJlIGFsbW9zdFxuICAvLyBzYW1lIGZyb20gcGFyc2VyJ3MgcGVyc3BlY3RpdmUuXG5cbiAgcHAkOC5wYXJzZUZvckluID0gZnVuY3Rpb24obm9kZSwgaW5pdCkge1xuICAgIHZhciBpc0ZvckluID0gdGhpcy50eXBlID09PSB0eXBlcyQxLl9pbjtcbiAgICB0aGlzLm5leHQoKTtcblxuICAgIGlmIChcbiAgICAgIGluaXQudHlwZSA9PT0gXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIgJiZcbiAgICAgIGluaXQuZGVjbGFyYXRpb25zWzBdLmluaXQgIT0gbnVsbCAmJlxuICAgICAgKFxuICAgICAgICAhaXNGb3JJbiB8fFxuICAgICAgICB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA4IHx8XG4gICAgICAgIHRoaXMuc3RyaWN0IHx8XG4gICAgICAgIGluaXQua2luZCAhPT0gXCJ2YXJcIiB8fFxuICAgICAgICBpbml0LmRlY2xhcmF0aW9uc1swXS5pZC50eXBlICE9PSBcIklkZW50aWZpZXJcIlxuICAgICAgKVxuICAgICkge1xuICAgICAgdGhpcy5yYWlzZShcbiAgICAgICAgaW5pdC5zdGFydCxcbiAgICAgICAgKChpc0ZvckluID8gXCJmb3ItaW5cIiA6IFwiZm9yLW9mXCIpICsgXCIgbG9vcCB2YXJpYWJsZSBkZWNsYXJhdGlvbiBtYXkgbm90IGhhdmUgYW4gaW5pdGlhbGl6ZXJcIilcbiAgICAgICk7XG4gICAgfVxuICAgIG5vZGUubGVmdCA9IGluaXQ7XG4gICAgbm9kZS5yaWdodCA9IGlzRm9ySW4gPyB0aGlzLnBhcnNlRXhwcmVzc2lvbigpIDogdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMkMS5wYXJlblIpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJmb3JcIik7XG4gICAgdGhpcy5leGl0U2NvcGUoKTtcbiAgICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzRm9ySW4gPyBcIkZvckluU3RhdGVtZW50XCIgOiBcIkZvck9mU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgLy8gUGFyc2UgYSBsaXN0IG9mIHZhcmlhYmxlIGRlY2xhcmF0aW9ucy5cblxuICBwcCQ4LnBhcnNlVmFyID0gZnVuY3Rpb24obm9kZSwgaXNGb3IsIGtpbmQsIGFsbG93TWlzc2luZ0luaXRpYWxpemVyKSB7XG4gICAgbm9kZS5kZWNsYXJhdGlvbnMgPSBbXTtcbiAgICBub2RlLmtpbmQgPSBraW5kO1xuICAgIGZvciAoOzspIHtcbiAgICAgIHZhciBkZWNsID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMucGFyc2VWYXJJZChkZWNsLCBraW5kKTtcbiAgICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLmVxKSkge1xuICAgICAgICBkZWNsLmluaXQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oaXNGb3IpO1xuICAgICAgfSBlbHNlIGlmICghYWxsb3dNaXNzaW5nSW5pdGlhbGl6ZXIgJiYga2luZCA9PT0gXCJjb25zdFwiICYmICEodGhpcy50eXBlID09PSB0eXBlcyQxLl9pbiB8fCAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgfSBlbHNlIGlmICghYWxsb3dNaXNzaW5nSW5pdGlhbGl6ZXIgJiYgZGVjbC5pZC50eXBlICE9PSBcIklkZW50aWZpZXJcIiAmJiAhKGlzRm9yICYmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2luIHx8IHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpKSkge1xuICAgICAgICB0aGlzLnJhaXNlKHRoaXMubGFzdFRva0VuZCwgXCJDb21wbGV4IGJpbmRpbmcgcGF0dGVybnMgcmVxdWlyZSBhbiBpbml0aWFsaXphdGlvbiB2YWx1ZVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlY2wuaW5pdCA9IG51bGw7XG4gICAgICB9XG4gICAgICBub2RlLmRlY2xhcmF0aW9ucy5wdXNoKHRoaXMuZmluaXNoTm9kZShkZWNsLCBcIlZhcmlhYmxlRGVjbGFyYXRvclwiKSk7XG4gICAgICBpZiAoIXRoaXMuZWF0KHR5cGVzJDEuY29tbWEpKSB7IGJyZWFrIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVcbiAgfTtcblxuICBwcCQ4LnBhcnNlVmFySWQgPSBmdW5jdGlvbihkZWNsLCBraW5kKSB7XG4gICAgZGVjbC5pZCA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICAgIHRoaXMuY2hlY2tMVmFsUGF0dGVybihkZWNsLmlkLCBraW5kID09PSBcInZhclwiID8gQklORF9WQVIgOiBCSU5EX0xFWElDQUwsIGZhbHNlKTtcbiAgfTtcblxuICB2YXIgRlVOQ19TVEFURU1FTlQgPSAxLCBGVU5DX0hBTkdJTkdfU1RBVEVNRU5UID0gMiwgRlVOQ19OVUxMQUJMRV9JRCA9IDQ7XG5cbiAgLy8gUGFyc2UgYSBmdW5jdGlvbiBkZWNsYXJhdGlvbiBvciBsaXRlcmFsIChkZXBlbmRpbmcgb24gdGhlXG4gIC8vIGBzdGF0ZW1lbnQgJiBGVU5DX1NUQVRFTUVOVGApLlxuXG4gIC8vIFJlbW92ZSBgYWxsb3dFeHByZXNzaW9uQm9keWAgZm9yIDcuMC4wLCBhcyBpdCBpcyBvbmx5IGNhbGxlZCB3aXRoIGZhbHNlXG4gIHBwJDgucGFyc2VGdW5jdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIHN0YXRlbWVudCwgYWxsb3dFeHByZXNzaW9uQm9keSwgaXNBc3luYywgZm9ySW5pdCkge1xuICAgIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSB8fCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiAhaXNBc3luYykge1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zdGFyICYmIChzdGF0ZW1lbnQgJiBGVU5DX0hBTkdJTkdfU1RBVEVNRU5UKSlcbiAgICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgbm9kZS5nZW5lcmF0b3IgPSB0aGlzLmVhdCh0eXBlcyQxLnN0YXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpXG4gICAgICB7IG5vZGUuYXN5bmMgPSAhIWlzQXN5bmM7IH1cblxuICAgIGlmIChzdGF0ZW1lbnQgJiBGVU5DX1NUQVRFTUVOVCkge1xuICAgICAgbm9kZS5pZCA9IChzdGF0ZW1lbnQgJiBGVU5DX05VTExBQkxFX0lEKSAmJiB0aGlzLnR5cGUgIT09IHR5cGVzJDEubmFtZSA/IG51bGwgOiB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICAgIGlmIChub2RlLmlkICYmICEoc3RhdGVtZW50ICYgRlVOQ19IQU5HSU5HX1NUQVRFTUVOVCkpXG4gICAgICAgIC8vIElmIGl0IGlzIGEgcmVndWxhciBmdW5jdGlvbiBkZWNsYXJhdGlvbiBpbiBzbG9wcHkgbW9kZSwgdGhlbiBpdCBpc1xuICAgICAgICAvLyBzdWJqZWN0IHRvIEFubmV4IEIgc2VtYW50aWNzIChCSU5EX0ZVTkNUSU9OKS4gT3RoZXJ3aXNlLCB0aGUgYmluZGluZ1xuICAgICAgICAvLyBtb2RlIGRlcGVuZHMgb24gcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBzY29wZSAoc2VlXG4gICAgICAgIC8vIHRyZWF0RnVuY3Rpb25zQXNWYXIpLlxuICAgICAgICB7IHRoaXMuY2hlY2tMVmFsU2ltcGxlKG5vZGUuaWQsICh0aGlzLnN0cmljdCB8fCBub2RlLmdlbmVyYXRvciB8fCBub2RlLmFzeW5jKSA/IHRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhciA/IEJJTkRfVkFSIDogQklORF9MRVhJQ0FMIDogQklORF9GVU5DVElPTik7IH1cbiAgICB9XG5cbiAgICB2YXIgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIG9sZEF3YWl0SWRlbnRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3M7XG4gICAgdGhpcy55aWVsZFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gMDtcbiAgICB0aGlzLmVudGVyU2NvcGUoZnVuY3Rpb25GbGFncyhub2RlLmFzeW5jLCBub2RlLmdlbmVyYXRvcikpO1xuXG4gICAgaWYgKCEoc3RhdGVtZW50ICYgRlVOQ19TVEFURU1FTlQpKVxuICAgICAgeyBub2RlLmlkID0gdGhpcy50eXBlID09PSB0eXBlcyQxLm5hbWUgPyB0aGlzLnBhcnNlSWRlbnQoKSA6IG51bGw7IH1cblxuICAgIHRoaXMucGFyc2VGdW5jdGlvblBhcmFtcyhub2RlKTtcbiAgICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGFsbG93RXhwcmVzc2lvbkJvZHksIGZhbHNlLCBmb3JJbml0KTtcblxuICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gb2xkQXdhaXRJZGVudFBvcztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIChzdGF0ZW1lbnQgJiBGVU5DX1NUQVRFTUVOVCkgPyBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiA6IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZUZ1bmN0aW9uUGFyYW1zID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEucGFyZW5MKTtcbiAgICBub2RlLnBhcmFtcyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdCh0eXBlcyQxLnBhcmVuUiwgZmFsc2UsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KTtcbiAgICB0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpO1xuICB9O1xuXG4gIC8vIFBhcnNlIGEgY2xhc3MgZGVjbGFyYXRpb24gb3IgbGl0ZXJhbCAoZGVwZW5kaW5nIG9uIHRoZVxuICAvLyBgaXNTdGF0ZW1lbnRgIHBhcmFtZXRlcikuXG5cbiAgcHAkOC5wYXJzZUNsYXNzID0gZnVuY3Rpb24obm9kZSwgaXNTdGF0ZW1lbnQpIHtcbiAgICB0aGlzLm5leHQoKTtcblxuICAgIC8vIGVjbWEtMjYyIDE0LjYgQ2xhc3MgRGVmaW5pdGlvbnNcbiAgICAvLyBBIGNsYXNzIGRlZmluaXRpb24gaXMgYWx3YXlzIHN0cmljdCBtb2RlIGNvZGUuXG4gICAgdmFyIG9sZFN0cmljdCA9IHRoaXMuc3RyaWN0O1xuICAgIHRoaXMuc3RyaWN0ID0gdHJ1ZTtcblxuICAgIHRoaXMucGFyc2VDbGFzc0lkKG5vZGUsIGlzU3RhdGVtZW50KTtcbiAgICB0aGlzLnBhcnNlQ2xhc3NTdXBlcihub2RlKTtcbiAgICB2YXIgcHJpdmF0ZU5hbWVNYXAgPSB0aGlzLmVudGVyQ2xhc3NCb2R5KCk7XG4gICAgdmFyIGNsYXNzQm9keSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdmFyIGhhZENvbnN0cnVjdG9yID0gZmFsc2U7XG4gICAgY2xhc3NCb2R5LmJvZHkgPSBbXTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmJyYWNlTCk7XG4gICAgd2hpbGUgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5icmFjZVIpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5wYXJzZUNsYXNzRWxlbWVudChub2RlLnN1cGVyQ2xhc3MgIT09IG51bGwpO1xuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgY2xhc3NCb2R5LmJvZHkucHVzaChlbGVtZW50KTtcbiAgICAgICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gXCJNZXRob2REZWZpbml0aW9uXCIgJiYgZWxlbWVudC5raW5kID09PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgICBpZiAoaGFkQ29uc3RydWN0b3IpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGVsZW1lbnQuc3RhcnQsIFwiRHVwbGljYXRlIGNvbnN0cnVjdG9yIGluIHRoZSBzYW1lIGNsYXNzXCIpOyB9XG4gICAgICAgICAgaGFkQ29uc3RydWN0b3IgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQua2V5ICYmIGVsZW1lbnQua2V5LnR5cGUgPT09IFwiUHJpdmF0ZUlkZW50aWZpZXJcIiAmJiBpc1ByaXZhdGVOYW1lQ29uZmxpY3RlZChwcml2YXRlTmFtZU1hcCwgZWxlbWVudCkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZWxlbWVudC5rZXkuc3RhcnQsIChcIklkZW50aWZpZXIgJyNcIiArIChlbGVtZW50LmtleS5uYW1lKSArIFwiJyBoYXMgYWxyZWFkeSBiZWVuIGRlY2xhcmVkXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnN0cmljdCA9IG9sZFN0cmljdDtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLmZpbmlzaE5vZGUoY2xhc3NCb2R5LCBcIkNsYXNzQm9keVwiKTtcbiAgICB0aGlzLmV4aXRDbGFzc0JvZHkoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzU3RhdGVtZW50ID8gXCJDbGFzc0RlY2xhcmF0aW9uXCIgOiBcIkNsYXNzRXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIHBwJDgucGFyc2VDbGFzc0VsZW1lbnQgPSBmdW5jdGlvbihjb25zdHJ1Y3RvckFsbG93c1N1cGVyKSB7XG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzJDEuc2VtaSkpIHsgcmV0dXJuIG51bGwgfVxuXG4gICAgdmFyIGVjbWFWZXJzaW9uID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uO1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB2YXIga2V5TmFtZSA9IFwiXCI7XG4gICAgdmFyIGlzR2VuZXJhdG9yID0gZmFsc2U7XG4gICAgdmFyIGlzQXN5bmMgPSBmYWxzZTtcbiAgICB2YXIga2luZCA9IFwibWV0aG9kXCI7XG4gICAgdmFyIGlzU3RhdGljID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKFwic3RhdGljXCIpKSB7XG4gICAgICAvLyBQYXJzZSBzdGF0aWMgaW5pdCBibG9ja1xuICAgICAgaWYgKGVjbWFWZXJzaW9uID49IDEzICYmIHRoaXMuZWF0KHR5cGVzJDEuYnJhY2VMKSkge1xuICAgICAgICB0aGlzLnBhcnNlQ2xhc3NTdGF0aWNCbG9jayhub2RlKTtcbiAgICAgICAgcmV0dXJuIG5vZGVcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzQ2xhc3NFbGVtZW50TmFtZVN0YXJ0KCkgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLnN0YXIpIHtcbiAgICAgICAgaXNTdGF0aWMgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5TmFtZSA9IFwic3RhdGljXCI7XG4gICAgICB9XG4gICAgfVxuICAgIG5vZGUuc3RhdGljID0gaXNTdGF0aWM7XG4gICAgaWYgKCFrZXlOYW1lICYmIGVjbWFWZXJzaW9uID49IDggJiYgdGhpcy5lYXRDb250ZXh0dWFsKFwiYXN5bmNcIikpIHtcbiAgICAgIGlmICgodGhpcy5pc0NsYXNzRWxlbWVudE5hbWVTdGFydCgpIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zdGFyKSAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgICBpc0FzeW5jID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleU5hbWUgPSBcImFzeW5jXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgha2V5TmFtZSAmJiAoZWNtYVZlcnNpb24gPj0gOSB8fCAhaXNBc3luYykgJiYgdGhpcy5lYXQodHlwZXMkMS5zdGFyKSkge1xuICAgICAgaXNHZW5lcmF0b3IgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWtleU5hbWUgJiYgIWlzQXN5bmMgJiYgIWlzR2VuZXJhdG9yKSB7XG4gICAgICB2YXIgbGFzdFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoXCJnZXRcIikgfHwgdGhpcy5lYXRDb250ZXh0dWFsKFwic2V0XCIpKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2xhc3NFbGVtZW50TmFtZVN0YXJ0KCkpIHtcbiAgICAgICAgICBraW5kID0gbGFzdFZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGtleU5hbWUgPSBsYXN0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQYXJzZSBlbGVtZW50IG5hbWVcbiAgICBpZiAoa2V5TmFtZSkge1xuICAgICAgLy8gJ2FzeW5jJywgJ2dldCcsICdzZXQnLCBvciAnc3RhdGljJyB3ZXJlIG5vdCBhIGtleXdvcmQgY29udGV4dHVhbGx5LlxuICAgICAgLy8gVGhlIGxhc3QgdG9rZW4gaXMgYW55IG9mIHRob3NlLiBNYWtlIGl0IHRoZSBlbGVtZW50IG5hbWUuXG4gICAgICBub2RlLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICBub2RlLmtleSA9IHRoaXMuc3RhcnROb2RlQXQodGhpcy5sYXN0VG9rU3RhcnQsIHRoaXMubGFzdFRva1N0YXJ0TG9jKTtcbiAgICAgIG5vZGUua2V5Lm5hbWUgPSBrZXlOYW1lO1xuICAgICAgdGhpcy5maW5pc2hOb2RlKG5vZGUua2V5LCBcIklkZW50aWZpZXJcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFyc2VDbGFzc0VsZW1lbnROYW1lKG5vZGUpO1xuICAgIH1cblxuICAgIC8vIFBhcnNlIGVsZW1lbnQgdmFsdWVcbiAgICBpZiAoZWNtYVZlcnNpb24gPCAxMyB8fCB0aGlzLnR5cGUgPT09IHR5cGVzJDEucGFyZW5MIHx8IGtpbmQgIT09IFwibWV0aG9kXCIgfHwgaXNHZW5lcmF0b3IgfHwgaXNBc3luYykge1xuICAgICAgdmFyIGlzQ29uc3RydWN0b3IgPSAhbm9kZS5zdGF0aWMgJiYgY2hlY2tLZXlOYW1lKG5vZGUsIFwiY29uc3RydWN0b3JcIik7XG4gICAgICB2YXIgYWxsb3dzRGlyZWN0U3VwZXIgPSBpc0NvbnN0cnVjdG9yICYmIGNvbnN0cnVjdG9yQWxsb3dzU3VwZXI7XG4gICAgICAvLyBDb3VsZG4ndCBtb3ZlIHRoaXMgY2hlY2sgaW50byB0aGUgJ3BhcnNlQ2xhc3NNZXRob2QnIG1ldGhvZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICAgIGlmIChpc0NvbnN0cnVjdG9yICYmIGtpbmQgIT09IFwibWV0aG9kXCIpIHsgdGhpcy5yYWlzZShub2RlLmtleS5zdGFydCwgXCJDb25zdHJ1Y3RvciBjYW4ndCBoYXZlIGdldC9zZXQgbW9kaWZpZXJcIik7IH1cbiAgICAgIG5vZGUua2luZCA9IGlzQ29uc3RydWN0b3IgPyBcImNvbnN0cnVjdG9yXCIgOiBraW5kO1xuICAgICAgdGhpcy5wYXJzZUNsYXNzTWV0aG9kKG5vZGUsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd3NEaXJlY3RTdXBlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFyc2VDbGFzc0ZpZWxkKG5vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlXG4gIH07XG5cbiAgcHAkOC5pc0NsYXNzRWxlbWVudE5hbWVTdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLnR5cGUgPT09IHR5cGVzJDEubmFtZSB8fFxuICAgICAgdGhpcy50eXBlID09PSB0eXBlcyQxLnByaXZhdGVJZCB8fFxuICAgICAgdGhpcy50eXBlID09PSB0eXBlcyQxLm51bSB8fFxuICAgICAgdGhpcy50eXBlID09PSB0eXBlcyQxLnN0cmluZyB8fFxuICAgICAgdGhpcy50eXBlID09PSB0eXBlcyQxLmJyYWNrZXRMIHx8XG4gICAgICB0aGlzLnR5cGUua2V5d29yZFxuICAgIClcbiAgfTtcblxuICBwcCQ4LnBhcnNlQ2xhc3NFbGVtZW50TmFtZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnByaXZhdGVJZCkge1xuICAgICAgaWYgKHRoaXMudmFsdWUgPT09IFwiY29uc3RydWN0b3JcIikge1xuICAgICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiQ2xhc3NlcyBjYW4ndCBoYXZlIGFuIGVsZW1lbnQgbmFtZWQgJyNjb25zdHJ1Y3RvcidcIik7XG4gICAgICB9XG4gICAgICBlbGVtZW50LmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICBlbGVtZW50LmtleSA9IHRoaXMucGFyc2VQcml2YXRlSWRlbnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShlbGVtZW50KTtcbiAgICB9XG4gIH07XG5cbiAgcHAkOC5wYXJzZUNsYXNzTWV0aG9kID0gZnVuY3Rpb24obWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYywgYWxsb3dzRGlyZWN0U3VwZXIpIHtcbiAgICAvLyBDaGVjayBrZXkgYW5kIGZsYWdzXG4gICAgdmFyIGtleSA9IG1ldGhvZC5rZXk7XG4gICAgaWYgKG1ldGhvZC5raW5kID09PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgIGlmIChpc0dlbmVyYXRvcikgeyB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDb25zdHJ1Y3RvciBjYW4ndCBiZSBhIGdlbmVyYXRvclwiKTsgfVxuICAgICAgaWYgKGlzQXN5bmMpIHsgdGhpcy5yYWlzZShrZXkuc3RhcnQsIFwiQ29uc3RydWN0b3IgY2FuJ3QgYmUgYW4gYXN5bmMgbWV0aG9kXCIpOyB9XG4gICAgfSBlbHNlIGlmIChtZXRob2Quc3RhdGljICYmIGNoZWNrS2V5TmFtZShtZXRob2QsIFwicHJvdG90eXBlXCIpKSB7XG4gICAgICB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDbGFzc2VzIG1heSBub3QgaGF2ZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBwcm90b3R5cGVcIik7XG4gICAgfVxuXG4gICAgLy8gUGFyc2UgdmFsdWVcbiAgICB2YXIgdmFsdWUgPSBtZXRob2QudmFsdWUgPSB0aGlzLnBhcnNlTWV0aG9kKGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd3NEaXJlY3RTdXBlcik7XG5cbiAgICAvLyBDaGVjayB2YWx1ZVxuICAgIGlmIChtZXRob2Qua2luZCA9PT0gXCJnZXRcIiAmJiB2YWx1ZS5wYXJhbXMubGVuZ3RoICE9PSAwKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodmFsdWUuc3RhcnQsIFwiZ2V0dGVyIHNob3VsZCBoYXZlIG5vIHBhcmFtc1wiKTsgfVxuICAgIGlmIChtZXRob2Qua2luZCA9PT0gXCJzZXRcIiAmJiB2YWx1ZS5wYXJhbXMubGVuZ3RoICE9PSAxKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodmFsdWUuc3RhcnQsIFwic2V0dGVyIHNob3VsZCBoYXZlIGV4YWN0bHkgb25lIHBhcmFtXCIpOyB9XG4gICAgaWYgKG1ldGhvZC5raW5kID09PSBcInNldFwiICYmIHZhbHVlLnBhcmFtc1swXS50eXBlID09PSBcIlJlc3RFbGVtZW50XCIpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh2YWx1ZS5wYXJhbXNbMF0uc3RhcnQsIFwiU2V0dGVyIGNhbm5vdCB1c2UgcmVzdCBwYXJhbXNcIik7IH1cblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobWV0aG9kLCBcIk1ldGhvZERlZmluaXRpb25cIilcbiAgfTtcblxuICBwcCQ4LnBhcnNlQ2xhc3NGaWVsZCA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgaWYgKGNoZWNrS2V5TmFtZShmaWVsZCwgXCJjb25zdHJ1Y3RvclwiKSkge1xuICAgICAgdGhpcy5yYWlzZShmaWVsZC5rZXkuc3RhcnQsIFwiQ2xhc3NlcyBjYW4ndCBoYXZlIGEgZmllbGQgbmFtZWQgJ2NvbnN0cnVjdG9yJ1wiKTtcbiAgICB9IGVsc2UgaWYgKGZpZWxkLnN0YXRpYyAmJiBjaGVja0tleU5hbWUoZmllbGQsIFwicHJvdG90eXBlXCIpKSB7XG4gICAgICB0aGlzLnJhaXNlKGZpZWxkLmtleS5zdGFydCwgXCJDbGFzc2VzIGNhbid0IGhhdmUgYSBzdGF0aWMgZmllbGQgbmFtZWQgJ3Byb3RvdHlwZSdcIik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzJDEuZXEpKSB7XG4gICAgICAvLyBUbyByYWlzZSBTeW50YXhFcnJvciBpZiAnYXJndW1lbnRzJyBleGlzdHMgaW4gdGhlIGluaXRpYWxpemVyLlxuICAgICAgdGhpcy5lbnRlclNjb3BlKFNDT1BFX0NMQVNTX0ZJRUxEX0lOSVQgfCBTQ09QRV9TVVBFUik7XG4gICAgICBmaWVsZC52YWx1ZSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgdGhpcy5leGl0U2NvcGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmllbGQudmFsdWUgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnNlbWljb2xvbigpO1xuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShmaWVsZCwgXCJQcm9wZXJ0eURlZmluaXRpb25cIilcbiAgfTtcblxuICBwcCQ4LnBhcnNlQ2xhc3NTdGF0aWNCbG9jayA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBub2RlLmJvZHkgPSBbXTtcblxuICAgIHZhciBvbGRMYWJlbHMgPSB0aGlzLmxhYmVscztcbiAgICB0aGlzLmxhYmVscyA9IFtdO1xuICAgIHRoaXMuZW50ZXJTY29wZShTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0sgfCBTQ09QRV9TVVBFUik7XG4gICAgd2hpbGUgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5icmFjZVIpIHtcbiAgICAgIHZhciBzdG10ID0gdGhpcy5wYXJzZVN0YXRlbWVudChudWxsKTtcbiAgICAgIG5vZGUuYm9keS5wdXNoKHN0bXQpO1xuICAgIH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLmV4aXRTY29wZSgpO1xuICAgIHRoaXMubGFiZWxzID0gb2xkTGFiZWxzO1xuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlN0YXRpY0Jsb2NrXCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZUNsYXNzSWQgPSBmdW5jdGlvbihub2RlLCBpc1N0YXRlbWVudCkge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEubmFtZSkge1xuICAgICAgbm9kZS5pZCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgICAgaWYgKGlzU3RhdGVtZW50KVxuICAgICAgICB7IHRoaXMuY2hlY2tMVmFsU2ltcGxlKG5vZGUuaWQsIEJJTkRfTEVYSUNBTCwgZmFsc2UpOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1N0YXRlbWVudCA9PT0gdHJ1ZSlcbiAgICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgbm9kZS5pZCA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIHBwJDgucGFyc2VDbGFzc1N1cGVyID0gZnVuY3Rpb24obm9kZSkge1xuICAgIG5vZGUuc3VwZXJDbGFzcyA9IHRoaXMuZWF0KHR5cGVzJDEuX2V4dGVuZHMpID8gdGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKG51bGwsIGZhbHNlKSA6IG51bGw7XG4gIH07XG5cbiAgcHAkOC5lbnRlckNsYXNzQm9keSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlbGVtZW50ID0ge2RlY2xhcmVkOiBPYmplY3QuY3JlYXRlKG51bGwpLCB1c2VkOiBbXX07XG4gICAgdGhpcy5wcml2YXRlTmFtZVN0YWNrLnB1c2goZWxlbWVudCk7XG4gICAgcmV0dXJuIGVsZW1lbnQuZGVjbGFyZWRcbiAgfTtcblxuICBwcCQ4LmV4aXRDbGFzc0JvZHkgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVmID0gdGhpcy5wcml2YXRlTmFtZVN0YWNrLnBvcCgpO1xuICAgIHZhciBkZWNsYXJlZCA9IHJlZi5kZWNsYXJlZDtcbiAgICB2YXIgdXNlZCA9IHJlZi51c2VkO1xuICAgIGlmICghdGhpcy5vcHRpb25zLmNoZWNrUHJpdmF0ZUZpZWxkcykgeyByZXR1cm4gfVxuICAgIHZhciBsZW4gPSB0aGlzLnByaXZhdGVOYW1lU3RhY2subGVuZ3RoO1xuICAgIHZhciBwYXJlbnQgPSBsZW4gPT09IDAgPyBudWxsIDogdGhpcy5wcml2YXRlTmFtZVN0YWNrW2xlbiAtIDFdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXNlZC5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGlkID0gdXNlZFtpXTtcbiAgICAgIGlmICghaGFzT3duKGRlY2xhcmVkLCBpZC5uYW1lKSkge1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgcGFyZW50LnVzZWQucHVzaChpZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGlkLnN0YXJ0LCAoXCJQcml2YXRlIGZpZWxkICcjXCIgKyAoaWQubmFtZSkgKyBcIicgbXVzdCBiZSBkZWNsYXJlZCBpbiBhbiBlbmNsb3NpbmcgY2xhc3NcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGlzUHJpdmF0ZU5hbWVDb25mbGljdGVkKHByaXZhdGVOYW1lTWFwLCBlbGVtZW50KSB7XG4gICAgdmFyIG5hbWUgPSBlbGVtZW50LmtleS5uYW1lO1xuICAgIHZhciBjdXJyID0gcHJpdmF0ZU5hbWVNYXBbbmFtZV07XG5cbiAgICB2YXIgbmV4dCA9IFwidHJ1ZVwiO1xuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFwiTWV0aG9kRGVmaW5pdGlvblwiICYmIChlbGVtZW50LmtpbmQgPT09IFwiZ2V0XCIgfHwgZWxlbWVudC5raW5kID09PSBcInNldFwiKSkge1xuICAgICAgbmV4dCA9IChlbGVtZW50LnN0YXRpYyA/IFwic1wiIDogXCJpXCIpICsgZWxlbWVudC5raW5kO1xuICAgIH1cblxuICAgIC8vIGBjbGFzcyB7IGdldCAjYSgpe307IHN0YXRpYyBzZXQgI2EoXyl7fSB9YCBpcyBhbHNvIGNvbmZsaWN0LlxuICAgIGlmIChcbiAgICAgIGN1cnIgPT09IFwiaWdldFwiICYmIG5leHQgPT09IFwiaXNldFwiIHx8XG4gICAgICBjdXJyID09PSBcImlzZXRcIiAmJiBuZXh0ID09PSBcImlnZXRcIiB8fFxuICAgICAgY3VyciA9PT0gXCJzZ2V0XCIgJiYgbmV4dCA9PT0gXCJzc2V0XCIgfHxcbiAgICAgIGN1cnIgPT09IFwic3NldFwiICYmIG5leHQgPT09IFwic2dldFwiXG4gICAgKSB7XG4gICAgICBwcml2YXRlTmFtZU1hcFtuYW1lXSA9IFwidHJ1ZVwiO1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIGlmICghY3Vycikge1xuICAgICAgcHJpdmF0ZU5hbWVNYXBbbmFtZV0gPSBuZXh0O1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tLZXlOYW1lKG5vZGUsIG5hbWUpIHtcbiAgICB2YXIgY29tcHV0ZWQgPSBub2RlLmNvbXB1dGVkO1xuICAgIHZhciBrZXkgPSBub2RlLmtleTtcbiAgICByZXR1cm4gIWNvbXB1dGVkICYmIChcbiAgICAgIGtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBrZXkubmFtZSA9PT0gbmFtZSB8fFxuICAgICAga2V5LnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmIGtleS52YWx1ZSA9PT0gbmFtZVxuICAgIClcbiAgfVxuXG4gIC8vIFBhcnNlcyBtb2R1bGUgZXhwb3J0IGRlY2xhcmF0aW9uLlxuXG4gIHBwJDgucGFyc2VFeHBvcnRBbGxEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIGV4cG9ydHMpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExKSB7XG4gICAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKFwiYXNcIikpIHtcbiAgICAgICAgbm9kZS5leHBvcnRlZCA9IHRoaXMucGFyc2VNb2R1bGVFeHBvcnROYW1lKCk7XG4gICAgICAgIHRoaXMuY2hlY2tFeHBvcnQoZXhwb3J0cywgbm9kZS5leHBvcnRlZCwgdGhpcy5sYXN0VG9rU3RhcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5leHBvcnRlZCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImZyb21cIik7XG4gICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5zdHJpbmcpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTYpXG4gICAgICB7IG5vZGUuYXR0cmlidXRlcyA9IHRoaXMucGFyc2VXaXRoQ2xhdXNlKCk7IH1cbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiKVxuICB9O1xuXG4gIHBwJDgucGFyc2VFeHBvcnQgPSBmdW5jdGlvbihub2RlLCBleHBvcnRzKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgLy8gZXhwb3J0ICogZnJvbSAnLi4uJ1xuICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLnN0YXIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUV4cG9ydEFsbERlY2xhcmF0aW9uKG5vZGUsIGV4cG9ydHMpXG4gICAgfVxuICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLl9kZWZhdWx0KSkgeyAvLyBleHBvcnQgZGVmYXVsdCAuLi5cbiAgICAgIHRoaXMuY2hlY2tFeHBvcnQoZXhwb3J0cywgXCJkZWZhdWx0XCIsIHRoaXMubGFzdFRva1N0YXJ0KTtcbiAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIpXG4gICAgfVxuICAgIC8vIGV4cG9ydCB2YXJ8Y29uc3R8bGV0fGZ1bmN0aW9ufGNsYXNzIC4uLlxuICAgIGlmICh0aGlzLnNob3VsZFBhcnNlRXhwb3J0U3RhdGVtZW50KCkpIHtcbiAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlRXhwb3J0RGVjbGFyYXRpb24obm9kZSk7XG4gICAgICBpZiAobm9kZS5kZWNsYXJhdGlvbi50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIilcbiAgICAgICAgeyB0aGlzLmNoZWNrVmFyaWFibGVFeHBvcnQoZXhwb3J0cywgbm9kZS5kZWNsYXJhdGlvbi5kZWNsYXJhdGlvbnMpOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgdGhpcy5jaGVja0V4cG9ydChleHBvcnRzLCBub2RlLmRlY2xhcmF0aW9uLmlkLCBub2RlLmRlY2xhcmF0aW9uLmlkLnN0YXJ0KTsgfVxuICAgICAgbm9kZS5zcGVjaWZpZXJzID0gW107XG4gICAgICBub2RlLnNvdXJjZSA9IG51bGw7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDE2KVxuICAgICAgICB7IG5vZGUuYXR0cmlidXRlcyA9IFtdOyB9XG4gICAgfSBlbHNlIHsgLy8gZXhwb3J0IHsgeCwgeSBhcyB6IH0gW2Zyb20gJy4uLiddXG4gICAgICBub2RlLmRlY2xhcmF0aW9uID0gbnVsbDtcbiAgICAgIG5vZGUuc3BlY2lmaWVycyA9IHRoaXMucGFyc2VFeHBvcnRTcGVjaWZpZXJzKGV4cG9ydHMpO1xuICAgICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbChcImZyb21cIikpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5zdHJpbmcpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxNilcbiAgICAgICAgICB7IG5vZGUuYXR0cmlidXRlcyA9IHRoaXMucGFyc2VXaXRoQ2xhdXNlKCk7IH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5zcGVjaWZpZXJzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIC8vIGNoZWNrIGZvciBrZXl3b3JkcyB1c2VkIGFzIGxvY2FsIG5hbWVzXG4gICAgICAgICAgdmFyIHNwZWMgPSBsaXN0W2ldO1xuXG4gICAgICAgICAgdGhpcy5jaGVja1VucmVzZXJ2ZWQoc3BlYy5sb2NhbCk7XG4gICAgICAgICAgLy8gY2hlY2sgaWYgZXhwb3J0IGlzIGRlZmluZWRcbiAgICAgICAgICB0aGlzLmNoZWNrTG9jYWxFeHBvcnQoc3BlYy5sb2NhbCk7XG5cbiAgICAgICAgICBpZiAoc3BlYy5sb2NhbC50eXBlID09PSBcIkxpdGVyYWxcIikge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShzcGVjLmxvY2FsLnN0YXJ0LCBcIkEgc3RyaW5nIGxpdGVyYWwgY2Fubm90IGJlIHVzZWQgYXMgYW4gZXhwb3J0ZWQgYmluZGluZyB3aXRob3V0IGBmcm9tYC5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbm9kZS5zb3VyY2UgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDE2KVxuICAgICAgICAgIHsgbm9kZS5hdHRyaWJ1dGVzID0gW107IH1cbiAgICAgIH1cbiAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZUV4cG9ydERlY2xhcmF0aW9uID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlU3RhdGVtZW50KG51bGwpXG4gIH07XG5cbiAgcHAkOC5wYXJzZUV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpc0FzeW5jO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2Z1bmN0aW9uIHx8IChpc0FzeW5jID0gdGhpcy5pc0FzeW5jRnVuY3Rpb24oKSkpIHtcbiAgICAgIHZhciBmTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGlmIChpc0FzeW5jKSB7IHRoaXMubmV4dCgpOyB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKGZOb2RlLCBGVU5DX1NUQVRFTUVOVCB8IEZVTkNfTlVMTEFCTEVfSUQsIGZhbHNlLCBpc0FzeW5jKVxuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLl9jbGFzcykge1xuICAgICAgdmFyIGNOb2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3MoY05vZGUsIFwibnVsbGFibGVJRFwiKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgICByZXR1cm4gZGVjbGFyYXRpb25cbiAgICB9XG4gIH07XG5cbiAgcHAkOC5jaGVja0V4cG9ydCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIHBvcykge1xuICAgIGlmICghZXhwb3J0cykgeyByZXR1cm4gfVxuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIilcbiAgICAgIHsgbmFtZSA9IG5hbWUudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgPyBuYW1lLm5hbWUgOiBuYW1lLnZhbHVlOyB9XG4gICAgaWYgKGhhc093bihleHBvcnRzLCBuYW1lKSlcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHBvcywgXCJEdXBsaWNhdGUgZXhwb3J0ICdcIiArIG5hbWUgKyBcIidcIik7IH1cbiAgICBleHBvcnRzW25hbWVdID0gdHJ1ZTtcbiAgfTtcblxuICBwcCQ4LmNoZWNrUGF0dGVybkV4cG9ydCA9IGZ1bmN0aW9uKGV4cG9ydHMsIHBhdCkge1xuICAgIHZhciB0eXBlID0gcGF0LnR5cGU7XG4gICAgaWYgKHR5cGUgPT09IFwiSWRlbnRpZmllclwiKVxuICAgICAgeyB0aGlzLmNoZWNrRXhwb3J0KGV4cG9ydHMsIHBhdCwgcGF0LnN0YXJ0KTsgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiKVxuICAgICAgeyBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHBhdC5wcm9wZXJ0aWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgICAge1xuICAgICAgICAgIHZhciBwcm9wID0gbGlzdFtpXTtcblxuICAgICAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHByb3ApO1xuICAgICAgICB9IH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcIkFycmF5UGF0dGVyblwiKVxuICAgICAgeyBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSBwYXQuZWxlbWVudHM7IGkkMSA8IGxpc3QkMS5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICAgIHZhciBlbHQgPSBsaXN0JDFbaSQxXTtcblxuICAgICAgICAgIGlmIChlbHQpIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgZWx0KTsgfVxuICAgICAgfSB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJQcm9wZXJ0eVwiKVxuICAgICAgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwYXQudmFsdWUpOyB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiKVxuICAgICAgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwYXQubGVmdCk7IH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcIlJlc3RFbGVtZW50XCIpXG4gICAgICB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHBhdC5hcmd1bWVudCk7IH1cbiAgfTtcblxuICBwcCQ4LmNoZWNrVmFyaWFibGVFeHBvcnQgPSBmdW5jdGlvbihleHBvcnRzLCBkZWNscykge1xuICAgIGlmICghZXhwb3J0cykgeyByZXR1cm4gfVxuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gZGVjbHM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAge1xuICAgICAgdmFyIGRlY2wgPSBsaXN0W2ldO1xuXG4gICAgICB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBkZWNsLmlkKTtcbiAgICB9XG4gIH07XG5cbiAgcHAkOC5zaG91bGRQYXJzZUV4cG9ydFN0YXRlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUua2V5d29yZCA9PT0gXCJ2YXJcIiB8fFxuICAgICAgdGhpcy50eXBlLmtleXdvcmQgPT09IFwiY29uc3RcIiB8fFxuICAgICAgdGhpcy50eXBlLmtleXdvcmQgPT09IFwiY2xhc3NcIiB8fFxuICAgICAgdGhpcy50eXBlLmtleXdvcmQgPT09IFwiZnVuY3Rpb25cIiB8fFxuICAgICAgdGhpcy5pc0xldCgpIHx8XG4gICAgICB0aGlzLmlzQXN5bmNGdW5jdGlvbigpXG4gIH07XG5cbiAgLy8gUGFyc2VzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgbW9kdWxlIGV4cG9ydHMuXG5cbiAgcHAkOC5wYXJzZUV4cG9ydFNwZWNpZmllciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS5sb2NhbCA9IHRoaXMucGFyc2VNb2R1bGVFeHBvcnROYW1lKCk7XG5cbiAgICBub2RlLmV4cG9ydGVkID0gdGhpcy5lYXRDb250ZXh0dWFsKFwiYXNcIikgPyB0aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpIDogbm9kZS5sb2NhbDtcbiAgICB0aGlzLmNoZWNrRXhwb3J0KFxuICAgICAgZXhwb3J0cyxcbiAgICAgIG5vZGUuZXhwb3J0ZWQsXG4gICAgICBub2RlLmV4cG9ydGVkLnN0YXJ0XG4gICAgKTtcblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRTcGVjaWZpZXJcIilcbiAgfTtcblxuICBwcCQ4LnBhcnNlRXhwb3J0U3BlY2lmaWVycyA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiAgICB2YXIgbm9kZXMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICAgIC8vIGV4cG9ydCB7IHgsIHkgYXMgeiB9IFtmcm9tICcuLi4nXVxuICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuYnJhY2VMKTtcbiAgICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzJDEuYnJhY2VSKSkge1xuICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmNvbW1hKTtcbiAgICAgICAgaWYgKHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKHR5cGVzJDEuYnJhY2VSKSkgeyBicmVhayB9XG4gICAgICB9IGVsc2UgeyBmaXJzdCA9IGZhbHNlOyB9XG5cbiAgICAgIG5vZGVzLnB1c2godGhpcy5wYXJzZUV4cG9ydFNwZWNpZmllcihleHBvcnRzKSk7XG4gICAgfVxuICAgIHJldHVybiBub2Rlc1xuICB9O1xuXG4gIC8vIFBhcnNlcyBpbXBvcnQgZGVjbGFyYXRpb24uXG5cbiAgcHAkOC5wYXJzZUltcG9ydCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcblxuICAgIC8vIGltcG9ydCAnLi4uJ1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuc3RyaW5nKSB7XG4gICAgICBub2RlLnNwZWNpZmllcnMgPSBlbXB0eSQxO1xuICAgICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zcGVjaWZpZXJzID0gdGhpcy5wYXJzZUltcG9ydFNwZWNpZmllcnMoKTtcbiAgICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImZyb21cIik7XG4gICAgICBub2RlLnNvdXJjZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zdHJpbmcgPyB0aGlzLnBhcnNlRXhwckF0b20oKSA6IHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDE2KVxuICAgICAgeyBub2RlLmF0dHJpYnV0ZXMgPSB0aGlzLnBhcnNlV2l0aENsYXVzZSgpOyB9XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RGVjbGFyYXRpb25cIilcbiAgfTtcblxuICAvLyBQYXJzZXMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBtb2R1bGUgaW1wb3J0cy5cblxuICBwcCQ4LnBhcnNlSW1wb3J0U3BlY2lmaWVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUuaW1wb3J0ZWQgPSB0aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpO1xuXG4gICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbChcImFzXCIpKSB7XG4gICAgICBub2RlLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2hlY2tVbnJlc2VydmVkKG5vZGUuaW1wb3J0ZWQpO1xuICAgICAgbm9kZS5sb2NhbCA9IG5vZGUuaW1wb3J0ZWQ7XG4gICAgfVxuICAgIHRoaXMuY2hlY2tMVmFsU2ltcGxlKG5vZGUubG9jYWwsIEJJTkRfTEVYSUNBTCk7XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0U3BlY2lmaWVyXCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZUltcG9ydERlZmF1bHRTcGVjaWZpZXIgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBpbXBvcnQgZGVmYXVsdE9iaiwgeyB4LCB5IGFzIHogfSBmcm9tICcuLi4nXG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICB0aGlzLmNoZWNrTFZhbFNpbXBsZShub2RlLmxvY2FsLCBCSU5EX0xFWElDQUwpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZUltcG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJhc1wiKTtcbiAgICBub2RlLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgdGhpcy5jaGVja0xWYWxTaW1wbGUobm9kZS5sb2NhbCwgQklORF9MRVhJQ0FMKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZUltcG9ydFNwZWNpZmllcnMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbm9kZXMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEubmFtZSkge1xuICAgICAgbm9kZXMucHVzaCh0aGlzLnBhcnNlSW1wb3J0RGVmYXVsdFNwZWNpZmllcigpKTtcbiAgICAgIGlmICghdGhpcy5lYXQodHlwZXMkMS5jb21tYSkpIHsgcmV0dXJuIG5vZGVzIH1cbiAgICB9XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zdGFyKSB7XG4gICAgICBub2Rlcy5wdXNoKHRoaXMucGFyc2VJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIoKSk7XG4gICAgICByZXR1cm4gbm9kZXNcbiAgICB9XG4gICAgdGhpcy5leHBlY3QodHlwZXMkMS5icmFjZUwpO1xuICAgIHdoaWxlICghdGhpcy5lYXQodHlwZXMkMS5icmFjZVIpKSB7XG4gICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuY29tbWEpO1xuICAgICAgICBpZiAodGhpcy5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMkMS5icmFjZVIpKSB7IGJyZWFrIH1cbiAgICAgIH0gZWxzZSB7IGZpcnN0ID0gZmFsc2U7IH1cblxuICAgICAgbm9kZXMucHVzaCh0aGlzLnBhcnNlSW1wb3J0U3BlY2lmaWVyKCkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXNcbiAgfTtcblxuICBwcCQ4LnBhcnNlV2l0aENsYXVzZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBub2RlcyA9IFtdO1xuICAgIGlmICghdGhpcy5lYXQodHlwZXMkMS5fd2l0aCkpIHtcbiAgICAgIHJldHVybiBub2Rlc1xuICAgIH1cbiAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmJyYWNlTCk7XG4gICAgdmFyIGF0dHJpYnV0ZUtleXMgPSB7fTtcbiAgICB2YXIgZmlyc3QgPSB0cnVlO1xuICAgIHdoaWxlICghdGhpcy5lYXQodHlwZXMkMS5icmFjZVIpKSB7XG4gICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuY29tbWEpO1xuICAgICAgICBpZiAodGhpcy5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMkMS5icmFjZVIpKSB7IGJyZWFrIH1cbiAgICAgIH0gZWxzZSB7IGZpcnN0ID0gZmFsc2U7IH1cblxuICAgICAgdmFyIGF0dHIgPSB0aGlzLnBhcnNlSW1wb3J0QXR0cmlidXRlKCk7XG4gICAgICB2YXIga2V5TmFtZSA9IGF0dHIua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiID8gYXR0ci5rZXkubmFtZSA6IGF0dHIua2V5LnZhbHVlO1xuICAgICAgaWYgKGhhc093bihhdHRyaWJ1dGVLZXlzLCBrZXlOYW1lKSlcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoYXR0ci5rZXkuc3RhcnQsIFwiRHVwbGljYXRlIGF0dHJpYnV0ZSBrZXkgJ1wiICsga2V5TmFtZSArIFwiJ1wiKTsgfVxuICAgICAgYXR0cmlidXRlS2V5c1trZXlOYW1lXSA9IHRydWU7XG4gICAgICBub2Rlcy5wdXNoKGF0dHIpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXNcbiAgfTtcblxuICBwcCQ4LnBhcnNlSW1wb3J0QXR0cmlidXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUua2V5ID0gdGhpcy50eXBlID09PSB0eXBlcyQxLnN0cmluZyA/IHRoaXMucGFyc2VFeHByQXRvbSgpIDogdGhpcy5wYXJzZUlkZW50KHRoaXMub3B0aW9ucy5hbGxvd1Jlc2VydmVkICE9PSBcIm5ldmVyXCIpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuY29sb24pO1xuICAgIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzJDEuc3RyaW5nKSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gICAgbm9kZS52YWx1ZSA9IHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnRBdHRyaWJ1dGVcIilcbiAgfTtcblxuICBwcCQ4LnBhcnNlTW9kdWxlRXhwb3J0TmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTMgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLnN0cmluZykge1xuICAgICAgdmFyIHN0cmluZ0xpdGVyYWwgPSB0aGlzLnBhcnNlTGl0ZXJhbCh0aGlzLnZhbHVlKTtcbiAgICAgIGlmIChsb25lU3Vycm9nYXRlLnRlc3Qoc3RyaW5nTGl0ZXJhbC52YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShzdHJpbmdMaXRlcmFsLnN0YXJ0LCBcIkFuIGV4cG9ydCBuYW1lIGNhbm5vdCBpbmNsdWRlIGEgbG9uZSBzdXJyb2dhdGUuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmluZ0xpdGVyYWxcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VJZGVudCh0cnVlKVxuICB9O1xuXG4gIC8vIFNldCBgRXhwcmVzc2lvblN0YXRlbWVudCNkaXJlY3RpdmVgIHByb3BlcnR5IGZvciBkaXJlY3RpdmUgcHJvbG9ndWVzLlxuICBwcCQ4LmFkYXB0RGlyZWN0aXZlUHJvbG9ndWUgPSBmdW5jdGlvbihzdGF0ZW1lbnRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZW1lbnRzLmxlbmd0aCAmJiB0aGlzLmlzRGlyZWN0aXZlQ2FuZGlkYXRlKHN0YXRlbWVudHNbaV0pOyArK2kpIHtcbiAgICAgIHN0YXRlbWVudHNbaV0uZGlyZWN0aXZlID0gc3RhdGVtZW50c1tpXS5leHByZXNzaW9uLnJhdy5zbGljZSgxLCAtMSk7XG4gICAgfVxuICB9O1xuICBwcCQ4LmlzRGlyZWN0aXZlQ2FuZGlkYXRlID0gZnVuY3Rpb24oc3RhdGVtZW50KSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA1ICYmXG4gICAgICBzdGF0ZW1lbnQudHlwZSA9PT0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCIgJiZcbiAgICAgIHN0YXRlbWVudC5leHByZXNzaW9uLnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmXG4gICAgICB0eXBlb2Ygc3RhdGVtZW50LmV4cHJlc3Npb24udmFsdWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgIC8vIFJlamVjdCBwYXJlbnRoZXNpemVkIHN0cmluZ3MuXG4gICAgICAodGhpcy5pbnB1dFtzdGF0ZW1lbnQuc3RhcnRdID09PSBcIlxcXCJcIiB8fCB0aGlzLmlucHV0W3N0YXRlbWVudC5zdGFydF0gPT09IFwiJ1wiKVxuICAgIClcbiAgfTtcblxuICB2YXIgcHAkNyA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgLy8gQ29udmVydCBleGlzdGluZyBleHByZXNzaW9uIGF0b20gdG8gYXNzaWduYWJsZSBwYXR0ZXJuXG4gIC8vIGlmIHBvc3NpYmxlLlxuXG4gIHBwJDcudG9Bc3NpZ25hYmxlID0gZnVuY3Rpb24obm9kZSwgaXNCaW5kaW5nLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIG5vZGUpIHtcbiAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgICBpZiAodGhpcy5pbkFzeW5jICYmIG5vZGUubmFtZSA9PT0gXCJhd2FpdFwiKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIkNhbm5vdCB1c2UgJ2F3YWl0JyBhcyBpZGVudGlmaWVyIGluc2lkZSBhbiBhc3luYyBmdW5jdGlvblwiKTsgfVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgICAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgICAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgICBjYXNlIFwiUmVzdEVsZW1lbnRcIjpcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIk9iamVjdEV4cHJlc3Npb25cIjpcbiAgICAgICAgbm9kZS50eXBlID0gXCJPYmplY3RQYXR0ZXJuXCI7XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpOyB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5wcm9wZXJ0aWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIHZhciBwcm9wID0gbGlzdFtpXTtcblxuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShwcm9wLCBpc0JpbmRpbmcpO1xuICAgICAgICAgIC8vIEVhcmx5IGVycm9yOlxuICAgICAgICAgIC8vICAgQXNzaWdubWVudFJlc3RQcm9wZXJ0eVtZaWVsZCwgQXdhaXRdIDpcbiAgICAgICAgICAvLyAgICAgYC4uLmAgRGVzdHJ1Y3R1cmluZ0Fzc2lnbm1lbnRUYXJnZXRbWWllbGQsIEF3YWl0XVxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gICBJdCBpcyBhIFN5bnRheCBFcnJvciBpZiB8RGVzdHJ1Y3R1cmluZ0Fzc2lnbm1lbnRUYXJnZXR8IGlzIGFuIHxBcnJheUxpdGVyYWx8IG9yIGFuIHxPYmplY3RMaXRlcmFsfC5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBwcm9wLnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIiAmJlxuICAgICAgICAgICAgKHByb3AuYXJndW1lbnQudHlwZSA9PT0gXCJBcnJheVBhdHRlcm5cIiB8fCBwcm9wLmFyZ3VtZW50LnR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShwcm9wLmFyZ3VtZW50LnN0YXJ0LCBcIlVuZXhwZWN0ZWQgdG9rZW5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJQcm9wZXJ0eVwiOlxuICAgICAgICAvLyBBc3NpZ25tZW50UHJvcGVydHkgaGFzIHR5cGUgPT09IFwiUHJvcGVydHlcIlxuICAgICAgICBpZiAobm9kZS5raW5kICE9PSBcImluaXRcIikgeyB0aGlzLnJhaXNlKG5vZGUua2V5LnN0YXJ0LCBcIk9iamVjdCBwYXR0ZXJuIGNhbid0IGNvbnRhaW4gZ2V0dGVyIG9yIHNldHRlclwiKTsgfVxuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLnZhbHVlLCBpc0JpbmRpbmcpO1xuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiQXJyYXlFeHByZXNzaW9uXCI6XG4gICAgICAgIG5vZGUudHlwZSA9IFwiQXJyYXlQYXR0ZXJuXCI7XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpOyB9XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlTGlzdChub2RlLmVsZW1lbnRzLCBpc0JpbmRpbmcpO1xuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiU3ByZWFkRWxlbWVudFwiOlxuICAgICAgICBub2RlLnR5cGUgPSBcIlJlc3RFbGVtZW50XCI7XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUuYXJndW1lbnQsIGlzQmluZGluZyk7XG4gICAgICAgIGlmIChub2RlLmFyZ3VtZW50LnR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIilcbiAgICAgICAgICB7IHRoaXMucmFpc2Uobm9kZS5hcmd1bWVudC5zdGFydCwgXCJSZXN0IGVsZW1lbnRzIGNhbm5vdCBoYXZlIGEgZGVmYXVsdCB2YWx1ZVwiKTsgfVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKG5vZGUub3BlcmF0b3IgIT09IFwiPVwiKSB7IHRoaXMucmFpc2Uobm9kZS5sZWZ0LmVuZCwgXCJPbmx5ICc9JyBvcGVyYXRvciBjYW4gYmUgdXNlZCBmb3Igc3BlY2lmeWluZyBkZWZhdWx0IHZhbHVlLlwiKTsgfVxuICAgICAgICBub2RlLnR5cGUgPSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI7XG4gICAgICAgIGRlbGV0ZSBub2RlLm9wZXJhdG9yO1xuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLmxlZnQsIGlzQmluZGluZyk7XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLmV4cHJlc3Npb24sIGlzQmluZGluZywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJDaGFpbkV4cHJlc3Npb25cIjpcbiAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiT3B0aW9uYWwgY2hhaW5pbmcgY2Fubm90IGFwcGVhciBpbiBsZWZ0LWhhbmQgc2lkZVwiKTtcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKCFpc0JpbmRpbmcpIHsgYnJlYWsgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiQXNzaWduaW5nIHRvIHJ2YWx1ZVwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7IH1cbiAgICByZXR1cm4gbm9kZVxuICB9O1xuXG4gIC8vIENvbnZlcnQgbGlzdCBvZiBleHByZXNzaW9uIGF0b21zIHRvIGJpbmRpbmcgbGlzdC5cblxuICBwcCQ3LnRvQXNzaWduYWJsZUxpc3QgPSBmdW5jdGlvbihleHByTGlzdCwgaXNCaW5kaW5nKSB7XG4gICAgdmFyIGVuZCA9IGV4cHJMaXN0Lmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB2YXIgZWx0ID0gZXhwckxpc3RbaV07XG4gICAgICBpZiAoZWx0KSB7IHRoaXMudG9Bc3NpZ25hYmxlKGVsdCwgaXNCaW5kaW5nKTsgfVxuICAgIH1cbiAgICBpZiAoZW5kKSB7XG4gICAgICB2YXIgbGFzdCA9IGV4cHJMaXN0W2VuZCAtIDFdO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gNiAmJiBpc0JpbmRpbmcgJiYgbGFzdCAmJiBsYXN0LnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIiAmJiBsYXN0LmFyZ3VtZW50LnR5cGUgIT09IFwiSWRlbnRpZmllclwiKVxuICAgICAgICB7IHRoaXMudW5leHBlY3RlZChsYXN0LmFyZ3VtZW50LnN0YXJ0KTsgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwckxpc3RcbiAgfTtcblxuICAvLyBQYXJzZXMgc3ByZWFkIGVsZW1lbnQuXG5cbiAgcHAkNy5wYXJzZVNwcmVhZCA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlNwcmVhZEVsZW1lbnRcIilcbiAgfTtcblxuICBwcCQ3LnBhcnNlUmVzdEJpbmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG5cbiAgICAvLyBSZXN0RWxlbWVudCBpbnNpZGUgb2YgYSBmdW5jdGlvbiBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpZGVudGlmaWVyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gNiAmJiB0aGlzLnR5cGUgIT09IHR5cGVzJDEubmFtZSlcbiAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cblxuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJSZXN0RWxlbWVudFwiKVxuICB9O1xuXG4gIC8vIFBhcnNlcyBsdmFsdWUgKGFzc2lnbmFibGUpIGF0b20uXG5cbiAgcHAkNy5wYXJzZUJpbmRpbmdBdG9tID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgY2FzZSB0eXBlcyQxLmJyYWNrZXRMOlxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBub2RlLmVsZW1lbnRzID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KHR5cGVzJDEuYnJhY2tldFIsIHRydWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyYXlQYXR0ZXJuXCIpXG5cbiAgICAgIGNhc2UgdHlwZXMkMS5icmFjZUw6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqKHRydWUpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlSWRlbnQoKVxuICB9O1xuXG4gIHBwJDcucGFyc2VCaW5kaW5nTGlzdCA9IGZ1bmN0aW9uKGNsb3NlLCBhbGxvd0VtcHR5LCBhbGxvd1RyYWlsaW5nQ29tbWEsIGFsbG93TW9kaWZpZXJzKSB7XG4gICAgdmFyIGVsdHMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICAgIHdoaWxlICghdGhpcy5lYXQoY2xvc2UpKSB7XG4gICAgICBpZiAoZmlyc3QpIHsgZmlyc3QgPSBmYWxzZTsgfVxuICAgICAgZWxzZSB7IHRoaXMuZXhwZWN0KHR5cGVzJDEuY29tbWEpOyB9XG4gICAgICBpZiAoYWxsb3dFbXB0eSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzJDEuY29tbWEpIHtcbiAgICAgICAgZWx0cy5wdXNoKG51bGwpO1xuICAgICAgfSBlbHNlIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEoY2xvc2UpKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5lbGxpcHNpcykge1xuICAgICAgICB2YXIgcmVzdCA9IHRoaXMucGFyc2VSZXN0QmluZGluZygpO1xuICAgICAgICB0aGlzLnBhcnNlQmluZGluZ0xpc3RJdGVtKHJlc3QpO1xuICAgICAgICBlbHRzLnB1c2gocmVzdCk7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuY29tbWEpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpOyB9XG4gICAgICAgIHRoaXMuZXhwZWN0KGNsb3NlKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsdHMucHVzaCh0aGlzLnBhcnNlQXNzaWduYWJsZUxpc3RJdGVtKGFsbG93TW9kaWZpZXJzKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbHRzXG4gIH07XG5cbiAgcHAkNy5wYXJzZUFzc2lnbmFibGVMaXN0SXRlbSA9IGZ1bmN0aW9uKGFsbG93TW9kaWZpZXJzKSB7XG4gICAgdmFyIGVsZW0gPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHRoaXMuc3RhcnQsIHRoaXMuc3RhcnRMb2MpO1xuICAgIHRoaXMucGFyc2VCaW5kaW5nTGlzdEl0ZW0oZWxlbSk7XG4gICAgcmV0dXJuIGVsZW1cbiAgfTtcblxuICBwcCQ3LnBhcnNlQmluZGluZ0xpc3RJdGVtID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgICByZXR1cm4gcGFyYW1cbiAgfTtcblxuICAvLyBQYXJzZXMgYXNzaWdubWVudCBwYXR0ZXJuIGFyb3VuZCBnaXZlbiBhdG9tIGlmIHBvc3NpYmxlLlxuXG4gIHBwJDcucGFyc2VNYXliZURlZmF1bHQgPSBmdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIGxlZnQpIHtcbiAgICBsZWZ0ID0gbGVmdCB8fCB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNiB8fCAhdGhpcy5lYXQodHlwZXMkMS5lcSkpIHsgcmV0dXJuIGxlZnQgfVxuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUubGVmdCA9IGxlZnQ7XG4gICAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50UGF0dGVyblwiKVxuICB9O1xuXG4gIC8vIFRoZSBmb2xsb3dpbmcgdGhyZWUgZnVuY3Rpb25zIGFsbCB2ZXJpZnkgdGhhdCBhIG5vZGUgaXMgYW4gbHZhbHVlIOKAlFxuICAvLyBzb21ldGhpbmcgdGhhdCBjYW4gYmUgYm91bmQsIG9yIGFzc2lnbmVkIHRvLiBJbiBvcmRlciB0byBkbyBzbywgdGhleSBwZXJmb3JtXG4gIC8vIGEgdmFyaWV0eSBvZiBjaGVja3M6XG4gIC8vXG4gIC8vIC0gQ2hlY2sgdGhhdCBub25lIG9mIHRoZSBib3VuZC9hc3NpZ25lZC10byBpZGVudGlmaWVycyBhcmUgcmVzZXJ2ZWQgd29yZHMuXG4gIC8vIC0gUmVjb3JkIG5hbWUgZGVjbGFyYXRpb25zIGZvciBiaW5kaW5ncyBpbiB0aGUgYXBwcm9wcmlhdGUgc2NvcGUuXG4gIC8vIC0gQ2hlY2sgZHVwbGljYXRlIGFyZ3VtZW50IG5hbWVzLCBpZiBjaGVja0NsYXNoZXMgaXMgc2V0LlxuICAvL1xuICAvLyBJZiBhIGNvbXBsZXggYmluZGluZyBwYXR0ZXJuIGlzIGVuY291bnRlcmVkIChlLmcuLCBvYmplY3QgYW5kIGFycmF5XG4gIC8vIGRlc3RydWN0dXJpbmcpLCB0aGUgZW50aXJlIHBhdHRlcm4gaXMgcmVjdXJzaXZlbHkgY2hlY2tlZC5cbiAgLy9cbiAgLy8gVGhlcmUgYXJlIHRocmVlIHZlcnNpb25zIG9mIGNoZWNrTFZhbCooKSBhcHByb3ByaWF0ZSBmb3IgZGlmZmVyZW50XG4gIC8vIGNpcmN1bXN0YW5jZXM6XG4gIC8vXG4gIC8vIC0gY2hlY2tMVmFsU2ltcGxlKCkgc2hhbGwgYmUgdXNlZCBpZiB0aGUgc3ludGFjdGljIGNvbnN0cnVjdCBzdXBwb3J0c1xuICAvLyAgIG5vdGhpbmcgb3RoZXIgdGhhbiBpZGVudGlmaWVycyBhbmQgbWVtYmVyIGV4cHJlc3Npb25zLiBQYXJlbnRoZXNpemVkXG4gIC8vICAgZXhwcmVzc2lvbnMgYXJlIGFsc28gY29ycmVjdGx5IGhhbmRsZWQuIFRoaXMgaXMgZ2VuZXJhbGx5IGFwcHJvcHJpYXRlIGZvclxuICAvLyAgIGNvbnN0cnVjdHMgZm9yIHdoaWNoIHRoZSBzcGVjIHNheXNcbiAgLy9cbiAgLy8gICA+IEl0IGlzIGEgU3ludGF4IEVycm9yIGlmIEFzc2lnbm1lbnRUYXJnZXRUeXBlIG9mIFt0aGUgcHJvZHVjdGlvbl0gaXMgbm90XG4gIC8vICAgPiBzaW1wbGUuXG4gIC8vXG4gIC8vICAgSXQgaXMgYWxzbyBhcHByb3ByaWF0ZSBmb3IgY2hlY2tpbmcgaWYgYW4gaWRlbnRpZmllciBpcyB2YWxpZCBhbmQgbm90XG4gIC8vICAgZGVmaW5lZCBlbHNld2hlcmUsIGxpa2UgaW1wb3J0IGRlY2xhcmF0aW9ucyBvciBmdW5jdGlvbi9jbGFzcyBpZGVudGlmaWVycy5cbiAgLy9cbiAgLy8gICBFeGFtcGxlcyB3aGVyZSB0aGlzIGlzIHVzZWQgaW5jbHVkZTpcbiAgLy8gICAgIGEgKz0g4oCmO1xuICAvLyAgICAgaW1wb3J0IGEgZnJvbSAn4oCmJztcbiAgLy8gICB3aGVyZSBhIGlzIHRoZSBub2RlIHRvIGJlIGNoZWNrZWQuXG4gIC8vXG4gIC8vIC0gY2hlY2tMVmFsUGF0dGVybigpIHNoYWxsIGJlIHVzZWQgaWYgdGhlIHN5bnRhY3RpYyBjb25zdHJ1Y3Qgc3VwcG9ydHNcbiAgLy8gICBhbnl0aGluZyBjaGVja0xWYWxTaW1wbGUoKSBzdXBwb3J0cywgYXMgd2VsbCBhcyBvYmplY3QgYW5kIGFycmF5XG4gIC8vICAgZGVzdHJ1Y3R1cmluZyBwYXR0ZXJucy4gVGhpcyBpcyBnZW5lcmFsbHkgYXBwcm9wcmlhdGUgZm9yIGNvbnN0cnVjdHMgZm9yXG4gIC8vICAgd2hpY2ggdGhlIHNwZWMgc2F5c1xuICAvL1xuICAvLyAgID4gSXQgaXMgYSBTeW50YXggRXJyb3IgaWYgW3RoZSBwcm9kdWN0aW9uXSBpcyBuZWl0aGVyIGFuIE9iamVjdExpdGVyYWwgbm9yXG4gIC8vICAgPiBhbiBBcnJheUxpdGVyYWwgYW5kIEFzc2lnbm1lbnRUYXJnZXRUeXBlIG9mIFt0aGUgcHJvZHVjdGlvbl0gaXMgbm90XG4gIC8vICAgPiBzaW1wbGUuXG4gIC8vXG4gIC8vICAgRXhhbXBsZXMgd2hlcmUgdGhpcyBpcyB1c2VkIGluY2x1ZGU6XG4gIC8vICAgICAoYSA9IOKApik7XG4gIC8vICAgICBjb25zdCBhID0g4oCmO1xuICAvLyAgICAgdHJ5IHsg4oCmIH0gY2F0Y2ggKGEpIHsg4oCmIH1cbiAgLy8gICB3aGVyZSBhIGlzIHRoZSBub2RlIHRvIGJlIGNoZWNrZWQuXG4gIC8vXG4gIC8vIC0gY2hlY2tMVmFsSW5uZXJQYXR0ZXJuKCkgc2hhbGwgYmUgdXNlZCBpZiB0aGUgc3ludGFjdGljIGNvbnN0cnVjdCBzdXBwb3J0c1xuICAvLyAgIGFueXRoaW5nIGNoZWNrTFZhbFBhdHRlcm4oKSBzdXBwb3J0cywgYXMgd2VsbCBhcyBkZWZhdWx0IGFzc2lnbm1lbnRcbiAgLy8gICBwYXR0ZXJucywgcmVzdCBlbGVtZW50cywgYW5kIG90aGVyIGNvbnN0cnVjdHMgdGhhdCBtYXkgYXBwZWFyIHdpdGhpbiBhblxuICAvLyAgIG9iamVjdCBvciBhcnJheSBkZXN0cnVjdHVyaW5nIHBhdHRlcm4uXG4gIC8vXG4gIC8vICAgQXMgYSBzcGVjaWFsIGNhc2UsIGZ1bmN0aW9uIHBhcmFtZXRlcnMgYWxzbyB1c2UgY2hlY2tMVmFsSW5uZXJQYXR0ZXJuKCksXG4gIC8vICAgYXMgdGhleSBhbHNvIHN1cHBvcnQgZGVmYXVsdHMgYW5kIHJlc3QgY29uc3RydWN0cy5cbiAgLy9cbiAgLy8gVGhlc2UgZnVuY3Rpb25zIGRlbGliZXJhdGVseSBzdXBwb3J0IGJvdGggYXNzaWdubWVudCBhbmQgYmluZGluZyBjb25zdHJ1Y3RzLFxuICAvLyBhcyB0aGUgbG9naWMgZm9yIGJvdGggaXMgZXhjZWVkaW5nbHkgc2ltaWxhci4gSWYgdGhlIG5vZGUgaXMgdGhlIHRhcmdldCBvZlxuICAvLyBhbiBhc3NpZ25tZW50LCB0aGVuIGJpbmRpbmdUeXBlIHNob3VsZCBiZSBzZXQgdG8gQklORF9OT05FLiBPdGhlcndpc2UsIGl0XG4gIC8vIHNob3VsZCBiZSBzZXQgdG8gdGhlIGFwcHJvcHJpYXRlIEJJTkRfKiBjb25zdGFudCwgbGlrZSBCSU5EX1ZBUiBvclxuICAvLyBCSU5EX0xFWElDQUwuXG4gIC8vXG4gIC8vIElmIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhIG5vbi1CSU5EX05PTkUgYmluZGluZ1R5cGUsIHRoZW5cbiAgLy8gYWRkaXRpb25hbGx5IGEgY2hlY2tDbGFzaGVzIG9iamVjdCBtYXkgYmUgc3BlY2lmaWVkIHRvIGFsbG93IGNoZWNraW5nIGZvclxuICAvLyBkdXBsaWNhdGUgYXJndW1lbnQgbmFtZXMuIGNoZWNrQ2xhc2hlcyBpcyBpZ25vcmVkIGlmIHRoZSBwcm92aWRlZCBjb25zdHJ1Y3RcbiAgLy8gaXMgYW4gYXNzaWdubWVudCAoaS5lLiwgYmluZGluZ1R5cGUgaXMgQklORF9OT05FKS5cblxuICBwcCQ3LmNoZWNrTFZhbFNpbXBsZSA9IGZ1bmN0aW9uKGV4cHIsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpIHtcbiAgICBpZiAoIGJpbmRpbmdUeXBlID09PSB2b2lkIDAgKSBiaW5kaW5nVHlwZSA9IEJJTkRfTk9ORTtcblxuICAgIHZhciBpc0JpbmQgPSBiaW5kaW5nVHlwZSAhPT0gQklORF9OT05FO1xuXG4gICAgc3dpdGNoIChleHByLnR5cGUpIHtcbiAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgaWYgKHRoaXMuc3RyaWN0ICYmIHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdEJpbmQudGVzdChleHByLm5hbWUpKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCAoaXNCaW5kID8gXCJCaW5kaW5nIFwiIDogXCJBc3NpZ25pbmcgdG8gXCIpICsgZXhwci5uYW1lICsgXCIgaW4gc3RyaWN0IG1vZGVcIik7IH1cbiAgICAgIGlmIChpc0JpbmQpIHtcbiAgICAgICAgaWYgKGJpbmRpbmdUeXBlID09PSBCSU5EX0xFWElDQUwgJiYgZXhwci5uYW1lID09PSBcImxldFwiKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIFwibGV0IGlzIGRpc2FsbG93ZWQgYXMgYSBsZXhpY2FsbHkgYm91bmQgbmFtZVwiKTsgfVxuICAgICAgICBpZiAoY2hlY2tDbGFzaGVzKSB7XG4gICAgICAgICAgaWYgKGhhc093bihjaGVja0NsYXNoZXMsIGV4cHIubmFtZSkpXG4gICAgICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCBcIkFyZ3VtZW50IG5hbWUgY2xhc2hcIik7IH1cbiAgICAgICAgICBjaGVja0NsYXNoZXNbZXhwci5uYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJpbmRpbmdUeXBlICE9PSBCSU5EX09VVFNJREUpIHsgdGhpcy5kZWNsYXJlTmFtZShleHByLm5hbWUsIGJpbmRpbmdUeXBlLCBleHByLnN0YXJ0KTsgfVxuICAgICAgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJDaGFpbkV4cHJlc3Npb25cIjpcbiAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCBcIk9wdGlvbmFsIGNoYWluaW5nIGNhbm5vdCBhcHBlYXIgaW4gbGVmdC1oYW5kIHNpZGVcIik7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgIGlmIChpc0JpbmQpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIFwiQmluZGluZyBtZW1iZXIgZXhwcmVzc2lvblwiKTsgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgICAgaWYgKGlzQmluZCkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXhwci5zdGFydCwgXCJCaW5kaW5nIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvblwiKTsgfVxuICAgICAgcmV0dXJuIHRoaXMuY2hlY2tMVmFsU2ltcGxlKGV4cHIuZXhwcmVzc2lvbiwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcylcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLnJhaXNlKGV4cHIuc3RhcnQsIChpc0JpbmQgPyBcIkJpbmRpbmdcIiA6IFwiQXNzaWduaW5nIHRvXCIpICsgXCIgcnZhbHVlXCIpO1xuICAgIH1cbiAgfTtcblxuICBwcCQ3LmNoZWNrTFZhbFBhdHRlcm4gPSBmdW5jdGlvbihleHByLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKSB7XG4gICAgaWYgKCBiaW5kaW5nVHlwZSA9PT0gdm9pZCAwICkgYmluZGluZ1R5cGUgPSBCSU5EX05PTkU7XG5cbiAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICAgIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGV4cHIucHJvcGVydGllczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHByb3AgPSBsaXN0W2ldO1xuXG4gICAgICB0aGlzLmNoZWNrTFZhbElubmVyUGF0dGVybihwcm9wLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSBleHByLmVsZW1lbnRzOyBpJDEgPCBsaXN0JDEubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgICB2YXIgZWxlbSA9IGxpc3QkMVtpJDFdO1xuXG4gICAgICBpZiAoZWxlbSkgeyB0aGlzLmNoZWNrTFZhbElubmVyUGF0dGVybihlbGVtLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTsgfVxuICAgICAgfVxuICAgICAgYnJlYWtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLmNoZWNrTFZhbFNpbXBsZShleHByLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICB9XG4gIH07XG5cbiAgcHAkNy5jaGVja0xWYWxJbm5lclBhdHRlcm4gPSBmdW5jdGlvbihleHByLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKSB7XG4gICAgaWYgKCBiaW5kaW5nVHlwZSA9PT0gdm9pZCAwICkgYmluZGluZ1R5cGUgPSBCSU5EX05PTkU7XG5cbiAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICAgIGNhc2UgXCJQcm9wZXJ0eVwiOlxuICAgICAgLy8gQXNzaWdubWVudFByb3BlcnR5IGhhcyB0eXBlID09PSBcIlByb3BlcnR5XCJcbiAgICAgIHRoaXMuY2hlY2tMVmFsSW5uZXJQYXR0ZXJuKGV4cHIudmFsdWUsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgICAgdGhpcy5jaGVja0xWYWxQYXR0ZXJuKGV4cHIubGVmdCwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgICB0aGlzLmNoZWNrTFZhbFBhdHRlcm4oZXhwci5hcmd1bWVudCwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgICBicmVha1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMuY2hlY2tMVmFsUGF0dGVybihleHByLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVGhlIGFsZ29yaXRobSB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIGEgcmVnZXhwIGNhbiBhcHBlYXIgYXQgYVxuICAvLyBnaXZlbiBwb2ludCBpbiB0aGUgcHJvZ3JhbSBpcyBsb29zZWx5IGJhc2VkIG9uIHN3ZWV0LmpzJyBhcHByb2FjaC5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3N3ZWV0LmpzL3dpa2kvZGVzaWduXG5cblxuICB2YXIgVG9rQ29udGV4dCA9IGZ1bmN0aW9uIFRva0NvbnRleHQodG9rZW4sIGlzRXhwciwgcHJlc2VydmVTcGFjZSwgb3ZlcnJpZGUsIGdlbmVyYXRvcikge1xuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICB0aGlzLmlzRXhwciA9ICEhaXNFeHByO1xuICAgIHRoaXMucHJlc2VydmVTcGFjZSA9ICEhcHJlc2VydmVTcGFjZTtcbiAgICB0aGlzLm92ZXJyaWRlID0gb3ZlcnJpZGU7XG4gICAgdGhpcy5nZW5lcmF0b3IgPSAhIWdlbmVyYXRvcjtcbiAgfTtcblxuICB2YXIgdHlwZXMgPSB7XG4gICAgYl9zdGF0OiBuZXcgVG9rQ29udGV4dChcIntcIiwgZmFsc2UpLFxuICAgIGJfZXhwcjogbmV3IFRva0NvbnRleHQoXCJ7XCIsIHRydWUpLFxuICAgIGJfdG1wbDogbmV3IFRva0NvbnRleHQoXCIke1wiLCBmYWxzZSksXG4gICAgcF9zdGF0OiBuZXcgVG9rQ29udGV4dChcIihcIiwgZmFsc2UpLFxuICAgIHBfZXhwcjogbmV3IFRva0NvbnRleHQoXCIoXCIsIHRydWUpLFxuICAgIHFfdG1wbDogbmV3IFRva0NvbnRleHQoXCJgXCIsIHRydWUsIHRydWUsIGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLnRyeVJlYWRUZW1wbGF0ZVRva2VuKCk7IH0pLFxuICAgIGZfc3RhdDogbmV3IFRva0NvbnRleHQoXCJmdW5jdGlvblwiLCBmYWxzZSksXG4gICAgZl9leHByOiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIHRydWUpLFxuICAgIGZfZXhwcl9nZW46IG5ldyBUb2tDb250ZXh0KFwiZnVuY3Rpb25cIiwgdHJ1ZSwgZmFsc2UsIG51bGwsIHRydWUpLFxuICAgIGZfZ2VuOiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIGZhbHNlLCBmYWxzZSwgbnVsbCwgdHJ1ZSlcbiAgfTtcblxuICB2YXIgcHAkNiA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgcHAkNi5pbml0aWFsQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBbdHlwZXMuYl9zdGF0XVxuICB9O1xuXG4gIHBwJDYuY3VyQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHRbdGhpcy5jb250ZXh0Lmxlbmd0aCAtIDFdXG4gIH07XG5cbiAgcHAkNi5icmFjZUlzQmxvY2sgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLmN1ckNvbnRleHQoKTtcbiAgICBpZiAocGFyZW50ID09PSB0eXBlcy5mX2V4cHIgfHwgcGFyZW50ID09PSB0eXBlcy5mX3N0YXQpXG4gICAgICB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzJDEuY29sb24gJiYgKHBhcmVudCA9PT0gdHlwZXMuYl9zdGF0IHx8IHBhcmVudCA9PT0gdHlwZXMuYl9leHByKSlcbiAgICAgIHsgcmV0dXJuICFwYXJlbnQuaXNFeHByIH1cblxuICAgIC8vIFRoZSBjaGVjayBmb3IgYHR0Lm5hbWUgJiYgZXhwckFsbG93ZWRgIGRldGVjdHMgd2hldGhlciB3ZSBhcmVcbiAgICAvLyBhZnRlciBhIGB5aWVsZGAgb3IgYG9mYCBjb25zdHJ1Y3QuIFNlZSB0aGUgYHVwZGF0ZUNvbnRleHRgIGZvclxuICAgIC8vIGB0dC5uYW1lYC5cbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzJDEuX3JldHVybiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMkMS5uYW1lICYmIHRoaXMuZXhwckFsbG93ZWQpXG4gICAgICB7IHJldHVybiBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpIH1cbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzJDEuX2Vsc2UgfHwgcHJldlR5cGUgPT09IHR5cGVzJDEuc2VtaSB8fCBwcmV2VHlwZSA9PT0gdHlwZXMkMS5lb2YgfHwgcHJldlR5cGUgPT09IHR5cGVzJDEucGFyZW5SIHx8IHByZXZUeXBlID09PSB0eXBlcyQxLmFycm93KVxuICAgICAgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKHByZXZUeXBlID09PSB0eXBlcyQxLmJyYWNlTClcbiAgICAgIHsgcmV0dXJuIHBhcmVudCA9PT0gdHlwZXMuYl9zdGF0IH1cbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzJDEuX3ZhciB8fCBwcmV2VHlwZSA9PT0gdHlwZXMkMS5fY29uc3QgfHwgcHJldlR5cGUgPT09IHR5cGVzJDEubmFtZSlcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgICByZXR1cm4gIXRoaXMuZXhwckFsbG93ZWRcbiAgfTtcblxuICBwcCQ2LmluR2VuZXJhdG9yQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmNvbnRleHQubGVuZ3RoIC0gMTsgaSA+PSAxOyBpLS0pIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0W2ldO1xuICAgICAgaWYgKGNvbnRleHQudG9rZW4gPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgeyByZXR1cm4gY29udGV4dC5nZW5lcmF0b3IgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQ2LnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICAgIHZhciB1cGRhdGUsIHR5cGUgPSB0aGlzLnR5cGU7XG4gICAgaWYgKHR5cGUua2V5d29yZCAmJiBwcmV2VHlwZSA9PT0gdHlwZXMkMS5kb3QpXG4gICAgICB7IHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTsgfVxuICAgIGVsc2UgaWYgKHVwZGF0ZSA9IHR5cGUudXBkYXRlQ29udGV4dClcbiAgICAgIHsgdXBkYXRlLmNhbGwodGhpcywgcHJldlR5cGUpOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLmV4cHJBbGxvd2VkID0gdHlwZS5iZWZvcmVFeHByOyB9XG4gIH07XG5cbiAgLy8gVXNlZCB0byBoYW5kbGUgZWRnZSBjYXNlcyB3aGVuIHRva2VuIGNvbnRleHQgY291bGQgbm90IGJlIGluZmVycmVkIGNvcnJlY3RseSBkdXJpbmcgdG9rZW5pemF0aW9uIHBoYXNlXG5cbiAgcHAkNi5vdmVycmlkZUNvbnRleHQgPSBmdW5jdGlvbih0b2tlbkN0eCkge1xuICAgIGlmICh0aGlzLmN1ckNvbnRleHQoKSAhPT0gdG9rZW5DdHgpIHtcbiAgICAgIHRoaXMuY29udGV4dFt0aGlzLmNvbnRleHQubGVuZ3RoIC0gMV0gPSB0b2tlbkN0eDtcbiAgICB9XG4gIH07XG5cbiAgLy8gVG9rZW4tc3BlY2lmaWMgY29udGV4dCB1cGRhdGUgY29kZVxuXG4gIHR5cGVzJDEucGFyZW5SLnVwZGF0ZUNvbnRleHQgPSB0eXBlcyQxLmJyYWNlUi51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuY29udGV4dC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBvdXQgPSB0aGlzLmNvbnRleHQucG9wKCk7XG4gICAgaWYgKG91dCA9PT0gdHlwZXMuYl9zdGF0ICYmIHRoaXMuY3VyQ29udGV4dCgpLnRva2VuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIG91dCA9IHRoaXMuY29udGV4dC5wb3AoKTtcbiAgICB9XG4gICAgdGhpcy5leHByQWxsb3dlZCA9ICFvdXQuaXNFeHByO1xuICB9O1xuXG4gIHR5cGVzJDEuYnJhY2VMLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICAgIHRoaXMuY29udGV4dC5wdXNoKHRoaXMuYnJhY2VJc0Jsb2NrKHByZXZUeXBlKSA/IHR5cGVzLmJfc3RhdCA6IHR5cGVzLmJfZXhwcik7XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gIH07XG5cbiAgdHlwZXMkMS5kb2xsYXJCcmFjZUwudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29udGV4dC5wdXNoKHR5cGVzLmJfdG1wbCk7XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gIH07XG5cbiAgdHlwZXMkMS5wYXJlbkwudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gICAgdmFyIHN0YXRlbWVudFBhcmVucyA9IHByZXZUeXBlID09PSB0eXBlcyQxLl9pZiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMkMS5fZm9yIHx8IHByZXZUeXBlID09PSB0eXBlcyQxLl93aXRoIHx8IHByZXZUeXBlID09PSB0eXBlcyQxLl93aGlsZTtcbiAgICB0aGlzLmNvbnRleHQucHVzaChzdGF0ZW1lbnRQYXJlbnMgPyB0eXBlcy5wX3N0YXQgOiB0eXBlcy5wX2V4cHIpO1xuICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuICB9O1xuXG4gIHR5cGVzJDEuaW5jRGVjLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyB0b2tFeHByQWxsb3dlZCBzdGF5cyB1bmNoYW5nZWRcbiAgfTtcblxuICB0eXBlcyQxLl9mdW5jdGlvbi51cGRhdGVDb250ZXh0ID0gdHlwZXMkMS5fY2xhc3MudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gICAgaWYgKHByZXZUeXBlLmJlZm9yZUV4cHIgJiYgcHJldlR5cGUgIT09IHR5cGVzJDEuX2Vsc2UgJiZcbiAgICAgICAgIShwcmV2VHlwZSA9PT0gdHlwZXMkMS5zZW1pICYmIHRoaXMuY3VyQ29udGV4dCgpICE9PSB0eXBlcy5wX3N0YXQpICYmXG4gICAgICAgICEocHJldlR5cGUgPT09IHR5cGVzJDEuX3JldHVybiAmJiBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpKSAmJlxuICAgICAgICAhKChwcmV2VHlwZSA9PT0gdHlwZXMkMS5jb2xvbiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMkMS5icmFjZUwpICYmIHRoaXMuY3VyQ29udGV4dCgpID09PSB0eXBlcy5iX3N0YXQpKVxuICAgICAgeyB0aGlzLmNvbnRleHQucHVzaCh0eXBlcy5mX2V4cHIpOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLmNvbnRleHQucHVzaCh0eXBlcy5mX3N0YXQpOyB9XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlO1xuICB9O1xuXG4gIHR5cGVzJDEuY29sb24udXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmN1ckNvbnRleHQoKS50b2tlbiA9PT0gXCJmdW5jdGlvblwiKSB7IHRoaXMuY29udGV4dC5wb3AoKTsgfVxuICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuICB9O1xuXG4gIHR5cGVzJDEuYmFja1F1b3RlLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5jdXJDb250ZXh0KCkgPT09IHR5cGVzLnFfdG1wbClcbiAgICAgIHsgdGhpcy5jb250ZXh0LnBvcCgpOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLmNvbnRleHQucHVzaCh0eXBlcy5xX3RtcGwpOyB9XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlO1xuICB9O1xuXG4gIHR5cGVzJDEuc3Rhci51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzJDEuX2Z1bmN0aW9uKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLmNvbnRleHQubGVuZ3RoIC0gMTtcbiAgICAgIGlmICh0aGlzLmNvbnRleHRbaW5kZXhdID09PSB0eXBlcy5mX2V4cHIpXG4gICAgICAgIHsgdGhpcy5jb250ZXh0W2luZGV4XSA9IHR5cGVzLmZfZXhwcl9nZW47IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyB0aGlzLmNvbnRleHRbaW5kZXhdID0gdHlwZXMuZl9nZW47IH1cbiAgICB9XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gIH07XG5cbiAgdHlwZXMkMS5uYW1lLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICAgIHZhciBhbGxvd2VkID0gZmFsc2U7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHByZXZUeXBlICE9PSB0eXBlcyQxLmRvdCkge1xuICAgICAgaWYgKHRoaXMudmFsdWUgPT09IFwib2ZcIiAmJiAhdGhpcy5leHByQWxsb3dlZCB8fFxuICAgICAgICAgIHRoaXMudmFsdWUgPT09IFwieWllbGRcIiAmJiB0aGlzLmluR2VuZXJhdG9yQ29udGV4dCgpKVxuICAgICAgICB7IGFsbG93ZWQgPSB0cnVlOyB9XG4gICAgfVxuICAgIHRoaXMuZXhwckFsbG93ZWQgPSBhbGxvd2VkO1xuICB9O1xuXG4gIC8vIEEgcmVjdXJzaXZlIGRlc2NlbnQgcGFyc2VyIG9wZXJhdGVzIGJ5IGRlZmluaW5nIGZ1bmN0aW9ucyBmb3IgYWxsXG4gIC8vIHN5bnRhY3RpYyBlbGVtZW50cywgYW5kIHJlY3Vyc2l2ZWx5IGNhbGxpbmcgdGhvc2UsIGVhY2ggZnVuY3Rpb25cbiAgLy8gYWR2YW5jaW5nIHRoZSBpbnB1dCBzdHJlYW0gYW5kIHJldHVybmluZyBhbiBBU1Qgbm9kZS4gUHJlY2VkZW5jZVxuICAvLyBvZiBjb25zdHJ1Y3RzIChmb3IgZXhhbXBsZSwgdGhlIGZhY3QgdGhhdCBgIXhbMV1gIG1lYW5zIGAhKHhbMV0pYFxuICAvLyBpbnN0ZWFkIG9mIGAoIXgpWzFdYCBpcyBoYW5kbGVkIGJ5IHRoZSBmYWN0IHRoYXQgdGhlIHBhcnNlclxuICAvLyBmdW5jdGlvbiB0aGF0IHBhcnNlcyB1bmFyeSBwcmVmaXggb3BlcmF0b3JzIGlzIGNhbGxlZCBmaXJzdCwgYW5kXG4gIC8vIGluIHR1cm4gY2FsbHMgdGhlIGZ1bmN0aW9uIHRoYXQgcGFyc2VzIGBbXWAgc3Vic2NyaXB0cyDigJQgdGhhdFxuICAvLyB3YXksIGl0J2xsIHJlY2VpdmUgdGhlIG5vZGUgZm9yIGB4WzFdYCBhbHJlYWR5IHBhcnNlZCwgYW5kIHdyYXBzXG4gIC8vICp0aGF0KiBpbiB0aGUgdW5hcnkgb3BlcmF0b3Igbm9kZS5cbiAgLy9cbiAgLy8gQWNvcm4gdXNlcyBhbiBbb3BlcmF0b3IgcHJlY2VkZW5jZSBwYXJzZXJdW29wcF0gdG8gaGFuZGxlIGJpbmFyeVxuICAvLyBvcGVyYXRvciBwcmVjZWRlbmNlLCBiZWNhdXNlIGl0IGlzIG11Y2ggbW9yZSBjb21wYWN0IHRoYW4gdXNpbmdcbiAgLy8gdGhlIHRlY2huaXF1ZSBvdXRsaW5lZCBhYm92ZSwgd2hpY2ggdXNlcyBkaWZmZXJlbnQsIG5lc3RpbmdcbiAgLy8gZnVuY3Rpb25zIHRvIHNwZWNpZnkgcHJlY2VkZW5jZSwgZm9yIGFsbCBvZiB0aGUgdGVuIGJpbmFyeVxuICAvLyBwcmVjZWRlbmNlIGxldmVscyB0aGF0IEphdmFTY3JpcHQgZGVmaW5lcy5cbiAgLy9cbiAgLy8gW29wcF06IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvT3BlcmF0b3ItcHJlY2VkZW5jZV9wYXJzZXJcblxuXG4gIHZhciBwcCQ1ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICAvLyBDaGVjayBpZiBwcm9wZXJ0eSBuYW1lIGNsYXNoZXMgd2l0aCBhbHJlYWR5IGFkZGVkLlxuICAvLyBPYmplY3QvY2xhc3MgZ2V0dGVycyBhbmQgc2V0dGVycyBhcmUgbm90IGFsbG93ZWQgdG8gY2xhc2gg4oCUXG4gIC8vIGVpdGhlciB3aXRoIGVhY2ggb3RoZXIgb3Igd2l0aCBhbiBpbml0IHByb3BlcnR5IOKAlCBhbmQgaW5cbiAgLy8gc3RyaWN0IG1vZGUsIGluaXQgcHJvcGVydGllcyBhcmUgYWxzbyBub3QgYWxsb3dlZCB0byBiZSByZXBlYXRlZC5cblxuICBwcCQ1LmNoZWNrUHJvcENsYXNoID0gZnVuY3Rpb24ocHJvcCwgcHJvcEhhc2gsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgcHJvcC50eXBlID09PSBcIlNwcmVhZEVsZW1lbnRcIilcbiAgICAgIHsgcmV0dXJuIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgKHByb3AuY29tcHV0ZWQgfHwgcHJvcC5tZXRob2QgfHwgcHJvcC5zaG9ydGhhbmQpKVxuICAgICAgeyByZXR1cm4gfVxuICAgIHZhciBrZXkgPSBwcm9wLmtleTtcbiAgICB2YXIgbmFtZTtcbiAgICBzd2l0Y2ggKGtleS50eXBlKSB7XG4gICAgY2FzZSBcIklkZW50aWZpZXJcIjogbmFtZSA9IGtleS5uYW1lOyBicmVha1xuICAgIGNhc2UgXCJMaXRlcmFsXCI6IG5hbWUgPSBTdHJpbmcoa2V5LnZhbHVlKTsgYnJlYWtcbiAgICBkZWZhdWx0OiByZXR1cm5cbiAgICB9XG4gICAgdmFyIGtpbmQgPSBwcm9wLmtpbmQ7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICBpZiAobmFtZSA9PT0gXCJfX3Byb3RvX19cIiAmJiBraW5kID09PSBcImluaXRcIikge1xuICAgICAgICBpZiAocHJvcEhhc2gucHJvdG8pIHtcbiAgICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG8gPCAwKSB7XG4gICAgICAgICAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG8gPSBrZXkuc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZShrZXkuc3RhcnQsIFwiUmVkZWZpbml0aW9uIG9mIF9fcHJvdG9fXyBwcm9wZXJ0eVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvcEhhc2gucHJvdG8gPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIG5hbWUgPSBcIiRcIiArIG5hbWU7XG4gICAgdmFyIG90aGVyID0gcHJvcEhhc2hbbmFtZV07XG4gICAgaWYgKG90aGVyKSB7XG4gICAgICB2YXIgcmVkZWZpbml0aW9uO1xuICAgICAgaWYgKGtpbmQgPT09IFwiaW5pdFwiKSB7XG4gICAgICAgIHJlZGVmaW5pdGlvbiA9IHRoaXMuc3RyaWN0ICYmIG90aGVyLmluaXQgfHwgb3RoZXIuZ2V0IHx8IG90aGVyLnNldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZGVmaW5pdGlvbiA9IG90aGVyLmluaXQgfHwgb3RoZXJba2luZF07XG4gICAgICB9XG4gICAgICBpZiAocmVkZWZpbml0aW9uKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShrZXkuc3RhcnQsIFwiUmVkZWZpbml0aW9uIG9mIHByb3BlcnR5XCIpOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG90aGVyID0gcHJvcEhhc2hbbmFtZV0gPSB7XG4gICAgICAgIGluaXQ6IGZhbHNlLFxuICAgICAgICBnZXQ6IGZhbHNlLFxuICAgICAgICBzZXQ6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBvdGhlcltraW5kXSA9IHRydWU7XG4gIH07XG5cbiAgLy8gIyMjIEV4cHJlc3Npb24gcGFyc2luZ1xuXG4gIC8vIFRoZXNlIG5lc3QsIGZyb20gdGhlIG1vc3QgZ2VuZXJhbCBleHByZXNzaW9uIHR5cGUgYXQgdGhlIHRvcCB0b1xuICAvLyAnYXRvbWljJywgbm9uZGl2aXNpYmxlIGV4cHJlc3Npb24gdHlwZXMgYXQgdGhlIGJvdHRvbS4gTW9zdCBvZlxuICAvLyB0aGUgZnVuY3Rpb25zIHdpbGwgc2ltcGx5IGxldCB0aGUgZnVuY3Rpb24ocykgYmVsb3cgdGhlbSBwYXJzZSxcbiAgLy8gYW5kLCAqaWYqIHRoZSBzeW50YWN0aWMgY29uc3RydWN0IHRoZXkgaGFuZGxlIGlzIHByZXNlbnQsIHdyYXBcbiAgLy8gdGhlIEFTVCBub2RlIHRoYXQgdGhlIGlubmVyIHBhcnNlciBnYXZlIHRoZW0gaW4gYW5vdGhlciBub2RlLlxuXG4gIC8vIFBhcnNlIGEgZnVsbCBleHByZXNzaW9uLiBUaGUgb3B0aW9uYWwgYXJndW1lbnRzIGFyZSB1c2VkIHRvXG4gIC8vIGZvcmJpZCB0aGUgYGluYCBvcGVyYXRvciAoaW4gZm9yIGxvb3BzIGluaXRhbGl6YXRpb24gZXhwcmVzc2lvbnMpXG4gIC8vIGFuZCBwcm92aWRlIHJlZmVyZW5jZSBmb3Igc3RvcmluZyAnPScgb3BlcmF0b3IgaW5zaWRlIHNob3J0aGFuZFxuICAvLyBwcm9wZXJ0eSBhc3NpZ25tZW50IGluIGNvbnRleHRzIHdoZXJlIGJvdGggb2JqZWN0IGV4cHJlc3Npb25cbiAgLy8gYW5kIG9iamVjdCBwYXR0ZXJuIG1pZ2h0IGFwcGVhciAoc28gaXQncyBwb3NzaWJsZSB0byByYWlzZVxuICAvLyBkZWxheWVkIHN5bnRheCBlcnJvciBhdCBjb3JyZWN0IHBvc2l0aW9uKS5cblxuICBwcCQ1LnBhcnNlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZm9ySW5pdCwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5jb21tYSkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlLmV4cHJlc3Npb25zID0gW2V4cHJdO1xuICAgICAgd2hpbGUgKHRoaXMuZWF0KHR5cGVzJDEuY29tbWEpKSB7IG5vZGUuZXhwcmVzc2lvbnMucHVzaCh0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZm9ySW5pdCwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpOyB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU2VxdWVuY2VFeHByZXNzaW9uXCIpXG4gICAgfVxuICAgIHJldHVybiBleHByXG4gIH07XG5cbiAgLy8gUGFyc2UgYW4gYXNzaWdubWVudCBleHByZXNzaW9uLiBUaGlzIGluY2x1ZGVzIGFwcGxpY2F0aW9ucyBvZlxuICAvLyBvcGVyYXRvcnMgbGlrZSBgKz1gLlxuXG4gIHBwJDUucGFyc2VNYXliZUFzc2lnbiA9IGZ1bmN0aW9uKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGFmdGVyTGVmdFBhcnNlKSB7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwieWllbGRcIikpIHtcbiAgICAgIGlmICh0aGlzLmluR2VuZXJhdG9yKSB7IHJldHVybiB0aGlzLnBhcnNlWWllbGQoZm9ySW5pdCkgfVxuICAgICAgLy8gVGhlIHRva2VuaXplciB3aWxsIGFzc3VtZSBhbiBleHByZXNzaW9uIGlzIGFsbG93ZWQgYWZ0ZXJcbiAgICAgIC8vIGB5aWVsZGAsIGJ1dCB0aGlzIGlzbid0IHRoYXQga2luZCBvZiB5aWVsZFxuICAgICAgZWxzZSB7IHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTsgfVxuICAgIH1cblxuICAgIHZhciBvd25EZXN0cnVjdHVyaW5nRXJyb3JzID0gZmFsc2UsIG9sZFBhcmVuQXNzaWduID0gLTEsIG9sZFRyYWlsaW5nQ29tbWEgPSAtMSwgb2xkRG91YmxlUHJvdG8gPSAtMTtcbiAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgb2xkUGFyZW5Bc3NpZ24gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ247XG4gICAgICBvbGRUcmFpbGluZ0NvbW1hID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hO1xuICAgICAgb2xkRG91YmxlUHJvdG8gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvO1xuICAgICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgPSBuZXcgRGVzdHJ1Y3R1cmluZ0Vycm9ycztcbiAgICAgIG93bkRlc3RydWN0dXJpbmdFcnJvcnMgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnBhcmVuTCB8fCB0aGlzLnR5cGUgPT09IHR5cGVzJDEubmFtZSkge1xuICAgICAgdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID0gdGhpcy5zdGFydDtcbiAgICAgIHRoaXMucG90ZW50aWFsQXJyb3dJbkZvckF3YWl0ID0gZm9ySW5pdCA9PT0gXCJhd2FpdFwiO1xuICAgIH1cbiAgICB2YXIgbGVmdCA9IHRoaXMucGFyc2VNYXliZUNvbmRpdGlvbmFsKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIGlmIChhZnRlckxlZnRQYXJzZSkgeyBsZWZ0ID0gYWZ0ZXJMZWZ0UGFyc2UuY2FsbCh0aGlzLCBsZWZ0LCBzdGFydFBvcywgc3RhcnRMb2MpOyB9XG4gICAgaWYgKHRoaXMudHlwZS5pc0Fzc2lnbikge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlLm9wZXJhdG9yID0gdGhpcy52YWx1ZTtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuZXEpXG4gICAgICAgIHsgbGVmdCA9IHRoaXMudG9Bc3NpZ25hYmxlKGxlZnQsIGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTsgfVxuICAgICAgaWYgKCFvd25EZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG8gPSAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA+PSBsZWZ0LnN0YXJ0KVxuICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID0gLTE7IH0gLy8gcmVzZXQgYmVjYXVzZSBzaG9ydGhhbmQgZGVmYXVsdCB3YXMgdXNlZCBjb3JyZWN0bHlcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuZXEpXG4gICAgICAgIHsgdGhpcy5jaGVja0xWYWxQYXR0ZXJuKGxlZnQpOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgdGhpcy5jaGVja0xWYWxTaW1wbGUobGVmdCk7IH1cbiAgICAgIG5vZGUubGVmdCA9IGxlZnQ7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG5vZGUucmlnaHQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZm9ySW5pdCk7XG4gICAgICBpZiAob2xkRG91YmxlUHJvdG8gPiAtMSkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvID0gb2xkRG91YmxlUHJvdG87IH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3duRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTsgfVxuICAgIH1cbiAgICBpZiAob2xkUGFyZW5Bc3NpZ24gPiAtMSkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSBvbGRQYXJlbkFzc2lnbjsgfVxuICAgIGlmIChvbGRUcmFpbGluZ0NvbW1hID4gLTEpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gb2xkVHJhaWxpbmdDb21tYTsgfVxuICAgIHJldHVybiBsZWZ0XG4gIH07XG5cbiAgLy8gUGFyc2UgYSB0ZXJuYXJ5IGNvbmRpdGlvbmFsIChgPzpgKSBvcGVyYXRvci5cblxuICBwcCQ1LnBhcnNlTWF5YmVDb25kaXRpb25hbCA9IGZ1bmN0aW9uKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwck9wcyhmb3JJbml0LCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpIHsgcmV0dXJuIGV4cHIgfVxuICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLnF1ZXN0aW9uKSkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlLnRlc3QgPSBleHByO1xuICAgICAgbm9kZS5jb25zZXF1ZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmNvbG9uKTtcbiAgICAgIG5vZGUuYWx0ZXJuYXRlID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZvckluaXQpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgICByZXR1cm4gZXhwclxuICB9O1xuXG4gIC8vIFN0YXJ0IHRoZSBwcmVjZWRlbmNlIHBhcnNlci5cblxuICBwcCQ1LnBhcnNlRXhwck9wcyA9IGZ1bmN0aW9uKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeShyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmYWxzZSwgZmFsc2UsIGZvckluaXQpO1xuICAgIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSkgeyByZXR1cm4gZXhwciB9XG4gICAgcmV0dXJuIGV4cHIuc3RhcnQgPT09IHN0YXJ0UG9zICYmIGV4cHIudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiID8gZXhwciA6IHRoaXMucGFyc2VFeHByT3AoZXhwciwgc3RhcnRQb3MsIHN0YXJ0TG9jLCAtMSwgZm9ySW5pdClcbiAgfTtcblxuICAvLyBQYXJzZSBiaW5hcnkgb3BlcmF0b3JzIHdpdGggdGhlIG9wZXJhdG9yIHByZWNlZGVuY2UgcGFyc2luZ1xuICAvLyBhbGdvcml0aG0uIGBsZWZ0YCBpcyB0aGUgbGVmdC1oYW5kIHNpZGUgb2YgdGhlIG9wZXJhdG9yLlxuICAvLyBgbWluUHJlY2AgcHJvdmlkZXMgY29udGV4dCB0aGF0IGFsbG93cyB0aGUgZnVuY3Rpb24gdG8gc3RvcCBhbmRcbiAgLy8gZGVmZXIgZnVydGhlciBwYXJzZXIgdG8gb25lIG9mIGl0cyBjYWxsZXJzIHdoZW4gaXQgZW5jb3VudGVycyBhblxuICAvLyBvcGVyYXRvciB0aGF0IGhhcyBhIGxvd2VyIHByZWNlZGVuY2UgdGhhbiB0aGUgc2V0IGl0IGlzIHBhcnNpbmcuXG5cbiAgcHAkNS5wYXJzZUV4cHJPcCA9IGZ1bmN0aW9uKGxlZnQsIGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBtaW5QcmVjLCBmb3JJbml0KSB7XG4gICAgdmFyIHByZWMgPSB0aGlzLnR5cGUuYmlub3A7XG4gICAgaWYgKHByZWMgIT0gbnVsbCAmJiAoIWZvckluaXQgfHwgdGhpcy50eXBlICE9PSB0eXBlcyQxLl9pbikpIHtcbiAgICAgIGlmIChwcmVjID4gbWluUHJlYykge1xuICAgICAgICB2YXIgbG9naWNhbCA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5sb2dpY2FsT1IgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLmxvZ2ljYWxBTkQ7XG4gICAgICAgIHZhciBjb2FsZXNjZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5jb2FsZXNjZTtcbiAgICAgICAgaWYgKGNvYWxlc2NlKSB7XG4gICAgICAgICAgLy8gSGFuZGxlIHRoZSBwcmVjZWRlbmNlIG9mIGB0dC5jb2FsZXNjZWAgYXMgZXF1YWwgdG8gdGhlIHJhbmdlIG9mIGxvZ2ljYWwgZXhwcmVzc2lvbnMuXG4gICAgICAgICAgLy8gSW4gb3RoZXIgd29yZHMsIGBub2RlLnJpZ2h0YCBzaG91bGRuJ3QgY29udGFpbiBsb2dpY2FsIGV4cHJlc3Npb25zIGluIG9yZGVyIHRvIGNoZWNrIHRoZSBtaXhlZCBlcnJvci5cbiAgICAgICAgICBwcmVjID0gdHlwZXMkMS5sb2dpY2FsQU5ELmJpbm9wO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcCA9IHRoaXMudmFsdWU7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICAgIHZhciByaWdodCA9IHRoaXMucGFyc2VFeHByT3AodGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgZmFsc2UsIGZhbHNlLCBmb3JJbml0KSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBwcmVjLCBmb3JJbml0KTtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJ1aWxkQmluYXJ5KGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBsZWZ0LCByaWdodCwgb3AsIGxvZ2ljYWwgfHwgY29hbGVzY2UpO1xuICAgICAgICBpZiAoKGxvZ2ljYWwgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLmNvYWxlc2NlKSB8fCAoY29hbGVzY2UgJiYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5sb2dpY2FsT1IgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLmxvZ2ljYWxBTkQpKSkge1xuICAgICAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCBcIkxvZ2ljYWwgZXhwcmVzc2lvbnMgYW5kIGNvYWxlc2NlIGV4cHJlc3Npb25zIGNhbm5vdCBiZSBtaXhlZC4gV3JhcCBlaXRoZXIgYnkgcGFyZW50aGVzZXNcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHByT3Aobm9kZSwgbGVmdFN0YXJ0UG9zLCBsZWZ0U3RhcnRMb2MsIG1pblByZWMsIGZvckluaXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZWZ0XG4gIH07XG5cbiAgcHAkNS5idWlsZEJpbmFyeSA9IGZ1bmN0aW9uKHN0YXJ0UG9zLCBzdGFydExvYywgbGVmdCwgcmlnaHQsIG9wLCBsb2dpY2FsKSB7XG4gICAgaWYgKHJpZ2h0LnR5cGUgPT09IFwiUHJpdmF0ZUlkZW50aWZpZXJcIikgeyB0aGlzLnJhaXNlKHJpZ2h0LnN0YXJ0LCBcIlByaXZhdGUgaWRlbnRpZmllciBjYW4gb25seSBiZSBsZWZ0IHNpZGUgb2YgYmluYXJ5IGV4cHJlc3Npb25cIik7IH1cbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlLmxlZnQgPSBsZWZ0O1xuICAgIG5vZGUub3BlcmF0b3IgPSBvcDtcbiAgICBub2RlLnJpZ2h0ID0gcmlnaHQ7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBsb2dpY2FsID8gXCJMb2dpY2FsRXhwcmVzc2lvblwiIDogXCJCaW5hcnlFeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgLy8gUGFyc2UgdW5hcnkgb3BlcmF0b3JzLCBib3RoIHByZWZpeCBhbmQgcG9zdGZpeC5cblxuICBwcCQ1LnBhcnNlTWF5YmVVbmFyeSA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHNhd1VuYXJ5LCBpbmNEZWMsIGZvckluaXQpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2MsIGV4cHI7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwiYXdhaXRcIikgJiYgdGhpcy5jYW5Bd2FpdCkge1xuICAgICAgZXhwciA9IHRoaXMucGFyc2VBd2FpdChmb3JJbml0KTtcbiAgICAgIHNhd1VuYXJ5ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZS5wcmVmaXgpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwgdXBkYXRlID0gdGhpcy50eXBlID09PSB0eXBlcyQxLmluY0RlYztcbiAgICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnZhbHVlO1xuICAgICAgbm9kZS5wcmVmaXggPSB0cnVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgdHJ1ZSwgdXBkYXRlLCBmb3JJbml0KTtcbiAgICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICAgICAgaWYgKHVwZGF0ZSkgeyB0aGlzLmNoZWNrTFZhbFNpbXBsZShub2RlLmFyZ3VtZW50KTsgfVxuICAgICAgZWxzZSBpZiAodGhpcy5zdHJpY3QgJiYgbm9kZS5vcGVyYXRvciA9PT0gXCJkZWxldGVcIiAmJiBpc0xvY2FsVmFyaWFibGVBY2Nlc3Mobm9kZS5hcmd1bWVudCkpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiRGVsZXRpbmcgbG9jYWwgdmFyaWFibGUgaW4gc3RyaWN0IG1vZGVcIik7IH1cbiAgICAgIGVsc2UgaWYgKG5vZGUub3BlcmF0b3IgPT09IFwiZGVsZXRlXCIgJiYgaXNQcml2YXRlRmllbGRBY2Nlc3Mobm9kZS5hcmd1bWVudCkpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiUHJpdmF0ZSBmaWVsZHMgY2FuIG5vdCBiZSBkZWxldGVkXCIpOyB9XG4gICAgICBlbHNlIHsgc2F3VW5hcnkgPSB0cnVlOyB9XG4gICAgICBleHByID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIHVwZGF0ZSA/IFwiVXBkYXRlRXhwcmVzc2lvblwiIDogXCJVbmFyeUV4cHJlc3Npb25cIik7XG4gICAgfSBlbHNlIGlmICghc2F3VW5hcnkgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLnByaXZhdGVJZCkge1xuICAgICAgaWYgKChmb3JJbml0IHx8IHRoaXMucHJpdmF0ZU5hbWVTdGFjay5sZW5ndGggPT09IDApICYmIHRoaXMub3B0aW9ucy5jaGVja1ByaXZhdGVGaWVsZHMpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIGV4cHIgPSB0aGlzLnBhcnNlUHJpdmF0ZUlkZW50KCk7XG4gICAgICAvLyBvbmx5IGNvdWxkIGJlIHByaXZhdGUgZmllbGRzIGluICdpbicsIHN1Y2ggYXMgI3ggaW4gb2JqXG4gICAgICBpZiAodGhpcy50eXBlICE9PSB0eXBlcyQxLl9pbikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBleHByID0gdGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGZvckluaXQpO1xuICAgICAgaWYgKHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpKSB7IHJldHVybiBleHByIH1cbiAgICAgIHdoaWxlICh0aGlzLnR5cGUucG9zdGZpeCAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgICB2YXIgbm9kZSQxID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgICBub2RlJDEub3BlcmF0b3IgPSB0aGlzLnZhbHVlO1xuICAgICAgICBub2RlJDEucHJlZml4ID0gZmFsc2U7XG4gICAgICAgIG5vZGUkMS5hcmd1bWVudCA9IGV4cHI7XG4gICAgICAgIHRoaXMuY2hlY2tMVmFsU2ltcGxlKGV4cHIpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgZXhwciA9IHRoaXMuZmluaXNoTm9kZShub2RlJDEsIFwiVXBkYXRlRXhwcmVzc2lvblwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWluY0RlYyAmJiB0aGlzLmVhdCh0eXBlcyQxLnN0YXJzdGFyKSkge1xuICAgICAgaWYgKHNhd1VuYXJ5KVxuICAgICAgICB7IHRoaXMudW5leHBlY3RlZCh0aGlzLmxhc3RUb2tTdGFydCk7IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyByZXR1cm4gdGhpcy5idWlsZEJpbmFyeShzdGFydFBvcywgc3RhcnRMb2MsIGV4cHIsIHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIGZhbHNlLCBmYWxzZSwgZm9ySW5pdCksIFwiKipcIiwgZmFsc2UpIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGV4cHJcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNMb2NhbFZhcmlhYmxlQWNjZXNzKG5vZGUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgbm9kZS50eXBlID09PSBcIklkZW50aWZpZXJcIiB8fFxuICAgICAgbm9kZS50eXBlID09PSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIgJiYgaXNMb2NhbFZhcmlhYmxlQWNjZXNzKG5vZGUuZXhwcmVzc2lvbilcbiAgICApXG4gIH1cblxuICBmdW5jdGlvbiBpc1ByaXZhdGVGaWVsZEFjY2Vzcyhub2RlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIG5vZGUudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgJiYgbm9kZS5wcm9wZXJ0eS50eXBlID09PSBcIlByaXZhdGVJZGVudGlmaWVyXCIgfHxcbiAgICAgIG5vZGUudHlwZSA9PT0gXCJDaGFpbkV4cHJlc3Npb25cIiAmJiBpc1ByaXZhdGVGaWVsZEFjY2Vzcyhub2RlLmV4cHJlc3Npb24pIHx8XG4gICAgICBub2RlLnR5cGUgPT09IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIiAmJiBpc1ByaXZhdGVGaWVsZEFjY2Vzcyhub2RlLmV4cHJlc3Npb24pXG4gICAgKVxuICB9XG5cbiAgLy8gUGFyc2UgY2FsbCwgZG90LCBhbmQgYFtdYC1zdWJzY3JpcHQgZXhwcmVzc2lvbnMuXG5cbiAgcHAkNS5wYXJzZUV4cHJTdWJzY3JpcHRzID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZm9ySW5pdCkge1xuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByQXRvbShyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmb3JJbml0KTtcbiAgICBpZiAoZXhwci50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgJiYgdGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tTdGFydCwgdGhpcy5sYXN0VG9rRW5kKSAhPT0gXCIpXCIpXG4gICAgICB7IHJldHVybiBleHByIH1cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZVN1YnNjcmlwdHMoZXhwciwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBmYWxzZSwgZm9ySW5pdCk7XG4gICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgJiYgcmVzdWx0LnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID49IHJlc3VsdC5zdGFydCkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSAtMTsgfVxuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPj0gcmVzdWx0LnN0YXJ0KSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPSAtMTsgfVxuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA+PSByZXN1bHQuc3RhcnQpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gLTE7IH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9O1xuXG4gIHBwJDUucGFyc2VTdWJzY3JpcHRzID0gZnVuY3Rpb24oYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzLCBmb3JJbml0KSB7XG4gICAgdmFyIG1heWJlQXN5bmNBcnJvdyA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmIGJhc2UudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgYmFzZS5uYW1lID09PSBcImFzeW5jXCIgJiZcbiAgICAgICAgdGhpcy5sYXN0VG9rRW5kID09PSBiYXNlLmVuZCAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiBiYXNlLmVuZCAtIGJhc2Uuc3RhcnQgPT09IDUgJiZcbiAgICAgICAgdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID09PSBiYXNlLnN0YXJ0O1xuICAgIHZhciBvcHRpb25hbENoYWluZWQgPSBmYWxzZTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMucGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzLCBtYXliZUFzeW5jQXJyb3csIG9wdGlvbmFsQ2hhaW5lZCwgZm9ySW5pdCk7XG5cbiAgICAgIGlmIChlbGVtZW50Lm9wdGlvbmFsKSB7IG9wdGlvbmFsQ2hhaW5lZCA9IHRydWU7IH1cbiAgICAgIGlmIChlbGVtZW50ID09PSBiYXNlIHx8IGVsZW1lbnQudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiKSB7XG4gICAgICAgIGlmIChvcHRpb25hbENoYWluZWQpIHtcbiAgICAgICAgICB2YXIgY2hhaW5Ob2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgICAgIGNoYWluTm9kZS5leHByZXNzaW9uID0gZWxlbWVudDtcbiAgICAgICAgICBlbGVtZW50ID0gdGhpcy5maW5pc2hOb2RlKGNoYWluTm9kZSwgXCJDaGFpbkV4cHJlc3Npb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnRcbiAgICAgIH1cblxuICAgICAgYmFzZSA9IGVsZW1lbnQ7XG4gICAgfVxuICB9O1xuXG4gIHBwJDUuc2hvdWxkUGFyc2VBc3luY0Fycm93ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIHRoaXMuZWF0KHR5cGVzJDEuYXJyb3cpXG4gIH07XG5cbiAgcHAkNS5wYXJzZVN1YnNjcmlwdEFzeW5jQXJyb3cgPSBmdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIGV4cHJMaXN0LCBmb3JJbml0KSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBleHByTGlzdCwgdHJ1ZSwgZm9ySW5pdClcbiAgfTtcblxuICBwcCQ1LnBhcnNlU3Vic2NyaXB0ID0gZnVuY3Rpb24oYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzLCBtYXliZUFzeW5jQXJyb3csIG9wdGlvbmFsQ2hhaW5lZCwgZm9ySW5pdCkge1xuICAgIHZhciBvcHRpb25hbFN1cHBvcnRlZCA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMTtcbiAgICB2YXIgb3B0aW9uYWwgPSBvcHRpb25hbFN1cHBvcnRlZCAmJiB0aGlzLmVhdCh0eXBlcyQxLnF1ZXN0aW9uRG90KTtcbiAgICBpZiAobm9DYWxscyAmJiBvcHRpb25hbCkgeyB0aGlzLnJhaXNlKHRoaXMubGFzdFRva1N0YXJ0LCBcIk9wdGlvbmFsIGNoYWluaW5nIGNhbm5vdCBhcHBlYXIgaW4gdGhlIGNhbGxlZSBvZiBuZXcgZXhwcmVzc2lvbnNcIik7IH1cblxuICAgIHZhciBjb21wdXRlZCA9IHRoaXMuZWF0KHR5cGVzJDEuYnJhY2tldEwpO1xuICAgIGlmIChjb21wdXRlZCB8fCAob3B0aW9uYWwgJiYgdGhpcy50eXBlICE9PSB0eXBlcyQxLnBhcmVuTCAmJiB0aGlzLnR5cGUgIT09IHR5cGVzJDEuYmFja1F1b3RlKSB8fCB0aGlzLmVhdCh0eXBlcyQxLmRvdCkpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZS5vYmplY3QgPSBiYXNlO1xuICAgICAgaWYgKGNvbXB1dGVkKSB7XG4gICAgICAgIG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmJyYWNrZXRSKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnByaXZhdGVJZCAmJiBiYXNlLnR5cGUgIT09IFwiU3VwZXJcIikge1xuICAgICAgICBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZVByaXZhdGVJZGVudCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudCh0aGlzLm9wdGlvbnMuYWxsb3dSZXNlcnZlZCAhPT0gXCJuZXZlclwiKTtcbiAgICAgIH1cbiAgICAgIG5vZGUuY29tcHV0ZWQgPSAhIWNvbXB1dGVkO1xuICAgICAgaWYgKG9wdGlvbmFsU3VwcG9ydGVkKSB7XG4gICAgICAgIG5vZGUub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICAgIH1cbiAgICAgIGJhc2UgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIpO1xuICAgIH0gZWxzZSBpZiAoIW5vQ2FsbHMgJiYgdGhpcy5lYXQodHlwZXMkMS5wYXJlbkwpKSB7XG4gICAgICB2YXIgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzLCBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgb2xkQXdhaXRJZGVudFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcztcbiAgICAgIHRoaXMueWllbGRQb3MgPSAwO1xuICAgICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSAwO1xuICAgICAgdmFyIGV4cHJMaXN0ID0gdGhpcy5wYXJzZUV4cHJMaXN0KHR5cGVzJDEucGFyZW5SLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCwgZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgaWYgKG1heWJlQXN5bmNBcnJvdyAmJiAhb3B0aW9uYWwgJiYgdGhpcy5zaG91bGRQYXJzZUFzeW5jQXJyb3coKSkge1xuICAgICAgICB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG4gICAgICAgIGlmICh0aGlzLmF3YWl0SWRlbnRQb3MgPiAwKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLmF3YWl0SWRlbnRQb3MsIFwiQ2Fubm90IHVzZSAnYXdhaXQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGFuIGFzeW5jIGZ1bmN0aW9uXCIpOyB9XG4gICAgICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICAgICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICAgICAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSBvbGRBd2FpdElkZW50UG9zO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVN1YnNjcmlwdEFzeW5jQXJyb3coc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByTGlzdCwgZm9ySW5pdClcbiAgICAgIH1cbiAgICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICAgICAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zIHx8IHRoaXMueWllbGRQb3M7XG4gICAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3MgfHwgdGhpcy5hd2FpdFBvcztcbiAgICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3MgfHwgdGhpcy5hd2FpdElkZW50UG9zO1xuICAgICAgdmFyIG5vZGUkMSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUkMS5jYWxsZWUgPSBiYXNlO1xuICAgICAgbm9kZSQxLmFyZ3VtZW50cyA9IGV4cHJMaXN0O1xuICAgICAgaWYgKG9wdGlvbmFsU3VwcG9ydGVkKSB7XG4gICAgICAgIG5vZGUkMS5vcHRpb25hbCA9IG9wdGlvbmFsO1xuICAgICAgfVxuICAgICAgYmFzZSA9IHRoaXMuZmluaXNoTm9kZShub2RlJDEsIFwiQ2FsbEV4cHJlc3Npb25cIik7XG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuYmFja1F1b3RlKSB7XG4gICAgICBpZiAob3B0aW9uYWwgfHwgb3B0aW9uYWxDaGFpbmVkKSB7XG4gICAgICAgIHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJPcHRpb25hbCBjaGFpbmluZyBjYW5ub3QgYXBwZWFyIGluIHRoZSB0YWcgb2YgdGFnZ2VkIHRlbXBsYXRlIGV4cHJlc3Npb25zXCIpO1xuICAgICAgfVxuICAgICAgdmFyIG5vZGUkMiA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUkMi50YWcgPSBiYXNlO1xuICAgICAgbm9kZSQyLnF1YXNpID0gdGhpcy5wYXJzZVRlbXBsYXRlKHtpc1RhZ2dlZDogdHJ1ZX0pO1xuICAgICAgYmFzZSA9IHRoaXMuZmluaXNoTm9kZShub2RlJDIsIFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZVxuICB9O1xuXG4gIC8vIFBhcnNlIGFuIGF0b21pYyBleHByZXNzaW9uIOKAlCBlaXRoZXIgYSBzaW5nbGUgdG9rZW4gdGhhdCBpcyBhblxuICAvLyBleHByZXNzaW9uLCBhbiBleHByZXNzaW9uIHN0YXJ0ZWQgYnkgYSBrZXl3b3JkIGxpa2UgYGZ1bmN0aW9uYCBvclxuICAvLyBgbmV3YCwgb3IgYW4gZXhwcmVzc2lvbiB3cmFwcGVkIGluIHB1bmN0dWF0aW9uIGxpa2UgYCgpYCwgYFtdYCxcbiAgLy8gb3IgYHt9YC5cblxuICBwcCQ1LnBhcnNlRXhwckF0b20gPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmb3JJbml0LCBmb3JOZXcpIHtcbiAgICAvLyBJZiBhIGRpdmlzaW9uIG9wZXJhdG9yIGFwcGVhcnMgaW4gYW4gZXhwcmVzc2lvbiBwb3NpdGlvbiwgdGhlXG4gICAgLy8gdG9rZW5pemVyIGdvdCBjb25mdXNlZCwgYW5kIHdlIGZvcmNlIGl0IHRvIHJlYWQgYSByZWdleHAgaW5zdGVhZC5cbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnNsYXNoKSB7IHRoaXMucmVhZFJlZ2V4cCgpOyB9XG5cbiAgICB2YXIgbm9kZSwgY2FuQmVBcnJvdyA9IHRoaXMucG90ZW50aWFsQXJyb3dBdCA9PT0gdGhpcy5zdGFydDtcbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgIGNhc2UgdHlwZXMkMS5fc3VwZXI6XG4gICAgICBpZiAoIXRoaXMuYWxsb3dTdXBlcilcbiAgICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ3N1cGVyJyBrZXl3b3JkIG91dHNpZGUgYSBtZXRob2RcIik7IH1cbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnBhcmVuTCAmJiAhdGhpcy5hbGxvd0RpcmVjdFN1cGVyKVxuICAgICAgICB7IHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJzdXBlcigpIGNhbGwgb3V0c2lkZSBjb25zdHJ1Y3RvciBvZiBhIHN1YmNsYXNzXCIpOyB9XG4gICAgICAvLyBUaGUgYHN1cGVyYCBrZXl3b3JkIGNhbiBhcHBlYXIgYXQgYmVsb3c6XG4gICAgICAvLyBTdXBlclByb3BlcnR5OlxuICAgICAgLy8gICAgIHN1cGVyIFsgRXhwcmVzc2lvbiBdXG4gICAgICAvLyAgICAgc3VwZXIgLiBJZGVudGlmaWVyTmFtZVxuICAgICAgLy8gU3VwZXJDYWxsOlxuICAgICAgLy8gICAgIHN1cGVyICggQXJndW1lbnRzIClcbiAgICAgIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzJDEuZG90ICYmIHRoaXMudHlwZSAhPT0gdHlwZXMkMS5icmFja2V0TCAmJiB0aGlzLnR5cGUgIT09IHR5cGVzJDEucGFyZW5MKVxuICAgICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3VwZXJcIilcblxuICAgIGNhc2UgdHlwZXMkMS5fdGhpczpcbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGhpc0V4cHJlc3Npb25cIilcblxuICAgIGNhc2UgdHlwZXMkMS5uYW1lOlxuICAgICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jLCBjb250YWluc0VzYyA9IHRoaXMuY29udGFpbnNFc2M7XG4gICAgICB2YXIgaWQgPSB0aGlzLnBhcnNlSWRlbnQoZmFsc2UpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmICFjb250YWluc0VzYyAmJiBpZC5uYW1lID09PSBcImFzeW5jXCIgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgdGhpcy5lYXQodHlwZXMkMS5fZnVuY3Rpb24pKSB7XG4gICAgICAgIHRoaXMub3ZlcnJpZGVDb250ZXh0KHR5cGVzLmZfZXhwcik7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCAwLCBmYWxzZSwgdHJ1ZSwgZm9ySW5pdClcbiAgICAgIH1cbiAgICAgIGlmIChjYW5CZUFycm93ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLmFycm93KSlcbiAgICAgICAgICB7IHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgW2lkXSwgZmFsc2UsIGZvckluaXQpIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmIGlkLm5hbWUgPT09IFwiYXN5bmNcIiAmJiB0aGlzLnR5cGUgPT09IHR5cGVzJDEubmFtZSAmJiAhY29udGFpbnNFc2MgJiZcbiAgICAgICAgICAgICghdGhpcy5wb3RlbnRpYWxBcnJvd0luRm9yQXdhaXQgfHwgdGhpcy52YWx1ZSAhPT0gXCJvZlwiIHx8IHRoaXMuY29udGFpbnNFc2MpKSB7XG4gICAgICAgICAgaWQgPSB0aGlzLnBhcnNlSWRlbnQoZmFsc2UpO1xuICAgICAgICAgIGlmICh0aGlzLmNhbkluc2VydFNlbWljb2xvbigpIHx8ICF0aGlzLmVhdCh0eXBlcyQxLmFycm93KSlcbiAgICAgICAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIFtpZF0sIHRydWUsIGZvckluaXQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpZFxuXG4gICAgY2FzZSB0eXBlcyQxLnJlZ2V4cDpcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICBub2RlID0gdGhpcy5wYXJzZUxpdGVyYWwodmFsdWUudmFsdWUpO1xuICAgICAgbm9kZS5yZWdleCA9IHtwYXR0ZXJuOiB2YWx1ZS5wYXR0ZXJuLCBmbGFnczogdmFsdWUuZmxhZ3N9O1xuICAgICAgcmV0dXJuIG5vZGVcblxuICAgIGNhc2UgdHlwZXMkMS5udW06IGNhc2UgdHlwZXMkMS5zdHJpbmc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodGhpcy52YWx1ZSlcblxuICAgIGNhc2UgdHlwZXMkMS5fbnVsbDogY2FzZSB0eXBlcyQxLl90cnVlOiBjYXNlIHR5cGVzJDEuX2ZhbHNlOlxuICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBub2RlLnZhbHVlID0gdGhpcy50eXBlID09PSB0eXBlcyQxLl9udWxsID8gbnVsbCA6IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5fdHJ1ZTtcbiAgICAgIG5vZGUucmF3ID0gdGhpcy50eXBlLmtleXdvcmQ7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJMaXRlcmFsXCIpXG5cbiAgICBjYXNlIHR5cGVzJDEucGFyZW5MOlxuICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydCwgZXhwciA9IHRoaXMucGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbihjYW5CZUFycm93LCBmb3JJbml0KTtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPCAwICYmICF0aGlzLmlzU2ltcGxlQXNzaWduVGFyZ2V0KGV4cHIpKVxuICAgICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gc3RhcnQ7IH1cbiAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPCAwKVxuICAgICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA9IHN0YXJ0OyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhwclxuXG4gICAgY2FzZSB0eXBlcyQxLmJyYWNrZXRMOlxuICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG5vZGUuZWxlbWVudHMgPSB0aGlzLnBhcnNlRXhwckxpc3QodHlwZXMkMS5icmFja2V0UiwgdHJ1ZSwgdHJ1ZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyYXlFeHByZXNzaW9uXCIpXG5cbiAgICBjYXNlIHR5cGVzJDEuYnJhY2VMOlxuICAgICAgdGhpcy5vdmVycmlkZUNvbnRleHQodHlwZXMuYl9leHByKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKVxuXG4gICAgY2FzZSB0eXBlcyQxLl9mdW5jdGlvbjpcbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKG5vZGUsIDApXG5cbiAgICBjYXNlIHR5cGVzJDEuX2NsYXNzOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzcyh0aGlzLnN0YXJ0Tm9kZSgpLCBmYWxzZSlcblxuICAgIGNhc2UgdHlwZXMkMS5fbmV3OlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VOZXcoKVxuXG4gICAgY2FzZSB0eXBlcyQxLmJhY2tRdW90ZTpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlVGVtcGxhdGUoKVxuXG4gICAgY2FzZSB0eXBlcyQxLl9pbXBvcnQ6XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwckltcG9ydChmb3JOZXcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy51bmV4cGVjdGVkKClcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJBdG9tRGVmYXVsdCgpXG4gICAgfVxuICB9O1xuXG4gIHBwJDUucGFyc2VFeHByQXRvbURlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfTtcblxuICBwcCQ1LnBhcnNlRXhwckltcG9ydCA9IGZ1bmN0aW9uKGZvck5ldykge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcblxuICAgIC8vIENvbnN1bWUgYGltcG9ydGAgYXMgYW4gaWRlbnRpZmllciBmb3IgYGltcG9ydC5tZXRhYC5cbiAgICAvLyBCZWNhdXNlIGB0aGlzLnBhcnNlSWRlbnQodHJ1ZSlgIGRvZXNuJ3QgY2hlY2sgZXNjYXBlIHNlcXVlbmNlcywgaXQgbmVlZHMgdGhlIGNoZWNrIG9mIGB0aGlzLmNvbnRhaW5zRXNjYC5cbiAgICBpZiAodGhpcy5jb250YWluc0VzYykgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJFc2NhcGUgc2VxdWVuY2UgaW4ga2V5d29yZCBpbXBvcnRcIik7IH1cbiAgICB0aGlzLm5leHQoKTtcblxuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEucGFyZW5MICYmICFmb3JOZXcpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRHluYW1pY0ltcG9ydChub2RlKVxuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmRvdCkge1xuICAgICAgdmFyIG1ldGEgPSB0aGlzLnN0YXJ0Tm9kZUF0KG5vZGUuc3RhcnQsIG5vZGUubG9jICYmIG5vZGUubG9jLnN0YXJ0KTtcbiAgICAgIG1ldGEubmFtZSA9IFwiaW1wb3J0XCI7XG4gICAgICBub2RlLm1ldGEgPSB0aGlzLmZpbmlzaE5vZGUobWV0YSwgXCJJZGVudGlmaWVyXCIpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VJbXBvcnRNZXRhKG5vZGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgfTtcblxuICBwcCQ1LnBhcnNlRHluYW1pY0ltcG9ydCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTsgLy8gc2tpcCBgKGBcblxuICAgIC8vIFBhcnNlIG5vZGUuc291cmNlLlxuICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDE2KSB7XG4gICAgICBpZiAoIXRoaXMuZWF0KHR5cGVzJDEucGFyZW5SKSkge1xuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmNvbW1hKTtcbiAgICAgICAgaWYgKCF0aGlzLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcyQxLnBhcmVuUikpIHtcbiAgICAgICAgICBub2RlLm9wdGlvbnMgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgICAgICBpZiAoIXRoaXMuZWF0KHR5cGVzJDEucGFyZW5SKSkge1xuICAgICAgICAgICAgdGhpcy5leHBlY3QodHlwZXMkMS5jb21tYSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKHR5cGVzJDEucGFyZW5SKSkge1xuICAgICAgICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5vcHRpb25zID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5vcHRpb25zID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVmVyaWZ5IGVuZGluZy5cbiAgICAgIGlmICghdGhpcy5lYXQodHlwZXMkMS5wYXJlblIpKSB7XG4gICAgICAgIHZhciBlcnJvclBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLmNvbW1hKSAmJiB0aGlzLmVhdCh0eXBlcyQxLnBhcmVuUikpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXJyb3JQb3MsIFwiVHJhaWxpbmcgY29tbWEgaXMgbm90IGFsbG93ZWQgaW4gaW1wb3J0KClcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy51bmV4cGVjdGVkKGVycm9yUG9zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnRFeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgcHAkNS5wYXJzZUltcG9ydE1ldGEgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7IC8vIHNraXAgYC5gXG5cbiAgICB2YXIgY29udGFpbnNFc2MgPSB0aGlzLmNvbnRhaW5zRXNjO1xuICAgIG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlSWRlbnQodHJ1ZSk7XG5cbiAgICBpZiAobm9kZS5wcm9wZXJ0eS5uYW1lICE9PSBcIm1ldGFcIilcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUucHJvcGVydHkuc3RhcnQsIFwiVGhlIG9ubHkgdmFsaWQgbWV0YSBwcm9wZXJ0eSBmb3IgaW1wb3J0IGlzICdpbXBvcnQubWV0YSdcIik7IH1cbiAgICBpZiAoY29udGFpbnNFc2MpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIidpbXBvcnQubWV0YScgbXVzdCBub3QgY29udGFpbiBlc2NhcGVkIGNoYXJhY3RlcnNcIik7IH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnNvdXJjZVR5cGUgIT09IFwibW9kdWxlXCIgJiYgIXRoaXMub3B0aW9ucy5hbGxvd0ltcG9ydEV4cG9ydEV2ZXJ5d2hlcmUpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIkNhbm5vdCB1c2UgJ2ltcG9ydC5tZXRhJyBvdXRzaWRlIGEgbW9kdWxlXCIpOyB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTWV0YVByb3BlcnR5XCIpXG4gIH07XG5cbiAgcHAkNS5wYXJzZUxpdGVyYWwgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLnZhbHVlID0gdmFsdWU7XG4gICAgbm9kZS5yYXcgPSB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgICBpZiAobm9kZS5yYXcuY2hhckNvZGVBdChub2RlLnJhdy5sZW5ndGggLSAxKSA9PT0gMTEwKSB7IG5vZGUuYmlnaW50ID0gbm9kZS5yYXcuc2xpY2UoMCwgLTEpLnJlcGxhY2UoL18vZywgXCJcIik7IH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTGl0ZXJhbFwiKVxuICB9O1xuXG4gIHBwJDUucGFyc2VQYXJlbkV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLnBhcmVuTCk7XG4gICAgdmFyIHZhbCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMkMS5wYXJlblIpO1xuICAgIHJldHVybiB2YWxcbiAgfTtcblxuICBwcCQ1LnNob3VsZFBhcnNlQXJyb3cgPSBmdW5jdGlvbihleHByTGlzdCkge1xuICAgIHJldHVybiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKVxuICB9O1xuXG4gIHBwJDUucGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKGNhbkJlQXJyb3csIGZvckluaXQpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2MsIHZhbCwgYWxsb3dUcmFpbGluZ0NvbW1hID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDg7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICB0aGlzLm5leHQoKTtcblxuICAgICAgdmFyIGlubmVyU3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBpbm5lclN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICAgIHZhciBleHByTGlzdCA9IFtdLCBmaXJzdCA9IHRydWUsIGxhc3RJc0NvbW1hID0gZmFsc2U7XG4gICAgICB2YXIgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzLCBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgc3ByZWFkU3RhcnQ7XG4gICAgICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgICAgIHRoaXMuYXdhaXRQb3MgPSAwO1xuICAgICAgLy8gRG8gbm90IHNhdmUgYXdhaXRJZGVudFBvcyB0byBhbGxvdyBjaGVja2luZyBhd2FpdHMgbmVzdGVkIGluIHBhcmFtZXRlcnNcbiAgICAgIHdoaWxlICh0aGlzLnR5cGUgIT09IHR5cGVzJDEucGFyZW5SKSB7XG4gICAgICAgIGZpcnN0ID8gZmlyc3QgPSBmYWxzZSA6IHRoaXMuZXhwZWN0KHR5cGVzJDEuY29tbWEpO1xuICAgICAgICBpZiAoYWxsb3dUcmFpbGluZ0NvbW1hICYmIHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKHR5cGVzJDEucGFyZW5SLCB0cnVlKSkge1xuICAgICAgICAgIGxhc3RJc0NvbW1hID0gdHJ1ZTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5lbGxpcHNpcykge1xuICAgICAgICAgIHNwcmVhZFN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgICAgICBleHByTGlzdC5wdXNoKHRoaXMucGFyc2VQYXJlbkl0ZW0odGhpcy5wYXJzZVJlc3RCaW5kaW5nKCkpKTtcbiAgICAgICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmNvbW1hKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoXG4gICAgICAgICAgICAgIHRoaXMuc3RhcnQsXG4gICAgICAgICAgICAgIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhwckxpc3QucHVzaCh0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRoaXMucGFyc2VQYXJlbkl0ZW0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGlubmVyRW5kUG9zID0gdGhpcy5sYXN0VG9rRW5kLCBpbm5lckVuZExvYyA9IHRoaXMubGFzdFRva0VuZExvYztcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEucGFyZW5SKTtcblxuICAgICAgaWYgKGNhbkJlQXJyb3cgJiYgdGhpcy5zaG91bGRQYXJzZUFycm93KGV4cHJMaXN0KSAmJiB0aGlzLmVhdCh0eXBlcyQxLmFycm93KSkge1xuICAgICAgICB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG4gICAgICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICAgICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVBhcmVuQXJyb3dMaXN0KHN0YXJ0UG9zLCBzdGFydExvYywgZXhwckxpc3QsIGZvckluaXQpXG4gICAgICB9XG5cbiAgICAgIGlmICghZXhwckxpc3QubGVuZ3RoIHx8IGxhc3RJc0NvbW1hKSB7IHRoaXMudW5leHBlY3RlZCh0aGlzLmxhc3RUb2tTdGFydCk7IH1cbiAgICAgIGlmIChzcHJlYWRTdGFydCkgeyB0aGlzLnVuZXhwZWN0ZWQoc3ByZWFkU3RhcnQpOyB9XG4gICAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcyB8fCB0aGlzLnlpZWxkUG9zO1xuICAgICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zIHx8IHRoaXMuYXdhaXRQb3M7XG5cbiAgICAgIGlmIChleHByTGlzdC5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhbCA9IHRoaXMuc3RhcnROb2RlQXQoaW5uZXJTdGFydFBvcywgaW5uZXJTdGFydExvYyk7XG4gICAgICAgIHZhbC5leHByZXNzaW9ucyA9IGV4cHJMaXN0O1xuICAgICAgICB0aGlzLmZpbmlzaE5vZGVBdCh2YWwsIFwiU2VxdWVuY2VFeHByZXNzaW9uXCIsIGlubmVyRW5kUG9zLCBpbm5lckVuZExvYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBleHByTGlzdFswXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFsID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMucHJlc2VydmVQYXJlbnMpIHtcbiAgICAgIHZhciBwYXIgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBwYXIuZXhwcmVzc2lvbiA9IHZhbDtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocGFyLCBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWxcbiAgICB9XG4gIH07XG5cbiAgcHAkNS5wYXJzZVBhcmVuSXRlbSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbVxuICB9O1xuXG4gIHBwJDUucGFyc2VQYXJlbkFycm93TGlzdCA9IGZ1bmN0aW9uKHN0YXJ0UG9zLCBzdGFydExvYywgZXhwckxpc3QsIGZvckluaXQpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIGV4cHJMaXN0LCBmYWxzZSwgZm9ySW5pdClcbiAgfTtcblxuICAvLyBOZXcncyBwcmVjZWRlbmNlIGlzIHNsaWdodGx5IHRyaWNreS4gSXQgbXVzdCBhbGxvdyBpdHMgYXJndW1lbnQgdG9cbiAgLy8gYmUgYSBgW11gIG9yIGRvdCBzdWJzY3JpcHQgZXhwcmVzc2lvbiwgYnV0IG5vdCBhIGNhbGwg4oCUIGF0IGxlYXN0LFxuICAvLyBub3Qgd2l0aG91dCB3cmFwcGluZyBpdCBpbiBwYXJlbnRoZXNlcy4gVGh1cywgaXQgdXNlcyB0aGUgbm9DYWxsc1xuICAvLyBhcmd1bWVudCB0byBwYXJzZVN1YnNjcmlwdHMgdG8gcHJldmVudCBpdCBmcm9tIGNvbnN1bWluZyB0aGVcbiAgLy8gYXJndW1lbnQgbGlzdC5cblxuICB2YXIgZW1wdHkgPSBbXTtcblxuICBwcCQ1LnBhcnNlTmV3ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuY29udGFpbnNFc2MpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiRXNjYXBlIHNlcXVlbmNlIGluIGtleXdvcmQgbmV3XCIpOyB9XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLnR5cGUgPT09IHR5cGVzJDEuZG90KSB7XG4gICAgICB2YXIgbWV0YSA9IHRoaXMuc3RhcnROb2RlQXQobm9kZS5zdGFydCwgbm9kZS5sb2MgJiYgbm9kZS5sb2Muc3RhcnQpO1xuICAgICAgbWV0YS5uYW1lID0gXCJuZXdcIjtcbiAgICAgIG5vZGUubWV0YSA9IHRoaXMuZmluaXNoTm9kZShtZXRhLCBcIklkZW50aWZpZXJcIik7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHZhciBjb250YWluc0VzYyA9IHRoaXMuY29udGFpbnNFc2M7XG4gICAgICBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuICAgICAgaWYgKG5vZGUucHJvcGVydHkubmFtZSAhPT0gXCJ0YXJnZXRcIilcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5wcm9wZXJ0eS5zdGFydCwgXCJUaGUgb25seSB2YWxpZCBtZXRhIHByb3BlcnR5IGZvciBuZXcgaXMgJ25ldy50YXJnZXQnXCIpOyB9XG4gICAgICBpZiAoY29udGFpbnNFc2MpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiJ25ldy50YXJnZXQnIG11c3Qgbm90IGNvbnRhaW4gZXNjYXBlZCBjaGFyYWN0ZXJzXCIpOyB9XG4gICAgICBpZiAoIXRoaXMuYWxsb3dOZXdEb3RUYXJnZXQpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiJ25ldy50YXJnZXQnIGNhbiBvbmx5IGJlIHVzZWQgaW4gZnVuY3Rpb25zIGFuZCBjbGFzcyBzdGF0aWMgYmxvY2tcIik7IH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNZXRhUHJvcGVydHlcIilcbiAgICB9XG4gICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgIG5vZGUuY2FsbGVlID0gdGhpcy5wYXJzZVN1YnNjcmlwdHModGhpcy5wYXJzZUV4cHJBdG9tKG51bGwsIGZhbHNlLCB0cnVlKSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCB0cnVlLCBmYWxzZSk7XG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzJDEucGFyZW5MKSkgeyBub2RlLmFyZ3VtZW50cyA9IHRoaXMucGFyc2VFeHByTGlzdCh0eXBlcyQxLnBhcmVuUiwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgsIGZhbHNlKTsgfVxuICAgIGVsc2UgeyBub2RlLmFyZ3VtZW50cyA9IGVtcHR5OyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk5ld0V4cHJlc3Npb25cIilcbiAgfTtcblxuICAvLyBQYXJzZSB0ZW1wbGF0ZSBleHByZXNzaW9uLlxuXG4gIHBwJDUucGFyc2VUZW1wbGF0ZUVsZW1lbnQgPSBmdW5jdGlvbihyZWYpIHtcbiAgICB2YXIgaXNUYWdnZWQgPSByZWYuaXNUYWdnZWQ7XG5cbiAgICB2YXIgZWxlbSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5pbnZhbGlkVGVtcGxhdGUpIHtcbiAgICAgIGlmICghaXNUYWdnZWQpIHtcbiAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiQmFkIGVzY2FwZSBzZXF1ZW5jZSBpbiB1bnRhZ2dlZCB0ZW1wbGF0ZSBsaXRlcmFsXCIpO1xuICAgICAgfVxuICAgICAgZWxlbS52YWx1ZSA9IHtcbiAgICAgICAgcmF3OiB0aGlzLnZhbHVlLnJlcGxhY2UoL1xcclxcbj8vZywgXCJcXG5cIiksXG4gICAgICAgIGNvb2tlZDogbnVsbFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbS52YWx1ZSA9IHtcbiAgICAgICAgcmF3OiB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKS5yZXBsYWNlKC9cXHJcXG4/L2csIFwiXFxuXCIpLFxuICAgICAgICBjb29rZWQ6IHRoaXMudmFsdWVcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIGVsZW0udGFpbCA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5iYWNrUXVvdGU7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShlbGVtLCBcIlRlbXBsYXRlRWxlbWVudFwiKVxuICB9O1xuXG4gIHBwJDUucGFyc2VUZW1wbGF0ZSA9IGZ1bmN0aW9uKHJlZikge1xuICAgIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSB7fTtcbiAgICB2YXIgaXNUYWdnZWQgPSByZWYuaXNUYWdnZWQ7IGlmICggaXNUYWdnZWQgPT09IHZvaWQgMCApIGlzVGFnZ2VkID0gZmFsc2U7XG5cbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5leHByZXNzaW9ucyA9IFtdO1xuICAgIHZhciBjdXJFbHQgPSB0aGlzLnBhcnNlVGVtcGxhdGVFbGVtZW50KHtpc1RhZ2dlZDogaXNUYWdnZWR9KTtcbiAgICBub2RlLnF1YXNpcyA9IFtjdXJFbHRdO1xuICAgIHdoaWxlICghY3VyRWx0LnRhaWwpIHtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuZW9mKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlIGxpdGVyYWxcIik7IH1cbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuZG9sbGFyQnJhY2VMKTtcbiAgICAgIG5vZGUuZXhwcmVzc2lvbnMucHVzaCh0aGlzLnBhcnNlRXhwcmVzc2lvbigpKTtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuYnJhY2VSKTtcbiAgICAgIG5vZGUucXVhc2lzLnB1c2goY3VyRWx0ID0gdGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudCh7aXNUYWdnZWQ6IGlzVGFnZ2VkfSkpO1xuICAgIH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGVtcGxhdGVMaXRlcmFsXCIpXG4gIH07XG5cbiAgcHAkNS5pc0FzeW5jUHJvcCA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgICByZXR1cm4gIXByb3AuY29tcHV0ZWQgJiYgcHJvcC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgcHJvcC5rZXkubmFtZSA9PT0gXCJhc3luY1wiICYmXG4gICAgICAodGhpcy50eXBlID09PSB0eXBlcyQxLm5hbWUgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLm51bSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzJDEuc3RyaW5nIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5icmFja2V0TCB8fCB0aGlzLnR5cGUua2V5d29yZCB8fCAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLnN0YXIpKSAmJlxuICAgICAgIWxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSlcbiAgfTtcblxuICAvLyBQYXJzZSBhbiBvYmplY3QgbGl0ZXJhbCBvciBiaW5kaW5nIHBhdHRlcm4uXG5cbiAgcHAkNS5wYXJzZU9iaiA9IGZ1bmN0aW9uKGlzUGF0dGVybiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwgZmlyc3QgPSB0cnVlLCBwcm9wSGFzaCA9IHt9O1xuICAgIG5vZGUucHJvcGVydGllcyA9IFtdO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHdoaWxlICghdGhpcy5lYXQodHlwZXMkMS5icmFjZVIpKSB7XG4gICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuY29tbWEpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDUgJiYgdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMkMS5icmFjZVIpKSB7IGJyZWFrIH1cbiAgICAgIH0gZWxzZSB7IGZpcnN0ID0gZmFsc2U7IH1cblxuICAgICAgdmFyIHByb3AgPSB0aGlzLnBhcnNlUHJvcGVydHkoaXNQYXR0ZXJuLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIGlmICghaXNQYXR0ZXJuKSB7IHRoaXMuY2hlY2tQcm9wQ2xhc2gocHJvcCwgcHJvcEhhc2gsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpOyB9XG4gICAgICBub2RlLnByb3BlcnRpZXMucHVzaChwcm9wKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc1BhdHRlcm4gPyBcIk9iamVjdFBhdHRlcm5cIiA6IFwiT2JqZWN0RXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIHBwJDUucGFyc2VQcm9wZXJ0eSA9IGZ1bmN0aW9uKGlzUGF0dGVybiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIHZhciBwcm9wID0gdGhpcy5zdGFydE5vZGUoKSwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIHN0YXJ0UG9zLCBzdGFydExvYztcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy5lYXQodHlwZXMkMS5lbGxpcHNpcykpIHtcbiAgICAgIGlmIChpc1BhdHRlcm4pIHtcbiAgICAgICAgcHJvcC5hcmd1bWVudCA9IHRoaXMucGFyc2VJZGVudChmYWxzZSk7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuY29tbWEpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJDb21tYSBpcyBub3QgcGVybWl0dGVkIGFmdGVyIHRoZSByZXN0IGVsZW1lbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wLCBcIlJlc3RFbGVtZW50XCIpXG4gICAgICB9XG4gICAgICAvLyBQYXJzZSBhcmd1bWVudC5cbiAgICAgIHByb3AuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgLy8gVG8gZGlzYWxsb3cgdHJhaWxpbmcgY29tbWEgdmlhIGB0aGlzLnRvQXNzaWduYWJsZSgpYC5cbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuY29tbWEgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPCAwKSB7XG4gICAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IHRoaXMuc3RhcnQ7XG4gICAgICB9XG4gICAgICAvLyBGaW5pc2hcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcCwgXCJTcHJlYWRFbGVtZW50XCIpXG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgcHJvcC5tZXRob2QgPSBmYWxzZTtcbiAgICAgIHByb3Auc2hvcnRoYW5kID0gZmFsc2U7XG4gICAgICBpZiAoaXNQYXR0ZXJuIHx8IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgICAgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0O1xuICAgICAgICBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICB9XG4gICAgICBpZiAoIWlzUGF0dGVybilcbiAgICAgICAgeyBpc0dlbmVyYXRvciA9IHRoaXMuZWF0KHR5cGVzJDEuc3Rhcik7IH1cbiAgICB9XG4gICAgdmFyIGNvbnRhaW5zRXNjID0gdGhpcy5jb250YWluc0VzYztcbiAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3ApO1xuICAgIGlmICghaXNQYXR0ZXJuICYmICFjb250YWluc0VzYyAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiAhaXNHZW5lcmF0b3IgJiYgdGhpcy5pc0FzeW5jUHJvcChwcm9wKSkge1xuICAgICAgaXNBc3luYyA9IHRydWU7XG4gICAgICBpc0dlbmVyYXRvciA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHRoaXMuZWF0KHR5cGVzJDEuc3Rhcik7XG4gICAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3ApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpc0FzeW5jID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMucGFyc2VQcm9wZXJ0eVZhbHVlKHByb3AsIGlzUGF0dGVybiwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIHN0YXJ0UG9zLCBzdGFydExvYywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgY29udGFpbnNFc2MpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcCwgXCJQcm9wZXJ0eVwiKVxuICB9O1xuXG4gIHBwJDUucGFyc2VHZXR0ZXJTZXR0ZXIgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgdmFyIGtpbmQgPSBwcm9wLmtleS5uYW1lO1xuICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCk7XG4gICAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNZXRob2QoZmFsc2UpO1xuICAgIHByb3Aua2luZCA9IGtpbmQ7XG4gICAgdmFyIHBhcmFtQ291bnQgPSBwcm9wLmtpbmQgPT09IFwiZ2V0XCIgPyAwIDogMTtcbiAgICBpZiAocHJvcC52YWx1ZS5wYXJhbXMubGVuZ3RoICE9PSBwYXJhbUNvdW50KSB7XG4gICAgICB2YXIgc3RhcnQgPSBwcm9wLnZhbHVlLnN0YXJ0O1xuICAgICAgaWYgKHByb3Aua2luZCA9PT0gXCJnZXRcIilcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwiZ2V0dGVyIHNob3VsZCBoYXZlIG5vIHBhcmFtc1wiKTsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJzZXR0ZXIgc2hvdWxkIGhhdmUgZXhhY3RseSBvbmUgcGFyYW1cIik7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3Aua2luZCA9PT0gXCJzZXRcIiAmJiBwcm9wLnZhbHVlLnBhcmFtc1swXS50eXBlID09PSBcIlJlc3RFbGVtZW50XCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHByb3AudmFsdWUucGFyYW1zWzBdLnN0YXJ0LCBcIlNldHRlciBjYW5ub3QgdXNlIHJlc3QgcGFyYW1zXCIpOyB9XG4gICAgfVxuICB9O1xuXG4gIHBwJDUucGFyc2VQcm9wZXJ0eVZhbHVlID0gZnVuY3Rpb24ocHJvcCwgaXNQYXR0ZXJuLCBpc0dlbmVyYXRvciwgaXNBc3luYywgc3RhcnRQb3MsIHN0YXJ0TG9jLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBjb250YWluc0VzYykge1xuICAgIGlmICgoaXNHZW5lcmF0b3IgfHwgaXNBc3luYykgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLmNvbG9uKVxuICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuXG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzJDEuY29sb24pKSB7XG4gICAgICBwcm9wLnZhbHVlID0gaXNQYXR0ZXJuID8gdGhpcy5wYXJzZU1heWJlRGVmYXVsdCh0aGlzLnN0YXJ0LCB0aGlzLnN0YXJ0TG9jKSA6IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICBwcm9wLmtpbmQgPSBcImluaXRcIjtcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5wYXJlbkwpIHtcbiAgICAgIGlmIChpc1BhdHRlcm4pIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHByb3AubWV0aG9kID0gdHJ1ZTtcbiAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWV0aG9kKGlzR2VuZXJhdG9yLCBpc0FzeW5jKTtcbiAgICAgIHByb3Aua2luZCA9IFwiaW5pdFwiO1xuICAgIH0gZWxzZSBpZiAoIWlzUGF0dGVybiAmJiAhY29udGFpbnNFc2MgJiZcbiAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA1ICYmICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmXG4gICAgICAgICAgICAgICAocHJvcC5rZXkubmFtZSA9PT0gXCJnZXRcIiB8fCBwcm9wLmtleS5uYW1lID09PSBcInNldFwiKSAmJlxuICAgICAgICAgICAgICAgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5jb21tYSAmJiB0aGlzLnR5cGUgIT09IHR5cGVzJDEuYnJhY2VSICYmIHRoaXMudHlwZSAhPT0gdHlwZXMkMS5lcSkpIHtcbiAgICAgIGlmIChpc0dlbmVyYXRvciB8fCBpc0FzeW5jKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICB0aGlzLnBhcnNlR2V0dGVyU2V0dGVyKHByb3ApO1xuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgIXByb3AuY29tcHV0ZWQgJiYgcHJvcC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICAgIGlmIChpc0dlbmVyYXRvciB8fCBpc0FzeW5jKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICB0aGlzLmNoZWNrVW5yZXNlcnZlZChwcm9wLmtleSk7XG4gICAgICBpZiAocHJvcC5rZXkubmFtZSA9PT0gXCJhd2FpdFwiICYmICF0aGlzLmF3YWl0SWRlbnRQb3MpXG4gICAgICAgIHsgdGhpcy5hd2FpdElkZW50UG9zID0gc3RhcnRQb3M7IH1cbiAgICAgIGlmIChpc1BhdHRlcm4pIHtcbiAgICAgICAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNYXliZURlZmF1bHQoc3RhcnRQb3MsIHN0YXJ0TG9jLCB0aGlzLmNvcHlOb2RlKHByb3Aua2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5lcSAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA8IDApXG4gICAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA9IHRoaXMuc3RhcnQ7IH1cbiAgICAgICAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNYXliZURlZmF1bHQoc3RhcnRQb3MsIHN0YXJ0TG9jLCB0aGlzLmNvcHlOb2RlKHByb3Aua2V5KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wLnZhbHVlID0gdGhpcy5jb3B5Tm9kZShwcm9wLmtleSk7XG4gICAgICB9XG4gICAgICBwcm9wLmtpbmQgPSBcImluaXRcIjtcbiAgICAgIHByb3Auc2hvcnRoYW5kID0gdHJ1ZTtcbiAgICB9IGVsc2UgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICB9O1xuXG4gIHBwJDUucGFyc2VQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICBpZiAodGhpcy5lYXQodHlwZXMkMS5icmFja2V0TCkpIHtcbiAgICAgICAgcHJvcC5jb21wdXRlZCA9IHRydWU7XG4gICAgICAgIHByb3Aua2V5ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuYnJhY2tldFIpO1xuICAgICAgICByZXR1cm4gcHJvcC5rZXlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3AuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3Aua2V5ID0gdGhpcy50eXBlID09PSB0eXBlcyQxLm51bSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzJDEuc3RyaW5nID8gdGhpcy5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLnBhcnNlSWRlbnQodGhpcy5vcHRpb25zLmFsbG93UmVzZXJ2ZWQgIT09IFwibmV2ZXJcIilcbiAgfTtcblxuICAvLyBJbml0aWFsaXplIGVtcHR5IGZ1bmN0aW9uIG5vZGUuXG5cbiAgcHAkNS5pbml0RnVuY3Rpb24gPSBmdW5jdGlvbihub2RlKSB7XG4gICAgbm9kZS5pZCA9IG51bGw7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7IG5vZGUuZ2VuZXJhdG9yID0gbm9kZS5leHByZXNzaW9uID0gZmFsc2U7IH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpIHsgbm9kZS5hc3luYyA9IGZhbHNlOyB9XG4gIH07XG5cbiAgLy8gUGFyc2Ugb2JqZWN0IG9yIGNsYXNzIG1ldGhvZC5cblxuICBwcCQ1LnBhcnNlTWV0aG9kID0gZnVuY3Rpb24oaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGFsbG93RGlyZWN0U3VwZXIpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBvbGRBd2FpdElkZW50UG9zID0gdGhpcy5hd2FpdElkZW50UG9zO1xuXG4gICAgdGhpcy5pbml0RnVuY3Rpb24obm9kZSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KVxuICAgICAgeyBub2RlLmdlbmVyYXRvciA9IGlzR2VuZXJhdG9yOyB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KVxuICAgICAgeyBub2RlLmFzeW5jID0gISFpc0FzeW5jOyB9XG5cbiAgICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSAwO1xuICAgIHRoaXMuZW50ZXJTY29wZShmdW5jdGlvbkZsYWdzKGlzQXN5bmMsIG5vZGUuZ2VuZXJhdG9yKSB8IFNDT1BFX1NVUEVSIHwgKGFsbG93RGlyZWN0U3VwZXIgPyBTQ09QRV9ESVJFQ1RfU1VQRVIgOiAwKSk7XG5cbiAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLnBhcmVuTCk7XG4gICAgbm9kZS5wYXJhbXMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QodHlwZXMkMS5wYXJlblIsIGZhbHNlLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCk7XG4gICAgdGhpcy5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKTtcbiAgICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGZhbHNlLCB0cnVlLCBmYWxzZSk7XG5cbiAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3M7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIC8vIFBhcnNlIGFycm93IGZ1bmN0aW9uIGV4cHJlc3Npb24gd2l0aCBnaXZlbiBwYXJhbWV0ZXJzLlxuXG4gIHBwJDUucGFyc2VBcnJvd0V4cHJlc3Npb24gPSBmdW5jdGlvbihub2RlLCBwYXJhbXMsIGlzQXN5bmMsIGZvckluaXQpIHtcbiAgICB2YXIgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIG9sZEF3YWl0SWRlbnRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3M7XG5cbiAgICB0aGlzLmVudGVyU2NvcGUoZnVuY3Rpb25GbGFncyhpc0FzeW5jLCBmYWxzZSkgfCBTQ09QRV9BUlJPVyk7XG4gICAgdGhpcy5pbml0RnVuY3Rpb24obm9kZSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KSB7IG5vZGUuYXN5bmMgPSAhIWlzQXN5bmM7IH1cblxuICAgIHRoaXMueWllbGRQb3MgPSAwO1xuICAgIHRoaXMuYXdhaXRQb3MgPSAwO1xuICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG5cbiAgICBub2RlLnBhcmFtcyA9IHRoaXMudG9Bc3NpZ25hYmxlTGlzdChwYXJhbXMsIHRydWUpO1xuICAgIHRoaXMucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgdHJ1ZSwgZmFsc2UsIGZvckluaXQpO1xuXG4gICAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zO1xuICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSBvbGRBd2FpdElkZW50UG9zO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIC8vIFBhcnNlIGZ1bmN0aW9uIGJvZHkgYW5kIGNoZWNrIHBhcmFtZXRlcnMuXG5cbiAgcHAkNS5wYXJzZUZ1bmN0aW9uQm9keSA9IGZ1bmN0aW9uKG5vZGUsIGlzQXJyb3dGdW5jdGlvbiwgaXNNZXRob2QsIGZvckluaXQpIHtcbiAgICB2YXIgaXNFeHByZXNzaW9uID0gaXNBcnJvd0Z1bmN0aW9uICYmIHRoaXMudHlwZSAhPT0gdHlwZXMkMS5icmFjZUw7XG4gICAgdmFyIG9sZFN0cmljdCA9IHRoaXMuc3RyaWN0LCB1c2VTdHJpY3QgPSBmYWxzZTtcblxuICAgIGlmIChpc0V4cHJlc3Npb24pIHtcbiAgICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmb3JJbml0KTtcbiAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRydWU7XG4gICAgICB0aGlzLmNoZWNrUGFyYW1zKG5vZGUsIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5vblNpbXBsZSA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA3ICYmICF0aGlzLmlzU2ltcGxlUGFyYW1MaXN0KG5vZGUucGFyYW1zKTtcbiAgICAgIGlmICghb2xkU3RyaWN0IHx8IG5vblNpbXBsZSkge1xuICAgICAgICB1c2VTdHJpY3QgPSB0aGlzLnN0cmljdERpcmVjdGl2ZSh0aGlzLmVuZCk7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBzdHJpY3QgbW9kZSBmdW5jdGlvbiwgdmVyaWZ5IHRoYXQgYXJndW1lbnQgbmFtZXNcbiAgICAgICAgLy8gYXJlIG5vdCByZXBlYXRlZCwgYW5kIGl0IGRvZXMgbm90IHRyeSB0byBiaW5kIHRoZSB3b3JkcyBgZXZhbGBcbiAgICAgICAgLy8gb3IgYGFyZ3VtZW50c2AuXG4gICAgICAgIGlmICh1c2VTdHJpY3QgJiYgbm9uU2ltcGxlKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiSWxsZWdhbCAndXNlIHN0cmljdCcgZGlyZWN0aXZlIGluIGZ1bmN0aW9uIHdpdGggbm9uLXNpbXBsZSBwYXJhbWV0ZXIgbGlzdFwiKTsgfVxuICAgICAgfVxuICAgICAgLy8gU3RhcnQgYSBuZXcgc2NvcGUgd2l0aCByZWdhcmQgdG8gbGFiZWxzIGFuZCB0aGUgYGluRnVuY3Rpb25gXG4gICAgICAvLyBmbGFnIChyZXN0b3JlIHRoZW0gdG8gdGhlaXIgb2xkIHZhbHVlIGFmdGVyd2FyZHMpLlxuICAgICAgdmFyIG9sZExhYmVscyA9IHRoaXMubGFiZWxzO1xuICAgICAgdGhpcy5sYWJlbHMgPSBbXTtcbiAgICAgIGlmICh1c2VTdHJpY3QpIHsgdGhpcy5zdHJpY3QgPSB0cnVlOyB9XG5cbiAgICAgIC8vIEFkZCB0aGUgcGFyYW1zIHRvIHZhckRlY2xhcmVkTmFtZXMgdG8gZW5zdXJlIHRoYXQgYW4gZXJyb3IgaXMgdGhyb3duXG4gICAgICAvLyBpZiBhIGxldC9jb25zdCBkZWNsYXJhdGlvbiBpbiB0aGUgZnVuY3Rpb24gY2xhc2hlcyB3aXRoIG9uZSBvZiB0aGUgcGFyYW1zLlxuICAgICAgdGhpcy5jaGVja1BhcmFtcyhub2RlLCAhb2xkU3RyaWN0ICYmICF1c2VTdHJpY3QgJiYgIWlzQXJyb3dGdW5jdGlvbiAmJiAhaXNNZXRob2QgJiYgdGhpcy5pc1NpbXBsZVBhcmFtTGlzdChub2RlLnBhcmFtcykpO1xuICAgICAgLy8gRW5zdXJlIHRoZSBmdW5jdGlvbiBuYW1lIGlzbid0IGEgZm9yYmlkZGVuIGlkZW50aWZpZXIgaW4gc3RyaWN0IG1vZGUsIGUuZy4gJ2V2YWwnXG4gICAgICBpZiAodGhpcy5zdHJpY3QgJiYgbm9kZS5pZCkgeyB0aGlzLmNoZWNrTFZhbFNpbXBsZShub2RlLmlkLCBCSU5EX09VVFNJREUpOyB9XG4gICAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlQmxvY2soZmFsc2UsIHVuZGVmaW5lZCwgdXNlU3RyaWN0ICYmICFvbGRTdHJpY3QpO1xuICAgICAgbm9kZS5leHByZXNzaW9uID0gZmFsc2U7XG4gICAgICB0aGlzLmFkYXB0RGlyZWN0aXZlUHJvbG9ndWUobm9kZS5ib2R5LmJvZHkpO1xuICAgICAgdGhpcy5sYWJlbHMgPSBvbGRMYWJlbHM7XG4gICAgfVxuICAgIHRoaXMuZXhpdFNjb3BlKCk7XG4gIH07XG5cbiAgcHAkNS5pc1NpbXBsZVBhcmFtTGlzdCA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gcGFyYW1zOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgIHtcbiAgICAgIHZhciBwYXJhbSA9IGxpc3RbaV07XG5cbiAgICAgIGlmIChwYXJhbS50eXBlICE9PSBcIklkZW50aWZpZXJcIikgeyByZXR1cm4gZmFsc2VcbiAgICB9IH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuXG4gIC8vIENoZWNrcyBmdW5jdGlvbiBwYXJhbXMgZm9yIHZhcmlvdXMgZGlzYWxsb3dlZCBwYXR0ZXJucyBzdWNoIGFzIHVzaW5nIFwiZXZhbFwiXG4gIC8vIG9yIFwiYXJndW1lbnRzXCIgYW5kIGR1cGxpY2F0ZSBwYXJhbWV0ZXJzLlxuXG4gIHBwJDUuY2hlY2tQYXJhbXMgPSBmdW5jdGlvbihub2RlLCBhbGxvd0R1cGxpY2F0ZXMpIHtcbiAgICB2YXIgbmFtZUhhc2ggPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5wYXJhbXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAge1xuICAgICAgdmFyIHBhcmFtID0gbGlzdFtpXTtcblxuICAgICAgdGhpcy5jaGVja0xWYWxJbm5lclBhdHRlcm4ocGFyYW0sIEJJTkRfVkFSLCBhbGxvd0R1cGxpY2F0ZXMgPyBudWxsIDogbmFtZUhhc2gpO1xuICAgIH1cbiAgfTtcblxuICAvLyBQYXJzZXMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBleHByZXNzaW9ucywgYW5kIHJldHVybnMgdGhlbSBhc1xuICAvLyBhbiBhcnJheS4gYGNsb3NlYCBpcyB0aGUgdG9rZW4gdHlwZSB0aGF0IGVuZHMgdGhlIGxpc3QsIGFuZFxuICAvLyBgYWxsb3dFbXB0eWAgY2FuIGJlIHR1cm5lZCBvbiB0byBhbGxvdyBzdWJzZXF1ZW50IGNvbW1hcyB3aXRoXG4gIC8vIG5vdGhpbmcgaW4gYmV0d2VlbiB0aGVtIHRvIGJlIHBhcnNlZCBhcyBgbnVsbGAgKHdoaWNoIGlzIG5lZWRlZFxuICAvLyBmb3IgYXJyYXkgbGl0ZXJhbHMpLlxuXG4gIHBwJDUucGFyc2VFeHByTGlzdCA9IGZ1bmN0aW9uKGNsb3NlLCBhbGxvd1RyYWlsaW5nQ29tbWEsIGFsbG93RW1wdHksIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgZWx0cyA9IFtdLCBmaXJzdCA9IHRydWU7XG4gICAgd2hpbGUgKCF0aGlzLmVhdChjbG9zZSkpIHtcbiAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMkMS5jb21tYSk7XG4gICAgICAgIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEoY2xvc2UpKSB7IGJyZWFrIH1cbiAgICAgIH0gZWxzZSB7IGZpcnN0ID0gZmFsc2U7IH1cblxuICAgICAgdmFyIGVsdCA9ICh2b2lkIDApO1xuICAgICAgaWYgKGFsbG93RW1wdHkgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLmNvbW1hKVxuICAgICAgICB7IGVsdCA9IG51bGw7IH1cbiAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5lbGxpcHNpcykge1xuICAgICAgICBlbHQgPSB0aGlzLnBhcnNlU3ByZWFkKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyAmJiB0aGlzLnR5cGUgPT09IHR5cGVzJDEuY29tbWEgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hIDwgMClcbiAgICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IHRoaXMuc3RhcnQ7IH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsdCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICB9XG4gICAgICBlbHRzLnB1c2goZWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGVsdHNcbiAgfTtcblxuICBwcCQ1LmNoZWNrVW5yZXNlcnZlZCA9IGZ1bmN0aW9uKHJlZikge1xuICAgIHZhciBzdGFydCA9IHJlZi5zdGFydDtcbiAgICB2YXIgZW5kID0gcmVmLmVuZDtcbiAgICB2YXIgbmFtZSA9IHJlZi5uYW1lO1xuXG4gICAgaWYgKHRoaXMuaW5HZW5lcmF0b3IgJiYgbmFtZSA9PT0gXCJ5aWVsZFwiKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwiQ2Fubm90IHVzZSAneWllbGQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGEgZ2VuZXJhdG9yXCIpOyB9XG4gICAgaWYgKHRoaXMuaW5Bc3luYyAmJiBuYW1lID09PSBcImF3YWl0XCIpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJDYW5ub3QgdXNlICdhd2FpdCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cIik7IH1cbiAgICBpZiAoISh0aGlzLmN1cnJlbnRUaGlzU2NvcGUoKS5mbGFncyAmIFNDT1BFX1ZBUikgJiYgbmFtZSA9PT0gXCJhcmd1bWVudHNcIilcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcIkNhbm5vdCB1c2UgJ2FyZ3VtZW50cycgaW4gY2xhc3MgZmllbGQgaW5pdGlhbGl6ZXJcIik7IH1cbiAgICBpZiAodGhpcy5pbkNsYXNzU3RhdGljQmxvY2sgJiYgKG5hbWUgPT09IFwiYXJndW1lbnRzXCIgfHwgbmFtZSA9PT0gXCJhd2FpdFwiKSlcbiAgICAgIHsgdGhpcy5yYWlzZShzdGFydCwgKFwiQ2Fubm90IHVzZSBcIiArIG5hbWUgKyBcIiBpbiBjbGFzcyBzdGF0aWMgaW5pdGlhbGl6YXRpb24gYmxvY2tcIikpOyB9XG4gICAgaWYgKHRoaXMua2V5d29yZHMudGVzdChuYW1lKSlcbiAgICAgIHsgdGhpcy5yYWlzZShzdGFydCwgKFwiVW5leHBlY3RlZCBrZXl3b3JkICdcIiArIG5hbWUgKyBcIidcIikpOyB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYgJiZcbiAgICAgIHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIGVuZCkuaW5kZXhPZihcIlxcXFxcIikgIT09IC0xKSB7IHJldHVybiB9XG4gICAgdmFyIHJlID0gdGhpcy5zdHJpY3QgPyB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3QgOiB0aGlzLnJlc2VydmVkV29yZHM7XG4gICAgaWYgKHJlLnRlc3QobmFtZSkpIHtcbiAgICAgIGlmICghdGhpcy5pbkFzeW5jICYmIG5hbWUgPT09IFwiYXdhaXRcIilcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwiQ2Fubm90IHVzZSBrZXl3b3JkICdhd2FpdCcgb3V0c2lkZSBhbiBhc3luYyBmdW5jdGlvblwiKTsgfVxuICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCAoXCJUaGUga2V5d29yZCAnXCIgKyBuYW1lICsgXCInIGlzIHJlc2VydmVkXCIpKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUGFyc2UgdGhlIG5leHQgdG9rZW4gYXMgYW4gaWRlbnRpZmllci4gSWYgYGxpYmVyYWxgIGlzIHRydWUgKHVzZWRcbiAgLy8gd2hlbiBwYXJzaW5nIHByb3BlcnRpZXMpLCBpdCB3aWxsIGFsc28gY29udmVydCBrZXl3b3JkcyBpbnRvXG4gIC8vIGlkZW50aWZpZXJzLlxuXG4gIHBwJDUucGFyc2VJZGVudCA9IGZ1bmN0aW9uKGxpYmVyYWwpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMucGFyc2VJZGVudE5vZGUoKTtcbiAgICB0aGlzLm5leHQoISFsaWJlcmFsKTtcbiAgICB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJZGVudGlmaWVyXCIpO1xuICAgIGlmICghbGliZXJhbCkge1xuICAgICAgdGhpcy5jaGVja1VucmVzZXJ2ZWQobm9kZSk7XG4gICAgICBpZiAobm9kZS5uYW1lID09PSBcImF3YWl0XCIgJiYgIXRoaXMuYXdhaXRJZGVudFBvcylcbiAgICAgICAgeyB0aGlzLmF3YWl0SWRlbnRQb3MgPSBub2RlLnN0YXJ0OyB9XG4gICAgfVxuICAgIHJldHVybiBub2RlXG4gIH07XG5cbiAgcHAkNS5wYXJzZUlkZW50Tm9kZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLm5hbWUpIHtcbiAgICAgIG5vZGUubmFtZSA9IHRoaXMudmFsdWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUua2V5d29yZCkge1xuICAgICAgbm9kZS5uYW1lID0gdGhpcy50eXBlLmtleXdvcmQ7XG5cbiAgICAgIC8vIFRvIGZpeCBodHRwczovL2dpdGh1Yi5jb20vYWNvcm5qcy9hY29ybi9pc3N1ZXMvNTc1XG4gICAgICAvLyBgY2xhc3NgIGFuZCBgZnVuY3Rpb25gIGtleXdvcmRzIHB1c2ggbmV3IGNvbnRleHQgaW50byB0aGlzLmNvbnRleHQuXG4gICAgICAvLyBCdXQgdGhlcmUgaXMgbm8gY2hhbmNlIHRvIHBvcCB0aGUgY29udGV4dCBpZiB0aGUga2V5d29yZCBpcyBjb25zdW1lZCBhcyBhbiBpZGVudGlmaWVyIHN1Y2ggYXMgYSBwcm9wZXJ0eSBuYW1lLlxuICAgICAgLy8gSWYgdGhlIHByZXZpb3VzIHRva2VuIGlzIGEgZG90LCB0aGlzIGRvZXMgbm90IGFwcGx5IGJlY2F1c2UgdGhlIGNvbnRleHQtbWFuYWdpbmcgY29kZSBhbHJlYWR5IGlnbm9yZWQgdGhlIGtleXdvcmRcbiAgICAgIGlmICgobm9kZS5uYW1lID09PSBcImNsYXNzXCIgfHwgbm9kZS5uYW1lID09PSBcImZ1bmN0aW9uXCIpICYmXG4gICAgICAgICh0aGlzLmxhc3RUb2tFbmQgIT09IHRoaXMubGFzdFRva1N0YXJ0ICsgMSB8fCB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5sYXN0VG9rU3RhcnQpICE9PSA0NikpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LnBvcCgpO1xuICAgICAgfVxuICAgICAgdGhpcy50eXBlID0gdHlwZXMkMS5uYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVcbiAgfTtcblxuICBwcCQ1LnBhcnNlUHJpdmF0ZUlkZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEucHJpdmF0ZUlkKSB7XG4gICAgICBub2RlLm5hbWUgPSB0aGlzLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUHJpdmF0ZUlkZW50aWZpZXJcIik7XG5cbiAgICAvLyBGb3IgdmFsaWRhdGluZyBleGlzdGVuY2VcbiAgICBpZiAodGhpcy5vcHRpb25zLmNoZWNrUHJpdmF0ZUZpZWxkcykge1xuICAgICAgaWYgKHRoaXMucHJpdmF0ZU5hbWVTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCAoXCJQcml2YXRlIGZpZWxkICcjXCIgKyAobm9kZS5uYW1lKSArIFwiJyBtdXN0IGJlIGRlY2xhcmVkIGluIGFuIGVuY2xvc2luZyBjbGFzc1wiKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByaXZhdGVOYW1lU3RhY2tbdGhpcy5wcml2YXRlTmFtZVN0YWNrLmxlbmd0aCAtIDFdLnVzZWQucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZVxuICB9O1xuXG4gIC8vIFBhcnNlcyB5aWVsZCBleHByZXNzaW9uIGluc2lkZSBnZW5lcmF0b3IuXG5cbiAgcHAkNS5wYXJzZVlpZWxkID0gZnVuY3Rpb24oZm9ySW5pdCkge1xuICAgIGlmICghdGhpcy55aWVsZFBvcykgeyB0aGlzLnlpZWxkUG9zID0gdGhpcy5zdGFydDsgfVxuXG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuc2VtaSB8fCB0aGlzLmNhbkluc2VydFNlbWljb2xvbigpIHx8ICh0aGlzLnR5cGUgIT09IHR5cGVzJDEuc3RhciAmJiAhdGhpcy50eXBlLnN0YXJ0c0V4cHIpKSB7XG4gICAgICBub2RlLmRlbGVnYXRlID0gZmFsc2U7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5kZWxlZ2F0ZSA9IHRoaXMuZWF0KHR5cGVzJDEuc3Rhcik7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZvckluaXQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiWWllbGRFeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgcHAkNS5wYXJzZUF3YWl0ID0gZnVuY3Rpb24oZm9ySW5pdCkge1xuICAgIGlmICghdGhpcy5hd2FpdFBvcykgeyB0aGlzLmF3YWl0UG9zID0gdGhpcy5zdGFydDsgfVxuXG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCB0cnVlLCBmYWxzZSwgZm9ySW5pdCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkF3YWl0RXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIHZhciBwcCQ0ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcmFpc2UgZXhjZXB0aW9ucyBvbiBwYXJzZSBlcnJvcnMuIEl0XG4gIC8vIHRha2VzIGFuIG9mZnNldCBpbnRlZ2VyIChpbnRvIHRoZSBjdXJyZW50IGBpbnB1dGApIHRvIGluZGljYXRlXG4gIC8vIHRoZSBsb2NhdGlvbiBvZiB0aGUgZXJyb3IsIGF0dGFjaGVzIHRoZSBwb3NpdGlvbiB0byB0aGUgZW5kXG4gIC8vIG9mIHRoZSBlcnJvciBtZXNzYWdlLCBhbmQgdGhlbiByYWlzZXMgYSBgU3ludGF4RXJyb3JgIHdpdGggdGhhdFxuICAvLyBtZXNzYWdlLlxuXG4gIHBwJDQucmFpc2UgPSBmdW5jdGlvbihwb3MsIG1lc3NhZ2UpIHtcbiAgICB2YXIgbG9jID0gZ2V0TGluZUluZm8odGhpcy5pbnB1dCwgcG9zKTtcbiAgICBtZXNzYWdlICs9IFwiIChcIiArIGxvYy5saW5lICsgXCI6XCIgKyBsb2MuY29sdW1uICsgXCIpXCI7XG4gICAgaWYgKHRoaXMuc291cmNlRmlsZSkge1xuICAgICAgbWVzc2FnZSArPSBcIiBpbiBcIiArIHRoaXMuc291cmNlRmlsZTtcbiAgICB9XG4gICAgdmFyIGVyciA9IG5ldyBTeW50YXhFcnJvcihtZXNzYWdlKTtcbiAgICBlcnIucG9zID0gcG9zOyBlcnIubG9jID0gbG9jOyBlcnIucmFpc2VkQXQgPSB0aGlzLnBvcztcbiAgICB0aHJvdyBlcnJcbiAgfTtcblxuICBwcCQ0LnJhaXNlUmVjb3ZlcmFibGUgPSBwcCQ0LnJhaXNlO1xuXG4gIHBwJDQuY3VyUG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbih0aGlzLmN1ckxpbmUsIHRoaXMucG9zIC0gdGhpcy5saW5lU3RhcnQpXG4gICAgfVxuICB9O1xuXG4gIHZhciBwcCQzID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICB2YXIgU2NvcGUgPSBmdW5jdGlvbiBTY29wZShmbGFncykge1xuICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICAvLyBBIGxpc3Qgb2YgdmFyLWRlY2xhcmVkIG5hbWVzIGluIHRoZSBjdXJyZW50IGxleGljYWwgc2NvcGVcbiAgICB0aGlzLnZhciA9IFtdO1xuICAgIC8vIEEgbGlzdCBvZiBsZXhpY2FsbHktZGVjbGFyZWQgbmFtZXMgaW4gdGhlIGN1cnJlbnQgbGV4aWNhbCBzY29wZVxuICAgIHRoaXMubGV4aWNhbCA9IFtdO1xuICAgIC8vIEEgbGlzdCBvZiBsZXhpY2FsbHktZGVjbGFyZWQgRnVuY3Rpb25EZWNsYXJhdGlvbiBuYW1lcyBpbiB0aGUgY3VycmVudCBsZXhpY2FsIHNjb3BlXG4gICAgdGhpcy5mdW5jdGlvbnMgPSBbXTtcbiAgfTtcblxuICAvLyBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIGtlZXAgdHJhY2sgb2YgZGVjbGFyZWQgdmFyaWFibGVzIGluIHRoZSBjdXJyZW50IHNjb3BlIGluIG9yZGVyIHRvIGRldGVjdCBkdXBsaWNhdGUgdmFyaWFibGUgbmFtZXMuXG5cbiAgcHAkMy5lbnRlclNjb3BlID0gZnVuY3Rpb24oZmxhZ3MpIHtcbiAgICB0aGlzLnNjb3BlU3RhY2sucHVzaChuZXcgU2NvcGUoZmxhZ3MpKTtcbiAgfTtcblxuICBwcCQzLmV4aXRTY29wZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2NvcGVTdGFjay5wb3AoKTtcbiAgfTtcblxuICAvLyBUaGUgc3BlYyBzYXlzOlxuICAvLyA+IEF0IHRoZSB0b3AgbGV2ZWwgb2YgYSBmdW5jdGlvbiwgb3Igc2NyaXB0LCBmdW5jdGlvbiBkZWNsYXJhdGlvbnMgYXJlXG4gIC8vID4gdHJlYXRlZCBsaWtlIHZhciBkZWNsYXJhdGlvbnMgcmF0aGVyIHRoYW4gbGlrZSBsZXhpY2FsIGRlY2xhcmF0aW9ucy5cbiAgcHAkMy50cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZSA9IGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgcmV0dXJuIChzY29wZS5mbGFncyAmIFNDT1BFX0ZVTkNUSU9OKSB8fCAhdGhpcy5pbk1vZHVsZSAmJiAoc2NvcGUuZmxhZ3MgJiBTQ09QRV9UT1ApXG4gIH07XG5cbiAgcHAkMy5kZWNsYXJlTmFtZSA9IGZ1bmN0aW9uKG5hbWUsIGJpbmRpbmdUeXBlLCBwb3MpIHtcbiAgICB2YXIgcmVkZWNsYXJlZCA9IGZhbHNlO1xuICAgIGlmIChiaW5kaW5nVHlwZSA9PT0gQklORF9MRVhJQ0FMKSB7XG4gICAgICB2YXIgc2NvcGUgPSB0aGlzLmN1cnJlbnRTY29wZSgpO1xuICAgICAgcmVkZWNsYXJlZCA9IHNjb3BlLmxleGljYWwuaW5kZXhPZihuYW1lKSA+IC0xIHx8IHNjb3BlLmZ1bmN0aW9ucy5pbmRleE9mKG5hbWUpID4gLTEgfHwgc2NvcGUudmFyLmluZGV4T2YobmFtZSkgPiAtMTtcbiAgICAgIHNjb3BlLmxleGljYWwucHVzaChuYW1lKTtcbiAgICAgIGlmICh0aGlzLmluTW9kdWxlICYmIChzY29wZS5mbGFncyAmIFNDT1BFX1RPUCkpXG4gICAgICAgIHsgZGVsZXRlIHRoaXMudW5kZWZpbmVkRXhwb3J0c1tuYW1lXTsgfVxuICAgIH0gZWxzZSBpZiAoYmluZGluZ1R5cGUgPT09IEJJTkRfU0lNUExFX0NBVENIKSB7XG4gICAgICB2YXIgc2NvcGUkMSA9IHRoaXMuY3VycmVudFNjb3BlKCk7XG4gICAgICBzY29wZSQxLmxleGljYWwucHVzaChuYW1lKTtcbiAgICB9IGVsc2UgaWYgKGJpbmRpbmdUeXBlID09PSBCSU5EX0ZVTkNUSU9OKSB7XG4gICAgICB2YXIgc2NvcGUkMiA9IHRoaXMuY3VycmVudFNjb3BlKCk7XG4gICAgICBpZiAodGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFyKVxuICAgICAgICB7IHJlZGVjbGFyZWQgPSBzY29wZSQyLmxleGljYWwuaW5kZXhPZihuYW1lKSA+IC0xOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgcmVkZWNsYXJlZCA9IHNjb3BlJDIubGV4aWNhbC5pbmRleE9mKG5hbWUpID4gLTEgfHwgc2NvcGUkMi52YXIuaW5kZXhPZihuYW1lKSA+IC0xOyB9XG4gICAgICBzY29wZSQyLmZ1bmN0aW9ucy5wdXNoKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBzY29wZSQzID0gdGhpcy5zY29wZVN0YWNrW2ldO1xuICAgICAgICBpZiAoc2NvcGUkMy5sZXhpY2FsLmluZGV4T2YobmFtZSkgPiAtMSAmJiAhKChzY29wZSQzLmZsYWdzICYgU0NPUEVfU0lNUExFX0NBVENIKSAmJiBzY29wZSQzLmxleGljYWxbMF0gPT09IG5hbWUpIHx8XG4gICAgICAgICAgICAhdGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZShzY29wZSQzKSAmJiBzY29wZSQzLmZ1bmN0aW9ucy5pbmRleE9mKG5hbWUpID4gLTEpIHtcbiAgICAgICAgICByZWRlY2xhcmVkID0gdHJ1ZTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHNjb3BlJDMudmFyLnB1c2gobmFtZSk7XG4gICAgICAgIGlmICh0aGlzLmluTW9kdWxlICYmIChzY29wZSQzLmZsYWdzICYgU0NPUEVfVE9QKSlcbiAgICAgICAgICB7IGRlbGV0ZSB0aGlzLnVuZGVmaW5lZEV4cG9ydHNbbmFtZV07IH1cbiAgICAgICAgaWYgKHNjb3BlJDMuZmxhZ3MgJiBTQ09QRV9WQVIpIHsgYnJlYWsgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVkZWNsYXJlZCkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocG9zLCAoXCJJZGVudGlmaWVyICdcIiArIG5hbWUgKyBcIicgaGFzIGFscmVhZHkgYmVlbiBkZWNsYXJlZFwiKSk7IH1cbiAgfTtcblxuICBwcCQzLmNoZWNrTG9jYWxFeHBvcnQgPSBmdW5jdGlvbihpZCkge1xuICAgIC8vIHNjb3BlLmZ1bmN0aW9ucyBtdXN0IGJlIGVtcHR5IGFzIE1vZHVsZSBjb2RlIGlzIGFsd2F5cyBzdHJpY3QuXG4gICAgaWYgKHRoaXMuc2NvcGVTdGFja1swXS5sZXhpY2FsLmluZGV4T2YoaWQubmFtZSkgPT09IC0xICYmXG4gICAgICAgIHRoaXMuc2NvcGVTdGFja1swXS52YXIuaW5kZXhPZihpZC5uYW1lKSA9PT0gLTEpIHtcbiAgICAgIHRoaXMudW5kZWZpbmVkRXhwb3J0c1tpZC5uYW1lXSA9IGlkO1xuICAgIH1cbiAgfTtcblxuICBwcCQzLmN1cnJlbnRTY29wZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNjb3BlU3RhY2tbdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDFdXG4gIH07XG5cbiAgcHAkMy5jdXJyZW50VmFyU2NvcGUgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICAgIHZhciBzY29wZSA9IHRoaXMuc2NvcGVTdGFja1tpXTtcbiAgICAgIGlmIChzY29wZS5mbGFncyAmIChTQ09QRV9WQVIgfCBTQ09QRV9DTEFTU19GSUVMRF9JTklUIHwgU0NPUEVfQ0xBU1NfU1RBVElDX0JMT0NLKSkgeyByZXR1cm4gc2NvcGUgfVxuICAgIH1cbiAgfTtcblxuICAvLyBDb3VsZCBiZSB1c2VmdWwgZm9yIGB0aGlzYCwgYG5ldy50YXJnZXRgLCBgc3VwZXIoKWAsIGBzdXBlci5wcm9wZXJ0eWAsIGFuZCBgc3VwZXJbcHJvcGVydHldYC5cbiAgcHAkMy5jdXJyZW50VGhpc1Njb3BlID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxOzsgaS0tKSB7XG4gICAgICB2YXIgc2NvcGUgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgICBpZiAoc2NvcGUuZmxhZ3MgJiAoU0NPUEVfVkFSIHwgU0NPUEVfQ0xBU1NfRklFTERfSU5JVCB8IFNDT1BFX0NMQVNTX1NUQVRJQ19CTE9DSykgJiZcbiAgICAgICAgICAhKHNjb3BlLmZsYWdzICYgU0NPUEVfQVJST1cpKSB7IHJldHVybiBzY29wZSB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBOb2RlID0gZnVuY3Rpb24gTm9kZShwYXJzZXIsIHBvcywgbG9jKSB7XG4gICAgdGhpcy50eXBlID0gXCJcIjtcbiAgICB0aGlzLnN0YXJ0ID0gcG9zO1xuICAgIHRoaXMuZW5kID0gMDtcbiAgICBpZiAocGFyc2VyLm9wdGlvbnMubG9jYXRpb25zKVxuICAgICAgeyB0aGlzLmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbihwYXJzZXIsIGxvYyk7IH1cbiAgICBpZiAocGFyc2VyLm9wdGlvbnMuZGlyZWN0U291cmNlRmlsZSlcbiAgICAgIHsgdGhpcy5zb3VyY2VGaWxlID0gcGFyc2VyLm9wdGlvbnMuZGlyZWN0U291cmNlRmlsZTsgfVxuICAgIGlmIChwYXJzZXIub3B0aW9ucy5yYW5nZXMpXG4gICAgICB7IHRoaXMucmFuZ2UgPSBbcG9zLCAwXTsgfVxuICB9O1xuXG4gIC8vIFN0YXJ0IGFuIEFTVCBub2RlLCBhdHRhY2hpbmcgYSBzdGFydCBvZmZzZXQuXG5cbiAgdmFyIHBwJDIgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4gIHBwJDIuc3RhcnROb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHRoaXMuc3RhcnQsIHRoaXMuc3RhcnRMb2MpXG4gIH07XG5cbiAgcHAkMi5zdGFydE5vZGVBdCA9IGZ1bmN0aW9uKHBvcywgbG9jKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHBvcywgbG9jKVxuICB9O1xuXG4gIC8vIEZpbmlzaCBhbiBBU1Qgbm9kZSwgYWRkaW5nIGB0eXBlYCBhbmQgYGVuZGAgcHJvcGVydGllcy5cblxuICBmdW5jdGlvbiBmaW5pc2hOb2RlQXQobm9kZSwgdHlwZSwgcG9zLCBsb2MpIHtcbiAgICBub2RlLnR5cGUgPSB0eXBlO1xuICAgIG5vZGUuZW5kID0gcG9zO1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKVxuICAgICAgeyBub2RlLmxvYy5lbmQgPSBsb2M7IH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcylcbiAgICAgIHsgbm9kZS5yYW5nZVsxXSA9IHBvczsgfVxuICAgIHJldHVybiBub2RlXG4gIH1cblxuICBwcCQyLmZpbmlzaE5vZGUgPSBmdW5jdGlvbihub2RlLCB0eXBlKSB7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGVBdC5jYWxsKHRoaXMsIG5vZGUsIHR5cGUsIHRoaXMubGFzdFRva0VuZCwgdGhpcy5sYXN0VG9rRW5kTG9jKVxuICB9O1xuXG4gIC8vIEZpbmlzaCBub2RlIGF0IGdpdmVuIHBvc2l0aW9uXG5cbiAgcHAkMi5maW5pc2hOb2RlQXQgPSBmdW5jdGlvbihub2RlLCB0eXBlLCBwb3MsIGxvYykge1xuICAgIHJldHVybiBmaW5pc2hOb2RlQXQuY2FsbCh0aGlzLCBub2RlLCB0eXBlLCBwb3MsIGxvYylcbiAgfTtcblxuICBwcCQyLmNvcHlOb2RlID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHZhciBuZXdOb2RlID0gbmV3IE5vZGUodGhpcywgbm9kZS5zdGFydCwgdGhpcy5zdGFydExvYyk7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBub2RlKSB7IG5ld05vZGVbcHJvcF0gPSBub2RlW3Byb3BdOyB9XG4gICAgcmV0dXJuIG5ld05vZGVcbiAgfTtcblxuICAvLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBcImJpbi9nZW5lcmF0ZS11bmljb2RlLXNjcmlwdC12YWx1ZXMuanNcIi4gRG8gbm90IG1vZGlmeSBtYW51YWxseSFcbiAgdmFyIHNjcmlwdFZhbHVlc0FkZGVkSW5Vbmljb2RlID0gXCJHYXJhIEdhcmF5IEd1a2ggR3VydW5nX0toZW1hIEhya3QgS2F0YWthbmFfT3JfSGlyYWdhbmEgS2F3aSBLaXJhdF9SYWkgS3JhaSBOYWdfTXVuZGFyaSBOYWdtIE9sX09uYWwgT25hbyBTdW51IFN1bnV3YXIgVG9kaHJpIFRvZHIgVHVsdV9UaWdhbGFyaSBUdXRnIFVua25vd24gWnp6elwiO1xuXG4gIC8vIFRoaXMgZmlsZSBjb250YWlucyBVbmljb2RlIHByb3BlcnRpZXMgZXh0cmFjdGVkIGZyb20gdGhlIEVDTUFTY3JpcHQgc3BlY2lmaWNhdGlvbi5cbiAgLy8gVGhlIGxpc3RzIGFyZSBleHRyYWN0ZWQgbGlrZSBzbzpcbiAgLy8gJCQoJyN0YWJsZS1iaW5hcnktdW5pY29kZS1wcm9wZXJ0aWVzID4gZmlndXJlID4gdGFibGUgPiB0Ym9keSA+IHRyID4gdGQ6bnRoLWNoaWxkKDEpIGNvZGUnKS5tYXAoZWwgPT4gZWwuaW5uZXJUZXh0KVxuXG4gIC8vICN0YWJsZS1iaW5hcnktdW5pY29kZS1wcm9wZXJ0aWVzXG4gIHZhciBlY21hOUJpbmFyeVByb3BlcnRpZXMgPSBcIkFTQ0lJIEFTQ0lJX0hleF9EaWdpdCBBSGV4IEFscGhhYmV0aWMgQWxwaGEgQW55IEFzc2lnbmVkIEJpZGlfQ29udHJvbCBCaWRpX0MgQmlkaV9NaXJyb3JlZCBCaWRpX00gQ2FzZV9JZ25vcmFibGUgQ0kgQ2FzZWQgQ2hhbmdlc19XaGVuX0Nhc2Vmb2xkZWQgQ1dDRiBDaGFuZ2VzX1doZW5fQ2FzZW1hcHBlZCBDV0NNIENoYW5nZXNfV2hlbl9Mb3dlcmNhc2VkIENXTCBDaGFuZ2VzX1doZW5fTkZLQ19DYXNlZm9sZGVkIENXS0NGIENoYW5nZXNfV2hlbl9UaXRsZWNhc2VkIENXVCBDaGFuZ2VzX1doZW5fVXBwZXJjYXNlZCBDV1UgRGFzaCBEZWZhdWx0X0lnbm9yYWJsZV9Db2RlX1BvaW50IERJIERlcHJlY2F0ZWQgRGVwIERpYWNyaXRpYyBEaWEgRW1vamkgRW1vamlfQ29tcG9uZW50IEVtb2ppX01vZGlmaWVyIEVtb2ppX01vZGlmaWVyX0Jhc2UgRW1vamlfUHJlc2VudGF0aW9uIEV4dGVuZGVyIEV4dCBHcmFwaGVtZV9CYXNlIEdyX0Jhc2UgR3JhcGhlbWVfRXh0ZW5kIEdyX0V4dCBIZXhfRGlnaXQgSGV4IElEU19CaW5hcnlfT3BlcmF0b3IgSURTQiBJRFNfVHJpbmFyeV9PcGVyYXRvciBJRFNUIElEX0NvbnRpbnVlIElEQyBJRF9TdGFydCBJRFMgSWRlb2dyYXBoaWMgSWRlbyBKb2luX0NvbnRyb2wgSm9pbl9DIExvZ2ljYWxfT3JkZXJfRXhjZXB0aW9uIExPRSBMb3dlcmNhc2UgTG93ZXIgTWF0aCBOb25jaGFyYWN0ZXJfQ29kZV9Qb2ludCBOQ2hhciBQYXR0ZXJuX1N5bnRheCBQYXRfU3luIFBhdHRlcm5fV2hpdGVfU3BhY2UgUGF0X1dTIFF1b3RhdGlvbl9NYXJrIFFNYXJrIFJhZGljYWwgUmVnaW9uYWxfSW5kaWNhdG9yIFJJIFNlbnRlbmNlX1Rlcm1pbmFsIFNUZXJtIFNvZnRfRG90dGVkIFNEIFRlcm1pbmFsX1B1bmN0dWF0aW9uIFRlcm0gVW5pZmllZF9JZGVvZ3JhcGggVUlkZW8gVXBwZXJjYXNlIFVwcGVyIFZhcmlhdGlvbl9TZWxlY3RvciBWUyBXaGl0ZV9TcGFjZSBzcGFjZSBYSURfQ29udGludWUgWElEQyBYSURfU3RhcnQgWElEU1wiO1xuICB2YXIgZWNtYTEwQmluYXJ5UHJvcGVydGllcyA9IGVjbWE5QmluYXJ5UHJvcGVydGllcyArIFwiIEV4dGVuZGVkX1BpY3RvZ3JhcGhpY1wiO1xuICB2YXIgZWNtYTExQmluYXJ5UHJvcGVydGllcyA9IGVjbWExMEJpbmFyeVByb3BlcnRpZXM7XG4gIHZhciBlY21hMTJCaW5hcnlQcm9wZXJ0aWVzID0gZWNtYTExQmluYXJ5UHJvcGVydGllcyArIFwiIEVCYXNlIEVDb21wIEVNb2QgRVByZXMgRXh0UGljdFwiO1xuICB2YXIgZWNtYTEzQmluYXJ5UHJvcGVydGllcyA9IGVjbWExMkJpbmFyeVByb3BlcnRpZXM7XG4gIHZhciBlY21hMTRCaW5hcnlQcm9wZXJ0aWVzID0gZWNtYTEzQmluYXJ5UHJvcGVydGllcztcblxuICB2YXIgdW5pY29kZUJpbmFyeVByb3BlcnRpZXMgPSB7XG4gICAgOTogZWNtYTlCaW5hcnlQcm9wZXJ0aWVzLFxuICAgIDEwOiBlY21hMTBCaW5hcnlQcm9wZXJ0aWVzLFxuICAgIDExOiBlY21hMTFCaW5hcnlQcm9wZXJ0aWVzLFxuICAgIDEyOiBlY21hMTJCaW5hcnlQcm9wZXJ0aWVzLFxuICAgIDEzOiBlY21hMTNCaW5hcnlQcm9wZXJ0aWVzLFxuICAgIDE0OiBlY21hMTRCaW5hcnlQcm9wZXJ0aWVzXG4gIH07XG5cbiAgLy8gI3RhYmxlLWJpbmFyeS11bmljb2RlLXByb3BlcnRpZXMtb2Ytc3RyaW5nc1xuICB2YXIgZWNtYTE0QmluYXJ5UHJvcGVydGllc09mU3RyaW5ncyA9IFwiQmFzaWNfRW1vamkgRW1vamlfS2V5Y2FwX1NlcXVlbmNlIFJHSV9FbW9qaV9Nb2RpZmllcl9TZXF1ZW5jZSBSR0lfRW1vamlfRmxhZ19TZXF1ZW5jZSBSR0lfRW1vamlfVGFnX1NlcXVlbmNlIFJHSV9FbW9qaV9aV0pfU2VxdWVuY2UgUkdJX0Vtb2ppXCI7XG5cbiAgdmFyIHVuaWNvZGVCaW5hcnlQcm9wZXJ0aWVzT2ZTdHJpbmdzID0ge1xuICAgIDk6IFwiXCIsXG4gICAgMTA6IFwiXCIsXG4gICAgMTE6IFwiXCIsXG4gICAgMTI6IFwiXCIsXG4gICAgMTM6IFwiXCIsXG4gICAgMTQ6IGVjbWExNEJpbmFyeVByb3BlcnRpZXNPZlN0cmluZ3NcbiAgfTtcblxuICAvLyAjdGFibGUtdW5pY29kZS1nZW5lcmFsLWNhdGVnb3J5LXZhbHVlc1xuICB2YXIgdW5pY29kZUdlbmVyYWxDYXRlZ29yeVZhbHVlcyA9IFwiQ2FzZWRfTGV0dGVyIExDIENsb3NlX1B1bmN0dWF0aW9uIFBlIENvbm5lY3Rvcl9QdW5jdHVhdGlvbiBQYyBDb250cm9sIENjIGNudHJsIEN1cnJlbmN5X1N5bWJvbCBTYyBEYXNoX1B1bmN0dWF0aW9uIFBkIERlY2ltYWxfTnVtYmVyIE5kIGRpZ2l0IEVuY2xvc2luZ19NYXJrIE1lIEZpbmFsX1B1bmN0dWF0aW9uIFBmIEZvcm1hdCBDZiBJbml0aWFsX1B1bmN0dWF0aW9uIFBpIExldHRlciBMIExldHRlcl9OdW1iZXIgTmwgTGluZV9TZXBhcmF0b3IgWmwgTG93ZXJjYXNlX0xldHRlciBMbCBNYXJrIE0gQ29tYmluaW5nX01hcmsgTWF0aF9TeW1ib2wgU20gTW9kaWZpZXJfTGV0dGVyIExtIE1vZGlmaWVyX1N5bWJvbCBTayBOb25zcGFjaW5nX01hcmsgTW4gTnVtYmVyIE4gT3Blbl9QdW5jdHVhdGlvbiBQcyBPdGhlciBDIE90aGVyX0xldHRlciBMbyBPdGhlcl9OdW1iZXIgTm8gT3RoZXJfUHVuY3R1YXRpb24gUG8gT3RoZXJfU3ltYm9sIFNvIFBhcmFncmFwaF9TZXBhcmF0b3IgWnAgUHJpdmF0ZV9Vc2UgQ28gUHVuY3R1YXRpb24gUCBwdW5jdCBTZXBhcmF0b3IgWiBTcGFjZV9TZXBhcmF0b3IgWnMgU3BhY2luZ19NYXJrIE1jIFN1cnJvZ2F0ZSBDcyBTeW1ib2wgUyBUaXRsZWNhc2VfTGV0dGVyIEx0IFVuYXNzaWduZWQgQ24gVXBwZXJjYXNlX0xldHRlciBMdVwiO1xuXG4gIC8vICN0YWJsZS11bmljb2RlLXNjcmlwdC12YWx1ZXNcbiAgdmFyIGVjbWE5U2NyaXB0VmFsdWVzID0gXCJBZGxhbSBBZGxtIEFob20gQW5hdG9saWFuX0hpZXJvZ2x5cGhzIEhsdXcgQXJhYmljIEFyYWIgQXJtZW5pYW4gQXJtbiBBdmVzdGFuIEF2c3QgQmFsaW5lc2UgQmFsaSBCYW11bSBCYW11IEJhc3NhX1ZhaCBCYXNzIEJhdGFrIEJhdGsgQmVuZ2FsaSBCZW5nIEJoYWlrc3VraSBCaGtzIEJvcG9tb2ZvIEJvcG8gQnJhaG1pIEJyYWggQnJhaWxsZSBCcmFpIEJ1Z2luZXNlIEJ1Z2kgQnVoaWQgQnVoZCBDYW5hZGlhbl9BYm9yaWdpbmFsIENhbnMgQ2FyaWFuIENhcmkgQ2F1Y2FzaWFuX0FsYmFuaWFuIEFnaGIgQ2hha21hIENha20gQ2hhbSBDaGFtIENoZXJva2VlIENoZXIgQ29tbW9uIFp5eXkgQ29wdGljIENvcHQgUWFhYyBDdW5laWZvcm0gWHN1eCBDeXByaW90IENwcnQgQ3lyaWxsaWMgQ3lybCBEZXNlcmV0IERzcnQgRGV2YW5hZ2FyaSBEZXZhIER1cGxveWFuIER1cGwgRWd5cHRpYW5fSGllcm9nbHlwaHMgRWd5cCBFbGJhc2FuIEVsYmEgRXRoaW9waWMgRXRoaSBHZW9yZ2lhbiBHZW9yIEdsYWdvbGl0aWMgR2xhZyBHb3RoaWMgR290aCBHcmFudGhhIEdyYW4gR3JlZWsgR3JlayBHdWphcmF0aSBHdWpyIEd1cm11a2hpIEd1cnUgSGFuIEhhbmkgSGFuZ3VsIEhhbmcgSGFudW5vbyBIYW5vIEhhdHJhbiBIYXRyIEhlYnJldyBIZWJyIEhpcmFnYW5hIEhpcmEgSW1wZXJpYWxfQXJhbWFpYyBBcm1pIEluaGVyaXRlZCBaaW5oIFFhYWkgSW5zY3JpcHRpb25hbF9QYWhsYXZpIFBobGkgSW5zY3JpcHRpb25hbF9QYXJ0aGlhbiBQcnRpIEphdmFuZXNlIEphdmEgS2FpdGhpIEt0aGkgS2FubmFkYSBLbmRhIEthdGFrYW5hIEthbmEgS2F5YWhfTGkgS2FsaSBLaGFyb3NodGhpIEtoYXIgS2htZXIgS2htciBLaG9qa2kgS2hvaiBLaHVkYXdhZGkgU2luZCBMYW8gTGFvbyBMYXRpbiBMYXRuIExlcGNoYSBMZXBjIExpbWJ1IExpbWIgTGluZWFyX0EgTGluYSBMaW5lYXJfQiBMaW5iIExpc3UgTGlzdSBMeWNpYW4gTHljaSBMeWRpYW4gTHlkaSBNYWhhamFuaSBNYWhqIE1hbGF5YWxhbSBNbHltIE1hbmRhaWMgTWFuZCBNYW5pY2hhZWFuIE1hbmkgTWFyY2hlbiBNYXJjIE1hc2FyYW1fR29uZGkgR29ubSBNZWV0ZWlfTWF5ZWsgTXRlaSBNZW5kZV9LaWtha3VpIE1lbmQgTWVyb2l0aWNfQ3Vyc2l2ZSBNZXJjIE1lcm9pdGljX0hpZXJvZ2x5cGhzIE1lcm8gTWlhbyBQbHJkIE1vZGkgTW9uZ29saWFuIE1vbmcgTXJvIE1yb28gTXVsdGFuaSBNdWx0IE15YW5tYXIgTXltciBOYWJhdGFlYW4gTmJhdCBOZXdfVGFpX0x1ZSBUYWx1IE5ld2EgTmV3YSBOa28gTmtvbyBOdXNodSBOc2h1IE9naGFtIE9nYW0gT2xfQ2hpa2kgT2xjayBPbGRfSHVuZ2FyaWFuIEh1bmcgT2xkX0l0YWxpYyBJdGFsIE9sZF9Ob3J0aF9BcmFiaWFuIE5hcmIgT2xkX1Blcm1pYyBQZXJtIE9sZF9QZXJzaWFuIFhwZW8gT2xkX1NvdXRoX0FyYWJpYW4gU2FyYiBPbGRfVHVya2ljIE9ya2ggT3JpeWEgT3J5YSBPc2FnZSBPc2dlIE9zbWFueWEgT3NtYSBQYWhhd2hfSG1vbmcgSG1uZyBQYWxteXJlbmUgUGFsbSBQYXVfQ2luX0hhdSBQYXVjIFBoYWdzX1BhIFBoYWcgUGhvZW5pY2lhbiBQaG54IFBzYWx0ZXJfUGFobGF2aSBQaGxwIFJlamFuZyBSam5nIFJ1bmljIFJ1bnIgU2FtYXJpdGFuIFNhbXIgU2F1cmFzaHRyYSBTYXVyIFNoYXJhZGEgU2hyZCBTaGF2aWFuIFNoYXcgU2lkZGhhbSBTaWRkIFNpZ25Xcml0aW5nIFNnbncgU2luaGFsYSBTaW5oIFNvcmFfU29tcGVuZyBTb3JhIFNveW9tYm8gU295byBTdW5kYW5lc2UgU3VuZCBTeWxvdGlfTmFncmkgU3lsbyBTeXJpYWMgU3lyYyBUYWdhbG9nIFRnbGcgVGFnYmFud2EgVGFnYiBUYWlfTGUgVGFsZSBUYWlfVGhhbSBMYW5hIFRhaV9WaWV0IFRhdnQgVGFrcmkgVGFrciBUYW1pbCBUYW1sIFRhbmd1dCBUYW5nIFRlbHVndSBUZWx1IFRoYWFuYSBUaGFhIFRoYWkgVGhhaSBUaWJldGFuIFRpYnQgVGlmaW5hZ2ggVGZuZyBUaXJodXRhIFRpcmggVWdhcml0aWMgVWdhciBWYWkgVmFpaSBXYXJhbmdfQ2l0aSBXYXJhIFlpIFlpaWkgWmFuYWJhemFyX1NxdWFyZSBaYW5iXCI7XG4gIHZhciBlY21hMTBTY3JpcHRWYWx1ZXMgPSBlY21hOVNjcmlwdFZhbHVlcyArIFwiIERvZ3JhIERvZ3IgR3VuamFsYV9Hb25kaSBHb25nIEhhbmlmaV9Sb2hpbmd5YSBSb2hnIE1ha2FzYXIgTWFrYSBNZWRlZmFpZHJpbiBNZWRmIE9sZF9Tb2dkaWFuIFNvZ28gU29nZGlhbiBTb2dkXCI7XG4gIHZhciBlY21hMTFTY3JpcHRWYWx1ZXMgPSBlY21hMTBTY3JpcHRWYWx1ZXMgKyBcIiBFbHltYWljIEVseW0gTmFuZGluYWdhcmkgTmFuZCBOeWlha2VuZ19QdWFjaHVlX0htb25nIEhtbnAgV2FuY2hvIFdjaG9cIjtcbiAgdmFyIGVjbWExMlNjcmlwdFZhbHVlcyA9IGVjbWExMVNjcmlwdFZhbHVlcyArIFwiIENob3Jhc21pYW4gQ2hycyBEaWFrIERpdmVzX0FrdXJ1IEtoaXRhbl9TbWFsbF9TY3JpcHQgS2l0cyBZZXppIFllemlkaVwiO1xuICB2YXIgZWNtYTEzU2NyaXB0VmFsdWVzID0gZWNtYTEyU2NyaXB0VmFsdWVzICsgXCIgQ3lwcm9fTWlub2FuIENwbW4gT2xkX1V5Z2h1ciBPdWdyIFRhbmdzYSBUbnNhIFRvdG8gVml0aGt1cWkgVml0aFwiO1xuICB2YXIgZWNtYTE0U2NyaXB0VmFsdWVzID0gZWNtYTEzU2NyaXB0VmFsdWVzICsgXCIgXCIgKyBzY3JpcHRWYWx1ZXNBZGRlZEluVW5pY29kZTtcblxuICB2YXIgdW5pY29kZVNjcmlwdFZhbHVlcyA9IHtcbiAgICA5OiBlY21hOVNjcmlwdFZhbHVlcyxcbiAgICAxMDogZWNtYTEwU2NyaXB0VmFsdWVzLFxuICAgIDExOiBlY21hMTFTY3JpcHRWYWx1ZXMsXG4gICAgMTI6IGVjbWExMlNjcmlwdFZhbHVlcyxcbiAgICAxMzogZWNtYTEzU2NyaXB0VmFsdWVzLFxuICAgIDE0OiBlY21hMTRTY3JpcHRWYWx1ZXNcbiAgfTtcblxuICB2YXIgZGF0YSA9IHt9O1xuICBmdW5jdGlvbiBidWlsZFVuaWNvZGVEYXRhKGVjbWFWZXJzaW9uKSB7XG4gICAgdmFyIGQgPSBkYXRhW2VjbWFWZXJzaW9uXSA9IHtcbiAgICAgIGJpbmFyeTogd29yZHNSZWdleHAodW5pY29kZUJpbmFyeVByb3BlcnRpZXNbZWNtYVZlcnNpb25dICsgXCIgXCIgKyB1bmljb2RlR2VuZXJhbENhdGVnb3J5VmFsdWVzKSxcbiAgICAgIGJpbmFyeU9mU3RyaW5nczogd29yZHNSZWdleHAodW5pY29kZUJpbmFyeVByb3BlcnRpZXNPZlN0cmluZ3NbZWNtYVZlcnNpb25dKSxcbiAgICAgIG5vbkJpbmFyeToge1xuICAgICAgICBHZW5lcmFsX0NhdGVnb3J5OiB3b3Jkc1JlZ2V4cCh1bmljb2RlR2VuZXJhbENhdGVnb3J5VmFsdWVzKSxcbiAgICAgICAgU2NyaXB0OiB3b3Jkc1JlZ2V4cCh1bmljb2RlU2NyaXB0VmFsdWVzW2VjbWFWZXJzaW9uXSlcbiAgICAgIH1cbiAgICB9O1xuICAgIGQubm9uQmluYXJ5LlNjcmlwdF9FeHRlbnNpb25zID0gZC5ub25CaW5hcnkuU2NyaXB0O1xuXG4gICAgZC5ub25CaW5hcnkuZ2MgPSBkLm5vbkJpbmFyeS5HZW5lcmFsX0NhdGVnb3J5O1xuICAgIGQubm9uQmluYXJ5LnNjID0gZC5ub25CaW5hcnkuU2NyaXB0O1xuICAgIGQubm9uQmluYXJ5LnNjeCA9IGQubm9uQmluYXJ5LlNjcmlwdF9FeHRlbnNpb25zO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBbOSwgMTAsIDExLCAxMiwgMTMsIDE0XTsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICB2YXIgZWNtYVZlcnNpb24gPSBsaXN0W2ldO1xuXG4gICAgYnVpbGRVbmljb2RlRGF0YShlY21hVmVyc2lvbik7XG4gIH1cblxuICB2YXIgcHAkMSA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgLy8gVHJhY2sgZGlzanVuY3Rpb24gc3RydWN0dXJlIHRvIGRldGVybWluZSB3aGV0aGVyIGEgZHVwbGljYXRlXG4gIC8vIGNhcHR1cmUgZ3JvdXAgbmFtZSBpcyBhbGxvd2VkIGJlY2F1c2UgaXQgaXMgaW4gYSBzZXBhcmF0ZSBicmFuY2guXG4gIHZhciBCcmFuY2hJRCA9IGZ1bmN0aW9uIEJyYW5jaElEKHBhcmVudCwgYmFzZSkge1xuICAgIC8vIFBhcmVudCBkaXNqdW5jdGlvbiBicmFuY2hcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAvLyBJZGVudGlmaWVzIHRoaXMgc2V0IG9mIHNpYmxpbmcgYnJhbmNoZXNcbiAgICB0aGlzLmJhc2UgPSBiYXNlIHx8IHRoaXM7XG4gIH07XG5cbiAgQnJhbmNoSUQucHJvdG90eXBlLnNlcGFyYXRlZEZyb20gPSBmdW5jdGlvbiBzZXBhcmF0ZWRGcm9tIChhbHQpIHtcbiAgICAvLyBBIGJyYW5jaCBpcyBzZXBhcmF0ZSBmcm9tIGFub3RoZXIgYnJhbmNoIGlmIHRoZXkgb3IgYW55IG9mXG4gICAgLy8gdGhlaXIgcGFyZW50cyBhcmUgc2libGluZ3MgaW4gYSBnaXZlbiBkaXNqdW5jdGlvblxuICAgIGZvciAodmFyIHNlbGYgPSB0aGlzOyBzZWxmOyBzZWxmID0gc2VsZi5wYXJlbnQpIHtcbiAgICAgIGZvciAodmFyIG90aGVyID0gYWx0OyBvdGhlcjsgb3RoZXIgPSBvdGhlci5wYXJlbnQpIHtcbiAgICAgICAgaWYgKHNlbGYuYmFzZSA9PT0gb3RoZXIuYmFzZSAmJiBzZWxmICE9PSBvdGhlcikgeyByZXR1cm4gdHJ1ZSB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIEJyYW5jaElELnByb3RvdHlwZS5zaWJsaW5nID0gZnVuY3Rpb24gc2libGluZyAoKSB7XG4gICAgcmV0dXJuIG5ldyBCcmFuY2hJRCh0aGlzLnBhcmVudCwgdGhpcy5iYXNlKVxuICB9O1xuXG4gIHZhciBSZWdFeHBWYWxpZGF0aW9uU3RhdGUgPSBmdW5jdGlvbiBSZWdFeHBWYWxpZGF0aW9uU3RhdGUocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy52YWxpZEZsYWdzID0gXCJnaW1cIiArIChwYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ID8gXCJ1eVwiIDogXCJcIikgKyAocGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSA/IFwic1wiIDogXCJcIikgKyAocGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTMgPyBcImRcIiA6IFwiXCIpICsgKHBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDE1ID8gXCJ2XCIgOiBcIlwiKTtcbiAgICB0aGlzLnVuaWNvZGVQcm9wZXJ0aWVzID0gZGF0YVtwYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxNCA/IDE0IDogcGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb25dO1xuICAgIHRoaXMuc291cmNlID0gXCJcIjtcbiAgICB0aGlzLmZsYWdzID0gXCJcIjtcbiAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICB0aGlzLnN3aXRjaFUgPSBmYWxzZTtcbiAgICB0aGlzLnN3aXRjaFYgPSBmYWxzZTtcbiAgICB0aGlzLnN3aXRjaE4gPSBmYWxzZTtcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy5sYXN0SW50VmFsdWUgPSAwO1xuICAgIHRoaXMubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgICB0aGlzLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubnVtQ2FwdHVyaW5nUGFyZW5zID0gMDtcbiAgICB0aGlzLm1heEJhY2tSZWZlcmVuY2UgPSAwO1xuICAgIHRoaXMuZ3JvdXBOYW1lcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5iYWNrUmVmZXJlbmNlTmFtZXMgPSBbXTtcbiAgICB0aGlzLmJyYW5jaElEID0gbnVsbDtcbiAgfTtcblxuICBSZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQgKHN0YXJ0LCBwYXR0ZXJuLCBmbGFncykge1xuICAgIHZhciB1bmljb2RlU2V0cyA9IGZsYWdzLmluZGV4T2YoXCJ2XCIpICE9PSAtMTtcbiAgICB2YXIgdW5pY29kZSA9IGZsYWdzLmluZGV4T2YoXCJ1XCIpICE9PSAtMTtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQgfCAwO1xuICAgIHRoaXMuc291cmNlID0gcGF0dGVybiArIFwiXCI7XG4gICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIGlmICh1bmljb2RlU2V0cyAmJiB0aGlzLnBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDE1KSB7XG4gICAgICB0aGlzLnN3aXRjaFUgPSB0cnVlO1xuICAgICAgdGhpcy5zd2l0Y2hWID0gdHJ1ZTtcbiAgICAgIHRoaXMuc3dpdGNoTiA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3dpdGNoVSA9IHVuaWNvZGUgJiYgdGhpcy5wYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2O1xuICAgICAgdGhpcy5zd2l0Y2hWID0gZmFsc2U7XG4gICAgICB0aGlzLnN3aXRjaE4gPSB1bmljb2RlICYmIHRoaXMucGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOTtcbiAgICB9XG4gIH07XG5cbiAgUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5yYWlzZSA9IGZ1bmN0aW9uIHJhaXNlIChtZXNzYWdlKSB7XG4gICAgdGhpcy5wYXJzZXIucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCAoXCJJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbjogL1wiICsgKHRoaXMuc291cmNlKSArIFwiLzogXCIgKyBtZXNzYWdlKSk7XG4gIH07XG5cbiAgLy8gSWYgdSBmbGFnIGlzIGdpdmVuLCB0aGlzIHJldHVybnMgdGhlIGNvZGUgcG9pbnQgYXQgdGhlIGluZGV4IChpdCBjb21iaW5lcyBhIHN1cnJvZ2F0ZSBwYWlyKS5cbiAgLy8gT3RoZXJ3aXNlLCB0aGlzIHJldHVybnMgdGhlIGNvZGUgdW5pdCBvZiB0aGUgaW5kZXggKGNhbiBiZSBhIHBhcnQgb2YgYSBzdXJyb2dhdGUgcGFpcikuXG4gIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiBhdCAoaSwgZm9yY2VVKSB7XG4gICAgICBpZiAoIGZvcmNlVSA9PT0gdm9pZCAwICkgZm9yY2VVID0gZmFsc2U7XG5cbiAgICB2YXIgcyA9IHRoaXMuc291cmNlO1xuICAgIHZhciBsID0gcy5sZW5ndGg7XG4gICAgaWYgKGkgPj0gbCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHZhciBjID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmICghKGZvcmNlVSB8fCB0aGlzLnN3aXRjaFUpIHx8IGMgPD0gMHhEN0ZGIHx8IGMgPj0gMHhFMDAwIHx8IGkgKyAxID49IGwpIHtcbiAgICAgIHJldHVybiBjXG4gICAgfVxuICAgIHZhciBuZXh0ID0gcy5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICByZXR1cm4gbmV4dCA+PSAweERDMDAgJiYgbmV4dCA8PSAweERGRkYgPyAoYyA8PCAxMCkgKyBuZXh0IC0gMHgzNUZEQzAwIDogY1xuICB9O1xuXG4gIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUubmV4dEluZGV4ID0gZnVuY3Rpb24gbmV4dEluZGV4IChpLCBmb3JjZVUpIHtcbiAgICAgIGlmICggZm9yY2VVID09PSB2b2lkIDAgKSBmb3JjZVUgPSBmYWxzZTtcblxuICAgIHZhciBzID0gdGhpcy5zb3VyY2U7XG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgICBpZiAoaSA+PSBsKSB7XG4gICAgICByZXR1cm4gbFxuICAgIH1cbiAgICB2YXIgYyA9IHMuY2hhckNvZGVBdChpKSwgbmV4dDtcbiAgICBpZiAoIShmb3JjZVUgfHwgdGhpcy5zd2l0Y2hVKSB8fCBjIDw9IDB4RDdGRiB8fCBjID49IDB4RTAwMCB8fCBpICsgMSA+PSBsIHx8XG4gICAgICAgIChuZXh0ID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweERDMDAgfHwgbmV4dCA+IDB4REZGRikge1xuICAgICAgcmV0dXJuIGkgKyAxXG4gICAgfVxuICAgIHJldHVybiBpICsgMlxuICB9O1xuXG4gIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuY3VycmVudCA9IGZ1bmN0aW9uIGN1cnJlbnQgKGZvcmNlVSkge1xuICAgICAgaWYgKCBmb3JjZVUgPT09IHZvaWQgMCApIGZvcmNlVSA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIHRoaXMuYXQodGhpcy5wb3MsIGZvcmNlVSlcbiAgfTtcblxuICBSZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmxvb2thaGVhZCA9IGZ1bmN0aW9uIGxvb2thaGVhZCAoZm9yY2VVKSB7XG4gICAgICBpZiAoIGZvcmNlVSA9PT0gdm9pZCAwICkgZm9yY2VVID0gZmFsc2U7XG5cbiAgICByZXR1cm4gdGhpcy5hdCh0aGlzLm5leHRJbmRleCh0aGlzLnBvcywgZm9yY2VVKSwgZm9yY2VVKVxuICB9O1xuXG4gIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuYWR2YW5jZSA9IGZ1bmN0aW9uIGFkdmFuY2UgKGZvcmNlVSkge1xuICAgICAgaWYgKCBmb3JjZVUgPT09IHZvaWQgMCApIGZvcmNlVSA9IGZhbHNlO1xuXG4gICAgdGhpcy5wb3MgPSB0aGlzLm5leHRJbmRleCh0aGlzLnBvcywgZm9yY2VVKTtcbiAgfTtcblxuICBSZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmVhdCA9IGZ1bmN0aW9uIGVhdCAoY2gsIGZvcmNlVSkge1xuICAgICAgaWYgKCBmb3JjZVUgPT09IHZvaWQgMCApIGZvcmNlVSA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMuY3VycmVudChmb3JjZVUpID09PSBjaCkge1xuICAgICAgdGhpcy5hZHZhbmNlKGZvcmNlVSk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBSZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmVhdENoYXJzID0gZnVuY3Rpb24gZWF0Q2hhcnMgKGNocywgZm9yY2VVKSB7XG4gICAgICBpZiAoIGZvcmNlVSA9PT0gdm9pZCAwICkgZm9yY2VVID0gZmFsc2U7XG5cbiAgICB2YXIgcG9zID0gdGhpcy5wb3M7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBjaHM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB2YXIgY2ggPSBsaXN0W2ldO1xuXG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5hdChwb3MsIGZvcmNlVSk7XG4gICAgICBpZiAoY3VycmVudCA9PT0gLTEgfHwgY3VycmVudCAhPT0gY2gpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBwb3MgPSB0aGlzLm5leHRJbmRleChwb3MsIGZvcmNlVSk7XG4gICAgfVxuICAgIHRoaXMucG9zID0gcG9zO1xuICAgIHJldHVybiB0cnVlXG4gIH07XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIHRoZSBmbGFncyBwYXJ0IG9mIGEgZ2l2ZW4gUmVnRXhwTGl0ZXJhbC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWdFeHBWYWxpZGF0aW9uU3RhdGV9IHN0YXRlIFRoZSBzdGF0ZSB0byB2YWxpZGF0ZSBSZWdFeHAuXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgcHAkMS52YWxpZGF0ZVJlZ0V4cEZsYWdzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgdmFsaWRGbGFncyA9IHN0YXRlLnZhbGlkRmxhZ3M7XG4gICAgdmFyIGZsYWdzID0gc3RhdGUuZmxhZ3M7XG5cbiAgICB2YXIgdSA9IGZhbHNlO1xuICAgIHZhciB2ID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZsYWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZmxhZyA9IGZsYWdzLmNoYXJBdChpKTtcbiAgICAgIGlmICh2YWxpZEZsYWdzLmluZGV4T2YoZmxhZykgPT09IC0xKSB7XG4gICAgICAgIHRoaXMucmFpc2Uoc3RhdGUuc3RhcnQsIFwiSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24gZmxhZ1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChmbGFncy5pbmRleE9mKGZsYWcsIGkgKyAxKSA+IC0xKSB7XG4gICAgICAgIHRoaXMucmFpc2Uoc3RhdGUuc3RhcnQsIFwiRHVwbGljYXRlIHJlZ3VsYXIgZXhwcmVzc2lvbiBmbGFnXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGZsYWcgPT09IFwidVwiKSB7IHUgPSB0cnVlOyB9XG4gICAgICBpZiAoZmxhZyA9PT0gXCJ2XCIpIHsgdiA9IHRydWU7IH1cbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxNSAmJiB1ICYmIHYpIHtcbiAgICAgIHRoaXMucmFpc2Uoc3RhdGUuc3RhcnQsIFwiSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24gZmxhZ1wiKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gaGFzUHJvcChvYmopIHtcbiAgICBmb3IgKHZhciBfIGluIG9iaikgeyByZXR1cm4gdHJ1ZSB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgdGhlIHBhdHRlcm4gcGFydCBvZiBhIGdpdmVuIFJlZ0V4cExpdGVyYWwuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVnRXhwVmFsaWRhdGlvblN0YXRlfSBzdGF0ZSBUaGUgc3RhdGUgdG8gdmFsaWRhdGUgUmVnRXhwLlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHBwJDEudmFsaWRhdGVSZWdFeHBQYXR0ZXJuID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB0aGlzLnJlZ2V4cF9wYXR0ZXJuKHN0YXRlKTtcblxuICAgIC8vIFRoZSBnb2FsIHN5bWJvbCBmb3IgdGhlIHBhcnNlIGlzIHxQYXR0ZXJuW35VLCB+Tl18LiBJZiB0aGUgcmVzdWx0IG9mXG4gICAgLy8gcGFyc2luZyBjb250YWlucyBhIHxHcm91cE5hbWV8LCByZXBhcnNlIHdpdGggdGhlIGdvYWwgc3ltYm9sXG4gICAgLy8gfFBhdHRlcm5bflUsICtOXXwgYW5kIHVzZSB0aGlzIHJlc3VsdCBpbnN0ZWFkLiBUaHJvdyBhICpTeW50YXhFcnJvcipcbiAgICAvLyBleGNlcHRpb24gaWYgX1BfIGRpZCBub3QgY29uZm9ybSB0byB0aGUgZ3JhbW1hciwgaWYgYW55IGVsZW1lbnRzIG9mIF9QX1xuICAgIC8vIHdlcmUgbm90IG1hdGNoZWQgYnkgdGhlIHBhcnNlLCBvciBpZiBhbnkgRWFybHkgRXJyb3IgY29uZGl0aW9ucyBleGlzdC5cbiAgICBpZiAoIXN0YXRlLnN3aXRjaE4gJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgaGFzUHJvcChzdGF0ZS5ncm91cE5hbWVzKSkge1xuICAgICAgc3RhdGUuc3dpdGNoTiA9IHRydWU7XG4gICAgICB0aGlzLnJlZ2V4cF9wYXR0ZXJuKHN0YXRlKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUGF0dGVyblxuICBwcCQxLnJlZ2V4cF9wYXR0ZXJuID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBzdGF0ZS5wb3MgPSAwO1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgICBzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgPSBmYWxzZTtcbiAgICBzdGF0ZS5udW1DYXB0dXJpbmdQYXJlbnMgPSAwO1xuICAgIHN0YXRlLm1heEJhY2tSZWZlcmVuY2UgPSAwO1xuICAgIHN0YXRlLmdyb3VwTmFtZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHN0YXRlLmJhY2tSZWZlcmVuY2VOYW1lcy5sZW5ndGggPSAwO1xuICAgIHN0YXRlLmJyYW5jaElEID0gbnVsbDtcblxuICAgIHRoaXMucmVnZXhwX2Rpc2p1bmN0aW9uKHN0YXRlKTtcblxuICAgIGlmIChzdGF0ZS5wb3MgIT09IHN0YXRlLnNvdXJjZS5sZW5ndGgpIHtcbiAgICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZXMgYXMgVjguXG4gICAgICBpZiAoc3RhdGUuZWF0KDB4MjkgLyogKSAqLykpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJVbm1hdGNoZWQgJyknXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmVhdCgweDVEIC8qIF0gKi8pIHx8IHN0YXRlLmVhdCgweDdEIC8qIH0gKi8pKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiTG9uZSBxdWFudGlmaWVyIGJyYWNrZXRzXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhdGUubWF4QmFja1JlZmVyZW5jZSA+IHN0YXRlLm51bUNhcHR1cmluZ1BhcmVucykge1xuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGVzY2FwZVwiKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBzdGF0ZS5iYWNrUmVmZXJlbmNlTmFtZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB2YXIgbmFtZSA9IGxpc3RbaV07XG5cbiAgICAgIGlmICghc3RhdGUuZ3JvdXBOYW1lc1tuYW1lXSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgbmFtZWQgY2FwdHVyZSByZWZlcmVuY2VkXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1EaXNqdW5jdGlvblxuICBwcCQxLnJlZ2V4cF9kaXNqdW5jdGlvbiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHRyYWNrRGlzanVuY3Rpb24gPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTY7XG4gICAgaWYgKHRyYWNrRGlzanVuY3Rpb24pIHsgc3RhdGUuYnJhbmNoSUQgPSBuZXcgQnJhbmNoSUQoc3RhdGUuYnJhbmNoSUQsIG51bGwpOyB9XG4gICAgdGhpcy5yZWdleHBfYWx0ZXJuYXRpdmUoc3RhdGUpO1xuICAgIHdoaWxlIChzdGF0ZS5lYXQoMHg3QyAvKiB8ICovKSkge1xuICAgICAgaWYgKHRyYWNrRGlzanVuY3Rpb24pIHsgc3RhdGUuYnJhbmNoSUQgPSBzdGF0ZS5icmFuY2hJRC5zaWJsaW5nKCk7IH1cbiAgICAgIHRoaXMucmVnZXhwX2FsdGVybmF0aXZlKHN0YXRlKTtcbiAgICB9XG4gICAgaWYgKHRyYWNrRGlzanVuY3Rpb24pIHsgc3RhdGUuYnJhbmNoSUQgPSBzdGF0ZS5icmFuY2hJRC5wYXJlbnQ7IH1cblxuICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZSBhcyBWOC5cbiAgICBpZiAodGhpcy5yZWdleHBfZWF0UXVhbnRpZmllcihzdGF0ZSwgdHJ1ZSkpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiTm90aGluZyB0byByZXBlYXRcIik7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5lYXQoMHg3QiAvKiB7ICovKSkge1xuICAgICAgc3RhdGUucmFpc2UoXCJMb25lIHF1YW50aWZpZXIgYnJhY2tldHNcIik7XG4gICAgfVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUFsdGVybmF0aXZlXG4gIHBwJDEucmVnZXhwX2FsdGVybmF0aXZlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB3aGlsZSAoc3RhdGUucG9zIDwgc3RhdGUuc291cmNlLmxlbmd0aCAmJiB0aGlzLnJlZ2V4cF9lYXRUZXJtKHN0YXRlKSkge31cbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItVGVybVxuICBwcCQxLnJlZ2V4cF9lYXRUZXJtID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0QXNzZXJ0aW9uKHN0YXRlKSkge1xuICAgICAgLy8gSGFuZGxlIGBRdWFudGlmaWFibGVBc3NlcnRpb24gUXVhbnRpZmllcmAgYWx0ZXJuYXRpdmUuXG4gICAgICAvLyBgc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlYCBpcyB0cnVlIGlmIHRoZSBsYXN0IGVhdGVuIEFzc2VydGlvblxuICAgICAgLy8gaXMgYSBRdWFudGlmaWFibGVBc3NlcnRpb24uXG4gICAgICBpZiAoc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlICYmIHRoaXMucmVnZXhwX2VhdFF1YW50aWZpZXIoc3RhdGUpKSB7XG4gICAgICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZSBhcyBWOC5cbiAgICAgICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgcXVhbnRpZmllclwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuc3dpdGNoVSA/IHRoaXMucmVnZXhwX2VhdEF0b20oc3RhdGUpIDogdGhpcy5yZWdleHBfZWF0RXh0ZW5kZWRBdG9tKHN0YXRlKSkge1xuICAgICAgdGhpcy5yZWdleHBfZWF0UXVhbnRpZmllcihzdGF0ZSk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1Bc3NlcnRpb25cbiAgcHAkMS5yZWdleHBfZWF0QXNzZXJ0aW9uID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlID0gZmFsc2U7XG5cbiAgICAvLyBeLCAkXG4gICAgaWYgKHN0YXRlLmVhdCgweDVFIC8qIF4gKi8pIHx8IHN0YXRlLmVhdCgweDI0IC8qICQgKi8pKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIFxcYiBcXEJcbiAgICBpZiAoc3RhdGUuZWF0KDB4NUMgLyogXFwgKi8pKSB7XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4NDIgLyogQiAqLykgfHwgc3RhdGUuZWF0KDB4NjIgLyogYiAqLykpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cblxuICAgIC8vIExvb2thaGVhZCAvIExvb2tiZWhpbmRcbiAgICBpZiAoc3RhdGUuZWF0KDB4MjggLyogKCAqLykgJiYgc3RhdGUuZWF0KDB4M0YgLyogPyAqLykpIHtcbiAgICAgIHZhciBsb29rYmVoaW5kID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgICAgbG9va2JlaGluZCA9IHN0YXRlLmVhdCgweDNDIC8qIDwgKi8pO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmVhdCgweDNEIC8qID0gKi8pIHx8IHN0YXRlLmVhdCgweDIxIC8qICEgKi8pKSB7XG4gICAgICAgIHRoaXMucmVnZXhwX2Rpc2p1bmN0aW9uKHN0YXRlKTtcbiAgICAgICAgaWYgKCFzdGF0ZS5lYXQoMHgyOSAvKiApICovKSkge1xuICAgICAgICAgIHN0YXRlLnJhaXNlKFwiVW50ZXJtaW5hdGVkIGdyb3VwXCIpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSA9ICFsb29rYmVoaW5kO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVF1YW50aWZpZXJcbiAgcHAkMS5yZWdleHBfZWF0UXVhbnRpZmllciA9IGZ1bmN0aW9uKHN0YXRlLCBub0Vycm9yKSB7XG4gICAgaWYgKCBub0Vycm9yID09PSB2b2lkIDAgKSBub0Vycm9yID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5yZWdleHBfZWF0UXVhbnRpZmllclByZWZpeChzdGF0ZSwgbm9FcnJvcikpIHtcbiAgICAgIHN0YXRlLmVhdCgweDNGIC8qID8gKi8pO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUXVhbnRpZmllclByZWZpeFxuICBwcCQxLnJlZ2V4cF9lYXRRdWFudGlmaWVyUHJlZml4ID0gZnVuY3Rpb24oc3RhdGUsIG5vRXJyb3IpIHtcbiAgICByZXR1cm4gKFxuICAgICAgc3RhdGUuZWF0KDB4MkEgLyogKiAqLykgfHxcbiAgICAgIHN0YXRlLmVhdCgweDJCIC8qICsgKi8pIHx8XG4gICAgICBzdGF0ZS5lYXQoMHgzRiAvKiA/ICovKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0QnJhY2VkUXVhbnRpZmllcihzdGF0ZSwgbm9FcnJvcilcbiAgICApXG4gIH07XG4gIHBwJDEucmVnZXhwX2VhdEJyYWNlZFF1YW50aWZpZXIgPSBmdW5jdGlvbihzdGF0ZSwgbm9FcnJvcikge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICBpZiAoc3RhdGUuZWF0KDB4N0IgLyogeyAqLykpIHtcbiAgICAgIHZhciBtaW4gPSAwLCBtYXggPSAtMTtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXREZWNpbWFsRGlnaXRzKHN0YXRlKSkge1xuICAgICAgICBtaW4gPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICAgIGlmIChzdGF0ZS5lYXQoMHgyQyAvKiAsICovKSAmJiB0aGlzLnJlZ2V4cF9lYXREZWNpbWFsRGlnaXRzKHN0YXRlKSkge1xuICAgICAgICAgIG1heCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZWF0KDB4N0QgLyogfSAqLykpIHtcbiAgICAgICAgICAvLyBTeW50YXhFcnJvciBpbiBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jc2VjLXRlcm1cbiAgICAgICAgICBpZiAobWF4ICE9PSAtMSAmJiBtYXggPCBtaW4gJiYgIW5vRXJyb3IpIHtcbiAgICAgICAgICAgIHN0YXRlLnJhaXNlKFwibnVtYmVycyBvdXQgb2Ygb3JkZXIgaW4ge30gcXVhbnRpZmllclwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLnN3aXRjaFUgJiYgIW5vRXJyb3IpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbmNvbXBsZXRlIHF1YW50aWZpZXJcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQXRvbVxuICBwcCQxLnJlZ2V4cF9lYXRBdG9tID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5yZWdleHBfZWF0UGF0dGVybkNoYXJhY3RlcnMoc3RhdGUpIHx8XG4gICAgICBzdGF0ZS5lYXQoMHgyRSAvKiAuICovKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0UmV2ZXJzZVNvbGlkdXNBdG9tRXNjYXBlKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3Moc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q2FwdHVyaW5nR3JvdXAoc3RhdGUpXG4gICAgKVxuICB9O1xuICBwcCQxLnJlZ2V4cF9lYXRSZXZlcnNlU29saWR1c0F0b21Fc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICBpZiAoc3RhdGUuZWF0KDB4NUMgLyogXFwgKi8pKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0QXRvbUVzY2FwZShzdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgcHAkMS5yZWdleHBfZWF0VW5jYXB0dXJpbmdHcm91cCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIGlmIChzdGF0ZS5lYXQoMHgyOCAvKiAoICovKSkge1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDNGIC8qID8gKi8pKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTYpIHtcbiAgICAgICAgICB2YXIgYWRkTW9kaWZpZXJzID0gdGhpcy5yZWdleHBfZWF0TW9kaWZpZXJzKHN0YXRlKTtcbiAgICAgICAgICB2YXIgaGFzSHlwaGVuID0gc3RhdGUuZWF0KDB4MkQgLyogLSAqLyk7XG4gICAgICAgICAgaWYgKGFkZE1vZGlmaWVycyB8fCBoYXNIeXBoZW4pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWRkTW9kaWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBtb2RpZmllciA9IGFkZE1vZGlmaWVycy5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgIGlmIChhZGRNb2RpZmllcnMuaW5kZXhPZihtb2RpZmllciwgaSArIDEpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5yYWlzZShcIkR1cGxpY2F0ZSByZWd1bGFyIGV4cHJlc3Npb24gbW9kaWZpZXJzXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzSHlwaGVuKSB7XG4gICAgICAgICAgICAgIHZhciByZW1vdmVNb2RpZmllcnMgPSB0aGlzLnJlZ2V4cF9lYXRNb2RpZmllcnMoc3RhdGUpO1xuICAgICAgICAgICAgICBpZiAoIWFkZE1vZGlmaWVycyAmJiAhcmVtb3ZlTW9kaWZpZXJzICYmIHN0YXRlLmN1cnJlbnQoKSA9PT0gMHgzQSAvKiA6ICovKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbiBtb2RpZmllcnNcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcmVtb3ZlTW9kaWZpZXJzLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbW9kaWZpZXIkMSA9IHJlbW92ZU1vZGlmaWVycy5jaGFyQXQoaSQxKTtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICByZW1vdmVNb2RpZmllcnMuaW5kZXhPZihtb2RpZmllciQxLCBpJDEgKyAxKSA+IC0xIHx8XG4gICAgICAgICAgICAgICAgICBhZGRNb2RpZmllcnMuaW5kZXhPZihtb2RpZmllciQxKSA+IC0xXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5yYWlzZShcIkR1cGxpY2F0ZSByZWd1bGFyIGV4cHJlc3Npb24gbW9kaWZpZXJzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZWF0KDB4M0EgLyogOiAqLykpIHtcbiAgICAgICAgICB0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihzdGF0ZSk7XG4gICAgICAgICAgaWYgKHN0YXRlLmVhdCgweDI5IC8qICkgKi8pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBzdGF0ZS5yYWlzZShcIlVudGVybWluYXRlZCBncm91cFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBwcCQxLnJlZ2V4cF9lYXRDYXB0dXJpbmdHcm91cCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmVhdCgweDI4IC8qICggKi8pKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgICAgdGhpcy5yZWdleHBfZ3JvdXBTcGVjaWZpZXIoc3RhdGUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5jdXJyZW50KCkgPT09IDB4M0YgLyogPyAqLykge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZ3JvdXBcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihzdGF0ZSk7XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4MjkgLyogKSAqLykpIHtcbiAgICAgICAgc3RhdGUubnVtQ2FwdHVyaW5nUGFyZW5zICs9IDE7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIlVudGVybWluYXRlZCBncm91cFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIC8vIFJlZ3VsYXJFeHByZXNzaW9uTW9kaWZpZXJzIDo6XG4gIC8vICAgW2VtcHR5XVxuICAvLyAgIFJlZ3VsYXJFeHByZXNzaW9uTW9kaWZpZXJzIFJlZ3VsYXJFeHByZXNzaW9uTW9kaWZpZXJcbiAgcHAkMS5yZWdleHBfZWF0TW9kaWZpZXJzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgbW9kaWZpZXJzID0gXCJcIjtcbiAgICB2YXIgY2ggPSAwO1xuICAgIHdoaWxlICgoY2ggPSBzdGF0ZS5jdXJyZW50KCkpICE9PSAtMSAmJiBpc1JlZ3VsYXJFeHByZXNzaW9uTW9kaWZpZXIoY2gpKSB7XG4gICAgICBtb2RpZmllcnMgKz0gY29kZVBvaW50VG9TdHJpbmcoY2gpO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIH1cbiAgICByZXR1cm4gbW9kaWZpZXJzXG4gIH07XG4gIC8vIFJlZ3VsYXJFeHByZXNzaW9uTW9kaWZpZXIgOjogb25lIG9mXG4gIC8vICAgYGlgIGBtYCBgc2BcbiAgZnVuY3Rpb24gaXNSZWd1bGFyRXhwcmVzc2lvbk1vZGlmaWVyKGNoKSB7XG4gICAgcmV0dXJuIGNoID09PSAweDY5IC8qIGkgKi8gfHwgY2ggPT09IDB4NmQgLyogbSAqLyB8fCBjaCA9PT0gMHg3MyAvKiBzICovXG4gIH1cblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItRXh0ZW5kZWRBdG9tXG4gIHBwJDEucmVnZXhwX2VhdEV4dGVuZGVkQXRvbSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHN0YXRlLmVhdCgweDJFIC8qIC4gKi8pIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRSZXZlcnNlU29saWR1c0F0b21Fc2NhcGUoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzcyhzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdFVuY2FwdHVyaW5nR3JvdXAoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDYXB0dXJpbmdHcm91cChzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdEludmFsaWRCcmFjZWRRdWFudGlmaWVyKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0RXh0ZW5kZWRQYXR0ZXJuQ2hhcmFjdGVyKHN0YXRlKVxuICAgIClcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItSW52YWxpZEJyYWNlZFF1YW50aWZpZXJcbiAgcHAkMS5yZWdleHBfZWF0SW52YWxpZEJyYWNlZFF1YW50aWZpZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRCcmFjZWRRdWFudGlmaWVyKHN0YXRlLCB0cnVlKSkge1xuICAgICAgc3RhdGUucmFpc2UoXCJOb3RoaW5nIHRvIHJlcGVhdFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtU3ludGF4Q2hhcmFjdGVyXG4gIHBwJDEucmVnZXhwX2VhdFN5bnRheENoYXJhY3RlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChpc1N5bnRheENoYXJhY3RlcihjaCkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIGZ1bmN0aW9uIGlzU3ludGF4Q2hhcmFjdGVyKGNoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGNoID09PSAweDI0IC8qICQgKi8gfHxcbiAgICAgIGNoID49IDB4MjggLyogKCAqLyAmJiBjaCA8PSAweDJCIC8qICsgKi8gfHxcbiAgICAgIGNoID09PSAweDJFIC8qIC4gKi8gfHxcbiAgICAgIGNoID09PSAweDNGIC8qID8gKi8gfHxcbiAgICAgIGNoID49IDB4NUIgLyogWyAqLyAmJiBjaCA8PSAweDVFIC8qIF4gKi8gfHxcbiAgICAgIGNoID49IDB4N0IgLyogeyAqLyAmJiBjaCA8PSAweDdEIC8qIH0gKi9cbiAgICApXG4gIH1cblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1QYXR0ZXJuQ2hhcmFjdGVyXG4gIC8vIEJ1dCBlYXQgZWFnZXIuXG4gIHBwJDEucmVnZXhwX2VhdFBhdHRlcm5DaGFyYWN0ZXJzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgdmFyIGNoID0gMDtcbiAgICB3aGlsZSAoKGNoID0gc3RhdGUuY3VycmVudCgpKSAhPT0gLTEgJiYgIWlzU3ludGF4Q2hhcmFjdGVyKGNoKSkge1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUucG9zICE9PSBzdGFydFxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1FeHRlbmRlZFBhdHRlcm5DaGFyYWN0ZXJcbiAgcHAkMS5yZWdleHBfZWF0RXh0ZW5kZWRQYXR0ZXJuQ2hhcmFjdGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKFxuICAgICAgY2ggIT09IC0xICYmXG4gICAgICBjaCAhPT0gMHgyNCAvKiAkICovICYmXG4gICAgICAhKGNoID49IDB4MjggLyogKCAqLyAmJiBjaCA8PSAweDJCIC8qICsgKi8pICYmXG4gICAgICBjaCAhPT0gMHgyRSAvKiAuICovICYmXG4gICAgICBjaCAhPT0gMHgzRiAvKiA/ICovICYmXG4gICAgICBjaCAhPT0gMHg1QiAvKiBbICovICYmXG4gICAgICBjaCAhPT0gMHg1RSAvKiBeICovICYmXG4gICAgICBjaCAhPT0gMHg3QyAvKiB8ICovXG4gICAgKSB7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBHcm91cFNwZWNpZmllciA6OlxuICAvLyAgIFtlbXB0eV1cbiAgLy8gICBgP2AgR3JvdXBOYW1lXG4gIHBwJDEucmVnZXhwX2dyb3VwU3BlY2lmaWVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuZWF0KDB4M0YgLyogPyAqLykpIHtcbiAgICAgIGlmICghdGhpcy5yZWdleHBfZWF0R3JvdXBOYW1lKHN0YXRlKSkgeyBzdGF0ZS5yYWlzZShcIkludmFsaWQgZ3JvdXBcIik7IH1cbiAgICAgIHZhciB0cmFja0Rpc2p1bmN0aW9uID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDE2O1xuICAgICAgdmFyIGtub3duID0gc3RhdGUuZ3JvdXBOYW1lc1tzdGF0ZS5sYXN0U3RyaW5nVmFsdWVdO1xuICAgICAgaWYgKGtub3duKSB7XG4gICAgICAgIGlmICh0cmFja0Rpc2p1bmN0aW9uKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBrbm93bjsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBhbHRJRCA9IGxpc3RbaV07XG5cbiAgICAgICAgICAgIGlmICghYWx0SUQuc2VwYXJhdGVkRnJvbShzdGF0ZS5icmFuY2hJRCkpXG4gICAgICAgICAgICAgIHsgc3RhdGUucmFpc2UoXCJEdXBsaWNhdGUgY2FwdHVyZSBncm91cCBuYW1lXCIpOyB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLnJhaXNlKFwiRHVwbGljYXRlIGNhcHR1cmUgZ3JvdXAgbmFtZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRyYWNrRGlzanVuY3Rpb24pIHtcbiAgICAgICAgKGtub3duIHx8IChzdGF0ZS5ncm91cE5hbWVzW3N0YXRlLmxhc3RTdHJpbmdWYWx1ZV0gPSBbXSkpLnB1c2goc3RhdGUuYnJhbmNoSUQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUuZ3JvdXBOYW1lc1tzdGF0ZS5sYXN0U3RyaW5nVmFsdWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gR3JvdXBOYW1lIDo6XG4gIC8vICAgYDxgIFJlZ0V4cElkZW50aWZpZXJOYW1lIGA+YFxuICAvLyBOb3RlOiB0aGlzIHVwZGF0ZXMgYHN0YXRlLmxhc3RTdHJpbmdWYWx1ZWAgcHJvcGVydHkgd2l0aCB0aGUgZWF0ZW4gbmFtZS5cbiAgcHAkMS5yZWdleHBfZWF0R3JvdXBOYW1lID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICAgIGlmIChzdGF0ZS5lYXQoMHgzQyAvKiA8ICovKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJOYW1lKHN0YXRlKSAmJiBzdGF0ZS5lYXQoMHgzRSAvKiA+ICovKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGNhcHR1cmUgZ3JvdXAgbmFtZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gUmVnRXhwSWRlbnRpZmllck5hbWUgOjpcbiAgLy8gICBSZWdFeHBJZGVudGlmaWVyU3RhcnRcbiAgLy8gICBSZWdFeHBJZGVudGlmaWVyTmFtZSBSZWdFeHBJZGVudGlmaWVyUGFydFxuICAvLyBOb3RlOiB0aGlzIHVwZGF0ZXMgYHN0YXRlLmxhc3RTdHJpbmdWYWx1ZWAgcHJvcGVydHkgd2l0aCB0aGUgZWF0ZW4gbmFtZS5cbiAgcHAkMS5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllck5hbWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJTdGFydChzdGF0ZSkpIHtcbiAgICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyhzdGF0ZS5sYXN0SW50VmFsdWUpO1xuICAgICAgd2hpbGUgKHRoaXMucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJQYXJ0KHN0YXRlKSkge1xuICAgICAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgKz0gY29kZVBvaW50VG9TdHJpbmcoc3RhdGUubGFzdEludFZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIFJlZ0V4cElkZW50aWZpZXJTdGFydCA6OlxuICAvLyAgIFVuaWNvZGVJRFN0YXJ0XG4gIC8vICAgYCRgXG4gIC8vICAgYF9gXG4gIC8vICAgYFxcYCBSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2VbK1VdXG4gIHBwJDEucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJTdGFydCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHZhciBmb3JjZVUgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTE7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudChmb3JjZVUpO1xuICAgIHN0YXRlLmFkdmFuY2UoZm9yY2VVKTtcblxuICAgIGlmIChjaCA9PT0gMHg1QyAvKiBcXCAqLyAmJiB0aGlzLnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2Uoc3RhdGUsIGZvcmNlVSkpIHtcbiAgICAgIGNoID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHBJZGVudGlmaWVyU3RhcnQoY2gpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIGZ1bmN0aW9uIGlzUmVnRXhwSWRlbnRpZmllclN0YXJ0KGNoKSB7XG4gICAgcmV0dXJuIGlzSWRlbnRpZmllclN0YXJ0KGNoLCB0cnVlKSB8fCBjaCA9PT0gMHgyNCAvKiAkICovIHx8IGNoID09PSAweDVGIC8qIF8gKi9cbiAgfVxuXG4gIC8vIFJlZ0V4cElkZW50aWZpZXJQYXJ0IDo6XG4gIC8vICAgVW5pY29kZUlEQ29udGludWVcbiAgLy8gICBgJGBcbiAgLy8gICBgX2BcbiAgLy8gICBgXFxgIFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZVsrVV1cbiAgLy8gICA8WldOSj5cbiAgLy8gICA8WldKPlxuICBwcCQxLnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyUGFydCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHZhciBmb3JjZVUgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTE7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudChmb3JjZVUpO1xuICAgIHN0YXRlLmFkdmFuY2UoZm9yY2VVKTtcblxuICAgIGlmIChjaCA9PT0gMHg1QyAvKiBcXCAqLyAmJiB0aGlzLnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2Uoc3RhdGUsIGZvcmNlVSkpIHtcbiAgICAgIGNoID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHBJZGVudGlmaWVyUGFydChjaCkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgZnVuY3Rpb24gaXNSZWdFeHBJZGVudGlmaWVyUGFydChjaCkge1xuICAgIHJldHVybiBpc0lkZW50aWZpZXJDaGFyKGNoLCB0cnVlKSB8fCBjaCA9PT0gMHgyNCAvKiAkICovIHx8IGNoID09PSAweDVGIC8qIF8gKi8gfHwgY2ggPT09IDB4MjAwQyAvKiA8WldOSj4gKi8gfHwgY2ggPT09IDB4MjAwRCAvKiA8WldKPiAqL1xuICB9XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUF0b21Fc2NhcGVcbiAgcHAkMS5yZWdleHBfZWF0QXRvbUVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5yZWdleHBfZWF0QmFja1JlZmVyZW5jZShzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyRXNjYXBlKHN0YXRlKSB8fFxuICAgICAgKHN0YXRlLnN3aXRjaE4gJiYgdGhpcy5yZWdleHBfZWF0S0dyb3VwTmFtZShzdGF0ZSkpXG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgLy8gTWFrZSB0aGUgc2FtZSBtZXNzYWdlIGFzIFY4LlxuICAgICAgaWYgKHN0YXRlLmN1cnJlbnQoKSA9PT0gMHg2MyAvKiBjICovKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCB1bmljb2RlIGVzY2FwZVwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBwcCQxLnJlZ2V4cF9lYXRCYWNrUmVmZXJlbmNlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdERlY2ltYWxFc2NhcGUoc3RhdGUpKSB7XG4gICAgICB2YXIgbiA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICAgIC8vIEZvciBTeW50YXhFcnJvciBpbiBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jc2VjLWF0b21lc2NhcGVcbiAgICAgICAgaWYgKG4gPiBzdGF0ZS5tYXhCYWNrUmVmZXJlbmNlKSB7XG4gICAgICAgICAgc3RhdGUubWF4QmFja1JlZmVyZW5jZSA9IG47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIGlmIChuIDw9IHN0YXRlLm51bUNhcHR1cmluZ1BhcmVucykge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBwcCQxLnJlZ2V4cF9lYXRLR3JvdXBOYW1lID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuZWF0KDB4NkIgLyogayAqLykpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRHcm91cE5hbWUoc3RhdGUpKSB7XG4gICAgICAgIHN0YXRlLmJhY2tSZWZlcmVuY2VOYW1lcy5wdXNoKHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgbmFtZWQgcmVmZXJlbmNlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItQ2hhcmFjdGVyRXNjYXBlXG4gIHBwJDEucmVnZXhwX2VhdENoYXJhY3RlckVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMucmVnZXhwX2VhdENvbnRyb2xFc2NhcGUoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDQ29udHJvbExldHRlcihzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdFplcm8oc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRIZXhFc2NhcGVTZXF1ZW5jZShzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZShzdGF0ZSwgZmFsc2UpIHx8XG4gICAgICAoIXN0YXRlLnN3aXRjaFUgJiYgdGhpcy5yZWdleHBfZWF0TGVnYWN5T2N0YWxFc2NhcGVTZXF1ZW5jZShzdGF0ZSkpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRJZGVudGl0eUVzY2FwZShzdGF0ZSlcbiAgICApXG4gIH07XG4gIHBwJDEucmVnZXhwX2VhdENDb250cm9sTGV0dGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgaWYgKHN0YXRlLmVhdCgweDYzIC8qIGMgKi8pKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0Q29udHJvbExldHRlcihzdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgcHAkMS5yZWdleHBfZWF0WmVybyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmN1cnJlbnQoKSA9PT0gMHgzMCAvKiAwICovICYmICFpc0RlY2ltYWxEaWdpdChzdGF0ZS5sb29rYWhlYWQoKSkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1Db250cm9sRXNjYXBlXG4gIHBwJDEucmVnZXhwX2VhdENvbnRyb2xFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoY2ggPT09IDB4NzQgLyogdCAqLykge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwOTsgLyogXFx0ICovXG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoY2ggPT09IDB4NkUgLyogbiAqLykge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwQTsgLyogXFxuICovXG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoY2ggPT09IDB4NzYgLyogdiAqLykge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwQjsgLyogXFx2ICovXG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoY2ggPT09IDB4NjYgLyogZiAqLykge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwQzsgLyogXFxmICovXG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoY2ggPT09IDB4NzIgLyogciAqLykge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwRDsgLyogXFxyICovXG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1Db250cm9sTGV0dGVyXG4gIHBwJDEucmVnZXhwX2VhdENvbnRyb2xMZXR0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoaXNDb250cm9sTGV0dGVyKGNoKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gY2ggJSAweDIwO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIGZ1bmN0aW9uIGlzQ29udHJvbExldHRlcihjaCkge1xuICAgIHJldHVybiAoXG4gICAgICAoY2ggPj0gMHg0MSAvKiBBICovICYmIGNoIDw9IDB4NUEgLyogWiAqLykgfHxcbiAgICAgIChjaCA+PSAweDYxIC8qIGEgKi8gJiYgY2ggPD0gMHg3QSAvKiB6ICovKVxuICAgIClcbiAgfVxuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZVxuICBwcCQxLnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2UgPSBmdW5jdGlvbihzdGF0ZSwgZm9yY2VVKSB7XG4gICAgaWYgKCBmb3JjZVUgPT09IHZvaWQgMCApIGZvcmNlVSA9IGZhbHNlO1xuXG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHZhciBzd2l0Y2hVID0gZm9yY2VVIHx8IHN0YXRlLnN3aXRjaFU7XG5cbiAgICBpZiAoc3RhdGUuZWF0KDB4NzUgLyogdSAqLykpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cyhzdGF0ZSwgNCkpIHtcbiAgICAgICAgdmFyIGxlYWQgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICAgIGlmIChzd2l0Y2hVICYmIGxlYWQgPj0gMHhEODAwICYmIGxlYWQgPD0gMHhEQkZGKSB7XG4gICAgICAgICAgdmFyIGxlYWRTdXJyb2dhdGVFbmQgPSBzdGF0ZS5wb3M7XG4gICAgICAgICAgaWYgKHN0YXRlLmVhdCgweDVDIC8qIFxcICovKSAmJiBzdGF0ZS5lYXQoMHg3NSAvKiB1ICovKSAmJiB0aGlzLnJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cyhzdGF0ZSwgNCkpIHtcbiAgICAgICAgICAgIHZhciB0cmFpbCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgICAgICAgIGlmICh0cmFpbCA+PSAweERDMDAgJiYgdHJhaWwgPD0gMHhERkZGKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IChsZWFkIC0gMHhEODAwKSAqIDB4NDAwICsgKHRyYWlsIC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXRlLnBvcyA9IGxlYWRTdXJyb2dhdGVFbmQ7XG4gICAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gbGVhZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICBzd2l0Y2hVICYmXG4gICAgICAgIHN0YXRlLmVhdCgweDdCIC8qIHsgKi8pICYmXG4gICAgICAgIHRoaXMucmVnZXhwX2VhdEhleERpZ2l0cyhzdGF0ZSkgJiZcbiAgICAgICAgc3RhdGUuZWF0KDB4N0QgLyogfSAqLykgJiZcbiAgICAgICAgaXNWYWxpZFVuaWNvZGUoc3RhdGUubGFzdEludFZhbHVlKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoc3dpdGNoVSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgdW5pY29kZSBlc2NhcGVcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgZnVuY3Rpb24gaXNWYWxpZFVuaWNvZGUoY2gpIHtcbiAgICByZXR1cm4gY2ggPj0gMCAmJiBjaCA8PSAweDEwRkZGRlxuICB9XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUlkZW50aXR5RXNjYXBlXG4gIHBwJDEucmVnZXhwX2VhdElkZW50aXR5RXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdFN5bnRheENoYXJhY3RlcihzdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5lYXQoMHgyRiAvKiAvICovKSkge1xuICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDJGOyAvKiAvICovXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKGNoICE9PSAweDYzIC8qIGMgKi8gJiYgKCFzdGF0ZS5zd2l0Y2hOIHx8IGNoICE9PSAweDZCIC8qIGsgKi8pKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtRGVjaW1hbEVzY2FwZVxuICBwcCQxLnJlZ2V4cF9lYXREZWNpbWFsRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoY2ggPj0gMHgzMSAvKiAxICovICYmIGNoIDw9IDB4MzkgLyogOSAqLykge1xuICAgICAgZG8ge1xuICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAxMCAqIHN0YXRlLmxhc3RJbnRWYWx1ZSArIChjaCAtIDB4MzAgLyogMCAqLyk7XG4gICAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIH0gd2hpbGUgKChjaCA9IHN0YXRlLmN1cnJlbnQoKSkgPj0gMHgzMCAvKiAwICovICYmIGNoIDw9IDB4MzkgLyogOSAqLylcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIFJldHVybiB2YWx1ZXMgdXNlZCBieSBjaGFyYWN0ZXIgc2V0IHBhcnNpbmcgbWV0aG9kcywgbmVlZGVkIHRvXG4gIC8vIGZvcmJpZCBuZWdhdGlvbiBvZiBzZXRzIHRoYXQgY2FuIG1hdGNoIHN0cmluZ3MuXG4gIHZhciBDaGFyU2V0Tm9uZSA9IDA7IC8vIE5vdGhpbmcgcGFyc2VkXG4gIHZhciBDaGFyU2V0T2sgPSAxOyAvLyBDb25zdHJ1Y3QgcGFyc2VkLCBjYW5ub3QgY29udGFpbiBzdHJpbmdzXG4gIHZhciBDaGFyU2V0U3RyaW5nID0gMjsgLy8gQ29uc3RydWN0IHBhcnNlZCwgY2FuIGNvbnRhaW4gc3RyaW5nc1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNoYXJhY3RlckNsYXNzRXNjYXBlXG4gIHBwJDEucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG5cbiAgICBpZiAoaXNDaGFyYWN0ZXJDbGFzc0VzY2FwZShjaCkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IC0xO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIENoYXJTZXRPa1xuICAgIH1cblxuICAgIHZhciBuZWdhdGUgPSBmYWxzZTtcbiAgICBpZiAoXG4gICAgICBzdGF0ZS5zd2l0Y2hVICYmXG4gICAgICB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJlxuICAgICAgKChuZWdhdGUgPSBjaCA9PT0gMHg1MCAvKiBQICovKSB8fCBjaCA9PT0gMHg3MCAvKiBwICovKVxuICAgICkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gLTE7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgaWYgKFxuICAgICAgICBzdGF0ZS5lYXQoMHg3QiAvKiB7ICovKSAmJlxuICAgICAgICAocmVzdWx0ID0gdGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWVFeHByZXNzaW9uKHN0YXRlKSkgJiZcbiAgICAgICAgc3RhdGUuZWF0KDB4N0QgLyogfSAqLylcbiAgICAgICkge1xuICAgICAgICBpZiAobmVnYXRlICYmIHJlc3VsdCA9PT0gQ2hhclNldFN0cmluZykgeyBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgbmFtZVwiKTsgfVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgbmFtZVwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gQ2hhclNldE5vbmVcbiAgfTtcblxuICBmdW5jdGlvbiBpc0NoYXJhY3RlckNsYXNzRXNjYXBlKGNoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGNoID09PSAweDY0IC8qIGQgKi8gfHxcbiAgICAgIGNoID09PSAweDQ0IC8qIEQgKi8gfHxcbiAgICAgIGNoID09PSAweDczIC8qIHMgKi8gfHxcbiAgICAgIGNoID09PSAweDUzIC8qIFMgKi8gfHxcbiAgICAgIGNoID09PSAweDc3IC8qIHcgKi8gfHxcbiAgICAgIGNoID09PSAweDU3IC8qIFcgKi9cbiAgICApXG4gIH1cblxuICAvLyBVbmljb2RlUHJvcGVydHlWYWx1ZUV4cHJlc3Npb24gOjpcbiAgLy8gICBVbmljb2RlUHJvcGVydHlOYW1lIGA9YCBVbmljb2RlUHJvcGVydHlWYWx1ZVxuICAvLyAgIExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZVxuICBwcCQxLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZUV4cHJlc3Npb24gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcblxuICAgIC8vIFVuaWNvZGVQcm9wZXJ0eU5hbWUgYD1gIFVuaWNvZGVQcm9wZXJ0eVZhbHVlXG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eU5hbWUoc3RhdGUpICYmIHN0YXRlLmVhdCgweDNEIC8qID0gKi8pKSB7XG4gICAgICB2YXIgbmFtZSA9IHN0YXRlLmxhc3RTdHJpbmdWYWx1ZTtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZShzdGF0ZSkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc3RhdGUubGFzdFN0cmluZ1ZhbHVlO1xuICAgICAgICB0aGlzLnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVBbmRWYWx1ZShzdGF0ZSwgbmFtZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gQ2hhclNldE9rXG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuXG4gICAgLy8gTG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlXG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZShzdGF0ZSkpIHtcbiAgICAgIHZhciBuYW1lT3JWYWx1ZSA9IHN0YXRlLmxhc3RTdHJpbmdWYWx1ZTtcbiAgICAgIHJldHVybiB0aGlzLnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlKHN0YXRlLCBuYW1lT3JWYWx1ZSlcbiAgICB9XG4gICAgcmV0dXJuIENoYXJTZXROb25lXG4gIH07XG5cbiAgcHAkMS5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lQW5kVmFsdWUgPSBmdW5jdGlvbihzdGF0ZSwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoIWhhc093bihzdGF0ZS51bmljb2RlUHJvcGVydGllcy5ub25CaW5hcnksIG5hbWUpKVxuICAgICAgeyBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgbmFtZVwiKTsgfVxuICAgIGlmICghc3RhdGUudW5pY29kZVByb3BlcnRpZXMubm9uQmluYXJ5W25hbWVdLnRlc3QodmFsdWUpKVxuICAgICAgeyBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgdmFsdWVcIik7IH1cbiAgfTtcblxuICBwcCQxLnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlID0gZnVuY3Rpb24oc3RhdGUsIG5hbWVPclZhbHVlKSB7XG4gICAgaWYgKHN0YXRlLnVuaWNvZGVQcm9wZXJ0aWVzLmJpbmFyeS50ZXN0KG5hbWVPclZhbHVlKSkgeyByZXR1cm4gQ2hhclNldE9rIH1cbiAgICBpZiAoc3RhdGUuc3dpdGNoViAmJiBzdGF0ZS51bmljb2RlUHJvcGVydGllcy5iaW5hcnlPZlN0cmluZ3MudGVzdChuYW1lT3JWYWx1ZSkpIHsgcmV0dXJuIENoYXJTZXRTdHJpbmcgfVxuICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBwcm9wZXJ0eSBuYW1lXCIpO1xuICB9O1xuXG4gIC8vIFVuaWNvZGVQcm9wZXJ0eU5hbWUgOjpcbiAgLy8gICBVbmljb2RlUHJvcGVydHlOYW1lQ2hhcmFjdGVyc1xuICBwcCQxLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlOYW1lID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSAwO1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gICAgd2hpbGUgKGlzVW5pY29kZVByb3BlcnR5TmFtZUNoYXJhY3RlcihjaCA9IHN0YXRlLmN1cnJlbnQoKSkpIHtcbiAgICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyhjaCk7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgIT09IFwiXCJcbiAgfTtcblxuICBmdW5jdGlvbiBpc1VuaWNvZGVQcm9wZXJ0eU5hbWVDaGFyYWN0ZXIoY2gpIHtcbiAgICByZXR1cm4gaXNDb250cm9sTGV0dGVyKGNoKSB8fCBjaCA9PT0gMHg1RiAvKiBfICovXG4gIH1cblxuICAvLyBVbmljb2RlUHJvcGVydHlWYWx1ZSA6OlxuICAvLyAgIFVuaWNvZGVQcm9wZXJ0eVZhbHVlQ2hhcmFjdGVyc1xuICBwcCQxLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gMDtcbiAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICAgIHdoaWxlIChpc1VuaWNvZGVQcm9wZXJ0eVZhbHVlQ2hhcmFjdGVyKGNoID0gc3RhdGUuY3VycmVudCgpKSkge1xuICAgICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlICs9IGNvZGVQb2ludFRvU3RyaW5nKGNoKTtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSAhPT0gXCJcIlxuICB9O1xuICBmdW5jdGlvbiBpc1VuaWNvZGVQcm9wZXJ0eVZhbHVlQ2hhcmFjdGVyKGNoKSB7XG4gICAgcmV0dXJuIGlzVW5pY29kZVByb3BlcnR5TmFtZUNoYXJhY3RlcihjaCkgfHwgaXNEZWNpbWFsRGlnaXQoY2gpXG4gIH1cblxuICAvLyBMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUgOjpcbiAgLy8gICBVbmljb2RlUHJvcGVydHlWYWx1ZUNoYXJhY3RlcnNcbiAgcHAkMS5yZWdleHBfZWF0TG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWUoc3RhdGUpXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ2hhcmFjdGVyQ2xhc3NcbiAgcHAkMS5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3MgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5lYXQoMHg1QiAvKiBbICovKSkge1xuICAgICAgdmFyIG5lZ2F0ZSA9IHN0YXRlLmVhdCgweDVFIC8qIF4gKi8pO1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucmVnZXhwX2NsYXNzQ29udGVudHMoc3RhdGUpO1xuICAgICAgaWYgKCFzdGF0ZS5lYXQoMHg1RCAvKiBdICovKSlcbiAgICAgICAgeyBzdGF0ZS5yYWlzZShcIlVudGVybWluYXRlZCBjaGFyYWN0ZXIgY2xhc3NcIik7IH1cbiAgICAgIGlmIChuZWdhdGUgJiYgcmVzdWx0ID09PSBDaGFyU2V0U3RyaW5nKVxuICAgICAgICB7IHN0YXRlLnJhaXNlKFwiTmVnYXRlZCBjaGFyYWN0ZXIgY2xhc3MgbWF5IGNvbnRhaW4gc3RyaW5nc1wiKTsgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NDb250ZW50c1xuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1DbGFzc1Jhbmdlc1xuICBwcCQxLnJlZ2V4cF9jbGFzc0NvbnRlbnRzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuY3VycmVudCgpID09PSAweDVEIC8qIF0gKi8pIHsgcmV0dXJuIENoYXJTZXRPayB9XG4gICAgaWYgKHN0YXRlLnN3aXRjaFYpIHsgcmV0dXJuIHRoaXMucmVnZXhwX2NsYXNzU2V0RXhwcmVzc2lvbihzdGF0ZSkgfVxuICAgIHRoaXMucmVnZXhwX25vbkVtcHR5Q2xhc3NSYW5nZXMoc3RhdGUpO1xuICAgIHJldHVybiBDaGFyU2V0T2tcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1Ob25lbXB0eUNsYXNzUmFuZ2VzXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLU5vbmVtcHR5Q2xhc3NSYW5nZXNOb0Rhc2hcbiAgcHAkMS5yZWdleHBfbm9uRW1wdHlDbGFzc1JhbmdlcyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgd2hpbGUgKHRoaXMucmVnZXhwX2VhdENsYXNzQXRvbShzdGF0ZSkpIHtcbiAgICAgIHZhciBsZWZ0ID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDJEIC8qIC0gKi8pICYmIHRoaXMucmVnZXhwX2VhdENsYXNzQXRvbShzdGF0ZSkpIHtcbiAgICAgICAgdmFyIHJpZ2h0ID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgICBpZiAoc3RhdGUuc3dpdGNoVSAmJiAobGVmdCA9PT0gLTEgfHwgcmlnaHQgPT09IC0xKSkge1xuICAgICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBjaGFyYWN0ZXIgY2xhc3NcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnQgIT09IC0xICYmIHJpZ2h0ICE9PSAtMSAmJiBsZWZ0ID4gcmlnaHQpIHtcbiAgICAgICAgICBzdGF0ZS5yYWlzZShcIlJhbmdlIG91dCBvZiBvcmRlciBpbiBjaGFyYWN0ZXIgY2xhc3NcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ2xhc3NBdG9tXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNsYXNzQXRvbU5vRGFzaFxuICBwcCQxLnJlZ2V4cF9lYXRDbGFzc0F0b20gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcblxuICAgIGlmIChzdGF0ZS5lYXQoMHg1QyAvKiBcXCAqLykpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRDbGFzc0VzY2FwZShzdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZSBhcyBWOC5cbiAgICAgICAgdmFyIGNoJDEgPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgICAgIGlmIChjaCQxID09PSAweDYzIC8qIGMgKi8gfHwgaXNPY3RhbERpZ2l0KGNoJDEpKSB7XG4gICAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGNsYXNzIGVzY2FwZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZXNjYXBlXCIpO1xuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChjaCAhPT0gMHg1RCAvKiBdICovKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUNsYXNzRXNjYXBlXG4gIHBwJDEucmVnZXhwX2VhdENsYXNzRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG5cbiAgICBpZiAoc3RhdGUuZWF0KDB4NjIgLyogYiAqLykpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MDg7IC8qIDxCUz4gKi9cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnN3aXRjaFUgJiYgc3RhdGUuZWF0KDB4MkQgLyogLSAqLykpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MkQ7IC8qIC0gKi9cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKCFzdGF0ZS5zd2l0Y2hVICYmIHN0YXRlLmVhdCgweDYzIC8qIGMgKi8pKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0Q2xhc3NDb250cm9sTGV0dGVyKHN0YXRlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyRXNjYXBlKHN0YXRlKVxuICAgIClcbiAgfTtcblxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1NldEV4cHJlc3Npb25cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NVbmlvblxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc0ludGVyc2VjdGlvblxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1N1YnRyYWN0aW9uXG4gIHBwJDEucmVnZXhwX2NsYXNzU2V0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IENoYXJTZXRPaywgc3ViUmVzdWx0O1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldFJhbmdlKHN0YXRlKSkgOyBlbHNlIGlmIChzdWJSZXN1bHQgPSB0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldE9wZXJhbmQoc3RhdGUpKSB7XG4gICAgICBpZiAoc3ViUmVzdWx0ID09PSBDaGFyU2V0U3RyaW5nKSB7IHJlc3VsdCA9IENoYXJTZXRTdHJpbmc7IH1cbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzSW50ZXJzZWN0aW9uXG4gICAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgICB3aGlsZSAoc3RhdGUuZWF0Q2hhcnMoWzB4MjYsIDB4MjZdIC8qICYmICovKSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgc3RhdGUuY3VycmVudCgpICE9PSAweDI2IC8qICYgKi8gJiZcbiAgICAgICAgICAoc3ViUmVzdWx0ID0gdGhpcy5yZWdleHBfZWF0Q2xhc3NTZXRPcGVyYW5kKHN0YXRlKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKHN1YlJlc3VsdCAhPT0gQ2hhclNldFN0cmluZykgeyByZXN1bHQgPSBDaGFyU2V0T2s7IH1cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBjaGFyYWN0ZXIgaW4gY2hhcmFjdGVyIGNsYXNzXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ICE9PSBzdGF0ZS5wb3MpIHsgcmV0dXJuIHJlc3VsdCB9XG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1N1YnRyYWN0aW9uXG4gICAgICB3aGlsZSAoc3RhdGUuZWF0Q2hhcnMoWzB4MkQsIDB4MkRdIC8qIC0tICovKSkge1xuICAgICAgICBpZiAodGhpcy5yZWdleHBfZWF0Q2xhc3NTZXRPcGVyYW5kKHN0YXRlKSkgeyBjb250aW51ZSB9XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBjaGFyYWN0ZXIgaW4gY2hhcmFjdGVyIGNsYXNzXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ICE9PSBzdGF0ZS5wb3MpIHsgcmV0dXJuIHJlc3VsdCB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBjaGFyYWN0ZXIgaW4gY2hhcmFjdGVyIGNsYXNzXCIpO1xuICAgIH1cbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1VuaW9uXG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdENsYXNzU2V0UmFuZ2Uoc3RhdGUpKSB7IGNvbnRpbnVlIH1cbiAgICAgIHN1YlJlc3VsdCA9IHRoaXMucmVnZXhwX2VhdENsYXNzU2V0T3BlcmFuZChzdGF0ZSk7XG4gICAgICBpZiAoIXN1YlJlc3VsdCkgeyByZXR1cm4gcmVzdWx0IH1cbiAgICAgIGlmIChzdWJSZXN1bHQgPT09IENoYXJTZXRTdHJpbmcpIHsgcmVzdWx0ID0gQ2hhclNldFN0cmluZzsgfVxuICAgIH1cbiAgfTtcblxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1NldFJhbmdlXG4gIHBwJDEucmVnZXhwX2VhdENsYXNzU2V0UmFuZ2UgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0Q2xhc3NTZXRDaGFyYWN0ZXIoc3RhdGUpKSB7XG4gICAgICB2YXIgbGVmdCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIGlmIChzdGF0ZS5lYXQoMHgyRCAvKiAtICovKSAmJiB0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldENoYXJhY3RlcihzdGF0ZSkpIHtcbiAgICAgICAgdmFyIHJpZ2h0ID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgICBpZiAobGVmdCAhPT0gLTEgJiYgcmlnaHQgIT09IC0xICYmIGxlZnQgPiByaWdodCkge1xuICAgICAgICAgIHN0YXRlLnJhaXNlKFwiUmFuZ2Ugb3V0IG9mIG9yZGVyIGluIGNoYXJhY3RlciBjbGFzc1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzU2V0T3BlcmFuZFxuICBwcCQxLnJlZ2V4cF9lYXRDbGFzc1NldE9wZXJhbmQgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldENoYXJhY3RlcihzdGF0ZSkpIHsgcmV0dXJuIENoYXJTZXRPayB9XG4gICAgcmV0dXJuIHRoaXMucmVnZXhwX2VhdENsYXNzU3RyaW5nRGlzanVuY3Rpb24oc3RhdGUpIHx8IHRoaXMucmVnZXhwX2VhdE5lc3RlZENsYXNzKHN0YXRlKVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLU5lc3RlZENsYXNzXG4gIHBwJDEucmVnZXhwX2VhdE5lc3RlZENsYXNzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgaWYgKHN0YXRlLmVhdCgweDVCIC8qIFsgKi8pKSB7XG4gICAgICB2YXIgbmVnYXRlID0gc3RhdGUuZWF0KDB4NUUgLyogXiAqLyk7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZWdleHBfY2xhc3NDb250ZW50cyhzdGF0ZSk7XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4NUQgLyogXSAqLykpIHtcbiAgICAgICAgaWYgKG5lZ2F0ZSAmJiByZXN1bHQgPT09IENoYXJTZXRTdHJpbmcpIHtcbiAgICAgICAgICBzdGF0ZS5yYWlzZShcIk5lZ2F0ZWQgY2hhcmFjdGVyIGNsYXNzIG1heSBjb250YWluIHN0cmluZ3NcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5lYXQoMHg1QyAvKiBcXCAqLykpIHtcbiAgICAgIHZhciByZXN1bHQkMSA9IHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlKHN0YXRlKTtcbiAgICAgIGlmIChyZXN1bHQkMSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0JDFcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9O1xuXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzU3RyaW5nRGlzanVuY3Rpb25cbiAgcHAkMS5yZWdleHBfZWF0Q2xhc3NTdHJpbmdEaXNqdW5jdGlvbiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIGlmIChzdGF0ZS5lYXRDaGFycyhbMHg1QywgMHg3MV0gLyogXFxxICovKSkge1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDdCIC8qIHsgKi8pKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnJlZ2V4cF9jbGFzc1N0cmluZ0Rpc2p1bmN0aW9uQ29udGVudHMoc3RhdGUpO1xuICAgICAgICBpZiAoc3RhdGUuZWF0KDB4N0QgLyogfSAqLykpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZSBhcyBWOC5cbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGVzY2FwZVwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9O1xuXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzU3RyaW5nRGlzanVuY3Rpb25Db250ZW50c1xuICBwcCQxLnJlZ2V4cF9jbGFzc1N0cmluZ0Rpc2p1bmN0aW9uQ29udGVudHMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLnJlZ2V4cF9jbGFzc1N0cmluZyhzdGF0ZSk7XG4gICAgd2hpbGUgKHN0YXRlLmVhdCgweDdDIC8qIHwgKi8pKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfY2xhc3NTdHJpbmcoc3RhdGUpID09PSBDaGFyU2V0U3RyaW5nKSB7IHJlc3VsdCA9IENoYXJTZXRTdHJpbmc7IH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9O1xuXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzU3RyaW5nXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLU5vbkVtcHR5Q2xhc3NTdHJpbmdcbiAgcHAkMS5yZWdleHBfY2xhc3NTdHJpbmcgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgd2hpbGUgKHRoaXMucmVnZXhwX2VhdENsYXNzU2V0Q2hhcmFjdGVyKHN0YXRlKSkgeyBjb3VudCsrOyB9XG4gICAgcmV0dXJuIGNvdW50ID09PSAxID8gQ2hhclNldE9rIDogQ2hhclNldFN0cmluZ1xuICB9O1xuXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzU2V0Q2hhcmFjdGVyXG4gIHBwJDEucmVnZXhwX2VhdENsYXNzU2V0Q2hhcmFjdGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgaWYgKHN0YXRlLmVhdCgweDVDIC8qIFxcICovKSkge1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJFc2NhcGUoc3RhdGUpIHx8XG4gICAgICAgIHRoaXMucmVnZXhwX2VhdENsYXNzU2V0UmVzZXJ2ZWRQdW5jdHVhdG9yKHN0YXRlKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4NjIgLyogYiAqLykpIHtcbiAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwODsgLyogPEJTPiAqL1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChjaCA8IDAgfHwgY2ggPT09IHN0YXRlLmxvb2thaGVhZCgpICYmIGlzQ2xhc3NTZXRSZXNlcnZlZERvdWJsZVB1bmN0dWF0b3JDaGFyYWN0ZXIoY2gpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKGlzQ2xhc3NTZXRTeW50YXhDaGFyYWN0ZXIoY2gpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgIHJldHVybiB0cnVlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NTZXRSZXNlcnZlZERvdWJsZVB1bmN0dWF0b3JcbiAgZnVuY3Rpb24gaXNDbGFzc1NldFJlc2VydmVkRG91YmxlUHVuY3R1YXRvckNoYXJhY3RlcihjaCkge1xuICAgIHJldHVybiAoXG4gICAgICBjaCA9PT0gMHgyMSAvKiAhICovIHx8XG4gICAgICBjaCA+PSAweDIzIC8qICMgKi8gJiYgY2ggPD0gMHgyNiAvKiAmICovIHx8XG4gICAgICBjaCA+PSAweDJBIC8qICogKi8gJiYgY2ggPD0gMHgyQyAvKiAsICovIHx8XG4gICAgICBjaCA9PT0gMHgyRSAvKiAuICovIHx8XG4gICAgICBjaCA+PSAweDNBIC8qIDogKi8gJiYgY2ggPD0gMHg0MCAvKiBAICovIHx8XG4gICAgICBjaCA9PT0gMHg1RSAvKiBeICovIHx8XG4gICAgICBjaCA9PT0gMHg2MCAvKiBgICovIHx8XG4gICAgICBjaCA9PT0gMHg3RSAvKiB+ICovXG4gICAgKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NTZXRTeW50YXhDaGFyYWN0ZXJcbiAgZnVuY3Rpb24gaXNDbGFzc1NldFN5bnRheENoYXJhY3RlcihjaCkge1xuICAgIHJldHVybiAoXG4gICAgICBjaCA9PT0gMHgyOCAvKiAoICovIHx8XG4gICAgICBjaCA9PT0gMHgyOSAvKiApICovIHx8XG4gICAgICBjaCA9PT0gMHgyRCAvKiAtICovIHx8XG4gICAgICBjaCA9PT0gMHgyRiAvKiAvICovIHx8XG4gICAgICBjaCA+PSAweDVCIC8qIFsgKi8gJiYgY2ggPD0gMHg1RCAvKiBdICovIHx8XG4gICAgICBjaCA+PSAweDdCIC8qIHsgKi8gJiYgY2ggPD0gMHg3RCAvKiB9ICovXG4gICAgKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NTZXRSZXNlcnZlZFB1bmN0dWF0b3JcbiAgcHAkMS5yZWdleHBfZWF0Q2xhc3NTZXRSZXNlcnZlZFB1bmN0dWF0b3IgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoaXNDbGFzc1NldFJlc2VydmVkUHVuY3R1YXRvcihjaCkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NTZXRSZXNlcnZlZFB1bmN0dWF0b3JcbiAgZnVuY3Rpb24gaXNDbGFzc1NldFJlc2VydmVkUHVuY3R1YXRvcihjaCkge1xuICAgIHJldHVybiAoXG4gICAgICBjaCA9PT0gMHgyMSAvKiAhICovIHx8XG4gICAgICBjaCA9PT0gMHgyMyAvKiAjICovIHx8XG4gICAgICBjaCA9PT0gMHgyNSAvKiAlICovIHx8XG4gICAgICBjaCA9PT0gMHgyNiAvKiAmICovIHx8XG4gICAgICBjaCA9PT0gMHgyQyAvKiAsICovIHx8XG4gICAgICBjaCA9PT0gMHgyRCAvKiAtICovIHx8XG4gICAgICBjaCA+PSAweDNBIC8qIDogKi8gJiYgY2ggPD0gMHgzRSAvKiA+ICovIHx8XG4gICAgICBjaCA9PT0gMHg0MCAvKiBAICovIHx8XG4gICAgICBjaCA9PT0gMHg2MCAvKiBgICovIHx8XG4gICAgICBjaCA9PT0gMHg3RSAvKiB+ICovXG4gICAgKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUNsYXNzQ29udHJvbExldHRlclxuICBwcCQxLnJlZ2V4cF9lYXRDbGFzc0NvbnRyb2xMZXR0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoaXNEZWNpbWFsRGlnaXQoY2gpIHx8IGNoID09PSAweDVGIC8qIF8gKi8pIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoICUgMHgyMDtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleEVzY2FwZVNlcXVlbmNlXG4gIHBwJDEucmVnZXhwX2VhdEhleEVzY2FwZVNlcXVlbmNlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgaWYgKHN0YXRlLmVhdCgweDc4IC8qIHggKi8pKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0Rml4ZWRIZXhEaWdpdHMoc3RhdGUsIDIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZXNjYXBlXCIpO1xuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLURlY2ltYWxEaWdpdHNcbiAgcHAkMS5yZWdleHBfZWF0RGVjaW1hbERpZ2l0cyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHZhciBjaCA9IDA7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgICB3aGlsZSAoaXNEZWNpbWFsRGlnaXQoY2ggPSBzdGF0ZS5jdXJyZW50KCkpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAxMCAqIHN0YXRlLmxhc3RJbnRWYWx1ZSArIChjaCAtIDB4MzAgLyogMCAqLyk7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5wb3MgIT09IHN0YXJ0XG4gIH07XG4gIGZ1bmN0aW9uIGlzRGVjaW1hbERpZ2l0KGNoKSB7XG4gICAgcmV0dXJuIGNoID49IDB4MzAgLyogMCAqLyAmJiBjaCA8PSAweDM5IC8qIDkgKi9cbiAgfVxuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleERpZ2l0c1xuICBwcCQxLnJlZ2V4cF9lYXRIZXhEaWdpdHMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICB2YXIgY2ggPSAwO1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gICAgd2hpbGUgKGlzSGV4RGlnaXQoY2ggPSBzdGF0ZS5jdXJyZW50KCkpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAxNiAqIHN0YXRlLmxhc3RJbnRWYWx1ZSArIGhleFRvSW50KGNoKTtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLnBvcyAhPT0gc3RhcnRcbiAgfTtcbiAgZnVuY3Rpb24gaXNIZXhEaWdpdChjaCkge1xuICAgIHJldHVybiAoXG4gICAgICAoY2ggPj0gMHgzMCAvKiAwICovICYmIGNoIDw9IDB4MzkgLyogOSAqLykgfHxcbiAgICAgIChjaCA+PSAweDQxIC8qIEEgKi8gJiYgY2ggPD0gMHg0NiAvKiBGICovKSB8fFxuICAgICAgKGNoID49IDB4NjEgLyogYSAqLyAmJiBjaCA8PSAweDY2IC8qIGYgKi8pXG4gICAgKVxuICB9XG4gIGZ1bmN0aW9uIGhleFRvSW50KGNoKSB7XG4gICAgaWYgKGNoID49IDB4NDEgLyogQSAqLyAmJiBjaCA8PSAweDQ2IC8qIEYgKi8pIHtcbiAgICAgIHJldHVybiAxMCArIChjaCAtIDB4NDEgLyogQSAqLylcbiAgICB9XG4gICAgaWYgKGNoID49IDB4NjEgLyogYSAqLyAmJiBjaCA8PSAweDY2IC8qIGYgKi8pIHtcbiAgICAgIHJldHVybiAxMCArIChjaCAtIDB4NjEgLyogYSAqLylcbiAgICB9XG4gICAgcmV0dXJuIGNoIC0gMHgzMCAvKiAwICovXG4gIH1cblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItTGVnYWN5T2N0YWxFc2NhcGVTZXF1ZW5jZVxuICAvLyBBbGxvd3Mgb25seSAwLTM3NyhvY3RhbCkgaS5lLiAwLTI1NShkZWNpbWFsKS5cbiAgcHAkMS5yZWdleHBfZWF0TGVnYWN5T2N0YWxFc2NhcGVTZXF1ZW5jZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdE9jdGFsRGlnaXQoc3RhdGUpKSB7XG4gICAgICB2YXIgbjEgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0T2N0YWxEaWdpdChzdGF0ZSkpIHtcbiAgICAgICAgdmFyIG4yID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgICBpZiAobjEgPD0gMyAmJiB0aGlzLnJlZ2V4cF9lYXRPY3RhbERpZ2l0KHN0YXRlKSkge1xuICAgICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IG4xICogNjQgKyBuMiAqIDggKyBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gbjEgKiA4ICsgbjI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IG4xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtT2N0YWxEaWdpdFxuICBwcCQxLnJlZ2V4cF9lYXRPY3RhbERpZ2l0ID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKGlzT2N0YWxEaWdpdChjaCkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoIC0gMHgzMDsgLyogMCAqL1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgZnVuY3Rpb24gaXNPY3RhbERpZ2l0KGNoKSB7XG4gICAgcmV0dXJuIGNoID49IDB4MzAgLyogMCAqLyAmJiBjaCA8PSAweDM3IC8qIDcgKi9cbiAgfVxuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleDREaWdpdHNcbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtSGV4RGlnaXRcbiAgLy8gQW5kIEhleERpZ2l0IEhleERpZ2l0IGluIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleEVzY2FwZVNlcXVlbmNlXG4gIHBwJDEucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzID0gZnVuY3Rpb24oc3RhdGUsIGxlbmd0aCkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICAgIGlmICghaXNIZXhEaWdpdChjaCkpIHtcbiAgICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMTYgKiBzdGF0ZS5sYXN0SW50VmFsdWUgKyBoZXhUb0ludChjaCk7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH07XG5cbiAgLy8gT2JqZWN0IHR5cGUgdXNlZCB0byByZXByZXNlbnQgdG9rZW5zLiBOb3RlIHRoYXQgbm9ybWFsbHksIHRva2Vuc1xuICAvLyBzaW1wbHkgZXhpc3QgYXMgcHJvcGVydGllcyBvbiB0aGUgcGFyc2VyIG9iamVjdC4gVGhpcyBpcyBvbmx5XG4gIC8vIHVzZWQgZm9yIHRoZSBvblRva2VuIGNhbGxiYWNrIGFuZCB0aGUgZXh0ZXJuYWwgdG9rZW5pemVyLlxuXG4gIHZhciBUb2tlbiA9IGZ1bmN0aW9uIFRva2VuKHApIHtcbiAgICB0aGlzLnR5cGUgPSBwLnR5cGU7XG4gICAgdGhpcy52YWx1ZSA9IHAudmFsdWU7XG4gICAgdGhpcy5zdGFydCA9IHAuc3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBwLmVuZDtcbiAgICBpZiAocC5vcHRpb25zLmxvY2F0aW9ucylcbiAgICAgIHsgdGhpcy5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24ocCwgcC5zdGFydExvYywgcC5lbmRMb2MpOyB9XG4gICAgaWYgKHAub3B0aW9ucy5yYW5nZXMpXG4gICAgICB7IHRoaXMucmFuZ2UgPSBbcC5zdGFydCwgcC5lbmRdOyB9XG4gIH07XG5cbiAgLy8gIyMgVG9rZW5pemVyXG5cbiAgdmFyIHBwID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICAvLyBNb3ZlIHRvIHRoZSBuZXh0IHRva2VuXG5cbiAgcHAubmV4dCA9IGZ1bmN0aW9uKGlnbm9yZUVzY2FwZVNlcXVlbmNlSW5LZXl3b3JkKSB7XG4gICAgaWYgKCFpZ25vcmVFc2NhcGVTZXF1ZW5jZUluS2V5d29yZCAmJiB0aGlzLnR5cGUua2V5d29yZCAmJiB0aGlzLmNvbnRhaW5zRXNjKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJFc2NhcGUgc2VxdWVuY2UgaW4ga2V5d29yZCBcIiArIHRoaXMudHlwZS5rZXl3b3JkKTsgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMub25Ub2tlbilcbiAgICAgIHsgdGhpcy5vcHRpb25zLm9uVG9rZW4obmV3IFRva2VuKHRoaXMpKTsgfVxuXG4gICAgdGhpcy5sYXN0VG9rRW5kID0gdGhpcy5lbmQ7XG4gICAgdGhpcy5sYXN0VG9rU3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgIHRoaXMubGFzdFRva0VuZExvYyA9IHRoaXMuZW5kTG9jO1xuICAgIHRoaXMubGFzdFRva1N0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICB0aGlzLm5leHRUb2tlbigpO1xuICB9O1xuXG4gIHBwLmdldFRva2VuID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIG5ldyBUb2tlbih0aGlzKVxuICB9O1xuXG4gIC8vIElmIHdlJ3JlIGluIGFuIEVTNiBlbnZpcm9ubWVudCwgbWFrZSBwYXJzZXJzIGl0ZXJhYmxlXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiKVxuICAgIHsgcHBbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRoaXMkMSQxID0gdGhpcztcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMkMSQxLmdldFRva2VuKCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IHRva2VuLnR5cGUgPT09IHR5cGVzJDEuZW9mLFxuICAgICAgICAgICAgdmFsdWU6IHRva2VuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTsgfVxuXG4gIC8vIFRvZ2dsZSBzdHJpY3QgbW9kZS4gUmUtcmVhZHMgdGhlIG5leHQgbnVtYmVyIG9yIHN0cmluZyB0byBwbGVhc2VcbiAgLy8gcGVkYW50aWMgdGVzdHMgKGBcInVzZSBzdHJpY3RcIjsgMDEwO2Agc2hvdWxkIGZhaWwpLlxuXG4gIC8vIFJlYWQgYSBzaW5nbGUgdG9rZW4sIHVwZGF0aW5nIHRoZSBwYXJzZXIgb2JqZWN0J3MgdG9rZW4tcmVsYXRlZFxuICAvLyBwcm9wZXJ0aWVzLlxuXG4gIHBwLm5leHRUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdXJDb250ZXh0ID0gdGhpcy5jdXJDb250ZXh0KCk7XG4gICAgaWYgKCFjdXJDb250ZXh0IHx8ICFjdXJDb250ZXh0LnByZXNlcnZlU3BhY2UpIHsgdGhpcy5za2lwU3BhY2UoKTsgfVxuXG4gICAgdGhpcy5zdGFydCA9IHRoaXMucG9zO1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7IHRoaXMuc3RhcnRMb2MgPSB0aGlzLmN1clBvc2l0aW9uKCk7IH1cbiAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5lb2YpIH1cblxuICAgIGlmIChjdXJDb250ZXh0Lm92ZXJyaWRlKSB7IHJldHVybiBjdXJDb250ZXh0Lm92ZXJyaWRlKHRoaXMpIH1cbiAgICBlbHNlIHsgdGhpcy5yZWFkVG9rZW4odGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKTsgfVxuICB9O1xuXG4gIHBwLnJlYWRUb2tlbiA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgICAvLyBJZGVudGlmaWVyIG9yIGtleXdvcmQuICdcXHVYWFhYJyBzZXF1ZW5jZXMgYXJlIGFsbG93ZWQgaW5cbiAgICAvLyBpZGVudGlmaWVycywgc28gJ1xcJyBhbHNvIGRpc3BhdGNoZXMgdG8gdGhhdC5cbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY29kZSwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHx8IGNvZGUgPT09IDkyIC8qICdcXCcgKi8pXG4gICAgICB7IHJldHVybiB0aGlzLnJlYWRXb3JkKCkgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKVxuICB9O1xuXG4gIHBwLmZ1bGxDaGFyQ29kZUF0UG9zID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvZGUgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgIGlmIChjb2RlIDw9IDB4ZDdmZiB8fCBjb2RlID49IDB4ZGMwMCkgeyByZXR1cm4gY29kZSB9XG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICByZXR1cm4gbmV4dCA8PSAweGRiZmYgfHwgbmV4dCA+PSAweGUwMDAgPyBjb2RlIDogKGNvZGUgPDwgMTApICsgbmV4dCAtIDB4MzVmZGMwMFxuICB9O1xuXG4gIHBwLnNraXBCbG9ja0NvbW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhcnRMb2MgPSB0aGlzLm9wdGlvbnMub25Db21tZW50ICYmIHRoaXMuY3VyUG9zaXRpb24oKTtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcywgZW5kID0gdGhpcy5pbnB1dC5pbmRleE9mKFwiKi9cIiwgdGhpcy5wb3MgKz0gMik7XG4gICAgaWYgKGVuZCA9PT0gLTEpIHsgdGhpcy5yYWlzZSh0aGlzLnBvcyAtIDIsIFwiVW50ZXJtaW5hdGVkIGNvbW1lbnRcIik7IH1cbiAgICB0aGlzLnBvcyA9IGVuZCArIDI7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgIGZvciAodmFyIG5leHRCcmVhayA9ICh2b2lkIDApLCBwb3MgPSBzdGFydDsgKG5leHRCcmVhayA9IG5leHRMaW5lQnJlYWsodGhpcy5pbnB1dCwgcG9zLCB0aGlzLnBvcykpID4gLTE7KSB7XG4gICAgICAgICsrdGhpcy5jdXJMaW5lO1xuICAgICAgICBwb3MgPSB0aGlzLmxpbmVTdGFydCA9IG5leHRCcmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vbkNvbW1lbnQpXG4gICAgICB7IHRoaXMub3B0aW9ucy5vbkNvbW1lbnQodHJ1ZSwgdGhpcy5pbnB1dC5zbGljZShzdGFydCArIDIsIGVuZCksIHN0YXJ0LCB0aGlzLnBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRMb2MsIHRoaXMuY3VyUG9zaXRpb24oKSk7IH1cbiAgfTtcblxuICBwcC5za2lwTGluZUNvbW1lbnQgPSBmdW5jdGlvbihzdGFydFNraXApIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcbiAgICB2YXIgc3RhcnRMb2MgPSB0aGlzLm9wdGlvbnMub25Db21tZW50ICYmIHRoaXMuY3VyUG9zaXRpb24oKTtcbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKz0gc3RhcnRTa2lwKTtcbiAgICB3aGlsZSAodGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCAmJiAhaXNOZXdMaW5lKGNoKSkge1xuICAgICAgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMub25Db21tZW50KVxuICAgICAgeyB0aGlzLm9wdGlvbnMub25Db21tZW50KGZhbHNlLCB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0ICsgc3RhcnRTa2lwLCB0aGlzLnBvcyksIHN0YXJ0LCB0aGlzLnBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRMb2MsIHRoaXMuY3VyUG9zaXRpb24oKSk7IH1cbiAgfTtcblxuICAvLyBDYWxsZWQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBwYXJzZSBhbmQgYWZ0ZXIgZXZlcnkgdG9rZW4uIFNraXBzXG4gIC8vIHdoaXRlc3BhY2UgYW5kIGNvbW1lbnRzLCBhbmQuXG5cbiAgcHAuc2tpcFNwYWNlID0gZnVuY3Rpb24oKSB7XG4gICAgbG9vcDogd2hpbGUgKHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGgpIHtcbiAgICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICBjYXNlIDMyOiBjYXNlIDE2MDogLy8gJyAnXG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDEzOlxuICAgICAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSkgPT09IDEwKSB7XG4gICAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgfVxuICAgICAgY2FzZSAxMDogY2FzZSA4MjMyOiBjYXNlIDgyMzM6XG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgICAgKyt0aGlzLmN1ckxpbmU7XG4gICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSA0NzogLy8gJy8nXG4gICAgICAgIHN3aXRjaCAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSkpIHtcbiAgICAgICAgY2FzZSA0MjogLy8gJyonXG4gICAgICAgICAgdGhpcy5za2lwQmxvY2tDb21tZW50KCk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0NzpcbiAgICAgICAgICB0aGlzLnNraXBMaW5lQ29tbWVudCgyKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrIGxvb3BcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGNoID4gOCAmJiBjaCA8IDE0IHx8IGNoID49IDU3NjAgJiYgbm9uQVNDSUl3aGl0ZXNwYWNlLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjaCkpKSB7XG4gICAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhayBsb29wXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gQ2FsbGVkIGF0IHRoZSBlbmQgb2YgZXZlcnkgdG9rZW4uIFNldHMgYGVuZGAsIGB2YWxgLCBhbmRcbiAgLy8gbWFpbnRhaW5zIGBjb250ZXh0YCBhbmQgYGV4cHJBbGxvd2VkYCwgYW5kIHNraXBzIHRoZSBzcGFjZSBhZnRlclxuICAvLyB0aGUgdG9rZW4sIHNvIHRoYXQgdGhlIG5leHQgb25lJ3MgYHN0YXJ0YCB3aWxsIHBvaW50IGF0IHRoZVxuICAvLyByaWdodCBwb3NpdGlvbi5cblxuICBwcC5maW5pc2hUb2tlbiA9IGZ1bmN0aW9uKHR5cGUsIHZhbCkge1xuICAgIHRoaXMuZW5kID0gdGhpcy5wb3M7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHsgdGhpcy5lbmRMb2MgPSB0aGlzLmN1clBvc2l0aW9uKCk7IH1cbiAgICB2YXIgcHJldlR5cGUgPSB0aGlzLnR5cGU7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnZhbHVlID0gdmFsO1xuXG4gICAgdGhpcy51cGRhdGVDb250ZXh0KHByZXZUeXBlKTtcbiAgfTtcblxuICAvLyAjIyMgVG9rZW4gcmVhZGluZ1xuXG4gIC8vIFRoaXMgaXMgdGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHRvIGZldGNoIHRoZSBuZXh0IHRva2VuLiBJdFxuICAvLyBpcyBzb21ld2hhdCBvYnNjdXJlLCBiZWNhdXNlIGl0IHdvcmtzIGluIGNoYXJhY3RlciBjb2RlcyByYXRoZXJcbiAgLy8gdGhhbiBjaGFyYWN0ZXJzLCBhbmQgYmVjYXVzZSBvcGVyYXRvciBwYXJzaW5nIGhhcyBiZWVuIGlubGluZWRcbiAgLy8gaW50byBpdC5cbiAgLy9cbiAgLy8gQWxsIGluIHRoZSBuYW1lIG9mIHNwZWVkLlxuICAvL1xuICBwcC5yZWFkVG9rZW5fZG90ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA+PSA0OCAmJiBuZXh0IDw9IDU3KSB7IHJldHVybiB0aGlzLnJlYWROdW1iZXIodHJ1ZSkgfVxuICAgIHZhciBuZXh0MiA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiBuZXh0ID09PSA0NiAmJiBuZXh0MiA9PT0gNDYpIHsgLy8gNDYgPSBkb3QgJy4nXG4gICAgICB0aGlzLnBvcyArPSAzO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5lbGxpcHNpcylcbiAgICB9IGVsc2Uge1xuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuZG90KVxuICAgIH1cbiAgfTtcblxuICBwcC5yZWFkVG9rZW5fc2xhc2ggPSBmdW5jdGlvbigpIHsgLy8gJy8nXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICBpZiAodGhpcy5leHByQWxsb3dlZCkgeyArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5yZWFkUmVnZXhwKCkgfVxuICAgIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLmFzc2lnbiwgMikgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEuc2xhc2gsIDEpXG4gIH07XG5cbiAgcHAucmVhZFRva2VuX211bHRfbW9kdWxvX2V4cCA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJyUqJ1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgdmFyIHNpemUgPSAxO1xuICAgIHZhciB0b2tlbnR5cGUgPSBjb2RlID09PSA0MiA/IHR5cGVzJDEuc3RhciA6IHR5cGVzJDEubW9kdWxvO1xuXG4gICAgLy8gZXhwb25lbnRpYXRpb24gb3BlcmF0b3IgKiogYW5kICoqPVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNyAmJiBjb2RlID09PSA0MiAmJiBuZXh0ID09PSA0Mikge1xuICAgICAgKytzaXplO1xuICAgICAgdG9rZW50eXBlID0gdHlwZXMkMS5zdGFyc3RhcjtcbiAgICAgIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKTtcbiAgICB9XG5cbiAgICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5hc3NpZ24sIHNpemUgKyAxKSB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodG9rZW50eXBlLCBzaXplKVxuICB9O1xuXG4gIHBwLnJlYWRUb2tlbl9waXBlX2FtcCA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJ3wmJ1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IGNvZGUpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTIpIHtcbiAgICAgICAgdmFyIG5leHQyID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gICAgICAgIGlmIChuZXh0MiA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5hc3NpZ24sIDMpIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDEyNCA/IHR5cGVzJDEubG9naWNhbE9SIDogdHlwZXMkMS5sb2dpY2FsQU5ELCAyKVxuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5hc3NpZ24sIDIpIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcChjb2RlID09PSAxMjQgPyB0eXBlcyQxLmJpdHdpc2VPUiA6IHR5cGVzJDEuYml0d2lzZUFORCwgMSlcbiAgfTtcblxuICBwcC5yZWFkVG9rZW5fY2FyZXQgPSBmdW5jdGlvbigpIHsgLy8gJ14nXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5hc3NpZ24sIDIpIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLmJpdHdpc2VYT1IsIDEpXG4gIH07XG5cbiAgcHAucmVhZFRva2VuX3BsdXNfbWluID0gZnVuY3Rpb24oY29kZSkgeyAvLyAnKy0nXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgICAgaWYgKG5leHQgPT09IDQ1ICYmICF0aGlzLmluTW9kdWxlICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09PSA2MiAmJlxuICAgICAgICAgICh0aGlzLmxhc3RUb2tFbmQgPT09IDAgfHwgbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMucG9zKSkpKSB7XG4gICAgICAgIC8vIEEgYC0tPmAgbGluZSBjb21tZW50XG4gICAgICAgIHRoaXMuc2tpcExpbmVDb21tZW50KDMpO1xuICAgICAgICB0aGlzLnNraXBTcGFjZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW4oKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5pbmNEZWMsIDIpXG4gICAgfVxuICAgIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLmFzc2lnbiwgMikgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEucGx1c01pbiwgMSlcbiAgfTtcblxuICBwcC5yZWFkVG9rZW5fbHRfZ3QgPSBmdW5jdGlvbihjb2RlKSB7IC8vICc8PidcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIHZhciBzaXplID0gMTtcbiAgICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgICAgc2l6ZSA9IGNvZGUgPT09IDYyICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09PSA2MiA/IDMgOiAyO1xuICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIHNpemUpID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLmFzc2lnbiwgc2l6ZSArIDEpIH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEuYml0U2hpZnQsIHNpemUpXG4gICAgfVxuICAgIGlmIChuZXh0ID09PSAzMyAmJiBjb2RlID09PSA2MCAmJiAhdGhpcy5pbk1vZHVsZSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKSA9PT0gNDUgJiZcbiAgICAgICAgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMykgPT09IDQ1KSB7XG4gICAgICAvLyBgPCEtLWAsIGFuIFhNTC1zdHlsZSBjb21tZW50IHRoYXQgc2hvdWxkIGJlIGludGVycHJldGVkIGFzIGEgbGluZSBjb21tZW50XG4gICAgICB0aGlzLnNraXBMaW5lQ29tbWVudCg0KTtcbiAgICAgIHRoaXMuc2tpcFNwYWNlKCk7XG4gICAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW4oKVxuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gNjEpIHsgc2l6ZSA9IDI7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLnJlbGF0aW9uYWwsIHNpemUpXG4gIH07XG5cbiAgcHAucmVhZFRva2VuX2VxX2V4Y2wgPSBmdW5jdGlvbihjb2RlKSB7IC8vICc9ISdcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLmVxdWFsaXR5LCB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKSA9PT0gNjEgPyAzIDogMikgfVxuICAgIGlmIChjb2RlID09PSA2MSAmJiBuZXh0ID09PSA2MiAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikgeyAvLyAnPT4nXG4gICAgICB0aGlzLnBvcyArPSAyO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5hcnJvdylcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gNjEgPyB0eXBlcyQxLmVxIDogdHlwZXMkMS5wcmVmaXgsIDEpXG4gIH07XG5cbiAgcHAucmVhZFRva2VuX3F1ZXN0aW9uID0gZnVuY3Rpb24oKSB7IC8vICc/J1xuICAgIHZhciBlY21hVmVyc2lvbiA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbjtcbiAgICBpZiAoZWNtYVZlcnNpb24gPj0gMTEpIHtcbiAgICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgICBpZiAobmV4dCA9PT0gNDYpIHtcbiAgICAgICAgdmFyIG5leHQyID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gICAgICAgIGlmIChuZXh0MiA8IDQ4IHx8IG5leHQyID4gNTcpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5xdWVzdGlvbkRvdCwgMikgfVxuICAgICAgfVxuICAgICAgaWYgKG5leHQgPT09IDYzKSB7XG4gICAgICAgIGlmIChlY21hVmVyc2lvbiA+PSAxMikge1xuICAgICAgICAgIHZhciBuZXh0MiQxID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gICAgICAgICAgaWYgKG5leHQyJDEgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEuYXNzaWduLCAzKSB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5jb2FsZXNjZSwgMilcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5xdWVzdGlvbiwgMSlcbiAgfTtcblxuICBwcC5yZWFkVG9rZW5fbnVtYmVyU2lnbiA9IGZ1bmN0aW9uKCkgeyAvLyAnIydcbiAgICB2YXIgZWNtYVZlcnNpb24gPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb247XG4gICAgdmFyIGNvZGUgPSAzNTsgLy8gJyMnXG4gICAgaWYgKGVjbWFWZXJzaW9uID49IDEzKSB7XG4gICAgICArK3RoaXMucG9zO1xuICAgICAgY29kZSA9IHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKTtcbiAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChjb2RlLCB0cnVlKSB8fCBjb2RlID09PSA5MiAvKiAnXFwnICovKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEucHJpdmF0ZUlkLCB0aGlzLnJlYWRXb3JkMSgpKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmFpc2UodGhpcy5wb3MsIFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgJ1wiICsgY29kZVBvaW50VG9TdHJpbmcoY29kZSkgKyBcIidcIik7XG4gIH07XG5cbiAgcHAuZ2V0VG9rZW5Gcm9tQ29kZSA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAvLyBUaGUgaW50ZXJwcmV0YXRpb24gb2YgYSBkb3QgZGVwZW5kcyBvbiB3aGV0aGVyIGl0IGlzIGZvbGxvd2VkXG4gICAgLy8gYnkgYSBkaWdpdCBvciBhbm90aGVyIHR3byBkb3RzLlxuICAgIGNhc2UgNDY6IC8vICcuJ1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2RvdCgpXG5cbiAgICAvLyBQdW5jdHVhdGlvbiB0b2tlbnMuXG4gICAgY2FzZSA0MDogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5wYXJlbkwpXG4gICAgY2FzZSA0MTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5wYXJlblIpXG4gICAgY2FzZSA1OTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5zZW1pKVxuICAgIGNhc2UgNDQ6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuY29tbWEpXG4gICAgY2FzZSA5MTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5icmFja2V0TClcbiAgICBjYXNlIDkzOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLmJyYWNrZXRSKVxuICAgIGNhc2UgMTIzOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLmJyYWNlTClcbiAgICBjYXNlIDEyNTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5icmFjZVIpXG4gICAgY2FzZSA1ODogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5jb2xvbilcblxuICAgIGNhc2UgOTY6IC8vICdgJ1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYpIHsgYnJlYWsgfVxuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuYmFja1F1b3RlKVxuXG4gICAgY2FzZSA0ODogLy8gJzAnXG4gICAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgICAgaWYgKG5leHQgPT09IDEyMCB8fCBuZXh0ID09PSA4OCkgeyByZXR1cm4gdGhpcy5yZWFkUmFkaXhOdW1iZXIoMTYpIH0gLy8gJzB4JywgJzBYJyAtIGhleCBudW1iZXJcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgICBpZiAobmV4dCA9PT0gMTExIHx8IG5leHQgPT09IDc5KSB7IHJldHVybiB0aGlzLnJlYWRSYWRpeE51bWJlcig4KSB9IC8vICcwbycsICcwTycgLSBvY3RhbCBudW1iZXJcbiAgICAgICAgaWYgKG5leHQgPT09IDk4IHx8IG5leHQgPT09IDY2KSB7IHJldHVybiB0aGlzLnJlYWRSYWRpeE51bWJlcigyKSB9IC8vICcwYicsICcwQicgLSBiaW5hcnkgbnVtYmVyXG4gICAgICB9XG5cbiAgICAvLyBBbnl0aGluZyBlbHNlIGJlZ2lubmluZyB3aXRoIGEgZGlnaXQgaXMgYW4gaW50ZWdlciwgb2N0YWxcbiAgICAvLyBudW1iZXIsIG9yIGZsb2F0LlxuICAgIGNhc2UgNDk6IGNhc2UgNTA6IGNhc2UgNTE6IGNhc2UgNTI6IGNhc2UgNTM6IGNhc2UgNTQ6IGNhc2UgNTU6IGNhc2UgNTY6IGNhc2UgNTc6IC8vIDEtOVxuICAgICAgcmV0dXJuIHRoaXMucmVhZE51bWJlcihmYWxzZSlcblxuICAgIC8vIFF1b3RlcyBwcm9kdWNlIHN0cmluZ3MuXG4gICAgY2FzZSAzNDogY2FzZSAzOTogLy8gJ1wiJywgXCInXCJcbiAgICAgIHJldHVybiB0aGlzLnJlYWRTdHJpbmcoY29kZSlcblxuICAgIC8vIE9wZXJhdG9ycyBhcmUgcGFyc2VkIGlubGluZSBpbiB0aW55IHN0YXRlIG1hY2hpbmVzLiAnPScgKDYxKSBpc1xuICAgIC8vIG9mdGVuIHJlZmVycmVkIHRvLiBgZmluaXNoT3BgIHNpbXBseSBza2lwcyB0aGUgYW1vdW50IG9mXG4gICAgLy8gY2hhcmFjdGVycyBpdCBpcyBnaXZlbiBhcyBzZWNvbmQgYXJndW1lbnQsIGFuZCByZXR1cm5zIGEgdG9rZW5cbiAgICAvLyBvZiB0aGUgdHlwZSBnaXZlbiBieSBpdHMgZmlyc3QgYXJndW1lbnQuXG4gICAgY2FzZSA0NzogLy8gJy8nXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fc2xhc2goKVxuXG4gICAgY2FzZSAzNzogY2FzZSA0MjogLy8gJyUqJ1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX211bHRfbW9kdWxvX2V4cChjb2RlKVxuXG4gICAgY2FzZSAxMjQ6IGNhc2UgMzg6IC8vICd8JidcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9waXBlX2FtcChjb2RlKVxuXG4gICAgY2FzZSA5NDogLy8gJ14nXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fY2FyZXQoKVxuXG4gICAgY2FzZSA0MzogY2FzZSA0NTogLy8gJystJ1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX3BsdXNfbWluKGNvZGUpXG5cbiAgICBjYXNlIDYwOiBjYXNlIDYyOiAvLyAnPD4nXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fbHRfZ3QoY29kZSlcblxuICAgIGNhc2UgNjE6IGNhc2UgMzM6IC8vICc9ISdcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9lcV9leGNsKGNvZGUpXG5cbiAgICBjYXNlIDYzOiAvLyAnPydcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9xdWVzdGlvbigpXG5cbiAgICBjYXNlIDEyNjogLy8gJ34nXG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLnByZWZpeCwgMSlcblxuICAgIGNhc2UgMzU6IC8vICcjJ1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX251bWJlclNpZ24oKVxuICAgIH1cblxuICAgIHRoaXMucmFpc2UodGhpcy5wb3MsIFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgJ1wiICsgY29kZVBvaW50VG9TdHJpbmcoY29kZSkgKyBcIidcIik7XG4gIH07XG5cbiAgcHAuZmluaXNoT3AgPSBmdW5jdGlvbih0eXBlLCBzaXplKSB7XG4gICAgdmFyIHN0ciA9IHRoaXMuaW5wdXQuc2xpY2UodGhpcy5wb3MsIHRoaXMucG9zICsgc2l6ZSk7XG4gICAgdGhpcy5wb3MgKz0gc2l6ZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlLCBzdHIpXG4gIH07XG5cbiAgcHAucmVhZFJlZ2V4cCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlc2NhcGVkLCBpbkNsYXNzLCBzdGFydCA9IHRoaXMucG9zO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIlVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb25cIik7IH1cbiAgICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckF0KHRoaXMucG9zKTtcbiAgICAgIGlmIChsaW5lQnJlYWsudGVzdChjaCkpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIpOyB9XG4gICAgICBpZiAoIWVzY2FwZWQpIHtcbiAgICAgICAgaWYgKGNoID09PSBcIltcIikgeyBpbkNsYXNzID0gdHJ1ZTsgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gXCJdXCIgJiYgaW5DbGFzcykgeyBpbkNsYXNzID0gZmFsc2U7IH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09IFwiL1wiICYmICFpbkNsYXNzKSB7IGJyZWFrIH1cbiAgICAgICAgZXNjYXBlZCA9IGNoID09PSBcIlxcXFxcIjtcbiAgICAgIH0gZWxzZSB7IGVzY2FwZWQgPSBmYWxzZTsgfVxuICAgICAgKyt0aGlzLnBvcztcbiAgICB9XG4gICAgdmFyIHBhdHRlcm4gPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcyk7XG4gICAgKyt0aGlzLnBvcztcbiAgICB2YXIgZmxhZ3NTdGFydCA9IHRoaXMucG9zO1xuICAgIHZhciBmbGFncyA9IHRoaXMucmVhZFdvcmQxKCk7XG4gICAgaWYgKHRoaXMuY29udGFpbnNFc2MpIHsgdGhpcy51bmV4cGVjdGVkKGZsYWdzU3RhcnQpOyB9XG5cbiAgICAvLyBWYWxpZGF0ZSBwYXR0ZXJuXG4gICAgdmFyIHN0YXRlID0gdGhpcy5yZWdleHBTdGF0ZSB8fCAodGhpcy5yZWdleHBTdGF0ZSA9IG5ldyBSZWdFeHBWYWxpZGF0aW9uU3RhdGUodGhpcykpO1xuICAgIHN0YXRlLnJlc2V0KHN0YXJ0LCBwYXR0ZXJuLCBmbGFncyk7XG4gICAgdGhpcy52YWxpZGF0ZVJlZ0V4cEZsYWdzKHN0YXRlKTtcbiAgICB0aGlzLnZhbGlkYXRlUmVnRXhwUGF0dGVybihzdGF0ZSk7XG5cbiAgICAvLyBDcmVhdGUgTGl0ZXJhbCN2YWx1ZSBwcm9wZXJ0eSB2YWx1ZS5cbiAgICB2YXIgdmFsdWUgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICB2YWx1ZSA9IG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIEVTVHJlZSByZXF1aXJlcyBudWxsIGlmIGl0IGZhaWxlZCB0byBpbnN0YW50aWF0ZSBSZWdFeHAgb2JqZWN0LlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2VzdHJlZS9lc3RyZWUvYmxvYi9hMjcwMDNhZGY0ZmQ3YmZhZDQ0ZGU5Y2VmMzcyYTJlYWNkNTI3YjFjL2VzNS5tZCNyZWdleHBsaXRlcmFsXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5yZWdleHAsIHtwYXR0ZXJuOiBwYXR0ZXJuLCBmbGFnczogZmxhZ3MsIHZhbHVlOiB2YWx1ZX0pXG4gIH07XG5cbiAgLy8gUmVhZCBhbiBpbnRlZ2VyIGluIHRoZSBnaXZlbiByYWRpeC4gUmV0dXJuIG51bGwgaWYgemVybyBkaWdpdHNcbiAgLy8gd2VyZSByZWFkLCB0aGUgaW50ZWdlciB2YWx1ZSBvdGhlcndpc2UuIFdoZW4gYGxlbmAgaXMgZ2l2ZW4sIHRoaXNcbiAgLy8gd2lsbCByZXR1cm4gYG51bGxgIHVubGVzcyB0aGUgaW50ZWdlciBoYXMgZXhhY3RseSBgbGVuYCBkaWdpdHMuXG5cbiAgcHAucmVhZEludCA9IGZ1bmN0aW9uKHJhZGl4LCBsZW4sIG1heWJlTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbCkge1xuICAgIC8vIGBsZW5gIGlzIHVzZWQgZm9yIGNoYXJhY3RlciBlc2NhcGUgc2VxdWVuY2VzLiBJbiB0aGF0IGNhc2UsIGRpc2FsbG93IHNlcGFyYXRvcnMuXG4gICAgdmFyIGFsbG93U2VwYXJhdG9ycyA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMiAmJiBsZW4gPT09IHVuZGVmaW5lZDtcblxuICAgIC8vIGBtYXliZUxlZ2FjeU9jdGFsTnVtZXJpY0xpdGVyYWxgIGlzIHRydWUgaWYgaXQgZG9lc24ndCBoYXZlIHByZWZpeCAoMHgsMG8sMGIpXG4gICAgLy8gYW5kIGlzbid0IGZyYWN0aW9uIHBhcnQgbm9yIGV4cG9uZW50IHBhcnQuIEluIHRoYXQgY2FzZSwgaWYgdGhlIGZpcnN0IGRpZ2l0XG4gICAgLy8gaXMgemVybyB0aGVuIGRpc2FsbG93IHNlcGFyYXRvcnMuXG4gICAgdmFyIGlzTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbCA9IG1heWJlTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbCAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpID09PSA0ODtcblxuICAgIHZhciBzdGFydCA9IHRoaXMucG9zLCB0b3RhbCA9IDAsIGxhc3RDb2RlID0gMDtcbiAgICBmb3IgKHZhciBpID0gMCwgZSA9IGxlbiA9PSBudWxsID8gSW5maW5pdHkgOiBsZW47IGkgPCBlOyArK2ksICsrdGhpcy5wb3MpIHtcbiAgICAgIHZhciBjb2RlID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSwgdmFsID0gKHZvaWQgMCk7XG5cbiAgICAgIGlmIChhbGxvd1NlcGFyYXRvcnMgJiYgY29kZSA9PT0gOTUpIHtcbiAgICAgICAgaWYgKGlzTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbCkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5wb3MsIFwiTnVtZXJpYyBzZXBhcmF0b3IgaXMgbm90IGFsbG93ZWQgaW4gbGVnYWN5IG9jdGFsIG51bWVyaWMgbGl0ZXJhbHNcIik7IH1cbiAgICAgICAgaWYgKGxhc3RDb2RlID09PSA5NSkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5wb3MsIFwiTnVtZXJpYyBzZXBhcmF0b3IgbXVzdCBiZSBleGFjdGx5IG9uZSB1bmRlcnNjb3JlXCIpOyB9XG4gICAgICAgIGlmIChpID09PSAwKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnBvcywgXCJOdW1lcmljIHNlcGFyYXRvciBpcyBub3QgYWxsb3dlZCBhdCB0aGUgZmlyc3Qgb2YgZGlnaXRzXCIpOyB9XG4gICAgICAgIGxhc3RDb2RlID0gY29kZTtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgaWYgKGNvZGUgPj0gOTcpIHsgdmFsID0gY29kZSAtIDk3ICsgMTA7IH0gLy8gYVxuICAgICAgZWxzZSBpZiAoY29kZSA+PSA2NSkgeyB2YWwgPSBjb2RlIC0gNjUgKyAxMDsgfSAvLyBBXG4gICAgICBlbHNlIGlmIChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHsgdmFsID0gY29kZSAtIDQ4OyB9IC8vIDAtOVxuICAgICAgZWxzZSB7IHZhbCA9IEluZmluaXR5OyB9XG4gICAgICBpZiAodmFsID49IHJhZGl4KSB7IGJyZWFrIH1cbiAgICAgIGxhc3RDb2RlID0gY29kZTtcbiAgICAgIHRvdGFsID0gdG90YWwgKiByYWRpeCArIHZhbDtcbiAgICB9XG5cbiAgICBpZiAoYWxsb3dTZXBhcmF0b3JzICYmIGxhc3RDb2RlID09PSA5NSkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5wb3MgLSAxLCBcIk51bWVyaWMgc2VwYXJhdG9yIGlzIG5vdCBhbGxvd2VkIGF0IHRoZSBsYXN0IG9mIGRpZ2l0c1wiKTsgfVxuICAgIGlmICh0aGlzLnBvcyA9PT0gc3RhcnQgfHwgbGVuICE9IG51bGwgJiYgdGhpcy5wb3MgLSBzdGFydCAhPT0gbGVuKSB7IHJldHVybiBudWxsIH1cblxuICAgIHJldHVybiB0b3RhbFxuICB9O1xuXG4gIGZ1bmN0aW9uIHN0cmluZ1RvTnVtYmVyKHN0ciwgaXNMZWdhY3lPY3RhbE51bWVyaWNMaXRlcmFsKSB7XG4gICAgaWYgKGlzTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbCkge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KHN0ciwgOClcbiAgICB9XG5cbiAgICAvLyBgcGFyc2VGbG9hdCh2YWx1ZSlgIHN0b3BzIHBhcnNpbmcgYXQgdGhlIGZpcnN0IG51bWVyaWMgc2VwYXJhdG9yIHRoZW4gcmV0dXJucyBhIHdyb25nIHZhbHVlLlxuICAgIHJldHVybiBwYXJzZUZsb2F0KHN0ci5yZXBsYWNlKC9fL2csIFwiXCIpKVxuICB9XG5cbiAgZnVuY3Rpb24gc3RyaW5nVG9CaWdJbnQoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBCaWdJbnQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvLyBgQmlnSW50KHZhbHVlKWAgdGhyb3dzIHN5bnRheCBlcnJvciBpZiB0aGUgc3RyaW5nIGNvbnRhaW5zIG51bWVyaWMgc2VwYXJhdG9ycy5cbiAgICByZXR1cm4gQmlnSW50KHN0ci5yZXBsYWNlKC9fL2csIFwiXCIpKVxuICB9XG5cbiAgcHAucmVhZFJhZGl4TnVtYmVyID0gZnVuY3Rpb24ocmFkaXgpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcbiAgICB0aGlzLnBvcyArPSAyOyAvLyAweFxuICAgIHZhciB2YWwgPSB0aGlzLnJlYWRJbnQocmFkaXgpO1xuICAgIGlmICh2YWwgPT0gbnVsbCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQgKyAyLCBcIkV4cGVjdGVkIG51bWJlciBpbiByYWRpeCBcIiArIHJhZGl4KTsgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTEgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSA9PT0gMTEwKSB7XG4gICAgICB2YWwgPSBzdHJpbmdUb0JpZ0ludCh0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcykpO1xuICAgICAgKyt0aGlzLnBvcztcbiAgICB9IGVsc2UgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSkpIHsgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEubnVtLCB2YWwpXG4gIH07XG5cbiAgLy8gUmVhZCBhbiBpbnRlZ2VyLCBvY3RhbCBpbnRlZ2VyLCBvciBmbG9hdGluZy1wb2ludCBudW1iZXIuXG5cbiAgcHAucmVhZE51bWJlciA9IGZ1bmN0aW9uKHN0YXJ0c1dpdGhEb3QpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcbiAgICBpZiAoIXN0YXJ0c1dpdGhEb3QgJiYgdGhpcy5yZWFkSW50KDEwLCB1bmRlZmluZWQsIHRydWUpID09PSBudWxsKSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7IH1cbiAgICB2YXIgb2N0YWwgPSB0aGlzLnBvcyAtIHN0YXJ0ID49IDIgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHN0YXJ0KSA9PT0gNDg7XG4gICAgaWYgKG9jdGFsICYmIHRoaXMuc3RyaWN0KSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7IH1cbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgaWYgKCFvY3RhbCAmJiAhc3RhcnRzV2l0aERvdCAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTEgJiYgbmV4dCA9PT0gMTEwKSB7XG4gICAgICB2YXIgdmFsJDEgPSBzdHJpbmdUb0JpZ0ludCh0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcykpO1xuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydCh0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7IH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEubnVtLCB2YWwkMSlcbiAgICB9XG4gICAgaWYgKG9jdGFsICYmIC9bODldLy50ZXN0KHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMucG9zKSkpIHsgb2N0YWwgPSBmYWxzZTsgfVxuICAgIGlmIChuZXh0ID09PSA0NiAmJiAhb2N0YWwpIHsgLy8gJy4nXG4gICAgICArK3RoaXMucG9zO1xuICAgICAgdGhpcy5yZWFkSW50KDEwKTtcbiAgICAgIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgIH1cbiAgICBpZiAoKG5leHQgPT09IDY5IHx8IG5leHQgPT09IDEwMSkgJiYgIW9jdGFsKSB7IC8vICdlRSdcbiAgICAgIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcyk7XG4gICAgICBpZiAobmV4dCA9PT0gNDMgfHwgbmV4dCA9PT0gNDUpIHsgKyt0aGlzLnBvczsgfSAvLyAnKy0nXG4gICAgICBpZiAodGhpcy5yZWFkSW50KDEwKSA9PT0gbnVsbCkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpOyB9XG4gICAgfVxuICAgIGlmIChpc0lkZW50aWZpZXJTdGFydCh0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7IH1cblxuICAgIHZhciB2YWwgPSBzdHJpbmdUb051bWJlcih0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcyksIG9jdGFsKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLm51bSwgdmFsKVxuICB9O1xuXG4gIC8vIFJlYWQgYSBzdHJpbmcgdmFsdWUsIGludGVycHJldGluZyBiYWNrc2xhc2gtZXNjYXBlcy5cblxuICBwcC5yZWFkQ29kZVBvaW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSwgY29kZTtcblxuICAgIGlmIChjaCA9PT0gMTIzKSB7IC8vICd7J1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHZhciBjb2RlUG9zID0gKyt0aGlzLnBvcztcbiAgICAgIGNvZGUgPSB0aGlzLnJlYWRIZXhDaGFyKHRoaXMuaW5wdXQuaW5kZXhPZihcIn1cIiwgdGhpcy5wb3MpIC0gdGhpcy5wb3MpO1xuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIGlmIChjb2RlID4gMHgxMEZGRkYpIHsgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oY29kZVBvcywgXCJDb2RlIHBvaW50IG91dCBvZiBib3VuZHNcIik7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29kZSA9IHRoaXMucmVhZEhleENoYXIoNCk7XG4gICAgfVxuICAgIHJldHVybiBjb2RlXG4gIH07XG5cbiAgcHAucmVhZFN0cmluZyA9IGZ1bmN0aW9uKHF1b3RlKSB7XG4gICAgdmFyIG91dCA9IFwiXCIsIGNodW5rU3RhcnQgPSArK3RoaXMucG9zO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudFwiKTsgfVxuICAgICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICAgIGlmIChjaCA9PT0gcXVvdGUpIHsgYnJlYWsgfVxuICAgICAgaWYgKGNoID09PSA5MikgeyAvLyAnXFwnXG4gICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgICAgb3V0ICs9IHRoaXMucmVhZEVzY2FwZWRDaGFyKGZhbHNlKTtcbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gMHgyMDI4IHx8IGNoID09PSAweDIwMjkpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDEwKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpOyB9XG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgICAgdGhpcy5jdXJMaW5lKys7XG4gICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzTmV3TGluZShjaCkpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIik7IH1cbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgIH1cbiAgICB9XG4gICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MrKyk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5zdHJpbmcsIG91dClcbiAgfTtcblxuICAvLyBSZWFkcyB0ZW1wbGF0ZSBzdHJpbmcgdG9rZW5zLlxuXG4gIHZhciBJTlZBTElEX1RFTVBMQVRFX0VTQ0FQRV9FUlJPUiA9IHt9O1xuXG4gIHBwLnRyeVJlYWRUZW1wbGF0ZVRva2VuID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pblRlbXBsYXRlRWxlbWVudCA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucmVhZFRtcGxUb2tlbigpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciA9PT0gSU5WQUxJRF9URU1QTEFURV9FU0NBUEVfRVJST1IpIHtcbiAgICAgICAgdGhpcy5yZWFkSW52YWxpZFRlbXBsYXRlVG9rZW4oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuaW5UZW1wbGF0ZUVsZW1lbnQgPSBmYWxzZTtcbiAgfTtcblxuICBwcC5pbnZhbGlkU3RyaW5nVG9rZW4gPSBmdW5jdGlvbihwb3NpdGlvbiwgbWVzc2FnZSkge1xuICAgIGlmICh0aGlzLmluVGVtcGxhdGVFbGVtZW50ICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7XG4gICAgICB0aHJvdyBJTlZBTElEX1RFTVBMQVRFX0VTQ0FQRV9FUlJPUlxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJhaXNlKHBvc2l0aW9uLCBtZXNzYWdlKTtcbiAgICB9XG4gIH07XG5cbiAgcHAucmVhZFRtcGxUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBcIlwiLCBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgdGVtcGxhdGVcIik7IH1cbiAgICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgICBpZiAoY2ggPT09IDk2IHx8IGNoID09PSAzNiAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKSA9PT0gMTIzKSB7IC8vICdgJywgJyR7J1xuICAgICAgICBpZiAodGhpcy5wb3MgPT09IHRoaXMuc3RhcnQgJiYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS50ZW1wbGF0ZSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzJDEuaW52YWxpZFRlbXBsYXRlKSkge1xuICAgICAgICAgIGlmIChjaCA9PT0gMzYpIHtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IDI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLmRvbGxhckJyYWNlTClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuYmFja1F1b3RlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEudGVtcGxhdGUsIG91dClcbiAgICAgIH1cbiAgICAgIGlmIChjaCA9PT0gOTIpIHsgLy8gJ1xcJ1xuICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICAgIG91dCArPSB0aGlzLnJlYWRFc2NhcGVkQ2hhcih0cnVlKTtcbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgICAgfSBlbHNlIGlmIChpc05ld0xpbmUoY2gpKSB7XG4gICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpID09PSAxMCkgeyArK3RoaXMucG9zOyB9XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgb3V0ICs9IFwiXFxuXCI7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICAgICsrdGhpcy5jdXJMaW5lO1xuICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIH1cbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gUmVhZHMgYSB0ZW1wbGF0ZSB0b2tlbiB0byBzZWFyY2ggZm9yIHRoZSBlbmQsIHdpdGhvdXQgdmFsaWRhdGluZyBhbnkgZXNjYXBlIHNlcXVlbmNlc1xuICBwcC5yZWFkSW52YWxpZFRlbXBsYXRlVG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKDsgdGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aDsgdGhpcy5wb3MrKykge1xuICAgICAgc3dpdGNoICh0aGlzLmlucHV0W3RoaXMucG9zXSkge1xuICAgICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIiRcIjpcbiAgICAgICAgaWYgKHRoaXMuaW5wdXRbdGhpcy5wb3MgKyAxXSAhPT0gXCJ7XCIpIHsgYnJlYWsgfVxuICAgICAgICAvLyBmYWxsIHRocm91Z2hcbiAgICAgIGNhc2UgXCJgXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuaW52YWxpZFRlbXBsYXRlLCB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMucG9zKSlcblxuICAgICAgY2FzZSBcIlxcclwiOlxuICAgICAgICBpZiAodGhpcy5pbnB1dFt0aGlzLnBvcyArIDFdID09PSBcIlxcblwiKSB7ICsrdGhpcy5wb3M7IH1cbiAgICAgICAgLy8gZmFsbCB0aHJvdWdoXG4gICAgICBjYXNlIFwiXFxuXCI6IGNhc2UgXCJcXHUyMDI4XCI6IGNhc2UgXCJcXHUyMDI5XCI6XG4gICAgICAgICsrdGhpcy5jdXJMaW5lO1xuICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMucG9zICsgMTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIlVudGVybWluYXRlZCB0ZW1wbGF0ZVwiKTtcbiAgfTtcblxuICAvLyBVc2VkIHRvIHJlYWQgZXNjYXBlZCBjaGFyYWN0ZXJzXG5cbiAgcHAucmVhZEVzY2FwZWRDaGFyID0gZnVuY3Rpb24oaW5UZW1wbGF0ZSkge1xuICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMucG9zKTtcbiAgICArK3RoaXMucG9zO1xuICAgIHN3aXRjaCAoY2gpIHtcbiAgICBjYXNlIDExMDogcmV0dXJuIFwiXFxuXCIgLy8gJ24nIC0+ICdcXG4nXG4gICAgY2FzZSAxMTQ6IHJldHVybiBcIlxcclwiIC8vICdyJyAtPiAnXFxyJ1xuICAgIGNhc2UgMTIwOiByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLnJlYWRIZXhDaGFyKDIpKSAvLyAneCdcbiAgICBjYXNlIDExNzogcmV0dXJuIGNvZGVQb2ludFRvU3RyaW5nKHRoaXMucmVhZENvZGVQb2ludCgpKSAvLyAndSdcbiAgICBjYXNlIDExNjogcmV0dXJuIFwiXFx0XCIgLy8gJ3QnIC0+ICdcXHQnXG4gICAgY2FzZSA5ODogcmV0dXJuIFwiXFxiXCIgLy8gJ2InIC0+ICdcXGInXG4gICAgY2FzZSAxMTg6IHJldHVybiBcIlxcdTAwMGJcIiAvLyAndicgLT4gJ1xcdTAwMGInXG4gICAgY2FzZSAxMDI6IHJldHVybiBcIlxcZlwiIC8vICdmJyAtPiAnXFxmJ1xuICAgIGNhc2UgMTM6IGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpID09PSAxMCkgeyArK3RoaXMucG9zOyB9IC8vICdcXHJcXG4nXG4gICAgY2FzZSAxMDogLy8gJyBcXG4nXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykgeyB0aGlzLmxpbmVTdGFydCA9IHRoaXMucG9zOyArK3RoaXMuY3VyTGluZTsgfVxuICAgICAgcmV0dXJuIFwiXCJcbiAgICBjYXNlIDU2OlxuICAgIGNhc2UgNTc6XG4gICAgICBpZiAodGhpcy5zdHJpY3QpIHtcbiAgICAgICAgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oXG4gICAgICAgICAgdGhpcy5wb3MgLSAxLFxuICAgICAgICAgIFwiSW52YWxpZCBlc2NhcGUgc2VxdWVuY2VcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGluVGVtcGxhdGUpIHtcbiAgICAgICAgdmFyIGNvZGVQb3MgPSB0aGlzLnBvcyAtIDE7XG5cbiAgICAgICAgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oXG4gICAgICAgICAgY29kZVBvcyxcbiAgICAgICAgICBcIkludmFsaWQgZXNjYXBlIHNlcXVlbmNlIGluIHRlbXBsYXRlIHN0cmluZ1wiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChjaCA+PSA0OCAmJiBjaCA8PSA1NSkge1xuICAgICAgICB2YXIgb2N0YWxTdHIgPSB0aGlzLmlucHV0LnN1YnN0cih0aGlzLnBvcyAtIDEsIDMpLm1hdGNoKC9eWzAtN10rLylbMF07XG4gICAgICAgIHZhciBvY3RhbCA9IHBhcnNlSW50KG9jdGFsU3RyLCA4KTtcbiAgICAgICAgaWYgKG9jdGFsID4gMjU1KSB7XG4gICAgICAgICAgb2N0YWxTdHIgPSBvY3RhbFN0ci5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgb2N0YWwgPSBwYXJzZUludChvY3RhbFN0ciwgOCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgKz0gb2N0YWxTdHIubGVuZ3RoIC0gMTtcbiAgICAgICAgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgICAgICBpZiAoKG9jdGFsU3RyICE9PSBcIjBcIiB8fCBjaCA9PT0gNTYgfHwgY2ggPT09IDU3KSAmJiAodGhpcy5zdHJpY3QgfHwgaW5UZW1wbGF0ZSkpIHtcbiAgICAgICAgICB0aGlzLmludmFsaWRTdHJpbmdUb2tlbihcbiAgICAgICAgICAgIHRoaXMucG9zIC0gMSAtIG9jdGFsU3RyLmxlbmd0aCxcbiAgICAgICAgICAgIGluVGVtcGxhdGVcbiAgICAgICAgICAgICAgPyBcIk9jdGFsIGxpdGVyYWwgaW4gdGVtcGxhdGUgc3RyaW5nXCJcbiAgICAgICAgICAgICAgOiBcIk9jdGFsIGxpdGVyYWwgaW4gc3RyaWN0IG1vZGVcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUob2N0YWwpXG4gICAgICB9XG4gICAgICBpZiAoaXNOZXdMaW5lKGNoKSkge1xuICAgICAgICAvLyBVbmljb2RlIG5ldyBsaW5lIGNoYXJhY3RlcnMgYWZ0ZXIgXFwgZ2V0IHJlbW92ZWQgZnJvbSBvdXRwdXQgaW4gYm90aFxuICAgICAgICAvLyB0ZW1wbGF0ZSBsaXRlcmFscyBhbmQgc3RyaW5nc1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykgeyB0aGlzLmxpbmVTdGFydCA9IHRoaXMucG9zOyArK3RoaXMuY3VyTGluZTsgfVxuICAgICAgICByZXR1cm4gXCJcIlxuICAgICAgfVxuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpXG4gICAgfVxuICB9O1xuXG4gIC8vIFVzZWQgdG8gcmVhZCBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlcyAoJ1xceCcsICdcXHUnLCAnXFxVJykuXG5cbiAgcHAucmVhZEhleENoYXIgPSBmdW5jdGlvbihsZW4pIHtcbiAgICB2YXIgY29kZVBvcyA9IHRoaXMucG9zO1xuICAgIHZhciBuID0gdGhpcy5yZWFkSW50KDE2LCBsZW4pO1xuICAgIGlmIChuID09PSBudWxsKSB7IHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKGNvZGVQb3MsIFwiQmFkIGNoYXJhY3RlciBlc2NhcGUgc2VxdWVuY2VcIik7IH1cbiAgICByZXR1cm4gblxuICB9O1xuXG4gIC8vIFJlYWQgYW4gaWRlbnRpZmllciwgYW5kIHJldHVybiBpdCBhcyBhIHN0cmluZy4gU2V0cyBgdGhpcy5jb250YWluc0VzY2BcbiAgLy8gdG8gd2hldGhlciB0aGUgd29yZCBjb250YWluZWQgYSAnXFx1JyBlc2NhcGUuXG4gIC8vXG4gIC8vIEluY3JlbWVudGFsbHkgYWRkcyBvbmx5IGVzY2FwZWQgY2hhcnMsIGFkZGluZyBvdGhlciBjaHVua3MgYXMtaXNcbiAgLy8gYXMgYSBtaWNyby1vcHRpbWl6YXRpb24uXG5cbiAgcHAucmVhZFdvcmQxID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jb250YWluc0VzYyA9IGZhbHNlO1xuICAgIHZhciB3b3JkID0gXCJcIiwgZmlyc3QgPSB0cnVlLCBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgdmFyIGFzdHJhbCA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2O1xuICAgIHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgICB2YXIgY2ggPSB0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCk7XG4gICAgICBpZiAoaXNJZGVudGlmaWVyQ2hhcihjaCwgYXN0cmFsKSkge1xuICAgICAgICB0aGlzLnBvcyArPSBjaCA8PSAweGZmZmYgPyAxIDogMjtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDkyKSB7IC8vIFwiXFxcIlxuICAgICAgICB0aGlzLmNvbnRhaW5zRXNjID0gdHJ1ZTtcbiAgICAgICAgd29yZCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgICAgdmFyIGVzY1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcykgIT09IDExNykgLy8gXCJ1XCJcbiAgICAgICAgICB7IHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKHRoaXMucG9zLCBcIkV4cGVjdGluZyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZSBcXFxcdVhYWFhcIik7IH1cbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgdmFyIGVzYyA9IHRoaXMucmVhZENvZGVQb2ludCgpO1xuICAgICAgICBpZiAoIShmaXJzdCA/IGlzSWRlbnRpZmllclN0YXJ0IDogaXNJZGVudGlmaWVyQ2hhcikoZXNjLCBhc3RyYWwpKVxuICAgICAgICAgIHsgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oZXNjU3RhcnQsIFwiSW52YWxpZCBVbmljb2RlIGVzY2FwZVwiKTsgfVxuICAgICAgICB3b3JkICs9IGNvZGVQb2ludFRvU3RyaW5nKGVzYyk7XG4gICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBmaXJzdCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gd29yZCArIHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpXG4gIH07XG5cbiAgLy8gUmVhZCBhbiBpZGVudGlmaWVyIG9yIGtleXdvcmQgdG9rZW4uIFdpbGwgY2hlY2sgZm9yIHJlc2VydmVkXG4gIC8vIHdvcmRzIHdoZW4gbmVjZXNzYXJ5LlxuXG4gIHBwLnJlYWRXb3JkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHdvcmQgPSB0aGlzLnJlYWRXb3JkMSgpO1xuICAgIHZhciB0eXBlID0gdHlwZXMkMS5uYW1lO1xuICAgIGlmICh0aGlzLmtleXdvcmRzLnRlc3Qod29yZCkpIHtcbiAgICAgIHR5cGUgPSBrZXl3b3Jkc1t3b3JkXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZSwgd29yZClcbiAgfTtcblxuICAvLyBBY29ybiBpcyBhIHRpbnksIGZhc3QgSmF2YVNjcmlwdCBwYXJzZXIgd3JpdHRlbiBpbiBKYXZhU2NyaXB0LlxuICAvL1xuICAvLyBBY29ybiB3YXMgd3JpdHRlbiBieSBNYXJpam4gSGF2ZXJiZWtlLCBJbmd2YXIgU3RlcGFueWFuLCBhbmRcbiAgLy8gdmFyaW91cyBjb250cmlidXRvcnMgYW5kIHJlbGVhc2VkIHVuZGVyIGFuIE1JVCBsaWNlbnNlLlxuICAvL1xuICAvLyBHaXQgcmVwb3NpdG9yaWVzIGZvciBBY29ybiBhcmUgYXZhaWxhYmxlIGF0XG4gIC8vXG4gIC8vICAgICBodHRwOi8vbWFyaWpuaGF2ZXJiZWtlLm5sL2dpdC9hY29yblxuICAvLyAgICAgaHR0cHM6Ly9naXRodWIuY29tL2Fjb3JuanMvYWNvcm4uZ2l0XG4gIC8vXG4gIC8vIFBsZWFzZSB1c2UgdGhlIFtnaXRodWIgYnVnIHRyYWNrZXJdW2doYnRdIHRvIHJlcG9ydCBpc3N1ZXMuXG4gIC8vXG4gIC8vIFtnaGJ0XTogaHR0cHM6Ly9naXRodWIuY29tL2Fjb3JuanMvYWNvcm4vaXNzdWVzXG4gIC8vXG4gIC8vIFt3YWxrXTogdXRpbC93YWxrLmpzXG5cblxuICB2YXIgdmVyc2lvbiA9IFwiOC4xNC4xXCI7XG5cbiAgUGFyc2VyLmFjb3JuID0ge1xuICAgIFBhcnNlcjogUGFyc2VyLFxuICAgIHZlcnNpb246IHZlcnNpb24sXG4gICAgZGVmYXVsdE9wdGlvbnM6IGRlZmF1bHRPcHRpb25zLFxuICAgIFBvc2l0aW9uOiBQb3NpdGlvbixcbiAgICBTb3VyY2VMb2NhdGlvbjogU291cmNlTG9jYXRpb24sXG4gICAgZ2V0TGluZUluZm86IGdldExpbmVJbmZvLFxuICAgIE5vZGU6IE5vZGUsXG4gICAgVG9rZW5UeXBlOiBUb2tlblR5cGUsXG4gICAgdG9rVHlwZXM6IHR5cGVzJDEsXG4gICAga2V5d29yZFR5cGVzOiBrZXl3b3JkcyxcbiAgICBUb2tDb250ZXh0OiBUb2tDb250ZXh0LFxuICAgIHRva0NvbnRleHRzOiB0eXBlcyxcbiAgICBpc0lkZW50aWZpZXJDaGFyOiBpc0lkZW50aWZpZXJDaGFyLFxuICAgIGlzSWRlbnRpZmllclN0YXJ0OiBpc0lkZW50aWZpZXJTdGFydCxcbiAgICBUb2tlbjogVG9rZW4sXG4gICAgaXNOZXdMaW5lOiBpc05ld0xpbmUsXG4gICAgbGluZUJyZWFrOiBsaW5lQnJlYWssXG4gICAgbGluZUJyZWFrRzogbGluZUJyZWFrRyxcbiAgICBub25BU0NJSXdoaXRlc3BhY2U6IG5vbkFTQ0lJd2hpdGVzcGFjZVxuICB9O1xuXG4gIC8vIFRoZSBtYWluIGV4cG9ydGVkIGludGVyZmFjZSAodW5kZXIgYHNlbGYuYWNvcm5gIHdoZW4gaW4gdGhlXG4gIC8vIGJyb3dzZXIpIGlzIGEgYHBhcnNlYCBmdW5jdGlvbiB0aGF0IHRha2VzIGEgY29kZSBzdHJpbmcgYW5kIHJldHVybnNcbiAgLy8gYW4gYWJzdHJhY3Qgc3ludGF4IHRyZWUgYXMgc3BlY2lmaWVkIGJ5IHRoZSBbRVNUcmVlIHNwZWNdW2VzdHJlZV0uXG4gIC8vXG4gIC8vIFtlc3RyZWVdOiBodHRwczovL2dpdGh1Yi5jb20vZXN0cmVlL2VzdHJlZVxuXG4gIGZ1bmN0aW9uIHBhcnNlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFBhcnNlci5wYXJzZShpbnB1dCwgb3B0aW9ucylcbiAgfVxuXG4gIC8vIFRoaXMgZnVuY3Rpb24gdHJpZXMgdG8gcGFyc2UgYSBzaW5nbGUgZXhwcmVzc2lvbiBhdCBhIGdpdmVuXG4gIC8vIG9mZnNldCBpbiBhIHN0cmluZy4gVXNlZnVsIGZvciBwYXJzaW5nIG1peGVkLWxhbmd1YWdlIGZvcm1hdHNcbiAgLy8gdGhhdCBlbWJlZCBKYXZhU2NyaXB0IGV4cHJlc3Npb25zLlxuXG4gIGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbkF0KGlucHV0LCBwb3MsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gUGFyc2VyLnBhcnNlRXhwcmVzc2lvbkF0KGlucHV0LCBwb3MsIG9wdGlvbnMpXG4gIH1cblxuICAvLyBBY29ybiBpcyBvcmdhbml6ZWQgYXMgYSB0b2tlbml6ZXIgYW5kIGEgcmVjdXJzaXZlLWRlc2NlbnQgcGFyc2VyLlxuICAvLyBUaGUgYHRva2VuaXplcmAgZXhwb3J0IHByb3ZpZGVzIGFuIGludGVyZmFjZSB0byB0aGUgdG9rZW5pemVyLlxuXG4gIGZ1bmN0aW9uIHRva2VuaXplcihpbnB1dCwgb3B0aW9ucykge1xuICAgIHJldHVybiBQYXJzZXIudG9rZW5pemVyKGlucHV0LCBvcHRpb25zKVxuICB9XG5cbiAgZXhwb3J0cy5Ob2RlID0gTm9kZTtcbiAgZXhwb3J0cy5QYXJzZXIgPSBQYXJzZXI7XG4gIGV4cG9ydHMuUG9zaXRpb24gPSBQb3NpdGlvbjtcbiAgZXhwb3J0cy5Tb3VyY2VMb2NhdGlvbiA9IFNvdXJjZUxvY2F0aW9uO1xuICBleHBvcnRzLlRva0NvbnRleHQgPSBUb2tDb250ZXh0O1xuICBleHBvcnRzLlRva2VuID0gVG9rZW47XG4gIGV4cG9ydHMuVG9rZW5UeXBlID0gVG9rZW5UeXBlO1xuICBleHBvcnRzLmRlZmF1bHRPcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gIGV4cG9ydHMuZ2V0TGluZUluZm8gPSBnZXRMaW5lSW5mbztcbiAgZXhwb3J0cy5pc0lkZW50aWZpZXJDaGFyID0gaXNJZGVudGlmaWVyQ2hhcjtcbiAgZXhwb3J0cy5pc0lkZW50aWZpZXJTdGFydCA9IGlzSWRlbnRpZmllclN0YXJ0O1xuICBleHBvcnRzLmlzTmV3TGluZSA9IGlzTmV3TGluZTtcbiAgZXhwb3J0cy5rZXl3b3JkVHlwZXMgPSBrZXl3b3JkcztcbiAgZXhwb3J0cy5saW5lQnJlYWsgPSBsaW5lQnJlYWs7XG4gIGV4cG9ydHMubGluZUJyZWFrRyA9IGxpbmVCcmVha0c7XG4gIGV4cG9ydHMubm9uQVNDSUl3aGl0ZXNwYWNlID0gbm9uQVNDSUl3aGl0ZXNwYWNlO1xuICBleHBvcnRzLnBhcnNlID0gcGFyc2U7XG4gIGV4cG9ydHMucGFyc2VFeHByZXNzaW9uQXQgPSBwYXJzZUV4cHJlc3Npb25BdDtcbiAgZXhwb3J0cy50b2tDb250ZXh0cyA9IHR5cGVzO1xuICBleHBvcnRzLnRva1R5cGVzID0gdHlwZXMkMTtcbiAgZXhwb3J0cy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XG4gIGV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG5cbn0pKTtcbiJdLCJuYW1lcyI6WyJnbG9iYWwiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsImdsb2JhbFRoaXMiLCJzZWxmIiwiYWNvcm4iLCJhc3RyYWxJZGVudGlmaWVyQ29kZXMiLCJhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcyIsIm5vbkFTQ0lJaWRlbnRpZmllckNoYXJzIiwibm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyIsInJlc2VydmVkV29yZHMiLCJzdHJpY3QiLCJzdHJpY3RCaW5kIiwiZWNtYTVBbmRMZXNzS2V5d29yZHMiLCJrZXl3b3JkcyQxIiwia2V5d29yZFJlbGF0aW9uYWxPcGVyYXRvciIsIm5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0IiwiUmVnRXhwIiwibm9uQVNDSUlpZGVudGlmaWVyIiwiaXNJbkFzdHJhbFNldCIsImNvZGUiLCJzZXQiLCJwb3MiLCJpIiwibGVuZ3RoIiwiaXNJZGVudGlmaWVyU3RhcnQiLCJhc3RyYWwiLCJ0ZXN0IiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiaXNJZGVudGlmaWVyQ2hhciIsIlRva2VuVHlwZSIsImxhYmVsIiwiY29uZiIsImtleXdvcmQiLCJiZWZvcmVFeHByIiwic3RhcnRzRXhwciIsImlzTG9vcCIsImlzQXNzaWduIiwicHJlZml4IiwicG9zdGZpeCIsImJpbm9wIiwidXBkYXRlQ29udGV4dCIsIm5hbWUiLCJwcmVjIiwia2V5d29yZHMiLCJrdyIsIm9wdGlvbnMiLCJ0eXBlcyQxIiwibnVtIiwicmVnZXhwIiwic3RyaW5nIiwicHJpdmF0ZUlkIiwiZW9mIiwiYnJhY2tldEwiLCJicmFja2V0UiIsImJyYWNlTCIsImJyYWNlUiIsInBhcmVuTCIsInBhcmVuUiIsImNvbW1hIiwic2VtaSIsImNvbG9uIiwiZG90IiwicXVlc3Rpb24iLCJxdWVzdGlvbkRvdCIsImFycm93IiwidGVtcGxhdGUiLCJpbnZhbGlkVGVtcGxhdGUiLCJlbGxpcHNpcyIsImJhY2tRdW90ZSIsImRvbGxhckJyYWNlTCIsImVxIiwiYXNzaWduIiwiaW5jRGVjIiwibG9naWNhbE9SIiwibG9naWNhbEFORCIsImJpdHdpc2VPUiIsImJpdHdpc2VYT1IiLCJiaXR3aXNlQU5EIiwiZXF1YWxpdHkiLCJyZWxhdGlvbmFsIiwiYml0U2hpZnQiLCJwbHVzTWluIiwibW9kdWxvIiwic3RhciIsInNsYXNoIiwic3RhcnN0YXIiLCJjb2FsZXNjZSIsIl9icmVhayIsIl9jYXNlIiwiX2NhdGNoIiwiX2NvbnRpbnVlIiwiX2RlYnVnZ2VyIiwiX2RlZmF1bHQiLCJfZG8iLCJfZWxzZSIsIl9maW5hbGx5IiwiX2ZvciIsIl9mdW5jdGlvbiIsIl9pZiIsIl9yZXR1cm4iLCJfc3dpdGNoIiwiX3Rocm93IiwiX3RyeSIsIl92YXIiLCJfY29uc3QiLCJfd2hpbGUiLCJfd2l0aCIsIl9uZXciLCJfdGhpcyIsIl9zdXBlciIsIl9jbGFzcyIsIl9leHRlbmRzIiwiX2V4cG9ydCIsIl9pbXBvcnQiLCJfbnVsbCIsIl90cnVlIiwiX2ZhbHNlIiwiX2luIiwiX2luc3RhbmNlb2YiLCJfdHlwZW9mIiwiX3ZvaWQiLCJfZGVsZXRlIiwibGluZUJyZWFrIiwibGluZUJyZWFrRyIsInNvdXJjZSIsImlzTmV3TGluZSIsIm5leHRMaW5lQnJlYWsiLCJmcm9tIiwiZW5kIiwibmV4dCIsImNoYXJDb2RlQXQiLCJub25BU0NJSXdoaXRlc3BhY2UiLCJza2lwV2hpdGVTcGFjZSIsInJlZiIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwidG9TdHJpbmciLCJoYXNPd24iLCJvYmoiLCJwcm9wTmFtZSIsImNhbGwiLCJpc0FycmF5IiwiQXJyYXkiLCJyZWdleHBDYWNoZSIsImNyZWF0ZSIsIndvcmRzUmVnZXhwIiwid29yZHMiLCJyZXBsYWNlIiwiY29kZVBvaW50VG9TdHJpbmciLCJsb25lU3Vycm9nYXRlIiwiUG9zaXRpb24iLCJsaW5lIiwiY29sIiwiY29sdW1uIiwib2Zmc2V0IiwibiIsIlNvdXJjZUxvY2F0aW9uIiwicCIsInN0YXJ0Iiwic291cmNlRmlsZSIsImdldExpbmVJbmZvIiwiaW5wdXQiLCJjdXIiLCJuZXh0QnJlYWsiLCJkZWZhdWx0T3B0aW9ucyIsImVjbWFWZXJzaW9uIiwic291cmNlVHlwZSIsIm9uSW5zZXJ0ZWRTZW1pY29sb24iLCJvblRyYWlsaW5nQ29tbWEiLCJhbGxvd1Jlc2VydmVkIiwiYWxsb3dSZXR1cm5PdXRzaWRlRnVuY3Rpb24iLCJhbGxvd0ltcG9ydEV4cG9ydEV2ZXJ5d2hlcmUiLCJhbGxvd0F3YWl0T3V0c2lkZUZ1bmN0aW9uIiwiYWxsb3dTdXBlck91dHNpZGVNZXRob2QiLCJhbGxvd0hhc2hCYW5nIiwiY2hlY2tQcml2YXRlRmllbGRzIiwibG9jYXRpb25zIiwib25Ub2tlbiIsIm9uQ29tbWVudCIsInJhbmdlcyIsInByb2dyYW0iLCJkaXJlY3RTb3VyY2VGaWxlIiwicHJlc2VydmVQYXJlbnMiLCJ3YXJuZWRBYm91dEVjbWFWZXJzaW9uIiwiZ2V0T3B0aW9ucyIsIm9wdHMiLCJvcHQiLCJjb25zb2xlIiwid2FybiIsInRva2VucyIsInRva2VuIiwicHVzaCIsInB1c2hDb21tZW50IiwiYXJyYXkiLCJibG9jayIsInRleHQiLCJzdGFydExvYyIsImVuZExvYyIsImNvbW1lbnQiLCJ0eXBlIiwidmFsdWUiLCJsb2MiLCJyYW5nZSIsIlNDT1BFX1RPUCIsIlNDT1BFX0ZVTkNUSU9OIiwiU0NPUEVfQVNZTkMiLCJTQ09QRV9HRU5FUkFUT1IiLCJTQ09QRV9BUlJPVyIsIlNDT1BFX1NJTVBMRV9DQVRDSCIsIlNDT1BFX1NVUEVSIiwiU0NPUEVfRElSRUNUX1NVUEVSIiwiU0NPUEVfQ0xBU1NfU1RBVElDX0JMT0NLIiwiU0NPUEVfQ0xBU1NfRklFTERfSU5JVCIsIlNDT1BFX1ZBUiIsImZ1bmN0aW9uRmxhZ3MiLCJhc3luYyIsImdlbmVyYXRvciIsIkJJTkRfTk9ORSIsIkJJTkRfVkFSIiwiQklORF9MRVhJQ0FMIiwiQklORF9GVU5DVElPTiIsIkJJTkRfU0lNUExFX0NBVENIIiwiQklORF9PVVRTSURFIiwiUGFyc2VyIiwic3RhcnRQb3MiLCJyZXNlcnZlZCIsInJlc2VydmVkU3RyaWN0IiwicmVzZXJ2ZWRXb3Jkc1N0cmljdCIsInJlc2VydmVkV29yZHNTdHJpY3RCaW5kIiwiY29udGFpbnNFc2MiLCJsaW5lU3RhcnQiLCJsYXN0SW5kZXhPZiIsImN1ckxpbmUiLCJzbGljZSIsInNwbGl0IiwiY3VyUG9zaXRpb24iLCJsYXN0VG9rRW5kTG9jIiwibGFzdFRva1N0YXJ0TG9jIiwibGFzdFRva1N0YXJ0IiwibGFzdFRva0VuZCIsImNvbnRleHQiLCJpbml0aWFsQ29udGV4dCIsImV4cHJBbGxvd2VkIiwiaW5Nb2R1bGUiLCJzdHJpY3REaXJlY3RpdmUiLCJwb3RlbnRpYWxBcnJvd0F0IiwicG90ZW50aWFsQXJyb3dJbkZvckF3YWl0IiwieWllbGRQb3MiLCJhd2FpdFBvcyIsImF3YWl0SWRlbnRQb3MiLCJsYWJlbHMiLCJ1bmRlZmluZWRFeHBvcnRzIiwic2tpcExpbmVDb21tZW50Iiwic2NvcGVTdGFjayIsImVudGVyU2NvcGUiLCJyZWdleHBTdGF0ZSIsInByaXZhdGVOYW1lU3RhY2siLCJwcm90b3R5cGVBY2Nlc3NvcnMiLCJpbkZ1bmN0aW9uIiwiY29uZmlndXJhYmxlIiwiaW5HZW5lcmF0b3IiLCJpbkFzeW5jIiwiY2FuQXdhaXQiLCJhbGxvd1N1cGVyIiwiYWxsb3dEaXJlY3RTdXBlciIsInRyZWF0RnVuY3Rpb25zQXNWYXIiLCJhbGxvd05ld0RvdFRhcmdldCIsImluQ2xhc3NTdGF0aWNCbG9jayIsInBhcnNlIiwibm9kZSIsInN0YXJ0Tm9kZSIsIm5leHRUb2tlbiIsInBhcnNlVG9wTGV2ZWwiLCJnZXQiLCJjdXJyZW50VmFyU2NvcGUiLCJmbGFncyIsImN1cnJlbnRUaGlzU2NvcGUiLCJ0cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZSIsImN1cnJlbnRTY29wZSIsImV4dGVuZCIsInBsdWdpbnMiLCJsZW4iLCJhcmd1bWVudHMiLCJjbHMiLCJwYXJzZUV4cHJlc3Npb25BdCIsInBhcnNlciIsInBhcnNlRXhwcmVzc2lvbiIsInRva2VuaXplciIsImRlZmluZVByb3BlcnRpZXMiLCJwcCQ5IiwibGl0ZXJhbCIsImxhc3RJbmRleCIsImV4ZWMiLCJtYXRjaCIsInNwYWNlQWZ0ZXIiLCJpbmRleCIsImNoYXJBdCIsImVhdCIsImlzQ29udGV4dHVhbCIsImVhdENvbnRleHR1YWwiLCJleHBlY3RDb250ZXh0dWFsIiwidW5leHBlY3RlZCIsImNhbkluc2VydFNlbWljb2xvbiIsImluc2VydFNlbWljb2xvbiIsInNlbWljb2xvbiIsImFmdGVyVHJhaWxpbmdDb21tYSIsInRva1R5cGUiLCJub3ROZXh0IiwiZXhwZWN0IiwicmFpc2UiLCJEZXN0cnVjdHVyaW5nRXJyb3JzIiwic2hvcnRoYW5kQXNzaWduIiwidHJhaWxpbmdDb21tYSIsInBhcmVudGhlc2l6ZWRBc3NpZ24iLCJwYXJlbnRoZXNpemVkQmluZCIsImRvdWJsZVByb3RvIiwiY2hlY2tQYXR0ZXJuRXJyb3JzIiwicmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyIsInJhaXNlUmVjb3ZlcmFibGUiLCJwYXJlbnMiLCJjaGVja0V4cHJlc3Npb25FcnJvcnMiLCJhbmRUaHJvdyIsImNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcyIsImlzU2ltcGxlQXNzaWduVGFyZ2V0IiwiZXhwciIsImV4cHJlc3Npb24iLCJwcCQ4IiwiYm9keSIsInN0bXQiLCJwYXJzZVN0YXRlbWVudCIsImxpc3QiLCJrZXlzIiwiYWRhcHREaXJlY3RpdmVQcm9sb2d1ZSIsImZpbmlzaE5vZGUiLCJsb29wTGFiZWwiLCJraW5kIiwic3dpdGNoTGFiZWwiLCJpc0xldCIsInNraXAiLCJuZXh0Q2giLCJpZGVudCIsImlzQXN5bmNGdW5jdGlvbiIsImFmdGVyIiwidG9wTGV2ZWwiLCJzdGFydHR5cGUiLCJwYXJzZUJyZWFrQ29udGludWVTdGF0ZW1lbnQiLCJwYXJzZURlYnVnZ2VyU3RhdGVtZW50IiwicGFyc2VEb1N0YXRlbWVudCIsInBhcnNlRm9yU3RhdGVtZW50IiwicGFyc2VGdW5jdGlvblN0YXRlbWVudCIsInBhcnNlQ2xhc3MiLCJwYXJzZUlmU3RhdGVtZW50IiwicGFyc2VSZXR1cm5TdGF0ZW1lbnQiLCJwYXJzZVN3aXRjaFN0YXRlbWVudCIsInBhcnNlVGhyb3dTdGF0ZW1lbnQiLCJwYXJzZVRyeVN0YXRlbWVudCIsInBhcnNlVmFyU3RhdGVtZW50IiwicGFyc2VXaGlsZVN0YXRlbWVudCIsInBhcnNlV2l0aFN0YXRlbWVudCIsInBhcnNlQmxvY2siLCJwYXJzZUVtcHR5U3RhdGVtZW50IiwicGFyc2VFeHByZXNzaW9uU3RhdGVtZW50IiwicGFyc2VJbXBvcnQiLCJwYXJzZUV4cG9ydCIsIm1heWJlTmFtZSIsInBhcnNlTGFiZWxlZFN0YXRlbWVudCIsImlzQnJlYWsiLCJwYXJzZUlkZW50IiwibGFiIiwicG9wIiwicGFyc2VQYXJlbkV4cHJlc3Npb24iLCJhd2FpdEF0IiwicGFyc2VGb3IiLCJpbml0JDEiLCJwYXJzZVZhciIsImRlY2xhcmF0aW9ucyIsImF3YWl0IiwicGFyc2VGb3JJbiIsInN0YXJ0c1dpdGhMZXQiLCJpc0Zvck9mIiwiaW5pdFBvcyIsImluaXQiLCJwYXJzZUV4cHJTdWJzY3JpcHRzIiwidG9Bc3NpZ25hYmxlIiwiY2hlY2tMVmFsUGF0dGVybiIsImlzQXN5bmMiLCJkZWNsYXJhdGlvblBvc2l0aW9uIiwicGFyc2VGdW5jdGlvbiIsIkZVTkNfU1RBVEVNRU5UIiwiRlVOQ19IQU5HSU5HX1NUQVRFTUVOVCIsImNvbnNlcXVlbnQiLCJhbHRlcm5hdGUiLCJhcmd1bWVudCIsImRpc2NyaW1pbmFudCIsImNhc2VzIiwic2F3RGVmYXVsdCIsImlzQ2FzZSIsImV4aXRTY29wZSIsImVtcHR5JDEiLCJwYXJzZUNhdGNoQ2xhdXNlUGFyYW0iLCJwYXJhbSIsInBhcnNlQmluZGluZ0F0b20iLCJzaW1wbGUiLCJoYW5kbGVyIiwiY2xhdXNlIiwiZmluYWxpemVyIiwiYWxsb3dNaXNzaW5nSW5pdGlhbGl6ZXIiLCJvYmplY3QiLCJpJDEiLCJsYWJlbCQxIiwic3RhdGVtZW50U3RhcnQiLCJpbmRleE9mIiwiY3JlYXRlTmV3TGV4aWNhbFNjb3BlIiwiZXhpdFN0cmljdCIsInVwZGF0ZSIsImlzRm9ySW4iLCJpZCIsImxlZnQiLCJyaWdodCIsInBhcnNlTWF5YmVBc3NpZ24iLCJpc0ZvciIsImRlY2wiLCJwYXJzZVZhcklkIiwiRlVOQ19OVUxMQUJMRV9JRCIsInN0YXRlbWVudCIsImFsbG93RXhwcmVzc2lvbkJvZHkiLCJmb3JJbml0IiwiaW5pdEZ1bmN0aW9uIiwiY2hlY2tMVmFsU2ltcGxlIiwib2xkWWllbGRQb3MiLCJvbGRBd2FpdFBvcyIsIm9sZEF3YWl0SWRlbnRQb3MiLCJwYXJzZUZ1bmN0aW9uUGFyYW1zIiwicGFyc2VGdW5jdGlvbkJvZHkiLCJwYXJhbXMiLCJwYXJzZUJpbmRpbmdMaXN0IiwiaXNTdGF0ZW1lbnQiLCJvbGRTdHJpY3QiLCJwYXJzZUNsYXNzSWQiLCJwYXJzZUNsYXNzU3VwZXIiLCJwcml2YXRlTmFtZU1hcCIsImVudGVyQ2xhc3NCb2R5IiwiY2xhc3NCb2R5IiwiaGFkQ29uc3RydWN0b3IiLCJlbGVtZW50IiwicGFyc2VDbGFzc0VsZW1lbnQiLCJzdXBlckNsYXNzIiwia2V5IiwiaXNQcml2YXRlTmFtZUNvbmZsaWN0ZWQiLCJleGl0Q2xhc3NCb2R5IiwiY29uc3RydWN0b3JBbGxvd3NTdXBlciIsImtleU5hbWUiLCJpc0dlbmVyYXRvciIsImlzU3RhdGljIiwicGFyc2VDbGFzc1N0YXRpY0Jsb2NrIiwiaXNDbGFzc0VsZW1lbnROYW1lU3RhcnQiLCJzdGF0aWMiLCJsYXN0VmFsdWUiLCJjb21wdXRlZCIsInN0YXJ0Tm9kZUF0IiwicGFyc2VDbGFzc0VsZW1lbnROYW1lIiwiaXNDb25zdHJ1Y3RvciIsImNoZWNrS2V5TmFtZSIsImFsbG93c0RpcmVjdFN1cGVyIiwicGFyc2VDbGFzc01ldGhvZCIsInBhcnNlQ2xhc3NGaWVsZCIsInBhcnNlUHJpdmF0ZUlkZW50IiwicGFyc2VQcm9wZXJ0eU5hbWUiLCJtZXRob2QiLCJwYXJzZU1ldGhvZCIsImZpZWxkIiwib2xkTGFiZWxzIiwiZGVjbGFyZWQiLCJ1c2VkIiwicGFyZW50IiwiY3VyciIsInBhcnNlRXhwb3J0QWxsRGVjbGFyYXRpb24iLCJleHBvcnRlZCIsInBhcnNlTW9kdWxlRXhwb3J0TmFtZSIsImNoZWNrRXhwb3J0IiwicGFyc2VFeHByQXRvbSIsImF0dHJpYnV0ZXMiLCJwYXJzZVdpdGhDbGF1c2UiLCJkZWNsYXJhdGlvbiIsInBhcnNlRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uIiwic2hvdWxkUGFyc2VFeHBvcnRTdGF0ZW1lbnQiLCJwYXJzZUV4cG9ydERlY2xhcmF0aW9uIiwiY2hlY2tWYXJpYWJsZUV4cG9ydCIsInNwZWNpZmllcnMiLCJwYXJzZUV4cG9ydFNwZWNpZmllcnMiLCJzcGVjIiwiY2hlY2tVbnJlc2VydmVkIiwibG9jYWwiLCJjaGVja0xvY2FsRXhwb3J0IiwiZk5vZGUiLCJjTm9kZSIsImNoZWNrUGF0dGVybkV4cG9ydCIsInBhdCIsInByb3BlcnRpZXMiLCJwcm9wIiwibGlzdCQxIiwiZWxlbWVudHMiLCJlbHQiLCJkZWNscyIsInBhcnNlRXhwb3J0U3BlY2lmaWVyIiwibm9kZXMiLCJmaXJzdCIsInBhcnNlSW1wb3J0U3BlY2lmaWVycyIsInBhcnNlSW1wb3J0U3BlY2lmaWVyIiwiaW1wb3J0ZWQiLCJwYXJzZUltcG9ydERlZmF1bHRTcGVjaWZpZXIiLCJwYXJzZUltcG9ydE5hbWVzcGFjZVNwZWNpZmllciIsImF0dHJpYnV0ZUtleXMiLCJhdHRyIiwicGFyc2VJbXBvcnRBdHRyaWJ1dGUiLCJzdHJpbmdMaXRlcmFsIiwicGFyc2VMaXRlcmFsIiwic3RhdGVtZW50cyIsImlzRGlyZWN0aXZlQ2FuZGlkYXRlIiwiZGlyZWN0aXZlIiwicmF3IiwicHAkNyIsImlzQmluZGluZyIsInRvQXNzaWduYWJsZUxpc3QiLCJvcGVyYXRvciIsImV4cHJMaXN0IiwibGFzdCIsInBhcnNlU3ByZWFkIiwicGFyc2VSZXN0QmluZGluZyIsInBhcnNlT2JqIiwiY2xvc2UiLCJhbGxvd0VtcHR5IiwiYWxsb3dUcmFpbGluZ0NvbW1hIiwiYWxsb3dNb2RpZmllcnMiLCJlbHRzIiwicmVzdCIsInBhcnNlQmluZGluZ0xpc3RJdGVtIiwicGFyc2VBc3NpZ25hYmxlTGlzdEl0ZW0iLCJlbGVtIiwicGFyc2VNYXliZURlZmF1bHQiLCJiaW5kaW5nVHlwZSIsImNoZWNrQ2xhc2hlcyIsImlzQmluZCIsImRlY2xhcmVOYW1lIiwiY2hlY2tMVmFsSW5uZXJQYXR0ZXJuIiwiVG9rQ29udGV4dCIsImlzRXhwciIsInByZXNlcnZlU3BhY2UiLCJvdmVycmlkZSIsInR5cGVzIiwiYl9zdGF0IiwiYl9leHByIiwiYl90bXBsIiwicF9zdGF0IiwicF9leHByIiwicV90bXBsIiwidHJ5UmVhZFRlbXBsYXRlVG9rZW4iLCJmX3N0YXQiLCJmX2V4cHIiLCJmX2V4cHJfZ2VuIiwiZl9nZW4iLCJwcCQ2IiwiY3VyQ29udGV4dCIsImJyYWNlSXNCbG9jayIsInByZXZUeXBlIiwiaW5HZW5lcmF0b3JDb250ZXh0Iiwib3ZlcnJpZGVDb250ZXh0IiwidG9rZW5DdHgiLCJvdXQiLCJzdGF0ZW1lbnRQYXJlbnMiLCJhbGxvd2VkIiwicHAkNSIsImNoZWNrUHJvcENsYXNoIiwicHJvcEhhc2giLCJzaG9ydGhhbmQiLCJwcm90byIsIm90aGVyIiwicmVkZWZpbml0aW9uIiwiZXhwcmVzc2lvbnMiLCJhZnRlckxlZnRQYXJzZSIsInBhcnNlWWllbGQiLCJvd25EZXN0cnVjdHVyaW5nRXJyb3JzIiwib2xkUGFyZW5Bc3NpZ24iLCJvbGRUcmFpbGluZ0NvbW1hIiwib2xkRG91YmxlUHJvdG8iLCJwYXJzZU1heWJlQ29uZGl0aW9uYWwiLCJwYXJzZUV4cHJPcHMiLCJwYXJzZU1heWJlVW5hcnkiLCJwYXJzZUV4cHJPcCIsImxlZnRTdGFydFBvcyIsImxlZnRTdGFydExvYyIsIm1pblByZWMiLCJsb2dpY2FsIiwib3AiLCJidWlsZEJpbmFyeSIsInNhd1VuYXJ5IiwicGFyc2VBd2FpdCIsImlzTG9jYWxWYXJpYWJsZUFjY2VzcyIsImlzUHJpdmF0ZUZpZWxkQWNjZXNzIiwibm9kZSQxIiwicHJvcGVydHkiLCJyZXN1bHQiLCJwYXJzZVN1YnNjcmlwdHMiLCJiYXNlIiwibm9DYWxscyIsIm1heWJlQXN5bmNBcnJvdyIsIm9wdGlvbmFsQ2hhaW5lZCIsInBhcnNlU3Vic2NyaXB0Iiwib3B0aW9uYWwiLCJjaGFpbk5vZGUiLCJzaG91bGRQYXJzZUFzeW5jQXJyb3ciLCJwYXJzZVN1YnNjcmlwdEFzeW5jQXJyb3ciLCJwYXJzZUFycm93RXhwcmVzc2lvbiIsIm9wdGlvbmFsU3VwcG9ydGVkIiwicGFyc2VFeHByTGlzdCIsImNhbGxlZSIsIm5vZGUkMiIsInRhZyIsInF1YXNpIiwicGFyc2VUZW1wbGF0ZSIsImlzVGFnZ2VkIiwiZm9yTmV3IiwicmVhZFJlZ2V4cCIsImNhbkJlQXJyb3ciLCJyZWdleCIsInBhdHRlcm4iLCJwYXJzZVBhcmVuQW5kRGlzdGluZ3Vpc2hFeHByZXNzaW9uIiwicGFyc2VOZXciLCJwYXJzZUV4cHJJbXBvcnQiLCJwYXJzZUV4cHJBdG9tRGVmYXVsdCIsInBhcnNlRHluYW1pY0ltcG9ydCIsIm1ldGEiLCJwYXJzZUltcG9ydE1ldGEiLCJlcnJvclBvcyIsImJpZ2ludCIsInZhbCIsInNob3VsZFBhcnNlQXJyb3ciLCJpbm5lclN0YXJ0UG9zIiwiaW5uZXJTdGFydExvYyIsImxhc3RJc0NvbW1hIiwic3ByZWFkU3RhcnQiLCJwYXJzZVBhcmVuSXRlbSIsImlubmVyRW5kUG9zIiwiaW5uZXJFbmRMb2MiLCJwYXJzZVBhcmVuQXJyb3dMaXN0IiwiZmluaXNoTm9kZUF0IiwicGFyIiwiaXRlbSIsImVtcHR5IiwicGFyc2VUZW1wbGF0ZUVsZW1lbnQiLCJjb29rZWQiLCJ0YWlsIiwiY3VyRWx0IiwicXVhc2lzIiwiaXNBc3luY1Byb3AiLCJpc1BhdHRlcm4iLCJwYXJzZVByb3BlcnR5IiwicGFyc2VQcm9wZXJ0eVZhbHVlIiwicGFyc2VHZXR0ZXJTZXR0ZXIiLCJwYXJhbUNvdW50IiwiY29weU5vZGUiLCJpc0Fycm93RnVuY3Rpb24iLCJpc01ldGhvZCIsImlzRXhwcmVzc2lvbiIsInVzZVN0cmljdCIsImNoZWNrUGFyYW1zIiwibm9uU2ltcGxlIiwiaXNTaW1wbGVQYXJhbUxpc3QiLCJ1bmRlZmluZWQiLCJhbGxvd0R1cGxpY2F0ZXMiLCJuYW1lSGFzaCIsInJlIiwibGliZXJhbCIsInBhcnNlSWRlbnROb2RlIiwiZGVsZWdhdGUiLCJwcCQ0IiwibWVzc2FnZSIsImVyciIsIlN5bnRheEVycm9yIiwicmFpc2VkQXQiLCJwcCQzIiwiU2NvcGUiLCJ2YXIiLCJsZXhpY2FsIiwiZnVuY3Rpb25zIiwic2NvcGUiLCJyZWRlY2xhcmVkIiwic2NvcGUkMSIsInNjb3BlJDIiLCJzY29wZSQzIiwiTm9kZSIsInBwJDIiLCJuZXdOb2RlIiwic2NyaXB0VmFsdWVzQWRkZWRJblVuaWNvZGUiLCJlY21hOUJpbmFyeVByb3BlcnRpZXMiLCJlY21hMTBCaW5hcnlQcm9wZXJ0aWVzIiwiZWNtYTExQmluYXJ5UHJvcGVydGllcyIsImVjbWExMkJpbmFyeVByb3BlcnRpZXMiLCJlY21hMTNCaW5hcnlQcm9wZXJ0aWVzIiwiZWNtYTE0QmluYXJ5UHJvcGVydGllcyIsInVuaWNvZGVCaW5hcnlQcm9wZXJ0aWVzIiwiZWNtYTE0QmluYXJ5UHJvcGVydGllc09mU3RyaW5ncyIsInVuaWNvZGVCaW5hcnlQcm9wZXJ0aWVzT2ZTdHJpbmdzIiwidW5pY29kZUdlbmVyYWxDYXRlZ29yeVZhbHVlcyIsImVjbWE5U2NyaXB0VmFsdWVzIiwiZWNtYTEwU2NyaXB0VmFsdWVzIiwiZWNtYTExU2NyaXB0VmFsdWVzIiwiZWNtYTEyU2NyaXB0VmFsdWVzIiwiZWNtYTEzU2NyaXB0VmFsdWVzIiwiZWNtYTE0U2NyaXB0VmFsdWVzIiwidW5pY29kZVNjcmlwdFZhbHVlcyIsImRhdGEiLCJidWlsZFVuaWNvZGVEYXRhIiwiZCIsImJpbmFyeSIsImJpbmFyeU9mU3RyaW5ncyIsIm5vbkJpbmFyeSIsIkdlbmVyYWxfQ2F0ZWdvcnkiLCJTY3JpcHQiLCJTY3JpcHRfRXh0ZW5zaW9ucyIsImdjIiwic2MiLCJzY3giLCJwcCQxIiwiQnJhbmNoSUQiLCJzZXBhcmF0ZWRGcm9tIiwiYWx0Iiwic2libGluZyIsIlJlZ0V4cFZhbGlkYXRpb25TdGF0ZSIsInZhbGlkRmxhZ3MiLCJ1bmljb2RlUHJvcGVydGllcyIsInN3aXRjaFUiLCJzd2l0Y2hWIiwic3dpdGNoTiIsImxhc3RJbnRWYWx1ZSIsImxhc3RTdHJpbmdWYWx1ZSIsImxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSIsIm51bUNhcHR1cmluZ1BhcmVucyIsIm1heEJhY2tSZWZlcmVuY2UiLCJncm91cE5hbWVzIiwiYmFja1JlZmVyZW5jZU5hbWVzIiwiYnJhbmNoSUQiLCJyZXNldCIsInVuaWNvZGVTZXRzIiwidW5pY29kZSIsImF0IiwiZm9yY2VVIiwicyIsImwiLCJjIiwibmV4dEluZGV4IiwiY3VycmVudCIsImxvb2thaGVhZCIsImFkdmFuY2UiLCJjaCIsImVhdENoYXJzIiwiY2hzIiwidmFsaWRhdGVSZWdFeHBGbGFncyIsInN0YXRlIiwidSIsInYiLCJmbGFnIiwiaGFzUHJvcCIsIl8iLCJ2YWxpZGF0ZVJlZ0V4cFBhdHRlcm4iLCJyZWdleHBfcGF0dGVybiIsInJlZ2V4cF9kaXNqdW5jdGlvbiIsInRyYWNrRGlzanVuY3Rpb24iLCJyZWdleHBfYWx0ZXJuYXRpdmUiLCJyZWdleHBfZWF0UXVhbnRpZmllciIsInJlZ2V4cF9lYXRUZXJtIiwicmVnZXhwX2VhdEFzc2VydGlvbiIsInJlZ2V4cF9lYXRBdG9tIiwicmVnZXhwX2VhdEV4dGVuZGVkQXRvbSIsImxvb2tiZWhpbmQiLCJub0Vycm9yIiwicmVnZXhwX2VhdFF1YW50aWZpZXJQcmVmaXgiLCJyZWdleHBfZWF0QnJhY2VkUXVhbnRpZmllciIsIm1pbiIsIm1heCIsInJlZ2V4cF9lYXREZWNpbWFsRGlnaXRzIiwicmVnZXhwX2VhdFBhdHRlcm5DaGFyYWN0ZXJzIiwicmVnZXhwX2VhdFJldmVyc2VTb2xpZHVzQXRvbUVzY2FwZSIsInJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzcyIsInJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwIiwicmVnZXhwX2VhdENhcHR1cmluZ0dyb3VwIiwicmVnZXhwX2VhdEF0b21Fc2NhcGUiLCJhZGRNb2RpZmllcnMiLCJyZWdleHBfZWF0TW9kaWZpZXJzIiwiaGFzSHlwaGVuIiwibW9kaWZpZXIiLCJyZW1vdmVNb2RpZmllcnMiLCJtb2RpZmllciQxIiwicmVnZXhwX2dyb3VwU3BlY2lmaWVyIiwibW9kaWZpZXJzIiwiaXNSZWd1bGFyRXhwcmVzc2lvbk1vZGlmaWVyIiwicmVnZXhwX2VhdEludmFsaWRCcmFjZWRRdWFudGlmaWVyIiwicmVnZXhwX2VhdEV4dGVuZGVkUGF0dGVybkNoYXJhY3RlciIsInJlZ2V4cF9lYXRTeW50YXhDaGFyYWN0ZXIiLCJpc1N5bnRheENoYXJhY3RlciIsInJlZ2V4cF9lYXRHcm91cE5hbWUiLCJrbm93biIsImFsdElEIiwicmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJOYW1lIiwicmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJTdGFydCIsInJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyUGFydCIsInJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2UiLCJpc1JlZ0V4cElkZW50aWZpZXJTdGFydCIsImlzUmVnRXhwSWRlbnRpZmllclBhcnQiLCJyZWdleHBfZWF0QmFja1JlZmVyZW5jZSIsInJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzc0VzY2FwZSIsInJlZ2V4cF9lYXRDaGFyYWN0ZXJFc2NhcGUiLCJyZWdleHBfZWF0S0dyb3VwTmFtZSIsInJlZ2V4cF9lYXREZWNpbWFsRXNjYXBlIiwicmVnZXhwX2VhdENvbnRyb2xFc2NhcGUiLCJyZWdleHBfZWF0Q0NvbnRyb2xMZXR0ZXIiLCJyZWdleHBfZWF0WmVybyIsInJlZ2V4cF9lYXRIZXhFc2NhcGVTZXF1ZW5jZSIsInJlZ2V4cF9lYXRMZWdhY3lPY3RhbEVzY2FwZVNlcXVlbmNlIiwicmVnZXhwX2VhdElkZW50aXR5RXNjYXBlIiwicmVnZXhwX2VhdENvbnRyb2xMZXR0ZXIiLCJpc0RlY2ltYWxEaWdpdCIsImlzQ29udHJvbExldHRlciIsInJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cyIsImxlYWQiLCJsZWFkU3Vycm9nYXRlRW5kIiwidHJhaWwiLCJyZWdleHBfZWF0SGV4RGlnaXRzIiwiaXNWYWxpZFVuaWNvZGUiLCJDaGFyU2V0Tm9uZSIsIkNoYXJTZXRPayIsIkNoYXJTZXRTdHJpbmciLCJpc0NoYXJhY3RlckNsYXNzRXNjYXBlIiwibmVnYXRlIiwicmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlRXhwcmVzc2lvbiIsInJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlOYW1lIiwicmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlIiwicmVnZXhwX3ZhbGlkYXRlVW5pY29kZVByb3BlcnR5TmFtZUFuZFZhbHVlIiwicmVnZXhwX2VhdExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZSIsIm5hbWVPclZhbHVlIiwicmVnZXhwX3ZhbGlkYXRlVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUiLCJpc1VuaWNvZGVQcm9wZXJ0eU5hbWVDaGFyYWN0ZXIiLCJpc1VuaWNvZGVQcm9wZXJ0eVZhbHVlQ2hhcmFjdGVyIiwicmVnZXhwX2NsYXNzQ29udGVudHMiLCJyZWdleHBfY2xhc3NTZXRFeHByZXNzaW9uIiwicmVnZXhwX25vbkVtcHR5Q2xhc3NSYW5nZXMiLCJyZWdleHBfZWF0Q2xhc3NBdG9tIiwicmVnZXhwX2VhdENsYXNzRXNjYXBlIiwiY2gkMSIsImlzT2N0YWxEaWdpdCIsInJlZ2V4cF9lYXRDbGFzc0NvbnRyb2xMZXR0ZXIiLCJzdWJSZXN1bHQiLCJyZWdleHBfZWF0Q2xhc3NTZXRSYW5nZSIsInJlZ2V4cF9lYXRDbGFzc1NldE9wZXJhbmQiLCJyZWdleHBfZWF0Q2xhc3NTZXRDaGFyYWN0ZXIiLCJyZWdleHBfZWF0Q2xhc3NTdHJpbmdEaXNqdW5jdGlvbiIsInJlZ2V4cF9lYXROZXN0ZWRDbGFzcyIsInJlc3VsdCQxIiwicmVnZXhwX2NsYXNzU3RyaW5nRGlzanVuY3Rpb25Db250ZW50cyIsInJlZ2V4cF9jbGFzc1N0cmluZyIsImNvdW50IiwicmVnZXhwX2VhdENsYXNzU2V0UmVzZXJ2ZWRQdW5jdHVhdG9yIiwiaXNDbGFzc1NldFJlc2VydmVkRG91YmxlUHVuY3R1YXRvckNoYXJhY3RlciIsImlzQ2xhc3NTZXRTeW50YXhDaGFyYWN0ZXIiLCJpc0NsYXNzU2V0UmVzZXJ2ZWRQdW5jdHVhdG9yIiwiaXNIZXhEaWdpdCIsImhleFRvSW50IiwicmVnZXhwX2VhdE9jdGFsRGlnaXQiLCJuMSIsIm4yIiwiVG9rZW4iLCJwcCIsImlnbm9yZUVzY2FwZVNlcXVlbmNlSW5LZXl3b3JkIiwiZ2V0VG9rZW4iLCJTeW1ib2wiLCJpdGVyYXRvciIsInRoaXMkMSQxIiwiZG9uZSIsInNraXBTcGFjZSIsImZpbmlzaFRva2VuIiwicmVhZFRva2VuIiwiZnVsbENoYXJDb2RlQXRQb3MiLCJyZWFkV29yZCIsImdldFRva2VuRnJvbUNvZGUiLCJza2lwQmxvY2tDb21tZW50Iiwic3RhcnRTa2lwIiwibG9vcCIsInJlYWRUb2tlbl9kb3QiLCJyZWFkTnVtYmVyIiwibmV4dDIiLCJyZWFkVG9rZW5fc2xhc2giLCJmaW5pc2hPcCIsInJlYWRUb2tlbl9tdWx0X21vZHVsb19leHAiLCJzaXplIiwidG9rZW50eXBlIiwicmVhZFRva2VuX3BpcGVfYW1wIiwicmVhZFRva2VuX2NhcmV0IiwicmVhZFRva2VuX3BsdXNfbWluIiwicmVhZFRva2VuX2x0X2d0IiwicmVhZFRva2VuX2VxX2V4Y2wiLCJyZWFkVG9rZW5fcXVlc3Rpb24iLCJuZXh0MiQxIiwicmVhZFRva2VuX251bWJlclNpZ24iLCJyZWFkV29yZDEiLCJyZWFkUmFkaXhOdW1iZXIiLCJyZWFkU3RyaW5nIiwic3RyIiwiZXNjYXBlZCIsImluQ2xhc3MiLCJmbGFnc1N0YXJ0IiwiZSIsInJlYWRJbnQiLCJyYWRpeCIsIm1heWJlTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbCIsImFsbG93U2VwYXJhdG9ycyIsImlzTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbCIsInRvdGFsIiwibGFzdENvZGUiLCJJbmZpbml0eSIsInN0cmluZ1RvTnVtYmVyIiwicGFyc2VJbnQiLCJwYXJzZUZsb2F0Iiwic3RyaW5nVG9CaWdJbnQiLCJCaWdJbnQiLCJzdGFydHNXaXRoRG90Iiwib2N0YWwiLCJ2YWwkMSIsInJlYWRDb2RlUG9pbnQiLCJjb2RlUG9zIiwicmVhZEhleENoYXIiLCJpbnZhbGlkU3RyaW5nVG9rZW4iLCJxdW90ZSIsImNodW5rU3RhcnQiLCJyZWFkRXNjYXBlZENoYXIiLCJJTlZBTElEX1RFTVBMQVRFX0VTQ0FQRV9FUlJPUiIsImluVGVtcGxhdGVFbGVtZW50IiwicmVhZFRtcGxUb2tlbiIsInJlYWRJbnZhbGlkVGVtcGxhdGVUb2tlbiIsInBvc2l0aW9uIiwiaW5UZW1wbGF0ZSIsIm9jdGFsU3RyIiwic3Vic3RyIiwid29yZCIsImVzY1N0YXJ0IiwiZXNjIiwidmVyc2lvbiIsInRva1R5cGVzIiwia2V5d29yZFR5cGVzIiwidG9rQ29udGV4dHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/acorn/dist/acorn.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/acorn/dist/acorn.mjs":
/*!*******************************************!*\
  !*** ./node_modules/acorn/dist/acorn.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Node: () => (/* binding */ Node),\n/* harmony export */   Parser: () => (/* binding */ Parser),\n/* harmony export */   Position: () => (/* binding */ Position),\n/* harmony export */   SourceLocation: () => (/* binding */ SourceLocation),\n/* harmony export */   TokContext: () => (/* binding */ TokContext),\n/* harmony export */   Token: () => (/* binding */ Token),\n/* harmony export */   TokenType: () => (/* binding */ TokenType),\n/* harmony export */   defaultOptions: () => (/* binding */ defaultOptions),\n/* harmony export */   getLineInfo: () => (/* binding */ getLineInfo),\n/* harmony export */   isIdentifierChar: () => (/* binding */ isIdentifierChar),\n/* harmony export */   isIdentifierStart: () => (/* binding */ isIdentifierStart),\n/* harmony export */   isNewLine: () => (/* binding */ isNewLine),\n/* harmony export */   keywordTypes: () => (/* binding */ keywords),\n/* harmony export */   lineBreak: () => (/* binding */ lineBreak),\n/* harmony export */   lineBreakG: () => (/* binding */ lineBreakG),\n/* harmony export */   nonASCIIwhitespace: () => (/* binding */ nonASCIIwhitespace),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   parseExpressionAt: () => (/* binding */ parseExpressionAt),\n/* harmony export */   tokContexts: () => (/* binding */ types),\n/* harmony export */   tokTypes: () => (/* binding */ types$1),\n/* harmony export */   tokenizer: () => (/* binding */ tokenizer),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n// This file was generated. Do not modify manually!\nvar astralIdentifierCodes = [\n    509,\n    0,\n    227,\n    0,\n    150,\n    4,\n    294,\n    9,\n    1368,\n    2,\n    2,\n    1,\n    6,\n    3,\n    41,\n    2,\n    5,\n    0,\n    166,\n    1,\n    574,\n    3,\n    9,\n    9,\n    7,\n    9,\n    32,\n    4,\n    318,\n    1,\n    80,\n    3,\n    71,\n    10,\n    50,\n    3,\n    123,\n    2,\n    54,\n    14,\n    32,\n    10,\n    3,\n    1,\n    11,\n    3,\n    46,\n    10,\n    8,\n    0,\n    46,\n    9,\n    7,\n    2,\n    37,\n    13,\n    2,\n    9,\n    6,\n    1,\n    45,\n    0,\n    13,\n    2,\n    49,\n    13,\n    9,\n    3,\n    2,\n    11,\n    83,\n    11,\n    7,\n    0,\n    3,\n    0,\n    158,\n    11,\n    6,\n    9,\n    7,\n    3,\n    56,\n    1,\n    2,\n    6,\n    3,\n    1,\n    3,\n    2,\n    10,\n    0,\n    11,\n    1,\n    3,\n    6,\n    4,\n    4,\n    68,\n    8,\n    2,\n    0,\n    3,\n    0,\n    2,\n    3,\n    2,\n    4,\n    2,\n    0,\n    15,\n    1,\n    83,\n    17,\n    10,\n    9,\n    5,\n    0,\n    82,\n    19,\n    13,\n    9,\n    214,\n    6,\n    3,\n    8,\n    28,\n    1,\n    83,\n    16,\n    16,\n    9,\n    82,\n    12,\n    9,\n    9,\n    7,\n    19,\n    58,\n    14,\n    5,\n    9,\n    243,\n    14,\n    166,\n    9,\n    71,\n    5,\n    2,\n    1,\n    3,\n    3,\n    2,\n    0,\n    2,\n    1,\n    13,\n    9,\n    120,\n    6,\n    3,\n    6,\n    4,\n    0,\n    29,\n    9,\n    41,\n    6,\n    2,\n    3,\n    9,\n    0,\n    10,\n    10,\n    47,\n    15,\n    343,\n    9,\n    54,\n    7,\n    2,\n    7,\n    17,\n    9,\n    57,\n    21,\n    2,\n    13,\n    123,\n    5,\n    4,\n    0,\n    2,\n    1,\n    2,\n    6,\n    2,\n    0,\n    9,\n    9,\n    49,\n    4,\n    2,\n    1,\n    2,\n    4,\n    9,\n    9,\n    330,\n    3,\n    10,\n    1,\n    2,\n    0,\n    49,\n    6,\n    4,\n    4,\n    14,\n    10,\n    5350,\n    0,\n    7,\n    14,\n    11465,\n    27,\n    2343,\n    9,\n    87,\n    9,\n    39,\n    4,\n    60,\n    6,\n    26,\n    9,\n    535,\n    9,\n    470,\n    0,\n    2,\n    54,\n    8,\n    3,\n    82,\n    0,\n    12,\n    1,\n    19628,\n    1,\n    4178,\n    9,\n    519,\n    45,\n    3,\n    22,\n    543,\n    4,\n    4,\n    5,\n    9,\n    7,\n    3,\n    6,\n    31,\n    3,\n    149,\n    2,\n    1418,\n    49,\n    513,\n    54,\n    5,\n    49,\n    9,\n    0,\n    15,\n    0,\n    23,\n    4,\n    2,\n    14,\n    1361,\n    6,\n    2,\n    16,\n    3,\n    6,\n    2,\n    1,\n    2,\n    4,\n    101,\n    0,\n    161,\n    6,\n    10,\n    9,\n    357,\n    0,\n    62,\n    13,\n    499,\n    13,\n    245,\n    1,\n    2,\n    9,\n    726,\n    6,\n    110,\n    6,\n    6,\n    9,\n    4759,\n    9,\n    787719,\n    239\n];\n// This file was generated. Do not modify manually!\nvar astralIdentifierStartCodes = [\n    0,\n    11,\n    2,\n    25,\n    2,\n    18,\n    2,\n    1,\n    2,\n    14,\n    3,\n    13,\n    35,\n    122,\n    70,\n    52,\n    268,\n    28,\n    4,\n    48,\n    48,\n    31,\n    14,\n    29,\n    6,\n    37,\n    11,\n    29,\n    3,\n    35,\n    5,\n    7,\n    2,\n    4,\n    43,\n    157,\n    19,\n    35,\n    5,\n    35,\n    5,\n    39,\n    9,\n    51,\n    13,\n    10,\n    2,\n    14,\n    2,\n    6,\n    2,\n    1,\n    2,\n    10,\n    2,\n    14,\n    2,\n    6,\n    2,\n    1,\n    4,\n    51,\n    13,\n    310,\n    10,\n    21,\n    11,\n    7,\n    25,\n    5,\n    2,\n    41,\n    2,\n    8,\n    70,\n    5,\n    3,\n    0,\n    2,\n    43,\n    2,\n    1,\n    4,\n    0,\n    3,\n    22,\n    11,\n    22,\n    10,\n    30,\n    66,\n    18,\n    2,\n    1,\n    11,\n    21,\n    11,\n    25,\n    71,\n    55,\n    7,\n    1,\n    65,\n    0,\n    16,\n    3,\n    2,\n    2,\n    2,\n    28,\n    43,\n    28,\n    4,\n    28,\n    36,\n    7,\n    2,\n    27,\n    28,\n    53,\n    11,\n    21,\n    11,\n    18,\n    14,\n    17,\n    111,\n    72,\n    56,\n    50,\n    14,\n    50,\n    14,\n    35,\n    39,\n    27,\n    10,\n    22,\n    251,\n    41,\n    7,\n    1,\n    17,\n    2,\n    60,\n    28,\n    11,\n    0,\n    9,\n    21,\n    43,\n    17,\n    47,\n    20,\n    28,\n    22,\n    13,\n    52,\n    58,\n    1,\n    3,\n    0,\n    14,\n    44,\n    33,\n    24,\n    27,\n    35,\n    30,\n    0,\n    3,\n    0,\n    9,\n    34,\n    4,\n    0,\n    13,\n    47,\n    15,\n    3,\n    22,\n    0,\n    2,\n    0,\n    36,\n    17,\n    2,\n    24,\n    20,\n    1,\n    64,\n    6,\n    2,\n    0,\n    2,\n    3,\n    2,\n    14,\n    2,\n    9,\n    8,\n    46,\n    39,\n    7,\n    3,\n    1,\n    3,\n    21,\n    2,\n    6,\n    2,\n    1,\n    2,\n    4,\n    4,\n    0,\n    19,\n    0,\n    13,\n    4,\n    31,\n    9,\n    2,\n    0,\n    3,\n    0,\n    2,\n    37,\n    2,\n    0,\n    26,\n    0,\n    2,\n    0,\n    45,\n    52,\n    19,\n    3,\n    21,\n    2,\n    31,\n    47,\n    21,\n    1,\n    2,\n    0,\n    185,\n    46,\n    42,\n    3,\n    37,\n    47,\n    21,\n    0,\n    60,\n    42,\n    14,\n    0,\n    72,\n    26,\n    38,\n    6,\n    186,\n    43,\n    117,\n    63,\n    32,\n    7,\n    3,\n    0,\n    3,\n    7,\n    2,\n    1,\n    2,\n    23,\n    16,\n    0,\n    2,\n    0,\n    95,\n    7,\n    3,\n    38,\n    17,\n    0,\n    2,\n    0,\n    29,\n    0,\n    11,\n    39,\n    8,\n    0,\n    22,\n    0,\n    12,\n    45,\n    20,\n    0,\n    19,\n    72,\n    200,\n    32,\n    32,\n    8,\n    2,\n    36,\n    18,\n    0,\n    50,\n    29,\n    113,\n    6,\n    2,\n    1,\n    2,\n    37,\n    22,\n    0,\n    26,\n    5,\n    2,\n    1,\n    2,\n    31,\n    15,\n    0,\n    328,\n    18,\n    16,\n    0,\n    2,\n    12,\n    2,\n    33,\n    125,\n    0,\n    80,\n    921,\n    103,\n    110,\n    18,\n    195,\n    2637,\n    96,\n    16,\n    1071,\n    18,\n    5,\n    26,\n    3994,\n    6,\n    582,\n    6842,\n    29,\n    1763,\n    568,\n    8,\n    30,\n    18,\n    78,\n    18,\n    29,\n    19,\n    47,\n    17,\n    3,\n    32,\n    20,\n    6,\n    18,\n    433,\n    44,\n    212,\n    63,\n    129,\n    74,\n    6,\n    0,\n    67,\n    12,\n    65,\n    1,\n    2,\n    0,\n    29,\n    6135,\n    9,\n    1237,\n    42,\n    9,\n    8936,\n    3,\n    2,\n    6,\n    2,\n    1,\n    2,\n    290,\n    16,\n    0,\n    30,\n    2,\n    3,\n    0,\n    15,\n    3,\n    9,\n    395,\n    2309,\n    106,\n    6,\n    12,\n    4,\n    8,\n    8,\n    9,\n    5991,\n    84,\n    2,\n    70,\n    2,\n    1,\n    3,\n    0,\n    3,\n    1,\n    3,\n    3,\n    2,\n    11,\n    2,\n    0,\n    2,\n    6,\n    2,\n    64,\n    2,\n    3,\n    3,\n    7,\n    2,\n    6,\n    2,\n    27,\n    2,\n    3,\n    2,\n    4,\n    2,\n    0,\n    4,\n    6,\n    2,\n    339,\n    3,\n    24,\n    2,\n    24,\n    2,\n    30,\n    2,\n    24,\n    2,\n    30,\n    2,\n    24,\n    2,\n    30,\n    2,\n    24,\n    2,\n    30,\n    2,\n    24,\n    2,\n    7,\n    1845,\n    30,\n    7,\n    5,\n    262,\n    61,\n    147,\n    44,\n    11,\n    6,\n    17,\n    0,\n    322,\n    29,\n    19,\n    43,\n    485,\n    27,\n    229,\n    29,\n    3,\n    0,\n    496,\n    6,\n    2,\n    3,\n    2,\n    1,\n    2,\n    14,\n    2,\n    196,\n    60,\n    67,\n    8,\n    0,\n    1205,\n    3,\n    2,\n    26,\n    2,\n    1,\n    2,\n    0,\n    3,\n    0,\n    2,\n    9,\n    2,\n    3,\n    2,\n    0,\n    2,\n    0,\n    7,\n    0,\n    5,\n    0,\n    2,\n    0,\n    2,\n    0,\n    2,\n    2,\n    2,\n    1,\n    2,\n    0,\n    3,\n    0,\n    2,\n    0,\n    2,\n    0,\n    2,\n    0,\n    2,\n    0,\n    2,\n    1,\n    2,\n    0,\n    3,\n    3,\n    2,\n    6,\n    2,\n    3,\n    2,\n    3,\n    2,\n    0,\n    2,\n    9,\n    2,\n    16,\n    6,\n    2,\n    2,\n    4,\n    2,\n    16,\n    4421,\n    42719,\n    33,\n    4153,\n    7,\n    221,\n    3,\n    5761,\n    15,\n    7472,\n    16,\n    621,\n    2467,\n    541,\n    1507,\n    4938,\n    6,\n    4191\n];\n// This file was generated. Do not modify manually!\nvar nonASCIIidentifierChars = \"‌‍\\xb7̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࢗ-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･\";\n// This file was generated. Do not modify manually!\nvar nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲊᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟍꟐꟑꟓꟕ-Ƛꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ\";\n// These are a run-length and offset encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range.\n// Reserved word lists for various dialects of the language\nvar reservedWords = {\n    3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n    5: \"class enum extends super const export import\",\n    6: \"enum\",\n    strict: \"implements interface let package private protected public static yield\",\n    strictBind: \"eval arguments\"\n};\n// And the keywords\nvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\nvar keywords$1 = {\n    5: ecma5AndLessKeywords,\n    \"5module\": ecma5AndLessKeywords + \" export import\",\n    6: ecma5AndLessKeywords + \" const class extends export import super\"\n};\nvar keywordRelationalOperator = /^in(stanceof)?$/;\n// ## Character categories\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code, set) {\n    var pos = 0x10000;\n    for(var i = 0; i < set.length; i += 2){\n        pos += set[i];\n        if (pos > code) {\n            return false;\n        }\n        pos += set[i + 1];\n        if (pos >= code) {\n            return true;\n        }\n    }\n    return false;\n}\n// Test whether a given character code starts an identifier.\nfunction isIdentifierStart(code, astral) {\n    if (code < 65) {\n        return code === 36;\n    }\n    if (code < 91) {\n        return true;\n    }\n    if (code < 97) {\n        return code === 95;\n    }\n    if (code < 123) {\n        return true;\n    }\n    if (code <= 0xffff) {\n        return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n    }\n    if (astral === false) {\n        return false;\n    }\n    return isInAstralSet(code, astralIdentifierStartCodes);\n}\n// Test whether a given character is part of an identifier.\nfunction isIdentifierChar(code, astral) {\n    if (code < 48) {\n        return code === 36;\n    }\n    if (code < 58) {\n        return true;\n    }\n    if (code < 65) {\n        return false;\n    }\n    if (code < 91) {\n        return true;\n    }\n    if (code < 97) {\n        return code === 95;\n    }\n    if (code < 123) {\n        return true;\n    }\n    if (code <= 0xffff) {\n        return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n    }\n    if (astral === false) {\n        return false;\n    }\n    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n}\n// ## Token types\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// The `startsExpr` property is used to check if the token ends a\n// `yield` expression. It is set on all token types that either can\n// directly start an expression (like a quotation mark) or can\n// continue an expression (like the body of a string).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\nvar TokenType = function TokenType(label, conf) {\n    if (conf === void 0) conf = {};\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n};\nfunction binop(name, prec) {\n    return new TokenType(name, {\n        beforeExpr: true,\n        binop: prec\n    });\n}\nvar beforeExpr = {\n    beforeExpr: true\n}, startsExpr = {\n    startsExpr: true\n};\n// Map keyword names to token types.\nvar keywords = {};\n// Succinct definitions of keyword token types\nfunction kw(name, options) {\n    if (options === void 0) options = {};\n    options.keyword = name;\n    return keywords[name] = new TokenType(name, options);\n}\nvar types$1 = {\n    num: new TokenType(\"num\", startsExpr),\n    regexp: new TokenType(\"regexp\", startsExpr),\n    string: new TokenType(\"string\", startsExpr),\n    name: new TokenType(\"name\", startsExpr),\n    privateId: new TokenType(\"privateId\", startsExpr),\n    eof: new TokenType(\"eof\"),\n    // Punctuation token types.\n    bracketL: new TokenType(\"[\", {\n        beforeExpr: true,\n        startsExpr: true\n    }),\n    bracketR: new TokenType(\"]\"),\n    braceL: new TokenType(\"{\", {\n        beforeExpr: true,\n        startsExpr: true\n    }),\n    braceR: new TokenType(\"}\"),\n    parenL: new TokenType(\"(\", {\n        beforeExpr: true,\n        startsExpr: true\n    }),\n    parenR: new TokenType(\")\"),\n    comma: new TokenType(\",\", beforeExpr),\n    semi: new TokenType(\";\", beforeExpr),\n    colon: new TokenType(\":\", beforeExpr),\n    dot: new TokenType(\".\"),\n    question: new TokenType(\"?\", beforeExpr),\n    questionDot: new TokenType(\"?.\"),\n    arrow: new TokenType(\"=>\", beforeExpr),\n    template: new TokenType(\"template\"),\n    invalidTemplate: new TokenType(\"invalidTemplate\"),\n    ellipsis: new TokenType(\"...\", beforeExpr),\n    backQuote: new TokenType(\"`\", startsExpr),\n    dollarBraceL: new TokenType(\"${\", {\n        beforeExpr: true,\n        startsExpr: true\n    }),\n    // Operators. These carry several kinds of properties to help the\n    // parser use them properly (the presence of these properties is\n    // what categorizes them as operators).\n    //\n    // `binop`, when present, specifies that this operator is a binary\n    // operator, and will refer to its precedence.\n    //\n    // `prefix` and `postfix` mark the operator as a prefix or postfix\n    // unary operator.\n    //\n    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n    // binary operators with a very low precedence, that should result\n    // in AssignmentExpression nodes.\n    eq: new TokenType(\"=\", {\n        beforeExpr: true,\n        isAssign: true\n    }),\n    assign: new TokenType(\"_=\", {\n        beforeExpr: true,\n        isAssign: true\n    }),\n    incDec: new TokenType(\"++/--\", {\n        prefix: true,\n        postfix: true,\n        startsExpr: true\n    }),\n    prefix: new TokenType(\"!/~\", {\n        beforeExpr: true,\n        prefix: true,\n        startsExpr: true\n    }),\n    logicalOR: binop(\"||\", 1),\n    logicalAND: binop(\"&&\", 2),\n    bitwiseOR: binop(\"|\", 3),\n    bitwiseXOR: binop(\"^\", 4),\n    bitwiseAND: binop(\"&\", 5),\n    equality: binop(\"==/!=/===/!==\", 6),\n    relational: binop(\"</>/<=/>=\", 7),\n    bitShift: binop(\"<</>>/>>>\", 8),\n    plusMin: new TokenType(\"+/-\", {\n        beforeExpr: true,\n        binop: 9,\n        prefix: true,\n        startsExpr: true\n    }),\n    modulo: binop(\"%\", 10),\n    star: binop(\"*\", 10),\n    slash: binop(\"/\", 10),\n    starstar: new TokenType(\"**\", {\n        beforeExpr: true\n    }),\n    coalesce: binop(\"??\", 1),\n    // Keyword token types.\n    _break: kw(\"break\"),\n    _case: kw(\"case\", beforeExpr),\n    _catch: kw(\"catch\"),\n    _continue: kw(\"continue\"),\n    _debugger: kw(\"debugger\"),\n    _default: kw(\"default\", beforeExpr),\n    _do: kw(\"do\", {\n        isLoop: true,\n        beforeExpr: true\n    }),\n    _else: kw(\"else\", beforeExpr),\n    _finally: kw(\"finally\"),\n    _for: kw(\"for\", {\n        isLoop: true\n    }),\n    _function: kw(\"function\", startsExpr),\n    _if: kw(\"if\"),\n    _return: kw(\"return\", beforeExpr),\n    _switch: kw(\"switch\"),\n    _throw: kw(\"throw\", beforeExpr),\n    _try: kw(\"try\"),\n    _var: kw(\"var\"),\n    _const: kw(\"const\"),\n    _while: kw(\"while\", {\n        isLoop: true\n    }),\n    _with: kw(\"with\"),\n    _new: kw(\"new\", {\n        beforeExpr: true,\n        startsExpr: true\n    }),\n    _this: kw(\"this\", startsExpr),\n    _super: kw(\"super\", startsExpr),\n    _class: kw(\"class\", startsExpr),\n    _extends: kw(\"extends\", beforeExpr),\n    _export: kw(\"export\"),\n    _import: kw(\"import\", startsExpr),\n    _null: kw(\"null\", startsExpr),\n    _true: kw(\"true\", startsExpr),\n    _false: kw(\"false\", startsExpr),\n    _in: kw(\"in\", {\n        beforeExpr: true,\n        binop: 7\n    }),\n    _instanceof: kw(\"instanceof\", {\n        beforeExpr: true,\n        binop: 7\n    }),\n    _typeof: kw(\"typeof\", {\n        beforeExpr: true,\n        prefix: true,\n        startsExpr: true\n    }),\n    _void: kw(\"void\", {\n        beforeExpr: true,\n        prefix: true,\n        startsExpr: true\n    }),\n    _delete: kw(\"delete\", {\n        beforeExpr: true,\n        prefix: true,\n        startsExpr: true\n    })\n};\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\nvar lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\nvar lineBreakG = new RegExp(lineBreak.source, \"g\");\nfunction isNewLine(code) {\n    return code === 10 || code === 13 || code === 0x2028 || code === 0x2029;\n}\nfunction nextLineBreak(code, from, end) {\n    if (end === void 0) end = code.length;\n    for(var i = from; i < end; i++){\n        var next = code.charCodeAt(i);\n        if (isNewLine(next)) {\n            return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;\n        }\n    }\n    return -1;\n}\nvar nonASCIIwhitespace = /[\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\nvar ref = Object.prototype;\nvar hasOwnProperty = ref.hasOwnProperty;\nvar toString = ref.toString;\nvar hasOwn = Object.hasOwn || function(obj, propName) {\n    return hasOwnProperty.call(obj, propName);\n};\nvar isArray = Array.isArray || function(obj) {\n    return toString.call(obj) === \"[object Array]\";\n};\nvar regexpCache = Object.create(null);\nfunction wordsRegexp(words) {\n    return regexpCache[words] || (regexpCache[words] = new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\"));\n}\nfunction codePointToString(code) {\n    // UTF-16 Decoding\n    if (code <= 0xFFFF) {\n        return String.fromCharCode(code);\n    }\n    code -= 0x10000;\n    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);\n}\nvar loneSurrogate = /(?:[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])/;\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\nvar Position = function Position(line, col) {\n    this.line = line;\n    this.column = col;\n};\nPosition.prototype.offset = function offset(n) {\n    return new Position(this.line, this.column + n);\n};\nvar SourceLocation = function SourceLocation(p, start, end) {\n    this.start = start;\n    this.end = end;\n    if (p.sourceFile !== null) {\n        this.source = p.sourceFile;\n    }\n};\n// The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\nfunction getLineInfo(input, offset) {\n    for(var line = 1, cur = 0;;){\n        var nextBreak = nextLineBreak(input, cur, offset);\n        if (nextBreak < 0) {\n            return new Position(line, offset - cur);\n        }\n        ++line;\n        cur = nextBreak;\n    }\n}\n// A second argument must be given to configure the parser process.\n// These options are recognized (only `ecmaVersion` is required):\nvar defaultOptions = {\n    // `ecmaVersion` indicates the ECMAScript version to parse. Must be\n    // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10\n    // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `\"latest\"`\n    // (the latest version the library supports). This influences\n    // support for strict mode, the set of reserved words, and support\n    // for new syntax features.\n    ecmaVersion: null,\n    // `sourceType` indicates the mode the code should be parsed in.\n    // Can be either `\"script\"` or `\"module\"`. This influences global\n    // strict mode and parsing of `import` and `export` declarations.\n    sourceType: \"script\",\n    // `onInsertedSemicolon` can be a callback that will be called when\n    // a semicolon is automatically inserted. It will be passed the\n    // position of the inserted semicolon as an offset, and if\n    // `locations` is enabled, it is given the location as a `{line,\n    // column}` object as second argument.\n    onInsertedSemicolon: null,\n    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n    // trailing commas.\n    onTrailingComma: null,\n    // By default, reserved words are only enforced if ecmaVersion >= 5.\n    // Set `allowReserved` to a boolean value to explicitly turn this on\n    // an off. When this option has the value \"never\", reserved words\n    // and keywords can also not be used as property names.\n    allowReserved: null,\n    // When enabled, a return at the top level is not considered an\n    // error.\n    allowReturnOutsideFunction: false,\n    // When enabled, import/export statements are not constrained to\n    // appearing at the top of the program, and an import.meta expression\n    // in a script isn't considered an error.\n    allowImportExportEverywhere: false,\n    // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.\n    // When enabled, await identifiers are allowed to appear at the top-level scope,\n    // but they are still not allowed in non-async functions.\n    allowAwaitOutsideFunction: null,\n    // When enabled, super identifiers are not constrained to\n    // appearing in methods and do not raise an error when they appear elsewhere.\n    allowSuperOutsideMethod: null,\n    // When enabled, hashbang directive in the beginning of file is\n    // allowed and treated as a line comment. Enabled by default when\n    // `ecmaVersion` >= 2023.\n    allowHashBang: false,\n    // By default, the parser will verify that private properties are\n    // only used in places where they are valid and have been declared.\n    // Set this to false to turn such checks off.\n    checkPrivateFields: true,\n    // When `locations` is on, `loc` properties holding objects with\n    // `start` and `end` properties in `{line, column}` form (with\n    // line being 1-based and column 0-based) will be attached to the\n    // nodes.\n    locations: false,\n    // A function can be passed as `onToken` option, which will\n    // cause Acorn to call that function with object in the same\n    // format as tokens returned from `tokenizer().getToken()`. Note\n    // that you are not allowed to call the parser from the\n    // callback—that will corrupt its internal state.\n    onToken: null,\n    // A function can be passed as `onComment` option, which will\n    // cause Acorn to call that function with `(block, text, start,\n    // end)` parameters whenever a comment is skipped. `block` is a\n    // boolean indicating whether this is a block (`/* */`) comment,\n    // `text` is the content of the comment, and `start` and `end` are\n    // character offsets that denote the start and end of the comment.\n    // When the `locations` option is on, two more parameters are\n    // passed, the full `{line, column}` locations of the start and\n    // end of the comments. Note that you are not allowed to call the\n    // parser from the callback—that will corrupt its internal state.\n    // When this option has an array as value, objects representing the\n    // comments are pushed to it.\n    onComment: null,\n    // Nodes have their start and end characters offsets recorded in\n    // `start` and `end` properties (directly on the node, rather than\n    // the `loc` object, which holds line/column data. To also add a\n    // [semi-standardized][range] `range` property holding a `[start,\n    // end]` array with the same numbers, set the `ranges` option to\n    // `true`.\n    //\n    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n    ranges: false,\n    // It is possible to parse multiple files into a single AST by\n    // passing the tree produced by parsing the first file as\n    // `program` option in subsequent parses. This will add the\n    // toplevel forms of the parsed file to the `Program` (top) node\n    // of an existing parse tree.\n    program: null,\n    // When `locations` is on, you can pass this to record the source\n    // file in every node's `loc` object.\n    sourceFile: null,\n    // This value, if given, is stored in every node, whether\n    // `locations` is on or off.\n    directSourceFile: null,\n    // When enabled, parenthesized expressions are represented by\n    // (non-standard) ParenthesizedExpression nodes\n    preserveParens: false\n};\n// Interpret and default an options object\nvar warnedAboutEcmaVersion = false;\nfunction getOptions(opts) {\n    var options = {};\n    for(var opt in defaultOptions){\n        options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];\n    }\n    if (options.ecmaVersion === \"latest\") {\n        options.ecmaVersion = 1e8;\n    } else if (options.ecmaVersion == null) {\n        if (!warnedAboutEcmaVersion && typeof console === \"object\" && console.warn) {\n            warnedAboutEcmaVersion = true;\n            console.warn(\"Since Acorn 8.0.0, options.ecmaVersion is required.\\nDefaulting to 2020, but this will stop working in the future.\");\n        }\n        options.ecmaVersion = 11;\n    } else if (options.ecmaVersion >= 2015) {\n        options.ecmaVersion -= 2009;\n    }\n    if (options.allowReserved == null) {\n        options.allowReserved = options.ecmaVersion < 5;\n    }\n    if (!opts || opts.allowHashBang == null) {\n        options.allowHashBang = options.ecmaVersion >= 14;\n    }\n    if (isArray(options.onToken)) {\n        var tokens = options.onToken;\n        options.onToken = function(token) {\n            return tokens.push(token);\n        };\n    }\n    if (isArray(options.onComment)) {\n        options.onComment = pushComment(options, options.onComment);\n    }\n    return options;\n}\nfunction pushComment(options, array) {\n    return function(block, text, start, end, startLoc, endLoc) {\n        var comment = {\n            type: block ? \"Block\" : \"Line\",\n            value: text,\n            start: start,\n            end: end\n        };\n        if (options.locations) {\n            comment.loc = new SourceLocation(this, startLoc, endLoc);\n        }\n        if (options.ranges) {\n            comment.range = [\n                start,\n                end\n            ];\n        }\n        array.push(comment);\n    };\n}\n// Each scope gets a bitset that may contain these flags\nvar SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_CLASS_FIELD_INIT = 512, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;\nfunction functionFlags(async, generator) {\n    return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);\n}\n// Used in checkLVal* and declareName to determine the type of a binding\nvar BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5; // Special case for function names as bound inside the function\nvar Parser = function Parser(options, input, startPos) {\n    this.options = options = getOptions(options);\n    this.sourceFile = options.sourceFile;\n    this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === \"module\" ? \"5module\" : 5]);\n    var reserved = \"\";\n    if (options.allowReserved !== true) {\n        reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];\n        if (options.sourceType === \"module\") {\n            reserved += \" await\";\n        }\n    }\n    this.reservedWords = wordsRegexp(reserved);\n    var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n    this.reservedWordsStrict = wordsRegexp(reservedStrict);\n    this.reservedWordsStrictBind = wordsRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n    this.input = String(input);\n    // Used to signal to callers of `readWord1` whether the word\n    // contained any escape sequences. This is needed because words with\n    // escape sequences must not be interpreted as keywords.\n    this.containsEsc = false;\n    // Set up token state\n    // The current position of the tokenizer in the input.\n    if (startPos) {\n        this.pos = startPos;\n        this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n        this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n    } else {\n        this.pos = this.lineStart = 0;\n        this.curLine = 1;\n    }\n    // Properties of the current token:\n    // Its type\n    this.type = types$1.eof;\n    // For tokens that include more information than their type, the value\n    this.value = null;\n    // Its start and end offset\n    this.start = this.end = this.pos;\n    // And, if locations are used, the {line, column} object\n    // corresponding to those offsets\n    this.startLoc = this.endLoc = this.curPosition();\n    // Position information for the previous token\n    this.lastTokEndLoc = this.lastTokStartLoc = null;\n    this.lastTokStart = this.lastTokEnd = this.pos;\n    // The context stack is used to superficially track syntactic\n    // context to predict whether a regular expression is allowed in a\n    // given position.\n    this.context = this.initialContext();\n    this.exprAllowed = true;\n    // Figure out if it's a module code.\n    this.inModule = options.sourceType === \"module\";\n    this.strict = this.inModule || this.strictDirective(this.pos);\n    // Used to signify the start of a potential arrow function\n    this.potentialArrowAt = -1;\n    this.potentialArrowInForAwait = false;\n    // Positions to delayed-check that yield/await does not exist in default parameters.\n    this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;\n    // Labels in scope.\n    this.labels = [];\n    // Thus-far undefined exports.\n    this.undefinedExports = Object.create(null);\n    // If enabled, skip leading hashbang line.\n    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\") {\n        this.skipLineComment(2);\n    }\n    // Scope tracking for duplicate variable names (see scope.js)\n    this.scopeStack = [];\n    this.enterScope(SCOPE_TOP);\n    // For RegExp validation\n    this.regexpState = null;\n    // The stack of private names.\n    // Each element has two properties: 'declared' and 'used'.\n    // When it exited from the outermost class definition, all used private names must be declared.\n    this.privateNameStack = [];\n};\nvar prototypeAccessors = {\n    inFunction: {\n        configurable: true\n    },\n    inGenerator: {\n        configurable: true\n    },\n    inAsync: {\n        configurable: true\n    },\n    canAwait: {\n        configurable: true\n    },\n    allowSuper: {\n        configurable: true\n    },\n    allowDirectSuper: {\n        configurable: true\n    },\n    treatFunctionsAsVar: {\n        configurable: true\n    },\n    allowNewDotTarget: {\n        configurable: true\n    },\n    inClassStaticBlock: {\n        configurable: true\n    }\n};\nParser.prototype.parse = function parse() {\n    var node = this.options.program || this.startNode();\n    this.nextToken();\n    return this.parseTopLevel(node);\n};\nprototypeAccessors.inFunction.get = function() {\n    return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;\n};\nprototypeAccessors.inGenerator.get = function() {\n    return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;\n};\nprototypeAccessors.inAsync.get = function() {\n    return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;\n};\nprototypeAccessors.canAwait.get = function() {\n    for(var i = this.scopeStack.length - 1; i >= 0; i--){\n        var ref = this.scopeStack[i];\n        var flags = ref.flags;\n        if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT)) {\n            return false;\n        }\n        if (flags & SCOPE_FUNCTION) {\n            return (flags & SCOPE_ASYNC) > 0;\n        }\n    }\n    return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;\n};\nprototypeAccessors.allowSuper.get = function() {\n    var ref = this.currentThisScope();\n    var flags = ref.flags;\n    return (flags & SCOPE_SUPER) > 0 || this.options.allowSuperOutsideMethod;\n};\nprototypeAccessors.allowDirectSuper.get = function() {\n    return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;\n};\nprototypeAccessors.treatFunctionsAsVar.get = function() {\n    return this.treatFunctionsAsVarInScope(this.currentScope());\n};\nprototypeAccessors.allowNewDotTarget.get = function() {\n    for(var i = this.scopeStack.length - 1; i >= 0; i--){\n        var ref = this.scopeStack[i];\n        var flags = ref.flags;\n        if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT) || flags & SCOPE_FUNCTION && !(flags & SCOPE_ARROW)) {\n            return true;\n        }\n    }\n    return false;\n};\nprototypeAccessors.inClassStaticBlock.get = function() {\n    return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;\n};\nParser.extend = function extend() {\n    var plugins = [], len = arguments.length;\n    while(len--)plugins[len] = arguments[len];\n    var cls = this;\n    for(var i = 0; i < plugins.length; i++){\n        cls = plugins[i](cls);\n    }\n    return cls;\n};\nParser.parse = function parse(input, options) {\n    return new this(options, input).parse();\n};\nParser.parseExpressionAt = function parseExpressionAt(input, pos, options) {\n    var parser = new this(options, input, pos);\n    parser.nextToken();\n    return parser.parseExpression();\n};\nParser.tokenizer = function tokenizer(input, options) {\n    return new this(options, input);\n};\nObject.defineProperties(Parser.prototype, prototypeAccessors);\nvar pp$9 = Parser.prototype;\n// ## Parser utilities\nvar literal = /^(?:'((?:\\\\[^]|[^'\\\\])*?)'|\"((?:\\\\[^]|[^\"\\\\])*?)\")/;\npp$9.strictDirective = function(start) {\n    if (this.options.ecmaVersion < 5) {\n        return false;\n    }\n    for(;;){\n        // Try to find string literal.\n        skipWhiteSpace.lastIndex = start;\n        start += skipWhiteSpace.exec(this.input)[0].length;\n        var match = literal.exec(this.input.slice(start));\n        if (!match) {\n            return false;\n        }\n        if ((match[1] || match[2]) === \"use strict\") {\n            skipWhiteSpace.lastIndex = start + match[0].length;\n            var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;\n            var next = this.input.charAt(end);\n            return next === \";\" || next === \"}\" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\\-/*%<>=,?^&]/.test(next) || next === \"!\" && this.input.charAt(end + 1) === \"=\");\n        }\n        start += match[0].length;\n        // Skip semicolon, if any.\n        skipWhiteSpace.lastIndex = start;\n        start += skipWhiteSpace.exec(this.input)[0].length;\n        if (this.input[start] === \";\") {\n            start++;\n        }\n    }\n};\n// Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\npp$9.eat = function(type) {\n    if (this.type === type) {\n        this.next();\n        return true;\n    } else {\n        return false;\n    }\n};\n// Tests whether parsed token is a contextual keyword.\npp$9.isContextual = function(name) {\n    return this.type === types$1.name && this.value === name && !this.containsEsc;\n};\n// Consumes contextual keyword if possible.\npp$9.eatContextual = function(name) {\n    if (!this.isContextual(name)) {\n        return false;\n    }\n    this.next();\n    return true;\n};\n// Asserts that following token is given contextual keyword.\npp$9.expectContextual = function(name) {\n    if (!this.eatContextual(name)) {\n        this.unexpected();\n    }\n};\n// Test whether a semicolon can be inserted at the current position.\npp$9.canInsertSemicolon = function() {\n    return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n};\npp$9.insertSemicolon = function() {\n    if (this.canInsertSemicolon()) {\n        if (this.options.onInsertedSemicolon) {\n            this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);\n        }\n        return true;\n    }\n};\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\npp$9.semicolon = function() {\n    if (!this.eat(types$1.semi) && !this.insertSemicolon()) {\n        this.unexpected();\n    }\n};\npp$9.afterTrailingComma = function(tokType, notNext) {\n    if (this.type === tokType) {\n        if (this.options.onTrailingComma) {\n            this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);\n        }\n        if (!notNext) {\n            this.next();\n        }\n        return true;\n    }\n};\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\npp$9.expect = function(type) {\n    this.eat(type) || this.unexpected();\n};\n// Raise an unexpected token error.\npp$9.unexpected = function(pos) {\n    this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n};\nvar DestructuringErrors = function DestructuringErrors() {\n    this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;\n};\npp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n    if (!refDestructuringErrors) {\n        return;\n    }\n    if (refDestructuringErrors.trailingComma > -1) {\n        this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\");\n    }\n    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n    if (parens > -1) {\n        this.raiseRecoverable(parens, isAssign ? \"Assigning to rvalue\" : \"Parenthesized pattern\");\n    }\n};\npp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n    if (!refDestructuringErrors) {\n        return false;\n    }\n    var shorthandAssign = refDestructuringErrors.shorthandAssign;\n    var doubleProto = refDestructuringErrors.doubleProto;\n    if (!andThrow) {\n        return shorthandAssign >= 0 || doubleProto >= 0;\n    }\n    if (shorthandAssign >= 0) {\n        this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\");\n    }\n    if (doubleProto >= 0) {\n        this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\");\n    }\n};\npp$9.checkYieldAwaitInDefaultParams = function() {\n    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {\n        this.raise(this.yieldPos, \"Yield expression cannot be a default value\");\n    }\n    if (this.awaitPos) {\n        this.raise(this.awaitPos, \"Await expression cannot be a default value\");\n    }\n};\npp$9.isSimpleAssignTarget = function(expr) {\n    if (expr.type === \"ParenthesizedExpression\") {\n        return this.isSimpleAssignTarget(expr.expression);\n    }\n    return expr.type === \"Identifier\" || expr.type === \"MemberExpression\";\n};\nvar pp$8 = Parser.prototype;\n// ### Statement parsing\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\npp$8.parseTopLevel = function(node) {\n    var exports = Object.create(null);\n    if (!node.body) {\n        node.body = [];\n    }\n    while(this.type !== types$1.eof){\n        var stmt = this.parseStatement(null, true, exports);\n        node.body.push(stmt);\n    }\n    if (this.inModule) {\n        for(var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1){\n            var name = list[i];\n            this.raiseRecoverable(this.undefinedExports[name].start, \"Export '\" + name + \"' is not defined\");\n        }\n    }\n    this.adaptDirectivePrologue(node.body);\n    this.next();\n    node.sourceType = this.options.sourceType;\n    return this.finishNode(node, \"Program\");\n};\nvar loopLabel = {\n    kind: \"loop\"\n}, switchLabel = {\n    kind: \"switch\"\n};\npp$8.isLet = function(context) {\n    if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) {\n        return false;\n    }\n    skipWhiteSpace.lastIndex = this.pos;\n    var skip = skipWhiteSpace.exec(this.input);\n    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n    // For ambiguous cases, determine if a LexicalDeclaration (or only a\n    // Statement) is allowed here. If context is not empty then only a Statement\n    // is allowed. However, `let [` is an explicit negative lookahead for\n    // ExpressionStatement, so special-case it first.\n    if (nextCh === 91 || nextCh === 92) {\n        return true;\n    } // '[', '\\'\n    if (context) {\n        return false;\n    }\n    if (nextCh === 123 || nextCh > 0xd7ff && nextCh < 0xdc00) {\n        return true;\n    } // '{', astral\n    if (isIdentifierStart(nextCh, true)) {\n        var pos = next + 1;\n        while(isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)){\n            ++pos;\n        }\n        if (nextCh === 92 || nextCh > 0xd7ff && nextCh < 0xdc00) {\n            return true;\n        }\n        var ident = this.input.slice(next, pos);\n        if (!keywordRelationalOperator.test(ident)) {\n            return true;\n        }\n    }\n    return false;\n};\n// check 'async [no LineTerminator here] function'\n// - 'async /*foo*/ function' is OK.\n// - 'async /*\\n*/ function' is invalid.\npp$8.isAsyncFunction = function() {\n    if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\")) {\n        return false;\n    }\n    skipWhiteSpace.lastIndex = this.pos;\n    var skip = skipWhiteSpace.exec(this.input);\n    var next = this.pos + skip[0].length, after;\n    return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === \"function\" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 0xd7ff && after < 0xdc00));\n};\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\npp$8.parseStatement = function(context, topLevel, exports) {\n    var starttype = this.type, node = this.startNode(), kind;\n    if (this.isLet(context)) {\n        starttype = types$1._var;\n        kind = \"let\";\n    }\n    // Most types of statements are recognized by the keyword they\n    // start with. Many are trivial to parse, some require a bit of\n    // complexity.\n    switch(starttype){\n        case types$1._break:\n        case types$1._continue:\n            return this.parseBreakContinueStatement(node, starttype.keyword);\n        case types$1._debugger:\n            return this.parseDebuggerStatement(node);\n        case types$1._do:\n            return this.parseDoStatement(node);\n        case types$1._for:\n            return this.parseForStatement(node);\n        case types$1._function:\n            // Function as sole body of either an if statement or a labeled statement\n            // works, but not when it is part of a labeled statement that is the sole\n            // body of an if statement.\n            if (context && (this.strict || context !== \"if\" && context !== \"label\") && this.options.ecmaVersion >= 6) {\n                this.unexpected();\n            }\n            return this.parseFunctionStatement(node, false, !context);\n        case types$1._class:\n            if (context) {\n                this.unexpected();\n            }\n            return this.parseClass(node, true);\n        case types$1._if:\n            return this.parseIfStatement(node);\n        case types$1._return:\n            return this.parseReturnStatement(node);\n        case types$1._switch:\n            return this.parseSwitchStatement(node);\n        case types$1._throw:\n            return this.parseThrowStatement(node);\n        case types$1._try:\n            return this.parseTryStatement(node);\n        case types$1._const:\n        case types$1._var:\n            kind = kind || this.value;\n            if (context && kind !== \"var\") {\n                this.unexpected();\n            }\n            return this.parseVarStatement(node, kind);\n        case types$1._while:\n            return this.parseWhileStatement(node);\n        case types$1._with:\n            return this.parseWithStatement(node);\n        case types$1.braceL:\n            return this.parseBlock(true, node);\n        case types$1.semi:\n            return this.parseEmptyStatement(node);\n        case types$1._export:\n        case types$1._import:\n            if (this.options.ecmaVersion > 10 && starttype === types$1._import) {\n                skipWhiteSpace.lastIndex = this.pos;\n                var skip = skipWhiteSpace.exec(this.input);\n                var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n                if (nextCh === 40 || nextCh === 46) {\n                    return this.parseExpressionStatement(node, this.parseExpression());\n                }\n            }\n            if (!this.options.allowImportExportEverywhere) {\n                if (!topLevel) {\n                    this.raise(this.start, \"'import' and 'export' may only appear at the top level\");\n                }\n                if (!this.inModule) {\n                    this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\");\n                }\n            }\n            return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports);\n        // If the statement does not start with a statement keyword or a\n        // brace, it's an ExpressionStatement or LabeledStatement. We\n        // simply start parsing an expression, and afterwards, if the\n        // next token is a colon and the expression was a simple\n        // Identifier node, we switch to interpreting it as a label.\n        default:\n            if (this.isAsyncFunction()) {\n                if (context) {\n                    this.unexpected();\n                }\n                this.next();\n                return this.parseFunctionStatement(node, true, !context);\n            }\n            var maybeName = this.value, expr = this.parseExpression();\n            if (starttype === types$1.name && expr.type === \"Identifier\" && this.eat(types$1.colon)) {\n                return this.parseLabeledStatement(node, maybeName, expr, context);\n            } else {\n                return this.parseExpressionStatement(node, expr);\n            }\n    }\n};\npp$8.parseBreakContinueStatement = function(node, keyword) {\n    var isBreak = keyword === \"break\";\n    this.next();\n    if (this.eat(types$1.semi) || this.insertSemicolon()) {\n        node.label = null;\n    } else if (this.type !== types$1.name) {\n        this.unexpected();\n    } else {\n        node.label = this.parseIdent();\n        this.semicolon();\n    }\n    // Verify that there is an actual destination to break or\n    // continue to.\n    var i = 0;\n    for(; i < this.labels.length; ++i){\n        var lab = this.labels[i];\n        if (node.label == null || lab.name === node.label.name) {\n            if (lab.kind != null && (isBreak || lab.kind === \"loop\")) {\n                break;\n            }\n            if (node.label && isBreak) {\n                break;\n            }\n        }\n    }\n    if (i === this.labels.length) {\n        this.raise(node.start, \"Unsyntactic \" + keyword);\n    }\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n};\npp$8.parseDebuggerStatement = function(node) {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\");\n};\npp$8.parseDoStatement = function(node) {\n    this.next();\n    this.labels.push(loopLabel);\n    node.body = this.parseStatement(\"do\");\n    this.labels.pop();\n    this.expect(types$1._while);\n    node.test = this.parseParenExpression();\n    if (this.options.ecmaVersion >= 6) {\n        this.eat(types$1.semi);\n    } else {\n        this.semicolon();\n    }\n    return this.finishNode(node, \"DoWhileStatement\");\n};\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\npp$8.parseForStatement = function(node) {\n    this.next();\n    var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual(\"await\") ? this.lastTokStart : -1;\n    this.labels.push(loopLabel);\n    this.enterScope(0);\n    this.expect(types$1.parenL);\n    if (this.type === types$1.semi) {\n        if (awaitAt > -1) {\n            this.unexpected(awaitAt);\n        }\n        return this.parseFor(node, null);\n    }\n    var isLet = this.isLet();\n    if (this.type === types$1._var || this.type === types$1._const || isLet) {\n        var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value;\n        this.next();\n        this.parseVar(init$1, true, kind);\n        this.finishNode(init$1, \"VariableDeclaration\");\n        if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\")) && init$1.declarations.length === 1) {\n            if (this.options.ecmaVersion >= 9) {\n                if (this.type === types$1._in) {\n                    if (awaitAt > -1) {\n                        this.unexpected(awaitAt);\n                    }\n                } else {\n                    node.await = awaitAt > -1;\n                }\n            }\n            return this.parseForIn(node, init$1);\n        }\n        if (awaitAt > -1) {\n            this.unexpected(awaitAt);\n        }\n        return this.parseFor(node, init$1);\n    }\n    var startsWithLet = this.isContextual(\"let\"), isForOf = false;\n    var containsEsc = this.containsEsc;\n    var refDestructuringErrors = new DestructuringErrors;\n    var initPos = this.start;\n    var init = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, \"await\") : this.parseExpression(true, refDestructuringErrors);\n    if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n        if (awaitAt > -1) {\n            if (this.type === types$1._in) {\n                this.unexpected(awaitAt);\n            }\n            node.await = true;\n        } else if (isForOf && this.options.ecmaVersion >= 8) {\n            if (init.start === initPos && !containsEsc && init.type === \"Identifier\" && init.name === \"async\") {\n                this.unexpected();\n            } else if (this.options.ecmaVersion >= 9) {\n                node.await = false;\n            }\n        }\n        if (startsWithLet && isForOf) {\n            this.raise(init.start, \"The left-hand side of a for-of loop may not start with 'let'.\");\n        }\n        this.toAssignable(init, false, refDestructuringErrors);\n        this.checkLValPattern(init);\n        return this.parseForIn(node, init);\n    } else {\n        this.checkExpressionErrors(refDestructuringErrors, true);\n    }\n    if (awaitAt > -1) {\n        this.unexpected(awaitAt);\n    }\n    return this.parseFor(node, init);\n};\npp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {\n    this.next();\n    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);\n};\npp$8.parseIfStatement = function(node) {\n    this.next();\n    node.test = this.parseParenExpression();\n    // allow function declarations in branches, but only in non-strict mode\n    node.consequent = this.parseStatement(\"if\");\n    node.alternate = this.eat(types$1._else) ? this.parseStatement(\"if\") : null;\n    return this.finishNode(node, \"IfStatement\");\n};\npp$8.parseReturnStatement = function(node) {\n    if (!this.inFunction && !this.options.allowReturnOutsideFunction) {\n        this.raise(this.start, \"'return' outside of function\");\n    }\n    this.next();\n    // In `return` (and `break`/`continue`), the keywords with\n    // optional arguments, we eagerly look for a semicolon or the\n    // possibility to insert one.\n    if (this.eat(types$1.semi) || this.insertSemicolon()) {\n        node.argument = null;\n    } else {\n        node.argument = this.parseExpression();\n        this.semicolon();\n    }\n    return this.finishNode(node, \"ReturnStatement\");\n};\npp$8.parseSwitchStatement = function(node) {\n    this.next();\n    node.discriminant = this.parseParenExpression();\n    node.cases = [];\n    this.expect(types$1.braceL);\n    this.labels.push(switchLabel);\n    this.enterScope(0);\n    // Statements under must be grouped (by label) in SwitchCase\n    // nodes. `cur` is used to keep the node that we are currently\n    // adding statements to.\n    var cur;\n    for(var sawDefault = false; this.type !== types$1.braceR;){\n        if (this.type === types$1._case || this.type === types$1._default) {\n            var isCase = this.type === types$1._case;\n            if (cur) {\n                this.finishNode(cur, \"SwitchCase\");\n            }\n            node.cases.push(cur = this.startNode());\n            cur.consequent = [];\n            this.next();\n            if (isCase) {\n                cur.test = this.parseExpression();\n            } else {\n                if (sawDefault) {\n                    this.raiseRecoverable(this.lastTokStart, \"Multiple default clauses\");\n                }\n                sawDefault = true;\n                cur.test = null;\n            }\n            this.expect(types$1.colon);\n        } else {\n            if (!cur) {\n                this.unexpected();\n            }\n            cur.consequent.push(this.parseStatement(null));\n        }\n    }\n    this.exitScope();\n    if (cur) {\n        this.finishNode(cur, \"SwitchCase\");\n    }\n    this.next(); // Closing brace\n    this.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\");\n};\npp$8.parseThrowStatement = function(node) {\n    this.next();\n    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {\n        this.raise(this.lastTokEnd, \"Illegal newline after throw\");\n    }\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\");\n};\n// Reused empty array added for node fields that are always empty.\nvar empty$1 = [];\npp$8.parseCatchClauseParam = function() {\n    var param = this.parseBindingAtom();\n    var simple = param.type === \"Identifier\";\n    this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);\n    this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);\n    this.expect(types$1.parenR);\n    return param;\n};\npp$8.parseTryStatement = function(node) {\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n    if (this.type === types$1._catch) {\n        var clause = this.startNode();\n        this.next();\n        if (this.eat(types$1.parenL)) {\n            clause.param = this.parseCatchClauseParam();\n        } else {\n            if (this.options.ecmaVersion < 10) {\n                this.unexpected();\n            }\n            clause.param = null;\n            this.enterScope(0);\n        }\n        clause.body = this.parseBlock(false);\n        this.exitScope();\n        node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n    node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;\n    if (!node.handler && !node.finalizer) {\n        this.raise(node.start, \"Missing catch or finally clause\");\n    }\n    return this.finishNode(node, \"TryStatement\");\n};\npp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {\n    this.next();\n    this.parseVar(node, false, kind, allowMissingInitializer);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\");\n};\npp$8.parseWhileStatement = function(node) {\n    this.next();\n    node.test = this.parseParenExpression();\n    this.labels.push(loopLabel);\n    node.body = this.parseStatement(\"while\");\n    this.labels.pop();\n    return this.finishNode(node, \"WhileStatement\");\n};\npp$8.parseWithStatement = function(node) {\n    if (this.strict) {\n        this.raise(this.start, \"'with' in strict mode\");\n    }\n    this.next();\n    node.object = this.parseParenExpression();\n    node.body = this.parseStatement(\"with\");\n    return this.finishNode(node, \"WithStatement\");\n};\npp$8.parseEmptyStatement = function(node) {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\");\n};\npp$8.parseLabeledStatement = function(node, maybeName, expr, context) {\n    for(var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1){\n        var label = list[i$1];\n        if (label.name === maybeName) {\n            this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n        }\n    }\n    var kind = this.type.isLoop ? \"loop\" : this.type === types$1._switch ? \"switch\" : null;\n    for(var i = this.labels.length - 1; i >= 0; i--){\n        var label$1 = this.labels[i];\n        if (label$1.statementStart === node.start) {\n            // Update information about previous labels on this node\n            label$1.statementStart = this.start;\n            label$1.kind = kind;\n        } else {\n            break;\n        }\n    }\n    this.labels.push({\n        name: maybeName,\n        kind: kind,\n        statementStart: this.start\n    });\n    node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n    this.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\");\n};\npp$8.parseExpressionStatement = function(node, expr) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\");\n};\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\npp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {\n    if (createNewLexicalScope === void 0) createNewLexicalScope = true;\n    if (node === void 0) node = this.startNode();\n    node.body = [];\n    this.expect(types$1.braceL);\n    if (createNewLexicalScope) {\n        this.enterScope(0);\n    }\n    while(this.type !== types$1.braceR){\n        var stmt = this.parseStatement(null);\n        node.body.push(stmt);\n    }\n    if (exitStrict) {\n        this.strict = false;\n    }\n    this.next();\n    if (createNewLexicalScope) {\n        this.exitScope();\n    }\n    return this.finishNode(node, \"BlockStatement\");\n};\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\npp$8.parseFor = function(node, init) {\n    node.init = init;\n    this.expect(types$1.semi);\n    node.test = this.type === types$1.semi ? null : this.parseExpression();\n    this.expect(types$1.semi);\n    node.update = this.type === types$1.parenR ? null : this.parseExpression();\n    this.expect(types$1.parenR);\n    node.body = this.parseStatement(\"for\");\n    this.exitScope();\n    this.labels.pop();\n    return this.finishNode(node, \"ForStatement\");\n};\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\npp$8.parseForIn = function(node, init) {\n    var isForIn = this.type === types$1._in;\n    this.next();\n    if (init.type === \"VariableDeclaration\" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== \"var\" || init.declarations[0].id.type !== \"Identifier\")) {\n        this.raise(init.start, (isForIn ? \"for-in\" : \"for-of\") + \" loop variable declaration may not have an initializer\");\n    }\n    node.left = init;\n    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();\n    this.expect(types$1.parenR);\n    node.body = this.parseStatement(\"for\");\n    this.exitScope();\n    this.labels.pop();\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\");\n};\n// Parse a list of variable declarations.\npp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {\n    node.declarations = [];\n    node.kind = kind;\n    for(;;){\n        var decl = this.startNode();\n        this.parseVarId(decl, kind);\n        if (this.eat(types$1.eq)) {\n            decl.init = this.parseMaybeAssign(isFor);\n        } else if (!allowMissingInitializer && kind === \"const\" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n            this.unexpected();\n        } else if (!allowMissingInitializer && decl.id.type !== \"Identifier\" && !(isFor && (this.type === types$1._in || this.isContextual(\"of\")))) {\n            this.raise(this.lastTokEnd, \"Complex binding patterns require an initialization value\");\n        } else {\n            decl.init = null;\n        }\n        node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n        if (!this.eat(types$1.comma)) {\n            break;\n        }\n    }\n    return node;\n};\npp$8.parseVarId = function(decl, kind) {\n    decl.id = this.parseBindingAtom();\n    this.checkLValPattern(decl.id, kind === \"var\" ? BIND_VAR : BIND_LEXICAL, false);\n};\nvar FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;\n// Parse a function declaration or literal (depending on the\n// `statement & FUNC_STATEMENT`).\n// Remove `allowExpressionBody` for 7.0.0, as it is only called with false\npp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {\n        if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {\n            this.unexpected();\n        }\n        node.generator = this.eat(types$1.star);\n    }\n    if (this.options.ecmaVersion >= 8) {\n        node.async = !!isAsync;\n    }\n    if (statement & FUNC_STATEMENT) {\n        node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();\n        if (node.id && !(statement & FUNC_HANGING_STATEMENT)) // If it is a regular function declaration in sloppy mode, then it is\n        // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding\n        // mode depends on properties of the current scope (see\n        // treatFunctionsAsVar).\n        {\n            this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);\n        }\n    }\n    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    this.enterScope(functionFlags(node.async, node.generator));\n    if (!(statement & FUNC_STATEMENT)) {\n        node.id = this.type === types$1.name ? this.parseIdent() : null;\n    }\n    this.parseFunctionParams(node);\n    this.parseFunctionBody(node, allowExpressionBody, false, forInit);\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos;\n    return this.finishNode(node, statement & FUNC_STATEMENT ? \"FunctionDeclaration\" : \"FunctionExpression\");\n};\npp$8.parseFunctionParams = function(node) {\n    this.expect(types$1.parenL);\n    node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);\n    this.checkYieldAwaitInDefaultParams();\n};\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\npp$8.parseClass = function(node, isStatement) {\n    this.next();\n    // ecma-262 14.6 Class Definitions\n    // A class definition is always strict mode code.\n    var oldStrict = this.strict;\n    this.strict = true;\n    this.parseClassId(node, isStatement);\n    this.parseClassSuper(node);\n    var privateNameMap = this.enterClassBody();\n    var classBody = this.startNode();\n    var hadConstructor = false;\n    classBody.body = [];\n    this.expect(types$1.braceL);\n    while(this.type !== types$1.braceR){\n        var element = this.parseClassElement(node.superClass !== null);\n        if (element) {\n            classBody.body.push(element);\n            if (element.type === \"MethodDefinition\" && element.kind === \"constructor\") {\n                if (hadConstructor) {\n                    this.raiseRecoverable(element.start, \"Duplicate constructor in the same class\");\n                }\n                hadConstructor = true;\n            } else if (element.key && element.key.type === \"PrivateIdentifier\" && isPrivateNameConflicted(privateNameMap, element)) {\n                this.raiseRecoverable(element.key.start, \"Identifier '#\" + element.key.name + \"' has already been declared\");\n            }\n        }\n    }\n    this.strict = oldStrict;\n    this.next();\n    node.body = this.finishNode(classBody, \"ClassBody\");\n    this.exitClassBody();\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n};\npp$8.parseClassElement = function(constructorAllowsSuper) {\n    if (this.eat(types$1.semi)) {\n        return null;\n    }\n    var ecmaVersion = this.options.ecmaVersion;\n    var node = this.startNode();\n    var keyName = \"\";\n    var isGenerator = false;\n    var isAsync = false;\n    var kind = \"method\";\n    var isStatic = false;\n    if (this.eatContextual(\"static\")) {\n        // Parse static init block\n        if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {\n            this.parseClassStaticBlock(node);\n            return node;\n        }\n        if (this.isClassElementNameStart() || this.type === types$1.star) {\n            isStatic = true;\n        } else {\n            keyName = \"static\";\n        }\n    }\n    node.static = isStatic;\n    if (!keyName && ecmaVersion >= 8 && this.eatContextual(\"async\")) {\n        if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {\n            isAsync = true;\n        } else {\n            keyName = \"async\";\n        }\n    }\n    if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {\n        isGenerator = true;\n    }\n    if (!keyName && !isAsync && !isGenerator) {\n        var lastValue = this.value;\n        if (this.eatContextual(\"get\") || this.eatContextual(\"set\")) {\n            if (this.isClassElementNameStart()) {\n                kind = lastValue;\n            } else {\n                keyName = lastValue;\n            }\n        }\n    }\n    // Parse element name\n    if (keyName) {\n        // 'async', 'get', 'set', or 'static' were not a keyword contextually.\n        // The last token is any of those. Make it the element name.\n        node.computed = false;\n        node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);\n        node.key.name = keyName;\n        this.finishNode(node.key, \"Identifier\");\n    } else {\n        this.parseClassElementName(node);\n    }\n    // Parse element value\n    if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== \"method\" || isGenerator || isAsync) {\n        var isConstructor = !node.static && checkKeyName(node, \"constructor\");\n        var allowsDirectSuper = isConstructor && constructorAllowsSuper;\n        // Couldn't move this check into the 'parseClassMethod' method for backward compatibility.\n        if (isConstructor && kind !== \"method\") {\n            this.raise(node.key.start, \"Constructor can't have get/set modifier\");\n        }\n        node.kind = isConstructor ? \"constructor\" : kind;\n        this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);\n    } else {\n        this.parseClassField(node);\n    }\n    return node;\n};\npp$8.isClassElementNameStart = function() {\n    return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;\n};\npp$8.parseClassElementName = function(element) {\n    if (this.type === types$1.privateId) {\n        if (this.value === \"constructor\") {\n            this.raise(this.start, \"Classes can't have an element named '#constructor'\");\n        }\n        element.computed = false;\n        element.key = this.parsePrivateIdent();\n    } else {\n        this.parsePropertyName(element);\n    }\n};\npp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {\n    // Check key and flags\n    var key = method.key;\n    if (method.kind === \"constructor\") {\n        if (isGenerator) {\n            this.raise(key.start, \"Constructor can't be a generator\");\n        }\n        if (isAsync) {\n            this.raise(key.start, \"Constructor can't be an async method\");\n        }\n    } else if (method.static && checkKeyName(method, \"prototype\")) {\n        this.raise(key.start, \"Classes may not have a static property named prototype\");\n    }\n    // Parse value\n    var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);\n    // Check value\n    if (method.kind === \"get\" && value.params.length !== 0) {\n        this.raiseRecoverable(value.start, \"getter should have no params\");\n    }\n    if (method.kind === \"set\" && value.params.length !== 1) {\n        this.raiseRecoverable(value.start, \"setter should have exactly one param\");\n    }\n    if (method.kind === \"set\" && value.params[0].type === \"RestElement\") {\n        this.raiseRecoverable(value.params[0].start, \"Setter cannot use rest params\");\n    }\n    return this.finishNode(method, \"MethodDefinition\");\n};\npp$8.parseClassField = function(field) {\n    if (checkKeyName(field, \"constructor\")) {\n        this.raise(field.key.start, \"Classes can't have a field named 'constructor'\");\n    } else if (field.static && checkKeyName(field, \"prototype\")) {\n        this.raise(field.key.start, \"Classes can't have a static field named 'prototype'\");\n    }\n    if (this.eat(types$1.eq)) {\n        // To raise SyntaxError if 'arguments' exists in the initializer.\n        this.enterScope(SCOPE_CLASS_FIELD_INIT | SCOPE_SUPER);\n        field.value = this.parseMaybeAssign();\n        this.exitScope();\n    } else {\n        field.value = null;\n    }\n    this.semicolon();\n    return this.finishNode(field, \"PropertyDefinition\");\n};\npp$8.parseClassStaticBlock = function(node) {\n    node.body = [];\n    var oldLabels = this.labels;\n    this.labels = [];\n    this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);\n    while(this.type !== types$1.braceR){\n        var stmt = this.parseStatement(null);\n        node.body.push(stmt);\n    }\n    this.next();\n    this.exitScope();\n    this.labels = oldLabels;\n    return this.finishNode(node, \"StaticBlock\");\n};\npp$8.parseClassId = function(node, isStatement) {\n    if (this.type === types$1.name) {\n        node.id = this.parseIdent();\n        if (isStatement) {\n            this.checkLValSimple(node.id, BIND_LEXICAL, false);\n        }\n    } else {\n        if (isStatement === true) {\n            this.unexpected();\n        }\n        node.id = null;\n    }\n};\npp$8.parseClassSuper = function(node) {\n    node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;\n};\npp$8.enterClassBody = function() {\n    var element = {\n        declared: Object.create(null),\n        used: []\n    };\n    this.privateNameStack.push(element);\n    return element.declared;\n};\npp$8.exitClassBody = function() {\n    var ref = this.privateNameStack.pop();\n    var declared = ref.declared;\n    var used = ref.used;\n    if (!this.options.checkPrivateFields) {\n        return;\n    }\n    var len = this.privateNameStack.length;\n    var parent = len === 0 ? null : this.privateNameStack[len - 1];\n    for(var i = 0; i < used.length; ++i){\n        var id = used[i];\n        if (!hasOwn(declared, id.name)) {\n            if (parent) {\n                parent.used.push(id);\n            } else {\n                this.raiseRecoverable(id.start, \"Private field '#\" + id.name + \"' must be declared in an enclosing class\");\n            }\n        }\n    }\n};\nfunction isPrivateNameConflicted(privateNameMap, element) {\n    var name = element.key.name;\n    var curr = privateNameMap[name];\n    var next = \"true\";\n    if (element.type === \"MethodDefinition\" && (element.kind === \"get\" || element.kind === \"set\")) {\n        next = (element.static ? \"s\" : \"i\") + element.kind;\n    }\n    // `class { get #a(){}; static set #a(_){} }` is also conflict.\n    if (curr === \"iget\" && next === \"iset\" || curr === \"iset\" && next === \"iget\" || curr === \"sget\" && next === \"sset\" || curr === \"sset\" && next === \"sget\") {\n        privateNameMap[name] = \"true\";\n        return false;\n    } else if (!curr) {\n        privateNameMap[name] = next;\n        return false;\n    } else {\n        return true;\n    }\n}\nfunction checkKeyName(node, name) {\n    var computed = node.computed;\n    var key = node.key;\n    return !computed && (key.type === \"Identifier\" && key.name === name || key.type === \"Literal\" && key.value === name);\n}\n// Parses module export declaration.\npp$8.parseExportAllDeclaration = function(node, exports) {\n    if (this.options.ecmaVersion >= 11) {\n        if (this.eatContextual(\"as\")) {\n            node.exported = this.parseModuleExportName();\n            this.checkExport(exports, node.exported, this.lastTokStart);\n        } else {\n            node.exported = null;\n        }\n    }\n    this.expectContextual(\"from\");\n    if (this.type !== types$1.string) {\n        this.unexpected();\n    }\n    node.source = this.parseExprAtom();\n    if (this.options.ecmaVersion >= 16) {\n        node.attributes = this.parseWithClause();\n    }\n    this.semicolon();\n    return this.finishNode(node, \"ExportAllDeclaration\");\n};\npp$8.parseExport = function(node, exports) {\n    this.next();\n    // export * from '...'\n    if (this.eat(types$1.star)) {\n        return this.parseExportAllDeclaration(node, exports);\n    }\n    if (this.eat(types$1._default)) {\n        this.checkExport(exports, \"default\", this.lastTokStart);\n        node.declaration = this.parseExportDefaultDeclaration();\n        return this.finishNode(node, \"ExportDefaultDeclaration\");\n    }\n    // export var|const|let|function|class ...\n    if (this.shouldParseExportStatement()) {\n        node.declaration = this.parseExportDeclaration(node);\n        if (node.declaration.type === \"VariableDeclaration\") {\n            this.checkVariableExport(exports, node.declaration.declarations);\n        } else {\n            this.checkExport(exports, node.declaration.id, node.declaration.id.start);\n        }\n        node.specifiers = [];\n        node.source = null;\n        if (this.options.ecmaVersion >= 16) {\n            node.attributes = [];\n        }\n    } else {\n        node.declaration = null;\n        node.specifiers = this.parseExportSpecifiers(exports);\n        if (this.eatContextual(\"from\")) {\n            if (this.type !== types$1.string) {\n                this.unexpected();\n            }\n            node.source = this.parseExprAtom();\n            if (this.options.ecmaVersion >= 16) {\n                node.attributes = this.parseWithClause();\n            }\n        } else {\n            for(var i = 0, list = node.specifiers; i < list.length; i += 1){\n                // check for keywords used as local names\n                var spec = list[i];\n                this.checkUnreserved(spec.local);\n                // check if export is defined\n                this.checkLocalExport(spec.local);\n                if (spec.local.type === \"Literal\") {\n                    this.raise(spec.local.start, \"A string literal cannot be used as an exported binding without `from`.\");\n                }\n            }\n            node.source = null;\n            if (this.options.ecmaVersion >= 16) {\n                node.attributes = [];\n            }\n        }\n        this.semicolon();\n    }\n    return this.finishNode(node, \"ExportNamedDeclaration\");\n};\npp$8.parseExportDeclaration = function(node) {\n    return this.parseStatement(null);\n};\npp$8.parseExportDefaultDeclaration = function() {\n    var isAsync;\n    if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {\n        var fNode = this.startNode();\n        this.next();\n        if (isAsync) {\n            this.next();\n        }\n        return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n    } else if (this.type === types$1._class) {\n        var cNode = this.startNode();\n        return this.parseClass(cNode, \"nullableID\");\n    } else {\n        var declaration = this.parseMaybeAssign();\n        this.semicolon();\n        return declaration;\n    }\n};\npp$8.checkExport = function(exports, name, pos) {\n    if (!exports) {\n        return;\n    }\n    if (typeof name !== \"string\") {\n        name = name.type === \"Identifier\" ? name.name : name.value;\n    }\n    if (hasOwn(exports, name)) {\n        this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\");\n    }\n    exports[name] = true;\n};\npp$8.checkPatternExport = function(exports, pat) {\n    var type = pat.type;\n    if (type === \"Identifier\") {\n        this.checkExport(exports, pat, pat.start);\n    } else if (type === \"ObjectPattern\") {\n        for(var i = 0, list = pat.properties; i < list.length; i += 1){\n            var prop = list[i];\n            this.checkPatternExport(exports, prop);\n        }\n    } else if (type === \"ArrayPattern\") {\n        for(var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1){\n            var elt = list$1[i$1];\n            if (elt) {\n                this.checkPatternExport(exports, elt);\n            }\n        }\n    } else if (type === \"Property\") {\n        this.checkPatternExport(exports, pat.value);\n    } else if (type === \"AssignmentPattern\") {\n        this.checkPatternExport(exports, pat.left);\n    } else if (type === \"RestElement\") {\n        this.checkPatternExport(exports, pat.argument);\n    }\n};\npp$8.checkVariableExport = function(exports, decls) {\n    if (!exports) {\n        return;\n    }\n    for(var i = 0, list = decls; i < list.length; i += 1){\n        var decl = list[i];\n        this.checkPatternExport(exports, decl.id);\n    }\n};\npp$8.shouldParseExportStatement = function() {\n    return this.type.keyword === \"var\" || this.type.keyword === \"const\" || this.type.keyword === \"class\" || this.type.keyword === \"function\" || this.isLet() || this.isAsyncFunction();\n};\n// Parses a comma-separated list of module exports.\npp$8.parseExportSpecifier = function(exports) {\n    var node = this.startNode();\n    node.local = this.parseModuleExportName();\n    node.exported = this.eatContextual(\"as\") ? this.parseModuleExportName() : node.local;\n    this.checkExport(exports, node.exported, node.exported.start);\n    return this.finishNode(node, \"ExportSpecifier\");\n};\npp$8.parseExportSpecifiers = function(exports) {\n    var nodes = [], first = true;\n    // export { x, y as z } [from '...']\n    this.expect(types$1.braceL);\n    while(!this.eat(types$1.braceR)){\n        if (!first) {\n            this.expect(types$1.comma);\n            if (this.afterTrailingComma(types$1.braceR)) {\n                break;\n            }\n        } else {\n            first = false;\n        }\n        nodes.push(this.parseExportSpecifier(exports));\n    }\n    return nodes;\n};\n// Parses import declaration.\npp$8.parseImport = function(node) {\n    this.next();\n    // import '...'\n    if (this.type === types$1.string) {\n        node.specifiers = empty$1;\n        node.source = this.parseExprAtom();\n    } else {\n        node.specifiers = this.parseImportSpecifiers();\n        this.expectContextual(\"from\");\n        node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();\n    }\n    if (this.options.ecmaVersion >= 16) {\n        node.attributes = this.parseWithClause();\n    }\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n};\n// Parses a comma-separated list of module imports.\npp$8.parseImportSpecifier = function() {\n    var node = this.startNode();\n    node.imported = this.parseModuleExportName();\n    if (this.eatContextual(\"as\")) {\n        node.local = this.parseIdent();\n    } else {\n        this.checkUnreserved(node.imported);\n        node.local = node.imported;\n    }\n    this.checkLValSimple(node.local, BIND_LEXICAL);\n    return this.finishNode(node, \"ImportSpecifier\");\n};\npp$8.parseImportDefaultSpecifier = function() {\n    // import defaultObj, { x, y as z } from '...'\n    var node = this.startNode();\n    node.local = this.parseIdent();\n    this.checkLValSimple(node.local, BIND_LEXICAL);\n    return this.finishNode(node, \"ImportDefaultSpecifier\");\n};\npp$8.parseImportNamespaceSpecifier = function() {\n    var node = this.startNode();\n    this.next();\n    this.expectContextual(\"as\");\n    node.local = this.parseIdent();\n    this.checkLValSimple(node.local, BIND_LEXICAL);\n    return this.finishNode(node, \"ImportNamespaceSpecifier\");\n};\npp$8.parseImportSpecifiers = function() {\n    var nodes = [], first = true;\n    if (this.type === types$1.name) {\n        nodes.push(this.parseImportDefaultSpecifier());\n        if (!this.eat(types$1.comma)) {\n            return nodes;\n        }\n    }\n    if (this.type === types$1.star) {\n        nodes.push(this.parseImportNamespaceSpecifier());\n        return nodes;\n    }\n    this.expect(types$1.braceL);\n    while(!this.eat(types$1.braceR)){\n        if (!first) {\n            this.expect(types$1.comma);\n            if (this.afterTrailingComma(types$1.braceR)) {\n                break;\n            }\n        } else {\n            first = false;\n        }\n        nodes.push(this.parseImportSpecifier());\n    }\n    return nodes;\n};\npp$8.parseWithClause = function() {\n    var nodes = [];\n    if (!this.eat(types$1._with)) {\n        return nodes;\n    }\n    this.expect(types$1.braceL);\n    var attributeKeys = {};\n    var first = true;\n    while(!this.eat(types$1.braceR)){\n        if (!first) {\n            this.expect(types$1.comma);\n            if (this.afterTrailingComma(types$1.braceR)) {\n                break;\n            }\n        } else {\n            first = false;\n        }\n        var attr = this.parseImportAttribute();\n        var keyName = attr.key.type === \"Identifier\" ? attr.key.name : attr.key.value;\n        if (hasOwn(attributeKeys, keyName)) {\n            this.raiseRecoverable(attr.key.start, \"Duplicate attribute key '\" + keyName + \"'\");\n        }\n        attributeKeys[keyName] = true;\n        nodes.push(attr);\n    }\n    return nodes;\n};\npp$8.parseImportAttribute = function() {\n    var node = this.startNode();\n    node.key = this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== \"never\");\n    this.expect(types$1.colon);\n    if (this.type !== types$1.string) {\n        this.unexpected();\n    }\n    node.value = this.parseExprAtom();\n    return this.finishNode(node, \"ImportAttribute\");\n};\npp$8.parseModuleExportName = function() {\n    if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {\n        var stringLiteral = this.parseLiteral(this.value);\n        if (loneSurrogate.test(stringLiteral.value)) {\n            this.raise(stringLiteral.start, \"An export name cannot include a lone surrogate.\");\n        }\n        return stringLiteral;\n    }\n    return this.parseIdent(true);\n};\n// Set `ExpressionStatement#directive` property for directive prologues.\npp$8.adaptDirectivePrologue = function(statements) {\n    for(var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i){\n        statements[i].directive = statements[i].expression.raw.slice(1, -1);\n    }\n};\npp$8.isDirectiveCandidate = function(statement) {\n    return this.options.ecmaVersion >= 5 && statement.type === \"ExpressionStatement\" && statement.expression.type === \"Literal\" && typeof statement.expression.value === \"string\" && // Reject parenthesized strings.\n    (this.input[statement.start] === '\"' || this.input[statement.start] === \"'\");\n};\nvar pp$7 = Parser.prototype;\n// Convert existing expression atom to assignable pattern\n// if possible.\npp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {\n    if (this.options.ecmaVersion >= 6 && node) {\n        switch(node.type){\n            case \"Identifier\":\n                if (this.inAsync && node.name === \"await\") {\n                    this.raise(node.start, \"Cannot use 'await' as identifier inside an async function\");\n                }\n                break;\n            case \"ObjectPattern\":\n            case \"ArrayPattern\":\n            case \"AssignmentPattern\":\n            case \"RestElement\":\n                break;\n            case \"ObjectExpression\":\n                node.type = \"ObjectPattern\";\n                if (refDestructuringErrors) {\n                    this.checkPatternErrors(refDestructuringErrors, true);\n                }\n                for(var i = 0, list = node.properties; i < list.length; i += 1){\n                    var prop = list[i];\n                    this.toAssignable(prop, isBinding);\n                    // Early error:\n                    //   AssignmentRestProperty[Yield, Await] :\n                    //     `...` DestructuringAssignmentTarget[Yield, Await]\n                    //\n                    //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.\n                    if (prop.type === \"RestElement\" && (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")) {\n                        this.raise(prop.argument.start, \"Unexpected token\");\n                    }\n                }\n                break;\n            case \"Property\":\n                // AssignmentProperty has type === \"Property\"\n                if (node.kind !== \"init\") {\n                    this.raise(node.key.start, \"Object pattern can't contain getter or setter\");\n                }\n                this.toAssignable(node.value, isBinding);\n                break;\n            case \"ArrayExpression\":\n                node.type = \"ArrayPattern\";\n                if (refDestructuringErrors) {\n                    this.checkPatternErrors(refDestructuringErrors, true);\n                }\n                this.toAssignableList(node.elements, isBinding);\n                break;\n            case \"SpreadElement\":\n                node.type = \"RestElement\";\n                this.toAssignable(node.argument, isBinding);\n                if (node.argument.type === \"AssignmentPattern\") {\n                    this.raise(node.argument.start, \"Rest elements cannot have a default value\");\n                }\n                break;\n            case \"AssignmentExpression\":\n                if (node.operator !== \"=\") {\n                    this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\");\n                }\n                node.type = \"AssignmentPattern\";\n                delete node.operator;\n                this.toAssignable(node.left, isBinding);\n                break;\n            case \"ParenthesizedExpression\":\n                this.toAssignable(node.expression, isBinding, refDestructuringErrors);\n                break;\n            case \"ChainExpression\":\n                this.raiseRecoverable(node.start, \"Optional chaining cannot appear in left-hand side\");\n                break;\n            case \"MemberExpression\":\n                if (!isBinding) {\n                    break;\n                }\n            default:\n                this.raise(node.start, \"Assigning to rvalue\");\n        }\n    } else if (refDestructuringErrors) {\n        this.checkPatternErrors(refDestructuringErrors, true);\n    }\n    return node;\n};\n// Convert list of expression atoms to binding list.\npp$7.toAssignableList = function(exprList, isBinding) {\n    var end = exprList.length;\n    for(var i = 0; i < end; i++){\n        var elt = exprList[i];\n        if (elt) {\n            this.toAssignable(elt, isBinding);\n        }\n    }\n    if (end) {\n        var last = exprList[end - 1];\n        if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\") {\n            this.unexpected(last.argument.start);\n        }\n    }\n    return exprList;\n};\n// Parses spread element.\npp$7.parseSpread = function(refDestructuringErrors) {\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n    return this.finishNode(node, \"SpreadElement\");\n};\npp$7.parseRestBinding = function() {\n    var node = this.startNode();\n    this.next();\n    // RestElement inside of a function parameter must be an identifier\n    if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {\n        this.unexpected();\n    }\n    node.argument = this.parseBindingAtom();\n    return this.finishNode(node, \"RestElement\");\n};\n// Parses lvalue (assignable) atom.\npp$7.parseBindingAtom = function() {\n    if (this.options.ecmaVersion >= 6) {\n        switch(this.type){\n            case types$1.bracketL:\n                var node = this.startNode();\n                this.next();\n                node.elements = this.parseBindingList(types$1.bracketR, true, true);\n                return this.finishNode(node, \"ArrayPattern\");\n            case types$1.braceL:\n                return this.parseObj(true);\n        }\n    }\n    return this.parseIdent();\n};\npp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {\n    var elts = [], first = true;\n    while(!this.eat(close)){\n        if (first) {\n            first = false;\n        } else {\n            this.expect(types$1.comma);\n        }\n        if (allowEmpty && this.type === types$1.comma) {\n            elts.push(null);\n        } else if (allowTrailingComma && this.afterTrailingComma(close)) {\n            break;\n        } else if (this.type === types$1.ellipsis) {\n            var rest = this.parseRestBinding();\n            this.parseBindingListItem(rest);\n            elts.push(rest);\n            if (this.type === types$1.comma) {\n                this.raiseRecoverable(this.start, \"Comma is not permitted after the rest element\");\n            }\n            this.expect(close);\n            break;\n        } else {\n            elts.push(this.parseAssignableListItem(allowModifiers));\n        }\n    }\n    return elts;\n};\npp$7.parseAssignableListItem = function(allowModifiers) {\n    var elem = this.parseMaybeDefault(this.start, this.startLoc);\n    this.parseBindingListItem(elem);\n    return elem;\n};\npp$7.parseBindingListItem = function(param) {\n    return param;\n};\n// Parses assignment pattern around given atom if possible.\npp$7.parseMaybeDefault = function(startPos, startLoc, left) {\n    left = left || this.parseBindingAtom();\n    if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {\n        return left;\n    }\n    var node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssign();\n    return this.finishNode(node, \"AssignmentPattern\");\n};\n// The following three functions all verify that a node is an lvalue —\n// something that can be bound, or assigned to. In order to do so, they perform\n// a variety of checks:\n//\n// - Check that none of the bound/assigned-to identifiers are reserved words.\n// - Record name declarations for bindings in the appropriate scope.\n// - Check duplicate argument names, if checkClashes is set.\n//\n// If a complex binding pattern is encountered (e.g., object and array\n// destructuring), the entire pattern is recursively checked.\n//\n// There are three versions of checkLVal*() appropriate for different\n// circumstances:\n//\n// - checkLValSimple() shall be used if the syntactic construct supports\n//   nothing other than identifiers and member expressions. Parenthesized\n//   expressions are also correctly handled. This is generally appropriate for\n//   constructs for which the spec says\n//\n//   > It is a Syntax Error if AssignmentTargetType of [the production] is not\n//   > simple.\n//\n//   It is also appropriate for checking if an identifier is valid and not\n//   defined elsewhere, like import declarations or function/class identifiers.\n//\n//   Examples where this is used include:\n//     a += …;\n//     import a from '…';\n//   where a is the node to be checked.\n//\n// - checkLValPattern() shall be used if the syntactic construct supports\n//   anything checkLValSimple() supports, as well as object and array\n//   destructuring patterns. This is generally appropriate for constructs for\n//   which the spec says\n//\n//   > It is a Syntax Error if [the production] is neither an ObjectLiteral nor\n//   > an ArrayLiteral and AssignmentTargetType of [the production] is not\n//   > simple.\n//\n//   Examples where this is used include:\n//     (a = …);\n//     const a = …;\n//     try { … } catch (a) { … }\n//   where a is the node to be checked.\n//\n// - checkLValInnerPattern() shall be used if the syntactic construct supports\n//   anything checkLValPattern() supports, as well as default assignment\n//   patterns, rest elements, and other constructs that may appear within an\n//   object or array destructuring pattern.\n//\n//   As a special case, function parameters also use checkLValInnerPattern(),\n//   as they also support defaults and rest constructs.\n//\n// These functions deliberately support both assignment and binding constructs,\n// as the logic for both is exceedingly similar. If the node is the target of\n// an assignment, then bindingType should be set to BIND_NONE. Otherwise, it\n// should be set to the appropriate BIND_* constant, like BIND_VAR or\n// BIND_LEXICAL.\n//\n// If the function is called with a non-BIND_NONE bindingType, then\n// additionally a checkClashes object may be specified to allow checking for\n// duplicate argument names. checkClashes is ignored if the provided construct\n// is an assignment (i.e., bindingType is BIND_NONE).\npp$7.checkLValSimple = function(expr, bindingType, checkClashes) {\n    if (bindingType === void 0) bindingType = BIND_NONE;\n    var isBind = bindingType !== BIND_NONE;\n    switch(expr.type){\n        case \"Identifier\":\n            if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {\n                this.raiseRecoverable(expr.start, (isBind ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\");\n            }\n            if (isBind) {\n                if (bindingType === BIND_LEXICAL && expr.name === \"let\") {\n                    this.raiseRecoverable(expr.start, \"let is disallowed as a lexically bound name\");\n                }\n                if (checkClashes) {\n                    if (hasOwn(checkClashes, expr.name)) {\n                        this.raiseRecoverable(expr.start, \"Argument name clash\");\n                    }\n                    checkClashes[expr.name] = true;\n                }\n                if (bindingType !== BIND_OUTSIDE) {\n                    this.declareName(expr.name, bindingType, expr.start);\n                }\n            }\n            break;\n        case \"ChainExpression\":\n            this.raiseRecoverable(expr.start, \"Optional chaining cannot appear in left-hand side\");\n            break;\n        case \"MemberExpression\":\n            if (isBind) {\n                this.raiseRecoverable(expr.start, \"Binding member expression\");\n            }\n            break;\n        case \"ParenthesizedExpression\":\n            if (isBind) {\n                this.raiseRecoverable(expr.start, \"Binding parenthesized expression\");\n            }\n            return this.checkLValSimple(expr.expression, bindingType, checkClashes);\n        default:\n            this.raise(expr.start, (isBind ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n    }\n};\npp$7.checkLValPattern = function(expr, bindingType, checkClashes) {\n    if (bindingType === void 0) bindingType = BIND_NONE;\n    switch(expr.type){\n        case \"ObjectPattern\":\n            for(var i = 0, list = expr.properties; i < list.length; i += 1){\n                var prop = list[i];\n                this.checkLValInnerPattern(prop, bindingType, checkClashes);\n            }\n            break;\n        case \"ArrayPattern\":\n            for(var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1){\n                var elem = list$1[i$1];\n                if (elem) {\n                    this.checkLValInnerPattern(elem, bindingType, checkClashes);\n                }\n            }\n            break;\n        default:\n            this.checkLValSimple(expr, bindingType, checkClashes);\n    }\n};\npp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {\n    if (bindingType === void 0) bindingType = BIND_NONE;\n    switch(expr.type){\n        case \"Property\":\n            // AssignmentProperty has type === \"Property\"\n            this.checkLValInnerPattern(expr.value, bindingType, checkClashes);\n            break;\n        case \"AssignmentPattern\":\n            this.checkLValPattern(expr.left, bindingType, checkClashes);\n            break;\n        case \"RestElement\":\n            this.checkLValPattern(expr.argument, bindingType, checkClashes);\n            break;\n        default:\n            this.checkLValPattern(expr, bindingType, checkClashes);\n    }\n};\n// The algorithm used to determine whether a regexp can appear at a\n// given point in the program is loosely based on sweet.js' approach.\n// See https://github.com/mozilla/sweet.js/wiki/design\nvar TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n    this.token = token;\n    this.isExpr = !!isExpr;\n    this.preserveSpace = !!preserveSpace;\n    this.override = override;\n    this.generator = !!generator;\n};\nvar types = {\n    b_stat: new TokContext(\"{\", false),\n    b_expr: new TokContext(\"{\", true),\n    b_tmpl: new TokContext(\"${\", false),\n    p_stat: new TokContext(\"(\", false),\n    p_expr: new TokContext(\"(\", true),\n    q_tmpl: new TokContext(\"`\", true, true, function(p) {\n        return p.tryReadTemplateToken();\n    }),\n    f_stat: new TokContext(\"function\", false),\n    f_expr: new TokContext(\"function\", true),\n    f_expr_gen: new TokContext(\"function\", true, false, null, true),\n    f_gen: new TokContext(\"function\", false, false, null, true)\n};\nvar pp$6 = Parser.prototype;\npp$6.initialContext = function() {\n    return [\n        types.b_stat\n    ];\n};\npp$6.curContext = function() {\n    return this.context[this.context.length - 1];\n};\npp$6.braceIsBlock = function(prevType) {\n    var parent = this.curContext();\n    if (parent === types.f_expr || parent === types.f_stat) {\n        return true;\n    }\n    if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {\n        return !parent.isExpr;\n    }\n    // The check for `tt.name && exprAllowed` detects whether we are\n    // after a `yield` or `of` construct. See the `updateContext` for\n    // `tt.name`.\n    if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {\n        return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n    }\n    if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {\n        return true;\n    }\n    if (prevType === types$1.braceL) {\n        return parent === types.b_stat;\n    }\n    if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {\n        return false;\n    }\n    return !this.exprAllowed;\n};\npp$6.inGeneratorContext = function() {\n    for(var i = this.context.length - 1; i >= 1; i--){\n        var context = this.context[i];\n        if (context.token === \"function\") {\n            return context.generator;\n        }\n    }\n    return false;\n};\npp$6.updateContext = function(prevType) {\n    var update, type = this.type;\n    if (type.keyword && prevType === types$1.dot) {\n        this.exprAllowed = false;\n    } else if (update = type.updateContext) {\n        update.call(this, prevType);\n    } else {\n        this.exprAllowed = type.beforeExpr;\n    }\n};\n// Used to handle edge cases when token context could not be inferred correctly during tokenization phase\npp$6.overrideContext = function(tokenCtx) {\n    if (this.curContext() !== tokenCtx) {\n        this.context[this.context.length - 1] = tokenCtx;\n    }\n};\n// Token-specific context update code\ntypes$1.parenR.updateContext = types$1.braceR.updateContext = function() {\n    if (this.context.length === 1) {\n        this.exprAllowed = true;\n        return;\n    }\n    var out = this.context.pop();\n    if (out === types.b_stat && this.curContext().token === \"function\") {\n        out = this.context.pop();\n    }\n    this.exprAllowed = !out.isExpr;\n};\ntypes$1.braceL.updateContext = function(prevType) {\n    this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);\n    this.exprAllowed = true;\n};\ntypes$1.dollarBraceL.updateContext = function() {\n    this.context.push(types.b_tmpl);\n    this.exprAllowed = true;\n};\ntypes$1.parenL.updateContext = function(prevType) {\n    var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;\n    this.context.push(statementParens ? types.p_stat : types.p_expr);\n    this.exprAllowed = true;\n};\ntypes$1.incDec.updateContext = function() {\n// tokExprAllowed stays unchanged\n};\ntypes$1._function.updateContext = types$1._class.updateContext = function(prevType) {\n    if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {\n        this.context.push(types.f_expr);\n    } else {\n        this.context.push(types.f_stat);\n    }\n    this.exprAllowed = false;\n};\ntypes$1.colon.updateContext = function() {\n    if (this.curContext().token === \"function\") {\n        this.context.pop();\n    }\n    this.exprAllowed = true;\n};\ntypes$1.backQuote.updateContext = function() {\n    if (this.curContext() === types.q_tmpl) {\n        this.context.pop();\n    } else {\n        this.context.push(types.q_tmpl);\n    }\n    this.exprAllowed = false;\n};\ntypes$1.star.updateContext = function(prevType) {\n    if (prevType === types$1._function) {\n        var index = this.context.length - 1;\n        if (this.context[index] === types.f_expr) {\n            this.context[index] = types.f_expr_gen;\n        } else {\n            this.context[index] = types.f_gen;\n        }\n    }\n    this.exprAllowed = true;\n};\ntypes$1.name.updateContext = function(prevType) {\n    var allowed = false;\n    if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {\n        if (this.value === \"of\" && !this.exprAllowed || this.value === \"yield\" && this.inGeneratorContext()) {\n            allowed = true;\n        }\n    }\n    this.exprAllowed = allowed;\n};\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts — that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\nvar pp$5 = Parser.prototype;\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash —\n// either with each other or with an init property — and in\n// strict mode, init properties are also not allowed to be repeated.\npp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {\n    if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\") {\n        return;\n    }\n    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {\n        return;\n    }\n    var key = prop.key;\n    var name;\n    switch(key.type){\n        case \"Identifier\":\n            name = key.name;\n            break;\n        case \"Literal\":\n            name = String(key.value);\n            break;\n        default:\n            return;\n    }\n    var kind = prop.kind;\n    if (this.options.ecmaVersion >= 6) {\n        if (name === \"__proto__\" && kind === \"init\") {\n            if (propHash.proto) {\n                if (refDestructuringErrors) {\n                    if (refDestructuringErrors.doubleProto < 0) {\n                        refDestructuringErrors.doubleProto = key.start;\n                    }\n                } else {\n                    this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\");\n                }\n            }\n            propHash.proto = true;\n        }\n        return;\n    }\n    name = \"$\" + name;\n    var other = propHash[name];\n    if (other) {\n        var redefinition;\n        if (kind === \"init\") {\n            redefinition = this.strict && other.init || other.get || other.set;\n        } else {\n            redefinition = other.init || other[kind];\n        }\n        if (redefinition) {\n            this.raiseRecoverable(key.start, \"Redefinition of property\");\n        }\n    } else {\n        other = propHash[name] = {\n            init: false,\n            get: false,\n            set: false\n        };\n    }\n    other[kind] = true;\n};\n// ### Expression parsing\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\npp$5.parseExpression = function(forInit, refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);\n    if (this.type === types$1.comma) {\n        var node = this.startNodeAt(startPos, startLoc);\n        node.expressions = [\n            expr\n        ];\n        while(this.eat(types$1.comma)){\n            node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));\n        }\n        return this.finishNode(node, \"SequenceExpression\");\n    }\n    return expr;\n};\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\npp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {\n    if (this.isContextual(\"yield\")) {\n        if (this.inGenerator) {\n            return this.parseYield(forInit);\n        } else {\n            this.exprAllowed = false;\n        }\n    }\n    var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;\n    if (refDestructuringErrors) {\n        oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n        oldTrailingComma = refDestructuringErrors.trailingComma;\n        oldDoubleProto = refDestructuringErrors.doubleProto;\n        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\n    } else {\n        refDestructuringErrors = new DestructuringErrors;\n        ownDestructuringErrors = true;\n    }\n    var startPos = this.start, startLoc = this.startLoc;\n    if (this.type === types$1.parenL || this.type === types$1.name) {\n        this.potentialArrowAt = this.start;\n        this.potentialArrowInForAwait = forInit === \"await\";\n    }\n    var left = this.parseMaybeConditional(forInit, refDestructuringErrors);\n    if (afterLeftParse) {\n        left = afterLeftParse.call(this, left, startPos, startLoc);\n    }\n    if (this.type.isAssign) {\n        var node = this.startNodeAt(startPos, startLoc);\n        node.operator = this.value;\n        if (this.type === types$1.eq) {\n            left = this.toAssignable(left, false, refDestructuringErrors);\n        }\n        if (!ownDestructuringErrors) {\n            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;\n        }\n        if (refDestructuringErrors.shorthandAssign >= left.start) {\n            refDestructuringErrors.shorthandAssign = -1;\n        } // reset because shorthand default was used correctly\n        if (this.type === types$1.eq) {\n            this.checkLValPattern(left);\n        } else {\n            this.checkLValSimple(left);\n        }\n        node.left = left;\n        this.next();\n        node.right = this.parseMaybeAssign(forInit);\n        if (oldDoubleProto > -1) {\n            refDestructuringErrors.doubleProto = oldDoubleProto;\n        }\n        return this.finishNode(node, \"AssignmentExpression\");\n    } else {\n        if (ownDestructuringErrors) {\n            this.checkExpressionErrors(refDestructuringErrors, true);\n        }\n    }\n    if (oldParenAssign > -1) {\n        refDestructuringErrors.parenthesizedAssign = oldParenAssign;\n    }\n    if (oldTrailingComma > -1) {\n        refDestructuringErrors.trailingComma = oldTrailingComma;\n    }\n    return left;\n};\n// Parse a ternary conditional (`?:`) operator.\npp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseExprOps(forInit, refDestructuringErrors);\n    if (this.checkExpressionErrors(refDestructuringErrors)) {\n        return expr;\n    }\n    if (this.eat(types$1.question)) {\n        var node = this.startNodeAt(startPos, startLoc);\n        node.test = expr;\n        node.consequent = this.parseMaybeAssign();\n        this.expect(types$1.colon);\n        node.alternate = this.parseMaybeAssign(forInit);\n        return this.finishNode(node, \"ConditionalExpression\");\n    }\n    return expr;\n};\n// Start the precedence parser.\npp$5.parseExprOps = function(forInit, refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);\n    if (this.checkExpressionErrors(refDestructuringErrors)) {\n        return expr;\n    }\n    return expr.start === startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);\n};\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\npp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {\n    var prec = this.type.binop;\n    if (prec != null && (!forInit || this.type !== types$1._in)) {\n        if (prec > minPrec) {\n            var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;\n            var coalesce = this.type === types$1.coalesce;\n            if (coalesce) {\n                // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.\n                // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.\n                prec = types$1.logicalAND.binop;\n            }\n            var op = this.value;\n            this.next();\n            var startPos = this.start, startLoc = this.startLoc;\n            var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);\n            var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);\n            if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {\n                this.raiseRecoverable(this.start, \"Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses\");\n            }\n            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);\n        }\n    }\n    return left;\n};\npp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n    if (right.type === \"PrivateIdentifier\") {\n        this.raise(right.start, \"Private identifier can only be left side of binary expression\");\n    }\n    var node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.operator = op;\n    node.right = right;\n    return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\");\n};\n// Parse unary operators, both prefix and postfix.\npp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {\n    var startPos = this.start, startLoc = this.startLoc, expr;\n    if (this.isContextual(\"await\") && this.canAwait) {\n        expr = this.parseAwait(forInit);\n        sawUnary = true;\n    } else if (this.type.prefix) {\n        var node = this.startNode(), update = this.type === types$1.incDec;\n        node.operator = this.value;\n        node.prefix = true;\n        this.next();\n        node.argument = this.parseMaybeUnary(null, true, update, forInit);\n        this.checkExpressionErrors(refDestructuringErrors, true);\n        if (update) {\n            this.checkLValSimple(node.argument);\n        } else if (this.strict && node.operator === \"delete\" && isLocalVariableAccess(node.argument)) {\n            this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\");\n        } else if (node.operator === \"delete\" && isPrivateFieldAccess(node.argument)) {\n            this.raiseRecoverable(node.start, \"Private fields can not be deleted\");\n        } else {\n            sawUnary = true;\n        }\n        expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n    } else if (!sawUnary && this.type === types$1.privateId) {\n        if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {\n            this.unexpected();\n        }\n        expr = this.parsePrivateIdent();\n        // only could be private fields in 'in', such as #x in obj\n        if (this.type !== types$1._in) {\n            this.unexpected();\n        }\n    } else {\n        expr = this.parseExprSubscripts(refDestructuringErrors, forInit);\n        if (this.checkExpressionErrors(refDestructuringErrors)) {\n            return expr;\n        }\n        while(this.type.postfix && !this.canInsertSemicolon()){\n            var node$1 = this.startNodeAt(startPos, startLoc);\n            node$1.operator = this.value;\n            node$1.prefix = false;\n            node$1.argument = expr;\n            this.checkLValSimple(expr);\n            this.next();\n            expr = this.finishNode(node$1, \"UpdateExpression\");\n        }\n    }\n    if (!incDec && this.eat(types$1.starstar)) {\n        if (sawUnary) {\n            this.unexpected(this.lastTokStart);\n        } else {\n            return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), \"**\", false);\n        }\n    } else {\n        return expr;\n    }\n};\nfunction isLocalVariableAccess(node) {\n    return node.type === \"Identifier\" || node.type === \"ParenthesizedExpression\" && isLocalVariableAccess(node.expression);\n}\nfunction isPrivateFieldAccess(node) {\n    return node.type === \"MemberExpression\" && node.property.type === \"PrivateIdentifier\" || node.type === \"ChainExpression\" && isPrivateFieldAccess(node.expression) || node.type === \"ParenthesizedExpression\" && isPrivateFieldAccess(node.expression);\n}\n// Parse call, dot, and `[]`-subscript expressions.\npp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseExprAtom(refDestructuringErrors, forInit);\n    if (expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\") {\n        return expr;\n    }\n    var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);\n    if (refDestructuringErrors && result.type === \"MemberExpression\") {\n        if (refDestructuringErrors.parenthesizedAssign >= result.start) {\n            refDestructuringErrors.parenthesizedAssign = -1;\n        }\n        if (refDestructuringErrors.parenthesizedBind >= result.start) {\n            refDestructuringErrors.parenthesizedBind = -1;\n        }\n        if (refDestructuringErrors.trailingComma >= result.start) {\n            refDestructuringErrors.trailingComma = -1;\n        }\n    }\n    return result;\n};\npp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {\n    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;\n    var optionalChained = false;\n    while(true){\n        var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);\n        if (element.optional) {\n            optionalChained = true;\n        }\n        if (element === base || element.type === \"ArrowFunctionExpression\") {\n            if (optionalChained) {\n                var chainNode = this.startNodeAt(startPos, startLoc);\n                chainNode.expression = element;\n                element = this.finishNode(chainNode, \"ChainExpression\");\n            }\n            return element;\n        }\n        base = element;\n    }\n};\npp$5.shouldParseAsyncArrow = function() {\n    return !this.canInsertSemicolon() && this.eat(types$1.arrow);\n};\npp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {\n    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);\n};\npp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {\n    var optionalSupported = this.options.ecmaVersion >= 11;\n    var optional = optionalSupported && this.eat(types$1.questionDot);\n    if (noCalls && optional) {\n        this.raise(this.lastTokStart, \"Optional chaining cannot appear in the callee of new expressions\");\n    }\n    var computed = this.eat(types$1.bracketL);\n    if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {\n        var node = this.startNodeAt(startPos, startLoc);\n        node.object = base;\n        if (computed) {\n            node.property = this.parseExpression();\n            this.expect(types$1.bracketR);\n        } else if (this.type === types$1.privateId && base.type !== \"Super\") {\n            node.property = this.parsePrivateIdent();\n        } else {\n            node.property = this.parseIdent(this.options.allowReserved !== \"never\");\n        }\n        node.computed = !!computed;\n        if (optionalSupported) {\n            node.optional = optional;\n        }\n        base = this.finishNode(node, \"MemberExpression\");\n    } else if (!noCalls && this.eat(types$1.parenL)) {\n        var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n        this.yieldPos = 0;\n        this.awaitPos = 0;\n        this.awaitIdentPos = 0;\n        var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);\n        if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {\n            this.checkPatternErrors(refDestructuringErrors, false);\n            this.checkYieldAwaitInDefaultParams();\n            if (this.awaitIdentPos > 0) {\n                this.raise(this.awaitIdentPos, \"Cannot use 'await' as identifier inside an async function\");\n            }\n            this.yieldPos = oldYieldPos;\n            this.awaitPos = oldAwaitPos;\n            this.awaitIdentPos = oldAwaitIdentPos;\n            return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);\n        }\n        this.checkExpressionErrors(refDestructuringErrors, true);\n        this.yieldPos = oldYieldPos || this.yieldPos;\n        this.awaitPos = oldAwaitPos || this.awaitPos;\n        this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;\n        var node$1 = this.startNodeAt(startPos, startLoc);\n        node$1.callee = base;\n        node$1.arguments = exprList;\n        if (optionalSupported) {\n            node$1.optional = optional;\n        }\n        base = this.finishNode(node$1, \"CallExpression\");\n    } else if (this.type === types$1.backQuote) {\n        if (optional || optionalChained) {\n            this.raise(this.start, \"Optional chaining cannot appear in the tag of tagged template expressions\");\n        }\n        var node$2 = this.startNodeAt(startPos, startLoc);\n        node$2.tag = base;\n        node$2.quasi = this.parseTemplate({\n            isTagged: true\n        });\n        base = this.finishNode(node$2, \"TaggedTemplateExpression\");\n    }\n    return base;\n};\n// Parse an atomic expression — either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\npp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {\n    // If a division operator appears in an expression position, the\n    // tokenizer got confused, and we force it to read a regexp instead.\n    if (this.type === types$1.slash) {\n        this.readRegexp();\n    }\n    var node, canBeArrow = this.potentialArrowAt === this.start;\n    switch(this.type){\n        case types$1._super:\n            if (!this.allowSuper) {\n                this.raise(this.start, \"'super' keyword outside a method\");\n            }\n            node = this.startNode();\n            this.next();\n            if (this.type === types$1.parenL && !this.allowDirectSuper) {\n                this.raise(node.start, \"super() call outside constructor of a subclass\");\n            }\n            // The `super` keyword can appear at below:\n            // SuperProperty:\n            //     super [ Expression ]\n            //     super . IdentifierName\n            // SuperCall:\n            //     super ( Arguments )\n            if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {\n                this.unexpected();\n            }\n            return this.finishNode(node, \"Super\");\n        case types$1._this:\n            node = this.startNode();\n            this.next();\n            return this.finishNode(node, \"ThisExpression\");\n        case types$1.name:\n            var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\n            var id = this.parseIdent(false);\n            if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types$1._function)) {\n                this.overrideContext(types.f_expr);\n                return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);\n            }\n            if (canBeArrow && !this.canInsertSemicolon()) {\n                if (this.eat(types$1.arrow)) {\n                    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [\n                        id\n                    ], false, forInit);\n                }\n                if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== \"of\" || this.containsEsc)) {\n                    id = this.parseIdent(false);\n                    if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {\n                        this.unexpected();\n                    }\n                    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [\n                        id\n                    ], true, forInit);\n                }\n            }\n            return id;\n        case types$1.regexp:\n            var value = this.value;\n            node = this.parseLiteral(value.value);\n            node.regex = {\n                pattern: value.pattern,\n                flags: value.flags\n            };\n            return node;\n        case types$1.num:\n        case types$1.string:\n            return this.parseLiteral(this.value);\n        case types$1._null:\n        case types$1._true:\n        case types$1._false:\n            node = this.startNode();\n            node.value = this.type === types$1._null ? null : this.type === types$1._true;\n            node.raw = this.type.keyword;\n            this.next();\n            return this.finishNode(node, \"Literal\");\n        case types$1.parenL:\n            var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);\n            if (refDestructuringErrors) {\n                if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {\n                    refDestructuringErrors.parenthesizedAssign = start;\n                }\n                if (refDestructuringErrors.parenthesizedBind < 0) {\n                    refDestructuringErrors.parenthesizedBind = start;\n                }\n            }\n            return expr;\n        case types$1.bracketL:\n            node = this.startNode();\n            this.next();\n            node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);\n            return this.finishNode(node, \"ArrayExpression\");\n        case types$1.braceL:\n            this.overrideContext(types.b_expr);\n            return this.parseObj(false, refDestructuringErrors);\n        case types$1._function:\n            node = this.startNode();\n            this.next();\n            return this.parseFunction(node, 0);\n        case types$1._class:\n            return this.parseClass(this.startNode(), false);\n        case types$1._new:\n            return this.parseNew();\n        case types$1.backQuote:\n            return this.parseTemplate();\n        case types$1._import:\n            if (this.options.ecmaVersion >= 11) {\n                return this.parseExprImport(forNew);\n            } else {\n                return this.unexpected();\n            }\n        default:\n            return this.parseExprAtomDefault();\n    }\n};\npp$5.parseExprAtomDefault = function() {\n    this.unexpected();\n};\npp$5.parseExprImport = function(forNew) {\n    var node = this.startNode();\n    // Consume `import` as an identifier for `import.meta`.\n    // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.\n    if (this.containsEsc) {\n        this.raiseRecoverable(this.start, \"Escape sequence in keyword import\");\n    }\n    this.next();\n    if (this.type === types$1.parenL && !forNew) {\n        return this.parseDynamicImport(node);\n    } else if (this.type === types$1.dot) {\n        var meta = this.startNodeAt(node.start, node.loc && node.loc.start);\n        meta.name = \"import\";\n        node.meta = this.finishNode(meta, \"Identifier\");\n        return this.parseImportMeta(node);\n    } else {\n        this.unexpected();\n    }\n};\npp$5.parseDynamicImport = function(node) {\n    this.next(); // skip `(`\n    // Parse node.source.\n    node.source = this.parseMaybeAssign();\n    if (this.options.ecmaVersion >= 16) {\n        if (!this.eat(types$1.parenR)) {\n            this.expect(types$1.comma);\n            if (!this.afterTrailingComma(types$1.parenR)) {\n                node.options = this.parseMaybeAssign();\n                if (!this.eat(types$1.parenR)) {\n                    this.expect(types$1.comma);\n                    if (!this.afterTrailingComma(types$1.parenR)) {\n                        this.unexpected();\n                    }\n                }\n            } else {\n                node.options = null;\n            }\n        } else {\n            node.options = null;\n        }\n    } else {\n        // Verify ending.\n        if (!this.eat(types$1.parenR)) {\n            var errorPos = this.start;\n            if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {\n                this.raiseRecoverable(errorPos, \"Trailing comma is not allowed in import()\");\n            } else {\n                this.unexpected(errorPos);\n            }\n        }\n    }\n    return this.finishNode(node, \"ImportExpression\");\n};\npp$5.parseImportMeta = function(node) {\n    this.next(); // skip `.`\n    var containsEsc = this.containsEsc;\n    node.property = this.parseIdent(true);\n    if (node.property.name !== \"meta\") {\n        this.raiseRecoverable(node.property.start, \"The only valid meta property for import is 'import.meta'\");\n    }\n    if (containsEsc) {\n        this.raiseRecoverable(node.start, \"'import.meta' must not contain escaped characters\");\n    }\n    if (this.options.sourceType !== \"module\" && !this.options.allowImportExportEverywhere) {\n        this.raiseRecoverable(node.start, \"Cannot use 'import.meta' outside a module\");\n    }\n    return this.finishNode(node, \"MetaProperty\");\n};\npp$5.parseLiteral = function(value) {\n    var node = this.startNode();\n    node.value = value;\n    node.raw = this.input.slice(this.start, this.end);\n    if (node.raw.charCodeAt(node.raw.length - 1) === 110) {\n        node.bigint = node.raw.slice(0, -1).replace(/_/g, \"\");\n    }\n    this.next();\n    return this.finishNode(node, \"Literal\");\n};\npp$5.parseParenExpression = function() {\n    this.expect(types$1.parenL);\n    var val = this.parseExpression();\n    this.expect(types$1.parenR);\n    return val;\n};\npp$5.shouldParseArrow = function(exprList) {\n    return !this.canInsertSemicolon();\n};\npp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {\n    var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\n    if (this.options.ecmaVersion >= 6) {\n        this.next();\n        var innerStartPos = this.start, innerStartLoc = this.startLoc;\n        var exprList = [], first = true, lastIsComma = false;\n        var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\n        this.yieldPos = 0;\n        this.awaitPos = 0;\n        // Do not save awaitIdentPos to allow checking awaits nested in parameters\n        while(this.type !== types$1.parenR){\n            first ? first = false : this.expect(types$1.comma);\n            if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {\n                lastIsComma = true;\n                break;\n            } else if (this.type === types$1.ellipsis) {\n                spreadStart = this.start;\n                exprList.push(this.parseParenItem(this.parseRestBinding()));\n                if (this.type === types$1.comma) {\n                    this.raiseRecoverable(this.start, \"Comma is not permitted after the rest element\");\n                }\n                break;\n            } else {\n                exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));\n            }\n        }\n        var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;\n        this.expect(types$1.parenR);\n        if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {\n            this.checkPatternErrors(refDestructuringErrors, false);\n            this.checkYieldAwaitInDefaultParams();\n            this.yieldPos = oldYieldPos;\n            this.awaitPos = oldAwaitPos;\n            return this.parseParenArrowList(startPos, startLoc, exprList, forInit);\n        }\n        if (!exprList.length || lastIsComma) {\n            this.unexpected(this.lastTokStart);\n        }\n        if (spreadStart) {\n            this.unexpected(spreadStart);\n        }\n        this.checkExpressionErrors(refDestructuringErrors, true);\n        this.yieldPos = oldYieldPos || this.yieldPos;\n        this.awaitPos = oldAwaitPos || this.awaitPos;\n        if (exprList.length > 1) {\n            val = this.startNodeAt(innerStartPos, innerStartLoc);\n            val.expressions = exprList;\n            this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n        } else {\n            val = exprList[0];\n        }\n    } else {\n        val = this.parseParenExpression();\n    }\n    if (this.options.preserveParens) {\n        var par = this.startNodeAt(startPos, startLoc);\n        par.expression = val;\n        return this.finishNode(par, \"ParenthesizedExpression\");\n    } else {\n        return val;\n    }\n};\npp$5.parseParenItem = function(item) {\n    return item;\n};\npp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {\n    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);\n};\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call — at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\nvar empty = [];\npp$5.parseNew = function() {\n    if (this.containsEsc) {\n        this.raiseRecoverable(this.start, \"Escape sequence in keyword new\");\n    }\n    var node = this.startNode();\n    this.next();\n    if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {\n        var meta = this.startNodeAt(node.start, node.loc && node.loc.start);\n        meta.name = \"new\";\n        node.meta = this.finishNode(meta, \"Identifier\");\n        this.next();\n        var containsEsc = this.containsEsc;\n        node.property = this.parseIdent(true);\n        if (node.property.name !== \"target\") {\n            this.raiseRecoverable(node.property.start, \"The only valid meta property for new is 'new.target'\");\n        }\n        if (containsEsc) {\n            this.raiseRecoverable(node.start, \"'new.target' must not contain escaped characters\");\n        }\n        if (!this.allowNewDotTarget) {\n            this.raiseRecoverable(node.start, \"'new.target' can only be used in functions and class static block\");\n        }\n        return this.finishNode(node, \"MetaProperty\");\n    }\n    var startPos = this.start, startLoc = this.startLoc;\n    node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);\n    if (this.eat(types$1.parenL)) {\n        node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);\n    } else {\n        node.arguments = empty;\n    }\n    return this.finishNode(node, \"NewExpression\");\n};\n// Parse template expression.\npp$5.parseTemplateElement = function(ref) {\n    var isTagged = ref.isTagged;\n    var elem = this.startNode();\n    if (this.type === types$1.invalidTemplate) {\n        if (!isTagged) {\n            this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\n        }\n        elem.value = {\n            raw: this.value.replace(/\\r\\n?/g, \"\\n\"),\n            cooked: null\n        };\n    } else {\n        elem.value = {\n            raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n            cooked: this.value\n        };\n    }\n    this.next();\n    elem.tail = this.type === types$1.backQuote;\n    return this.finishNode(elem, \"TemplateElement\");\n};\npp$5.parseTemplate = function(ref) {\n    if (ref === void 0) ref = {};\n    var isTagged = ref.isTagged;\n    if (isTagged === void 0) isTagged = false;\n    var node = this.startNode();\n    this.next();\n    node.expressions = [];\n    var curElt = this.parseTemplateElement({\n        isTagged: isTagged\n    });\n    node.quasis = [\n        curElt\n    ];\n    while(!curElt.tail){\n        if (this.type === types$1.eof) {\n            this.raise(this.pos, \"Unterminated template literal\");\n        }\n        this.expect(types$1.dollarBraceL);\n        node.expressions.push(this.parseExpression());\n        this.expect(types$1.braceR);\n        node.quasis.push(curElt = this.parseTemplateElement({\n            isTagged: isTagged\n        }));\n    }\n    this.next();\n    return this.finishNode(node, \"TemplateLiteral\");\n};\npp$5.isAsyncProp = function(prop) {\n    return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n};\n// Parse an object literal or binding pattern.\npp$5.parseObj = function(isPattern, refDestructuringErrors) {\n    var node = this.startNode(), first = true, propHash = {};\n    node.properties = [];\n    this.next();\n    while(!this.eat(types$1.braceR)){\n        if (!first) {\n            this.expect(types$1.comma);\n            if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {\n                break;\n            }\n        } else {\n            first = false;\n        }\n        var prop = this.parseProperty(isPattern, refDestructuringErrors);\n        if (!isPattern) {\n            this.checkPropClash(prop, propHash, refDestructuringErrors);\n        }\n        node.properties.push(prop);\n    }\n    return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\");\n};\npp$5.parseProperty = function(isPattern, refDestructuringErrors) {\n    var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;\n    if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {\n        if (isPattern) {\n            prop.argument = this.parseIdent(false);\n            if (this.type === types$1.comma) {\n                this.raiseRecoverable(this.start, \"Comma is not permitted after the rest element\");\n            }\n            return this.finishNode(prop, \"RestElement\");\n        }\n        // Parse argument.\n        prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n        // To disallow trailing comma via `this.toAssignable()`.\n        if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\n            refDestructuringErrors.trailingComma = this.start;\n        }\n        // Finish\n        return this.finishNode(prop, \"SpreadElement\");\n    }\n    if (this.options.ecmaVersion >= 6) {\n        prop.method = false;\n        prop.shorthand = false;\n        if (isPattern || refDestructuringErrors) {\n            startPos = this.start;\n            startLoc = this.startLoc;\n        }\n        if (!isPattern) {\n            isGenerator = this.eat(types$1.star);\n        }\n    }\n    var containsEsc = this.containsEsc;\n    this.parsePropertyName(prop);\n    if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\n        isAsync = true;\n        isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);\n        this.parsePropertyName(prop);\n    } else {\n        isAsync = false;\n    }\n    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\n    return this.finishNode(prop, \"Property\");\n};\npp$5.parseGetterSetter = function(prop) {\n    var kind = prop.key.name;\n    this.parsePropertyName(prop);\n    prop.value = this.parseMethod(false);\n    prop.kind = kind;\n    var paramCount = prop.kind === \"get\" ? 0 : 1;\n    if (prop.value.params.length !== paramCount) {\n        var start = prop.value.start;\n        if (prop.kind === \"get\") {\n            this.raiseRecoverable(start, \"getter should have no params\");\n        } else {\n            this.raiseRecoverable(start, \"setter should have exactly one param\");\n        }\n    } else {\n        if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\") {\n            this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\");\n        }\n    }\n};\npp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\n    if ((isGenerator || isAsync) && this.type === types$1.colon) {\n        this.unexpected();\n    }\n    if (this.eat(types$1.colon)) {\n        prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n        prop.kind = \"init\";\n    } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {\n        if (isPattern) {\n            this.unexpected();\n        }\n        prop.method = true;\n        prop.value = this.parseMethod(isGenerator, isAsync);\n        prop.kind = \"init\";\n    } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" && (prop.key.name === \"get\" || prop.key.name === \"set\") && this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq) {\n        if (isGenerator || isAsync) {\n            this.unexpected();\n        }\n        this.parseGetterSetter(prop);\n    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n        if (isGenerator || isAsync) {\n            this.unexpected();\n        }\n        this.checkUnreserved(prop.key);\n        if (prop.key.name === \"await\" && !this.awaitIdentPos) {\n            this.awaitIdentPos = startPos;\n        }\n        if (isPattern) {\n            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));\n        } else if (this.type === types$1.eq && refDestructuringErrors) {\n            if (refDestructuringErrors.shorthandAssign < 0) {\n                refDestructuringErrors.shorthandAssign = this.start;\n            }\n            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));\n        } else {\n            prop.value = this.copyNode(prop.key);\n        }\n        prop.kind = \"init\";\n        prop.shorthand = true;\n    } else {\n        this.unexpected();\n    }\n};\npp$5.parsePropertyName = function(prop) {\n    if (this.options.ecmaVersion >= 6) {\n        if (this.eat(types$1.bracketL)) {\n            prop.computed = true;\n            prop.key = this.parseMaybeAssign();\n            this.expect(types$1.bracketR);\n            return prop.key;\n        } else {\n            prop.computed = false;\n        }\n    }\n    return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== \"never\");\n};\n// Initialize empty function node.\npp$5.initFunction = function(node) {\n    node.id = null;\n    if (this.options.ecmaVersion >= 6) {\n        node.generator = node.expression = false;\n    }\n    if (this.options.ecmaVersion >= 8) {\n        node.async = false;\n    }\n};\n// Parse object or class method.\npp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {\n    var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 6) {\n        node.generator = isGenerator;\n    }\n    if (this.options.ecmaVersion >= 8) {\n        node.async = !!isAsync;\n    }\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n    this.expect(types$1.parenL);\n    node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);\n    this.checkYieldAwaitInDefaultParams();\n    this.parseFunctionBody(node, false, true, false);\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos;\n    return this.finishNode(node, \"FunctionExpression\");\n};\n// Parse arrow function expression with given parameters.\npp$5.parseArrowExpression = function(node, params, isAsync, forInit) {\n    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n    this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 8) {\n        node.async = !!isAsync;\n    }\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    node.params = this.toAssignableList(params, true);\n    this.parseFunctionBody(node, true, false, forInit);\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos;\n    return this.finishNode(node, \"ArrowFunctionExpression\");\n};\n// Parse function body and check parameters.\npp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {\n    var isExpression = isArrowFunction && this.type !== types$1.braceL;\n    var oldStrict = this.strict, useStrict = false;\n    if (isExpression) {\n        node.body = this.parseMaybeAssign(forInit);\n        node.expression = true;\n        this.checkParams(node, false);\n    } else {\n        var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n        if (!oldStrict || nonSimple) {\n            useStrict = this.strictDirective(this.end);\n            // If this is a strict mode function, verify that argument names\n            // are not repeated, and it does not try to bind the words `eval`\n            // or `arguments`.\n            if (useStrict && nonSimple) {\n                this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\");\n            }\n        }\n        // Start a new scope with regard to labels and the `inFunction`\n        // flag (restore them to their old value afterwards).\n        var oldLabels = this.labels;\n        this.labels = [];\n        if (useStrict) {\n            this.strict = true;\n        }\n        // Add the params to varDeclaredNames to ensure that an error is thrown\n        // if a let/const declaration in the function clashes with one of the params.\n        this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));\n        // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n        if (this.strict && node.id) {\n            this.checkLValSimple(node.id, BIND_OUTSIDE);\n        }\n        node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);\n        node.expression = false;\n        this.adaptDirectivePrologue(node.body.body);\n        this.labels = oldLabels;\n    }\n    this.exitScope();\n};\npp$5.isSimpleParamList = function(params) {\n    for(var i = 0, list = params; i < list.length; i += 1){\n        var param = list[i];\n        if (param.type !== \"Identifier\") {\n            return false;\n        }\n    }\n    return true;\n};\n// Checks function params for various disallowed patterns such as using \"eval\"\n// or \"arguments\" and duplicate parameters.\npp$5.checkParams = function(node, allowDuplicates) {\n    var nameHash = Object.create(null);\n    for(var i = 0, list = node.params; i < list.length; i += 1){\n        var param = list[i];\n        this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);\n    }\n};\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\npp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n    var elts = [], first = true;\n    while(!this.eat(close)){\n        if (!first) {\n            this.expect(types$1.comma);\n            if (allowTrailingComma && this.afterTrailingComma(close)) {\n                break;\n            }\n        } else {\n            first = false;\n        }\n        var elt = void 0;\n        if (allowEmpty && this.type === types$1.comma) {\n            elt = null;\n        } else if (this.type === types$1.ellipsis) {\n            elt = this.parseSpread(refDestructuringErrors);\n            if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {\n                refDestructuringErrors.trailingComma = this.start;\n            }\n        } else {\n            elt = this.parseMaybeAssign(false, refDestructuringErrors);\n        }\n        elts.push(elt);\n    }\n    return elts;\n};\npp$5.checkUnreserved = function(ref) {\n    var start = ref.start;\n    var end = ref.end;\n    var name = ref.name;\n    if (this.inGenerator && name === \"yield\") {\n        this.raiseRecoverable(start, \"Cannot use 'yield' as identifier inside a generator\");\n    }\n    if (this.inAsync && name === \"await\") {\n        this.raiseRecoverable(start, \"Cannot use 'await' as identifier inside an async function\");\n    }\n    if (!(this.currentThisScope().flags & SCOPE_VAR) && name === \"arguments\") {\n        this.raiseRecoverable(start, \"Cannot use 'arguments' in class field initializer\");\n    }\n    if (this.inClassStaticBlock && (name === \"arguments\" || name === \"await\")) {\n        this.raise(start, \"Cannot use \" + name + \" in class static initialization block\");\n    }\n    if (this.keywords.test(name)) {\n        this.raise(start, \"Unexpected keyword '\" + name + \"'\");\n    }\n    if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf(\"\\\\\") !== -1) {\n        return;\n    }\n    var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n    if (re.test(name)) {\n        if (!this.inAsync && name === \"await\") {\n            this.raiseRecoverable(start, \"Cannot use keyword 'await' outside an async function\");\n        }\n        this.raiseRecoverable(start, \"The keyword '\" + name + \"' is reserved\");\n    }\n};\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\npp$5.parseIdent = function(liberal) {\n    var node = this.parseIdentNode();\n    this.next(!!liberal);\n    this.finishNode(node, \"Identifier\");\n    if (!liberal) {\n        this.checkUnreserved(node);\n        if (node.name === \"await\" && !this.awaitIdentPos) {\n            this.awaitIdentPos = node.start;\n        }\n    }\n    return node;\n};\npp$5.parseIdentNode = function() {\n    var node = this.startNode();\n    if (this.type === types$1.name) {\n        node.name = this.value;\n    } else if (this.type.keyword) {\n        node.name = this.type.keyword;\n        // To fix https://github.com/acornjs/acorn/issues/575\n        // `class` and `function` keywords push new context into this.context.\n        // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.\n        // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword\n        if ((node.name === \"class\" || node.name === \"function\") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\n            this.context.pop();\n        }\n        this.type = types$1.name;\n    } else {\n        this.unexpected();\n    }\n    return node;\n};\npp$5.parsePrivateIdent = function() {\n    var node = this.startNode();\n    if (this.type === types$1.privateId) {\n        node.name = this.value;\n    } else {\n        this.unexpected();\n    }\n    this.next();\n    this.finishNode(node, \"PrivateIdentifier\");\n    // For validating existence\n    if (this.options.checkPrivateFields) {\n        if (this.privateNameStack.length === 0) {\n            this.raise(node.start, \"Private field '#\" + node.name + \"' must be declared in an enclosing class\");\n        } else {\n            this.privateNameStack[this.privateNameStack.length - 1].used.push(node);\n        }\n    }\n    return node;\n};\n// Parses yield expression inside generator.\npp$5.parseYield = function(forInit) {\n    if (!this.yieldPos) {\n        this.yieldPos = this.start;\n    }\n    var node = this.startNode();\n    this.next();\n    if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {\n        node.delegate = false;\n        node.argument = null;\n    } else {\n        node.delegate = this.eat(types$1.star);\n        node.argument = this.parseMaybeAssign(forInit);\n    }\n    return this.finishNode(node, \"YieldExpression\");\n};\npp$5.parseAwait = function(forInit) {\n    if (!this.awaitPos) {\n        this.awaitPos = this.start;\n    }\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeUnary(null, true, false, forInit);\n    return this.finishNode(node, \"AwaitExpression\");\n};\nvar pp$4 = Parser.prototype;\n// This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\npp$4.raise = function(pos, message) {\n    var loc = getLineInfo(this.input, pos);\n    message += \" (\" + loc.line + \":\" + loc.column + \")\";\n    if (this.sourceFile) {\n        message += \" in \" + this.sourceFile;\n    }\n    var err = new SyntaxError(message);\n    err.pos = pos;\n    err.loc = loc;\n    err.raisedAt = this.pos;\n    throw err;\n};\npp$4.raiseRecoverable = pp$4.raise;\npp$4.curPosition = function() {\n    if (this.options.locations) {\n        return new Position(this.curLine, this.pos - this.lineStart);\n    }\n};\nvar pp$3 = Parser.prototype;\nvar Scope = function Scope(flags) {\n    this.flags = flags;\n    // A list of var-declared names in the current lexical scope\n    this.var = [];\n    // A list of lexically-declared names in the current lexical scope\n    this.lexical = [];\n    // A list of lexically-declared FunctionDeclaration names in the current lexical scope\n    this.functions = [];\n};\n// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\npp$3.enterScope = function(flags) {\n    this.scopeStack.push(new Scope(flags));\n};\npp$3.exitScope = function() {\n    this.scopeStack.pop();\n};\n// The spec says:\n// > At the top level of a function, or script, function declarations are\n// > treated like var declarations rather than like lexical declarations.\npp$3.treatFunctionsAsVarInScope = function(scope) {\n    return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;\n};\npp$3.declareName = function(name, bindingType, pos) {\n    var redeclared = false;\n    if (bindingType === BIND_LEXICAL) {\n        var scope = this.currentScope();\n        redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\n        scope.lexical.push(name);\n        if (this.inModule && scope.flags & SCOPE_TOP) {\n            delete this.undefinedExports[name];\n        }\n    } else if (bindingType === BIND_SIMPLE_CATCH) {\n        var scope$1 = this.currentScope();\n        scope$1.lexical.push(name);\n    } else if (bindingType === BIND_FUNCTION) {\n        var scope$2 = this.currentScope();\n        if (this.treatFunctionsAsVar) {\n            redeclared = scope$2.lexical.indexOf(name) > -1;\n        } else {\n            redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;\n        }\n        scope$2.functions.push(name);\n    } else {\n        for(var i = this.scopeStack.length - 1; i >= 0; --i){\n            var scope$3 = this.scopeStack[i];\n            if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {\n                redeclared = true;\n                break;\n            }\n            scope$3.var.push(name);\n            if (this.inModule && scope$3.flags & SCOPE_TOP) {\n                delete this.undefinedExports[name];\n            }\n            if (scope$3.flags & SCOPE_VAR) {\n                break;\n            }\n        }\n    }\n    if (redeclared) {\n        this.raiseRecoverable(pos, \"Identifier '\" + name + \"' has already been declared\");\n    }\n};\npp$3.checkLocalExport = function(id) {\n    // scope.functions must be empty as Module code is always strict.\n    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {\n        this.undefinedExports[id.name] = id;\n    }\n};\npp$3.currentScope = function() {\n    return this.scopeStack[this.scopeStack.length - 1];\n};\npp$3.currentVarScope = function() {\n    for(var i = this.scopeStack.length - 1;; i--){\n        var scope = this.scopeStack[i];\n        if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK)) {\n            return scope;\n        }\n    }\n};\n// Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.\npp$3.currentThisScope = function() {\n    for(var i = this.scopeStack.length - 1;; i--){\n        var scope = this.scopeStack[i];\n        if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK) && !(scope.flags & SCOPE_ARROW)) {\n            return scope;\n        }\n    }\n};\nvar Node = function Node(parser, pos, loc) {\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    if (parser.options.locations) {\n        this.loc = new SourceLocation(parser, loc);\n    }\n    if (parser.options.directSourceFile) {\n        this.sourceFile = parser.options.directSourceFile;\n    }\n    if (parser.options.ranges) {\n        this.range = [\n            pos,\n            0\n        ];\n    }\n};\n// Start an AST node, attaching a start offset.\nvar pp$2 = Parser.prototype;\npp$2.startNode = function() {\n    return new Node(this, this.start, this.startLoc);\n};\npp$2.startNodeAt = function(pos, loc) {\n    return new Node(this, pos, loc);\n};\n// Finish an AST node, adding `type` and `end` properties.\nfunction finishNodeAt(node, type, pos, loc) {\n    node.type = type;\n    node.end = pos;\n    if (this.options.locations) {\n        node.loc.end = loc;\n    }\n    if (this.options.ranges) {\n        node.range[1] = pos;\n    }\n    return node;\n}\npp$2.finishNode = function(node, type) {\n    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);\n};\n// Finish node at given position\npp$2.finishNodeAt = function(node, type, pos, loc) {\n    return finishNodeAt.call(this, node, type, pos, loc);\n};\npp$2.copyNode = function(node) {\n    var newNode = new Node(this, node.start, this.startLoc);\n    for(var prop in node){\n        newNode[prop] = node[prop];\n    }\n    return newNode;\n};\n// This file was generated by \"bin/generate-unicode-script-values.js\". Do not modify manually!\nvar scriptValuesAddedInUnicode = \"Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz\";\n// This file contains Unicode properties extracted from the ECMAScript specification.\n// The lists are extracted like so:\n// $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)\n// #table-binary-unicode-properties\nvar ecma9BinaryProperties = \"ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS\";\nvar ecma10BinaryProperties = ecma9BinaryProperties + \" Extended_Pictographic\";\nvar ecma11BinaryProperties = ecma10BinaryProperties;\nvar ecma12BinaryProperties = ecma11BinaryProperties + \" EBase EComp EMod EPres ExtPict\";\nvar ecma13BinaryProperties = ecma12BinaryProperties;\nvar ecma14BinaryProperties = ecma13BinaryProperties;\nvar unicodeBinaryProperties = {\n    9: ecma9BinaryProperties,\n    10: ecma10BinaryProperties,\n    11: ecma11BinaryProperties,\n    12: ecma12BinaryProperties,\n    13: ecma13BinaryProperties,\n    14: ecma14BinaryProperties\n};\n// #table-binary-unicode-properties-of-strings\nvar ecma14BinaryPropertiesOfStrings = \"Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji\";\nvar unicodeBinaryPropertiesOfStrings = {\n    9: \"\",\n    10: \"\",\n    11: \"\",\n    12: \"\",\n    13: \"\",\n    14: ecma14BinaryPropertiesOfStrings\n};\n// #table-unicode-general-category-values\nvar unicodeGeneralCategoryValues = \"Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu\";\n// #table-unicode-script-values\nvar ecma9ScriptValues = \"Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb\";\nvar ecma10ScriptValues = ecma9ScriptValues + \" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd\";\nvar ecma11ScriptValues = ecma10ScriptValues + \" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho\";\nvar ecma12ScriptValues = ecma11ScriptValues + \" Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi\";\nvar ecma13ScriptValues = ecma12ScriptValues + \" Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith\";\nvar ecma14ScriptValues = ecma13ScriptValues + \" \" + scriptValuesAddedInUnicode;\nvar unicodeScriptValues = {\n    9: ecma9ScriptValues,\n    10: ecma10ScriptValues,\n    11: ecma11ScriptValues,\n    12: ecma12ScriptValues,\n    13: ecma13ScriptValues,\n    14: ecma14ScriptValues\n};\nvar data = {};\nfunction buildUnicodeData(ecmaVersion) {\n    var d = data[ecmaVersion] = {\n        binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + \" \" + unicodeGeneralCategoryValues),\n        binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),\n        nonBinary: {\n            General_Category: wordsRegexp(unicodeGeneralCategoryValues),\n            Script: wordsRegexp(unicodeScriptValues[ecmaVersion])\n        }\n    };\n    d.nonBinary.Script_Extensions = d.nonBinary.Script;\n    d.nonBinary.gc = d.nonBinary.General_Category;\n    d.nonBinary.sc = d.nonBinary.Script;\n    d.nonBinary.scx = d.nonBinary.Script_Extensions;\n}\nfor(var i = 0, list = [\n    9,\n    10,\n    11,\n    12,\n    13,\n    14\n]; i < list.length; i += 1){\n    var ecmaVersion = list[i];\n    buildUnicodeData(ecmaVersion);\n}\nvar pp$1 = Parser.prototype;\n// Track disjunction structure to determine whether a duplicate\n// capture group name is allowed because it is in a separate branch.\nvar BranchID = function BranchID(parent, base) {\n    // Parent disjunction branch\n    this.parent = parent;\n    // Identifies this set of sibling branches\n    this.base = base || this;\n};\nBranchID.prototype.separatedFrom = function separatedFrom(alt) {\n    // A branch is separate from another branch if they or any of\n    // their parents are siblings in a given disjunction\n    for(var self = this; self; self = self.parent){\n        for(var other = alt; other; other = other.parent){\n            if (self.base === other.base && self !== other) {\n                return true;\n            }\n        }\n    }\n    return false;\n};\nBranchID.prototype.sibling = function sibling() {\n    return new BranchID(this.parent, this.base);\n};\nvar RegExpValidationState = function RegExpValidationState(parser) {\n    this.parser = parser;\n    this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\") + (parser.options.ecmaVersion >= 13 ? \"d\" : \"\") + (parser.options.ecmaVersion >= 15 ? \"v\" : \"\");\n    this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];\n    this.source = \"\";\n    this.flags = \"\";\n    this.start = 0;\n    this.switchU = false;\n    this.switchV = false;\n    this.switchN = false;\n    this.pos = 0;\n    this.lastIntValue = 0;\n    this.lastStringValue = \"\";\n    this.lastAssertionIsQuantifiable = false;\n    this.numCapturingParens = 0;\n    this.maxBackReference = 0;\n    this.groupNames = Object.create(null);\n    this.backReferenceNames = [];\n    this.branchID = null;\n};\nRegExpValidationState.prototype.reset = function reset(start, pattern, flags) {\n    var unicodeSets = flags.indexOf(\"v\") !== -1;\n    var unicode = flags.indexOf(\"u\") !== -1;\n    this.start = start | 0;\n    this.source = pattern + \"\";\n    this.flags = flags;\n    if (unicodeSets && this.parser.options.ecmaVersion >= 15) {\n        this.switchU = true;\n        this.switchV = true;\n        this.switchN = true;\n    } else {\n        this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\n        this.switchV = false;\n        this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\n    }\n};\nRegExpValidationState.prototype.raise = function raise(message) {\n    this.parser.raiseRecoverable(this.start, \"Invalid regular expression: /\" + this.source + \"/: \" + message);\n};\n// If u flag is given, this returns the code point at the index (it combines a surrogate pair).\n// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).\nRegExpValidationState.prototype.at = function at(i, forceU) {\n    if (forceU === void 0) forceU = false;\n    var s = this.source;\n    var l = s.length;\n    if (i >= l) {\n        return -1;\n    }\n    var c = s.charCodeAt(i);\n    if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n        return c;\n    }\n    var next = s.charCodeAt(i + 1);\n    return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c;\n};\nRegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {\n    if (forceU === void 0) forceU = false;\n    var s = this.source;\n    var l = s.length;\n    if (i >= l) {\n        return l;\n    }\n    var c = s.charCodeAt(i), next;\n    if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {\n        return i + 1;\n    }\n    return i + 2;\n};\nRegExpValidationState.prototype.current = function current(forceU) {\n    if (forceU === void 0) forceU = false;\n    return this.at(this.pos, forceU);\n};\nRegExpValidationState.prototype.lookahead = function lookahead(forceU) {\n    if (forceU === void 0) forceU = false;\n    return this.at(this.nextIndex(this.pos, forceU), forceU);\n};\nRegExpValidationState.prototype.advance = function advance(forceU) {\n    if (forceU === void 0) forceU = false;\n    this.pos = this.nextIndex(this.pos, forceU);\n};\nRegExpValidationState.prototype.eat = function eat(ch, forceU) {\n    if (forceU === void 0) forceU = false;\n    if (this.current(forceU) === ch) {\n        this.advance(forceU);\n        return true;\n    }\n    return false;\n};\nRegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {\n    if (forceU === void 0) forceU = false;\n    var pos = this.pos;\n    for(var i = 0, list = chs; i < list.length; i += 1){\n        var ch = list[i];\n        var current = this.at(pos, forceU);\n        if (current === -1 || current !== ch) {\n            return false;\n        }\n        pos = this.nextIndex(pos, forceU);\n    }\n    this.pos = pos;\n    return true;\n};\n/**\n * Validate the flags part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */ pp$1.validateRegExpFlags = function(state) {\n    var validFlags = state.validFlags;\n    var flags = state.flags;\n    var u = false;\n    var v = false;\n    for(var i = 0; i < flags.length; i++){\n        var flag = flags.charAt(i);\n        if (validFlags.indexOf(flag) === -1) {\n            this.raise(state.start, \"Invalid regular expression flag\");\n        }\n        if (flags.indexOf(flag, i + 1) > -1) {\n            this.raise(state.start, \"Duplicate regular expression flag\");\n        }\n        if (flag === \"u\") {\n            u = true;\n        }\n        if (flag === \"v\") {\n            v = true;\n        }\n    }\n    if (this.options.ecmaVersion >= 15 && u && v) {\n        this.raise(state.start, \"Invalid regular expression flag\");\n    }\n};\nfunction hasProp(obj) {\n    for(var _ in obj){\n        return true;\n    }\n    return false;\n}\n/**\n * Validate the pattern part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */ pp$1.validateRegExpPattern = function(state) {\n    this.regexp_pattern(state);\n    // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of\n    // parsing contains a |GroupName|, reparse with the goal symbol\n    // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*\n    // exception if _P_ did not conform to the grammar, if any elements of _P_\n    // were not matched by the parse, or if any Early Error conditions exist.\n    if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {\n        state.switchN = true;\n        this.regexp_pattern(state);\n    }\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern\npp$1.regexp_pattern = function(state) {\n    state.pos = 0;\n    state.lastIntValue = 0;\n    state.lastStringValue = \"\";\n    state.lastAssertionIsQuantifiable = false;\n    state.numCapturingParens = 0;\n    state.maxBackReference = 0;\n    state.groupNames = Object.create(null);\n    state.backReferenceNames.length = 0;\n    state.branchID = null;\n    this.regexp_disjunction(state);\n    if (state.pos !== state.source.length) {\n        // Make the same messages as V8.\n        if (state.eat(0x29 /* ) */ )) {\n            state.raise(\"Unmatched ')'\");\n        }\n        if (state.eat(0x5D /* ] */ ) || state.eat(0x7D /* } */ )) {\n            state.raise(\"Lone quantifier brackets\");\n        }\n    }\n    if (state.maxBackReference > state.numCapturingParens) {\n        state.raise(\"Invalid escape\");\n    }\n    for(var i = 0, list = state.backReferenceNames; i < list.length; i += 1){\n        var name = list[i];\n        if (!state.groupNames[name]) {\n            state.raise(\"Invalid named capture referenced\");\n        }\n    }\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction\npp$1.regexp_disjunction = function(state) {\n    var trackDisjunction = this.options.ecmaVersion >= 16;\n    if (trackDisjunction) {\n        state.branchID = new BranchID(state.branchID, null);\n    }\n    this.regexp_alternative(state);\n    while(state.eat(0x7C /* | */ )){\n        if (trackDisjunction) {\n            state.branchID = state.branchID.sibling();\n        }\n        this.regexp_alternative(state);\n    }\n    if (trackDisjunction) {\n        state.branchID = state.branchID.parent;\n    }\n    // Make the same message as V8.\n    if (this.regexp_eatQuantifier(state, true)) {\n        state.raise(\"Nothing to repeat\");\n    }\n    if (state.eat(0x7B /* { */ )) {\n        state.raise(\"Lone quantifier brackets\");\n    }\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative\npp$1.regexp_alternative = function(state) {\n    while(state.pos < state.source.length && this.regexp_eatTerm(state)){}\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term\npp$1.regexp_eatTerm = function(state) {\n    if (this.regexp_eatAssertion(state)) {\n        // Handle `QuantifiableAssertion Quantifier` alternative.\n        // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion\n        // is a QuantifiableAssertion.\n        if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\n            // Make the same message as V8.\n            if (state.switchU) {\n                state.raise(\"Invalid quantifier\");\n            }\n        }\n        return true;\n    }\n    if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\n        this.regexp_eatQuantifier(state);\n        return true;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion\npp$1.regexp_eatAssertion = function(state) {\n    var start = state.pos;\n    state.lastAssertionIsQuantifiable = false;\n    // ^, $\n    if (state.eat(0x5E /* ^ */ ) || state.eat(0x24 /* $ */ )) {\n        return true;\n    }\n    // \\b \\B\n    if (state.eat(0x5C /* \\ */ )) {\n        if (state.eat(0x42 /* B */ ) || state.eat(0x62 /* b */ )) {\n            return true;\n        }\n        state.pos = start;\n    }\n    // Lookahead / Lookbehind\n    if (state.eat(0x28 /* ( */ ) && state.eat(0x3F /* ? */ )) {\n        var lookbehind = false;\n        if (this.options.ecmaVersion >= 9) {\n            lookbehind = state.eat(0x3C /* < */ );\n        }\n        if (state.eat(0x3D /* = */ ) || state.eat(0x21 /* ! */ )) {\n            this.regexp_disjunction(state);\n            if (!state.eat(0x29 /* ) */ )) {\n                state.raise(\"Unterminated group\");\n            }\n            state.lastAssertionIsQuantifiable = !lookbehind;\n            return true;\n        }\n    }\n    state.pos = start;\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier\npp$1.regexp_eatQuantifier = function(state, noError) {\n    if (noError === void 0) noError = false;\n    if (this.regexp_eatQuantifierPrefix(state, noError)) {\n        state.eat(0x3F /* ? */ );\n        return true;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix\npp$1.regexp_eatQuantifierPrefix = function(state, noError) {\n    return state.eat(0x2A /* * */ ) || state.eat(0x2B /* + */ ) || state.eat(0x3F /* ? */ ) || this.regexp_eatBracedQuantifier(state, noError);\n};\npp$1.regexp_eatBracedQuantifier = function(state, noError) {\n    var start = state.pos;\n    if (state.eat(0x7B /* { */ )) {\n        var min = 0, max = -1;\n        if (this.regexp_eatDecimalDigits(state)) {\n            min = state.lastIntValue;\n            if (state.eat(0x2C /* , */ ) && this.regexp_eatDecimalDigits(state)) {\n                max = state.lastIntValue;\n            }\n            if (state.eat(0x7D /* } */ )) {\n                // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term\n                if (max !== -1 && max < min && !noError) {\n                    state.raise(\"numbers out of order in {} quantifier\");\n                }\n                return true;\n            }\n        }\n        if (state.switchU && !noError) {\n            state.raise(\"Incomplete quantifier\");\n        }\n        state.pos = start;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom\npp$1.regexp_eatAtom = function(state) {\n    return this.regexp_eatPatternCharacters(state) || state.eat(0x2E /* . */ ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);\n};\npp$1.regexp_eatReverseSolidusAtomEscape = function(state) {\n    var start = state.pos;\n    if (state.eat(0x5C /* \\ */ )) {\n        if (this.regexp_eatAtomEscape(state)) {\n            return true;\n        }\n        state.pos = start;\n    }\n    return false;\n};\npp$1.regexp_eatUncapturingGroup = function(state) {\n    var start = state.pos;\n    if (state.eat(0x28 /* ( */ )) {\n        if (state.eat(0x3F /* ? */ )) {\n            if (this.options.ecmaVersion >= 16) {\n                var addModifiers = this.regexp_eatModifiers(state);\n                var hasHyphen = state.eat(0x2D /* - */ );\n                if (addModifiers || hasHyphen) {\n                    for(var i = 0; i < addModifiers.length; i++){\n                        var modifier = addModifiers.charAt(i);\n                        if (addModifiers.indexOf(modifier, i + 1) > -1) {\n                            state.raise(\"Duplicate regular expression modifiers\");\n                        }\n                    }\n                    if (hasHyphen) {\n                        var removeModifiers = this.regexp_eatModifiers(state);\n                        if (!addModifiers && !removeModifiers && state.current() === 0x3A /* : */ ) {\n                            state.raise(\"Invalid regular expression modifiers\");\n                        }\n                        for(var i$1 = 0; i$1 < removeModifiers.length; i$1++){\n                            var modifier$1 = removeModifiers.charAt(i$1);\n                            if (removeModifiers.indexOf(modifier$1, i$1 + 1) > -1 || addModifiers.indexOf(modifier$1) > -1) {\n                                state.raise(\"Duplicate regular expression modifiers\");\n                            }\n                        }\n                    }\n                }\n            }\n            if (state.eat(0x3A /* : */ )) {\n                this.regexp_disjunction(state);\n                if (state.eat(0x29 /* ) */ )) {\n                    return true;\n                }\n                state.raise(\"Unterminated group\");\n            }\n        }\n        state.pos = start;\n    }\n    return false;\n};\npp$1.regexp_eatCapturingGroup = function(state) {\n    if (state.eat(0x28 /* ( */ )) {\n        if (this.options.ecmaVersion >= 9) {\n            this.regexp_groupSpecifier(state);\n        } else if (state.current() === 0x3F /* ? */ ) {\n            state.raise(\"Invalid group\");\n        }\n        this.regexp_disjunction(state);\n        if (state.eat(0x29 /* ) */ )) {\n            state.numCapturingParens += 1;\n            return true;\n        }\n        state.raise(\"Unterminated group\");\n    }\n    return false;\n};\n// RegularExpressionModifiers ::\n//   [empty]\n//   RegularExpressionModifiers RegularExpressionModifier\npp$1.regexp_eatModifiers = function(state) {\n    var modifiers = \"\";\n    var ch = 0;\n    while((ch = state.current()) !== -1 && isRegularExpressionModifier(ch)){\n        modifiers += codePointToString(ch);\n        state.advance();\n    }\n    return modifiers;\n};\n// RegularExpressionModifier :: one of\n//   `i` `m` `s`\nfunction isRegularExpressionModifier(ch) {\n    return ch === 0x69 /* i */  || ch === 0x6d /* m */  || ch === 0x73 /* s */ ;\n}\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom\npp$1.regexp_eatExtendedAtom = function(state) {\n    return state.eat(0x2E /* . */ ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier\npp$1.regexp_eatInvalidBracedQuantifier = function(state) {\n    if (this.regexp_eatBracedQuantifier(state, true)) {\n        state.raise(\"Nothing to repeat\");\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter\npp$1.regexp_eatSyntaxCharacter = function(state) {\n    var ch = state.current();\n    if (isSyntaxCharacter(ch)) {\n        state.lastIntValue = ch;\n        state.advance();\n        return true;\n    }\n    return false;\n};\nfunction isSyntaxCharacter(ch) {\n    return ch === 0x24 /* $ */  || ch >= 0x28 /* ( */  && ch <= 0x2B /* + */  || ch === 0x2E /* . */  || ch === 0x3F /* ? */  || ch >= 0x5B /* [ */  && ch <= 0x5E /* ^ */  || ch >= 0x7B /* { */  && ch <= 0x7D /* } */ ;\n}\n// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter\n// But eat eager.\npp$1.regexp_eatPatternCharacters = function(state) {\n    var start = state.pos;\n    var ch = 0;\n    while((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)){\n        state.advance();\n    }\n    return state.pos !== start;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter\npp$1.regexp_eatExtendedPatternCharacter = function(state) {\n    var ch = state.current();\n    if (ch !== -1 && ch !== 0x24 /* $ */  && !(ch >= 0x28 /* ( */  && ch <= 0x2B /* + */ ) && ch !== 0x2E /* . */  && ch !== 0x3F /* ? */  && ch !== 0x5B /* [ */  && ch !== 0x5E /* ^ */  && ch !== 0x7C /* | */ ) {\n        state.advance();\n        return true;\n    }\n    return false;\n};\n// GroupSpecifier ::\n//   [empty]\n//   `?` GroupName\npp$1.regexp_groupSpecifier = function(state) {\n    if (state.eat(0x3F /* ? */ )) {\n        if (!this.regexp_eatGroupName(state)) {\n            state.raise(\"Invalid group\");\n        }\n        var trackDisjunction = this.options.ecmaVersion >= 16;\n        var known = state.groupNames[state.lastStringValue];\n        if (known) {\n            if (trackDisjunction) {\n                for(var i = 0, list = known; i < list.length; i += 1){\n                    var altID = list[i];\n                    if (!altID.separatedFrom(state.branchID)) {\n                        state.raise(\"Duplicate capture group name\");\n                    }\n                }\n            } else {\n                state.raise(\"Duplicate capture group name\");\n            }\n        }\n        if (trackDisjunction) {\n            (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);\n        } else {\n            state.groupNames[state.lastStringValue] = true;\n        }\n    }\n};\n// GroupName ::\n//   `<` RegExpIdentifierName `>`\n// Note: this updates `state.lastStringValue` property with the eaten name.\npp$1.regexp_eatGroupName = function(state) {\n    state.lastStringValue = \"\";\n    if (state.eat(0x3C /* < */ )) {\n        if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */ )) {\n            return true;\n        }\n        state.raise(\"Invalid capture group name\");\n    }\n    return false;\n};\n// RegExpIdentifierName ::\n//   RegExpIdentifierStart\n//   RegExpIdentifierName RegExpIdentifierPart\n// Note: this updates `state.lastStringValue` property with the eaten name.\npp$1.regexp_eatRegExpIdentifierName = function(state) {\n    state.lastStringValue = \"\";\n    if (this.regexp_eatRegExpIdentifierStart(state)) {\n        state.lastStringValue += codePointToString(state.lastIntValue);\n        while(this.regexp_eatRegExpIdentifierPart(state)){\n            state.lastStringValue += codePointToString(state.lastIntValue);\n        }\n        return true;\n    }\n    return false;\n};\n// RegExpIdentifierStart ::\n//   UnicodeIDStart\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[+U]\npp$1.regexp_eatRegExpIdentifierStart = function(state) {\n    var start = state.pos;\n    var forceU = this.options.ecmaVersion >= 11;\n    var ch = state.current(forceU);\n    state.advance(forceU);\n    if (ch === 0x5C /* \\ */  && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {\n        ch = state.lastIntValue;\n    }\n    if (isRegExpIdentifierStart(ch)) {\n        state.lastIntValue = ch;\n        return true;\n    }\n    state.pos = start;\n    return false;\n};\nfunction isRegExpIdentifierStart(ch) {\n    return isIdentifierStart(ch, true) || ch === 0x24 /* $ */  || ch === 0x5F /* _ */ ;\n}\n// RegExpIdentifierPart ::\n//   UnicodeIDContinue\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[+U]\n//   <ZWNJ>\n//   <ZWJ>\npp$1.regexp_eatRegExpIdentifierPart = function(state) {\n    var start = state.pos;\n    var forceU = this.options.ecmaVersion >= 11;\n    var ch = state.current(forceU);\n    state.advance(forceU);\n    if (ch === 0x5C /* \\ */  && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {\n        ch = state.lastIntValue;\n    }\n    if (isRegExpIdentifierPart(ch)) {\n        state.lastIntValue = ch;\n        return true;\n    }\n    state.pos = start;\n    return false;\n};\nfunction isRegExpIdentifierPart(ch) {\n    return isIdentifierChar(ch, true) || ch === 0x24 /* $ */  || ch === 0x5F /* _ */  || ch === 0x200C /* <ZWNJ> */  || ch === 0x200D /* <ZWJ> */ ;\n}\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape\npp$1.regexp_eatAtomEscape = function(state) {\n    if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {\n        return true;\n    }\n    if (state.switchU) {\n        // Make the same message as V8.\n        if (state.current() === 0x63 /* c */ ) {\n            state.raise(\"Invalid unicode escape\");\n        }\n        state.raise(\"Invalid escape\");\n    }\n    return false;\n};\npp$1.regexp_eatBackReference = function(state) {\n    var start = state.pos;\n    if (this.regexp_eatDecimalEscape(state)) {\n        var n = state.lastIntValue;\n        if (state.switchU) {\n            // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape\n            if (n > state.maxBackReference) {\n                state.maxBackReference = n;\n            }\n            return true;\n        }\n        if (n <= state.numCapturingParens) {\n            return true;\n        }\n        state.pos = start;\n    }\n    return false;\n};\npp$1.regexp_eatKGroupName = function(state) {\n    if (state.eat(0x6B /* k */ )) {\n        if (this.regexp_eatGroupName(state)) {\n            state.backReferenceNames.push(state.lastStringValue);\n            return true;\n        }\n        state.raise(\"Invalid named reference\");\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape\npp$1.regexp_eatCharacterEscape = function(state) {\n    return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);\n};\npp$1.regexp_eatCControlLetter = function(state) {\n    var start = state.pos;\n    if (state.eat(0x63 /* c */ )) {\n        if (this.regexp_eatControlLetter(state)) {\n            return true;\n        }\n        state.pos = start;\n    }\n    return false;\n};\npp$1.regexp_eatZero = function(state) {\n    if (state.current() === 0x30 /* 0 */  && !isDecimalDigit(state.lookahead())) {\n        state.lastIntValue = 0;\n        state.advance();\n        return true;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape\npp$1.regexp_eatControlEscape = function(state) {\n    var ch = state.current();\n    if (ch === 0x74 /* t */ ) {\n        state.lastIntValue = 0x09; /* \\t */ \n        state.advance();\n        return true;\n    }\n    if (ch === 0x6E /* n */ ) {\n        state.lastIntValue = 0x0A; /* \\n */ \n        state.advance();\n        return true;\n    }\n    if (ch === 0x76 /* v */ ) {\n        state.lastIntValue = 0x0B; /* \\v */ \n        state.advance();\n        return true;\n    }\n    if (ch === 0x66 /* f */ ) {\n        state.lastIntValue = 0x0C; /* \\f */ \n        state.advance();\n        return true;\n    }\n    if (ch === 0x72 /* r */ ) {\n        state.lastIntValue = 0x0D; /* \\r */ \n        state.advance();\n        return true;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter\npp$1.regexp_eatControlLetter = function(state) {\n    var ch = state.current();\n    if (isControlLetter(ch)) {\n        state.lastIntValue = ch % 0x20;\n        state.advance();\n        return true;\n    }\n    return false;\n};\nfunction isControlLetter(ch) {\n    return ch >= 0x41 /* A */  && ch <= 0x5A /* Z */  || ch >= 0x61 /* a */  && ch <= 0x7A /* z */ ;\n}\n// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence\npp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {\n    if (forceU === void 0) forceU = false;\n    var start = state.pos;\n    var switchU = forceU || state.switchU;\n    if (state.eat(0x75 /* u */ )) {\n        if (this.regexp_eatFixedHexDigits(state, 4)) {\n            var lead = state.lastIntValue;\n            if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {\n                var leadSurrogateEnd = state.pos;\n                if (state.eat(0x5C /* \\ */ ) && state.eat(0x75 /* u */ ) && this.regexp_eatFixedHexDigits(state, 4)) {\n                    var trail = state.lastIntValue;\n                    if (trail >= 0xDC00 && trail <= 0xDFFF) {\n                        state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n                        return true;\n                    }\n                }\n                state.pos = leadSurrogateEnd;\n                state.lastIntValue = lead;\n            }\n            return true;\n        }\n        if (switchU && state.eat(0x7B /* { */ ) && this.regexp_eatHexDigits(state) && state.eat(0x7D /* } */ ) && isValidUnicode(state.lastIntValue)) {\n            return true;\n        }\n        if (switchU) {\n            state.raise(\"Invalid unicode escape\");\n        }\n        state.pos = start;\n    }\n    return false;\n};\nfunction isValidUnicode(ch) {\n    return ch >= 0 && ch <= 0x10FFFF;\n}\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape\npp$1.regexp_eatIdentityEscape = function(state) {\n    if (state.switchU) {\n        if (this.regexp_eatSyntaxCharacter(state)) {\n            return true;\n        }\n        if (state.eat(0x2F /* / */ )) {\n            state.lastIntValue = 0x2F; /* / */ \n            return true;\n        }\n        return false;\n    }\n    var ch = state.current();\n    if (ch !== 0x63 /* c */  && (!state.switchN || ch !== 0x6B /* k */ )) {\n        state.lastIntValue = ch;\n        state.advance();\n        return true;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape\npp$1.regexp_eatDecimalEscape = function(state) {\n    state.lastIntValue = 0;\n    var ch = state.current();\n    if (ch >= 0x31 /* 1 */  && ch <= 0x39 /* 9 */ ) {\n        do {\n            state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */ );\n            state.advance();\n        }while ((ch = state.current()) >= 0x30 /* 0 */  && ch <= 0x39 /* 9 */ );\n        return true;\n    }\n    return false;\n};\n// Return values used by character set parsing methods, needed to\n// forbid negation of sets that can match strings.\nvar CharSetNone = 0; // Nothing parsed\nvar CharSetOk = 1; // Construct parsed, cannot contain strings\nvar CharSetString = 2; // Construct parsed, can contain strings\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape\npp$1.regexp_eatCharacterClassEscape = function(state) {\n    var ch = state.current();\n    if (isCharacterClassEscape(ch)) {\n        state.lastIntValue = -1;\n        state.advance();\n        return CharSetOk;\n    }\n    var negate = false;\n    if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 0x50 /* P */ ) || ch === 0x70 /* p */ )) {\n        state.lastIntValue = -1;\n        state.advance();\n        var result;\n        if (state.eat(0x7B /* { */ ) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(0x7D /* } */ )) {\n            if (negate && result === CharSetString) {\n                state.raise(\"Invalid property name\");\n            }\n            return result;\n        }\n        state.raise(\"Invalid property name\");\n    }\n    return CharSetNone;\n};\nfunction isCharacterClassEscape(ch) {\n    return ch === 0x64 /* d */  || ch === 0x44 /* D */  || ch === 0x73 /* s */  || ch === 0x53 /* S */  || ch === 0x77 /* w */  || ch === 0x57 /* W */ ;\n}\n// UnicodePropertyValueExpression ::\n//   UnicodePropertyName `=` UnicodePropertyValue\n//   LoneUnicodePropertyNameOrValue\npp$1.regexp_eatUnicodePropertyValueExpression = function(state) {\n    var start = state.pos;\n    // UnicodePropertyName `=` UnicodePropertyValue\n    if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */ )) {\n        var name = state.lastStringValue;\n        if (this.regexp_eatUnicodePropertyValue(state)) {\n            var value = state.lastStringValue;\n            this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\n            return CharSetOk;\n        }\n    }\n    state.pos = start;\n    // LoneUnicodePropertyNameOrValue\n    if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\n        var nameOrValue = state.lastStringValue;\n        return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);\n    }\n    return CharSetNone;\n};\npp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {\n    if (!hasOwn(state.unicodeProperties.nonBinary, name)) {\n        state.raise(\"Invalid property name\");\n    }\n    if (!state.unicodeProperties.nonBinary[name].test(value)) {\n        state.raise(\"Invalid property value\");\n    }\n};\npp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {\n    if (state.unicodeProperties.binary.test(nameOrValue)) {\n        return CharSetOk;\n    }\n    if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {\n        return CharSetString;\n    }\n    state.raise(\"Invalid property name\");\n};\n// UnicodePropertyName ::\n//   UnicodePropertyNameCharacters\npp$1.regexp_eatUnicodePropertyName = function(state) {\n    var ch = 0;\n    state.lastStringValue = \"\";\n    while(isUnicodePropertyNameCharacter(ch = state.current())){\n        state.lastStringValue += codePointToString(ch);\n        state.advance();\n    }\n    return state.lastStringValue !== \"\";\n};\nfunction isUnicodePropertyNameCharacter(ch) {\n    return isControlLetter(ch) || ch === 0x5F /* _ */ ;\n}\n// UnicodePropertyValue ::\n//   UnicodePropertyValueCharacters\npp$1.regexp_eatUnicodePropertyValue = function(state) {\n    var ch = 0;\n    state.lastStringValue = \"\";\n    while(isUnicodePropertyValueCharacter(ch = state.current())){\n        state.lastStringValue += codePointToString(ch);\n        state.advance();\n    }\n    return state.lastStringValue !== \"\";\n};\nfunction isUnicodePropertyValueCharacter(ch) {\n    return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);\n}\n// LoneUnicodePropertyNameOrValue ::\n//   UnicodePropertyValueCharacters\npp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {\n    return this.regexp_eatUnicodePropertyValue(state);\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass\npp$1.regexp_eatCharacterClass = function(state) {\n    if (state.eat(0x5B /* [ */ )) {\n        var negate = state.eat(0x5E /* ^ */ );\n        var result = this.regexp_classContents(state);\n        if (!state.eat(0x5D /* ] */ )) {\n            state.raise(\"Unterminated character class\");\n        }\n        if (negate && result === CharSetString) {\n            state.raise(\"Negated character class may contain strings\");\n        }\n        return true;\n    }\n    return false;\n};\n// https://tc39.es/ecma262/#prod-ClassContents\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges\npp$1.regexp_classContents = function(state) {\n    if (state.current() === 0x5D /* ] */ ) {\n        return CharSetOk;\n    }\n    if (state.switchV) {\n        return this.regexp_classSetExpression(state);\n    }\n    this.regexp_nonEmptyClassRanges(state);\n    return CharSetOk;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash\npp$1.regexp_nonEmptyClassRanges = function(state) {\n    while(this.regexp_eatClassAtom(state)){\n        var left = state.lastIntValue;\n        if (state.eat(0x2D /* - */ ) && this.regexp_eatClassAtom(state)) {\n            var right = state.lastIntValue;\n            if (state.switchU && (left === -1 || right === -1)) {\n                state.raise(\"Invalid character class\");\n            }\n            if (left !== -1 && right !== -1 && left > right) {\n                state.raise(\"Range out of order in character class\");\n            }\n        }\n    }\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash\npp$1.regexp_eatClassAtom = function(state) {\n    var start = state.pos;\n    if (state.eat(0x5C /* \\ */ )) {\n        if (this.regexp_eatClassEscape(state)) {\n            return true;\n        }\n        if (state.switchU) {\n            // Make the same message as V8.\n            var ch$1 = state.current();\n            if (ch$1 === 0x63 /* c */  || isOctalDigit(ch$1)) {\n                state.raise(\"Invalid class escape\");\n            }\n            state.raise(\"Invalid escape\");\n        }\n        state.pos = start;\n    }\n    var ch = state.current();\n    if (ch !== 0x5D /* ] */ ) {\n        state.lastIntValue = ch;\n        state.advance();\n        return true;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape\npp$1.regexp_eatClassEscape = function(state) {\n    var start = state.pos;\n    if (state.eat(0x62 /* b */ )) {\n        state.lastIntValue = 0x08; /* <BS> */ \n        return true;\n    }\n    if (state.switchU && state.eat(0x2D /* - */ )) {\n        state.lastIntValue = 0x2D; /* - */ \n        return true;\n    }\n    if (!state.switchU && state.eat(0x63 /* c */ )) {\n        if (this.regexp_eatClassControlLetter(state)) {\n            return true;\n        }\n        state.pos = start;\n    }\n    return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);\n};\n// https://tc39.es/ecma262/#prod-ClassSetExpression\n// https://tc39.es/ecma262/#prod-ClassUnion\n// https://tc39.es/ecma262/#prod-ClassIntersection\n// https://tc39.es/ecma262/#prod-ClassSubtraction\npp$1.regexp_classSetExpression = function(state) {\n    var result = CharSetOk, subResult;\n    if (this.regexp_eatClassSetRange(state)) ;\n    else if (subResult = this.regexp_eatClassSetOperand(state)) {\n        if (subResult === CharSetString) {\n            result = CharSetString;\n        }\n        // https://tc39.es/ecma262/#prod-ClassIntersection\n        var start = state.pos;\n        while(state.eatChars([\n            0x26,\n            0x26\n        ])){\n            if (state.current() !== 0x26 /* & */  && (subResult = this.regexp_eatClassSetOperand(state))) {\n                if (subResult !== CharSetString) {\n                    result = CharSetOk;\n                }\n                continue;\n            }\n            state.raise(\"Invalid character in character class\");\n        }\n        if (start !== state.pos) {\n            return result;\n        }\n        // https://tc39.es/ecma262/#prod-ClassSubtraction\n        while(state.eatChars([\n            0x2D,\n            0x2D\n        ])){\n            if (this.regexp_eatClassSetOperand(state)) {\n                continue;\n            }\n            state.raise(\"Invalid character in character class\");\n        }\n        if (start !== state.pos) {\n            return result;\n        }\n    } else {\n        state.raise(\"Invalid character in character class\");\n    }\n    // https://tc39.es/ecma262/#prod-ClassUnion\n    for(;;){\n        if (this.regexp_eatClassSetRange(state)) {\n            continue;\n        }\n        subResult = this.regexp_eatClassSetOperand(state);\n        if (!subResult) {\n            return result;\n        }\n        if (subResult === CharSetString) {\n            result = CharSetString;\n        }\n    }\n};\n// https://tc39.es/ecma262/#prod-ClassSetRange\npp$1.regexp_eatClassSetRange = function(state) {\n    var start = state.pos;\n    if (this.regexp_eatClassSetCharacter(state)) {\n        var left = state.lastIntValue;\n        if (state.eat(0x2D /* - */ ) && this.regexp_eatClassSetCharacter(state)) {\n            var right = state.lastIntValue;\n            if (left !== -1 && right !== -1 && left > right) {\n                state.raise(\"Range out of order in character class\");\n            }\n            return true;\n        }\n        state.pos = start;\n    }\n    return false;\n};\n// https://tc39.es/ecma262/#prod-ClassSetOperand\npp$1.regexp_eatClassSetOperand = function(state) {\n    if (this.regexp_eatClassSetCharacter(state)) {\n        return CharSetOk;\n    }\n    return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);\n};\n// https://tc39.es/ecma262/#prod-NestedClass\npp$1.regexp_eatNestedClass = function(state) {\n    var start = state.pos;\n    if (state.eat(0x5B /* [ */ )) {\n        var negate = state.eat(0x5E /* ^ */ );\n        var result = this.regexp_classContents(state);\n        if (state.eat(0x5D /* ] */ )) {\n            if (negate && result === CharSetString) {\n                state.raise(\"Negated character class may contain strings\");\n            }\n            return result;\n        }\n        state.pos = start;\n    }\n    if (state.eat(0x5C /* \\ */ )) {\n        var result$1 = this.regexp_eatCharacterClassEscape(state);\n        if (result$1) {\n            return result$1;\n        }\n        state.pos = start;\n    }\n    return null;\n};\n// https://tc39.es/ecma262/#prod-ClassStringDisjunction\npp$1.regexp_eatClassStringDisjunction = function(state) {\n    var start = state.pos;\n    if (state.eatChars([\n        0x5C,\n        0x71\n    ])) {\n        if (state.eat(0x7B /* { */ )) {\n            var result = this.regexp_classStringDisjunctionContents(state);\n            if (state.eat(0x7D /* } */ )) {\n                return result;\n            }\n        } else {\n            // Make the same message as V8.\n            state.raise(\"Invalid escape\");\n        }\n        state.pos = start;\n    }\n    return null;\n};\n// https://tc39.es/ecma262/#prod-ClassStringDisjunctionContents\npp$1.regexp_classStringDisjunctionContents = function(state) {\n    var result = this.regexp_classString(state);\n    while(state.eat(0x7C /* | */ )){\n        if (this.regexp_classString(state) === CharSetString) {\n            result = CharSetString;\n        }\n    }\n    return result;\n};\n// https://tc39.es/ecma262/#prod-ClassString\n// https://tc39.es/ecma262/#prod-NonEmptyClassString\npp$1.regexp_classString = function(state) {\n    var count = 0;\n    while(this.regexp_eatClassSetCharacter(state)){\n        count++;\n    }\n    return count === 1 ? CharSetOk : CharSetString;\n};\n// https://tc39.es/ecma262/#prod-ClassSetCharacter\npp$1.regexp_eatClassSetCharacter = function(state) {\n    var start = state.pos;\n    if (state.eat(0x5C /* \\ */ )) {\n        if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {\n            return true;\n        }\n        if (state.eat(0x62 /* b */ )) {\n            state.lastIntValue = 0x08; /* <BS> */ \n            return true;\n        }\n        state.pos = start;\n        return false;\n    }\n    var ch = state.current();\n    if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) {\n        return false;\n    }\n    if (isClassSetSyntaxCharacter(ch)) {\n        return false;\n    }\n    state.advance();\n    state.lastIntValue = ch;\n    return true;\n};\n// https://tc39.es/ecma262/#prod-ClassSetReservedDoublePunctuator\nfunction isClassSetReservedDoublePunctuatorCharacter(ch) {\n    return ch === 0x21 /* ! */  || ch >= 0x23 /* # */  && ch <= 0x26 /* & */  || ch >= 0x2A /* * */  && ch <= 0x2C /* , */  || ch === 0x2E /* . */  || ch >= 0x3A /* : */  && ch <= 0x40 /* @ */  || ch === 0x5E /* ^ */  || ch === 0x60 /* ` */  || ch === 0x7E /* ~ */ ;\n}\n// https://tc39.es/ecma262/#prod-ClassSetSyntaxCharacter\nfunction isClassSetSyntaxCharacter(ch) {\n    return ch === 0x28 /* ( */  || ch === 0x29 /* ) */  || ch === 0x2D /* - */  || ch === 0x2F /* / */  || ch >= 0x5B /* [ */  && ch <= 0x5D /* ] */  || ch >= 0x7B /* { */  && ch <= 0x7D /* } */ ;\n}\n// https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator\npp$1.regexp_eatClassSetReservedPunctuator = function(state) {\n    var ch = state.current();\n    if (isClassSetReservedPunctuator(ch)) {\n        state.lastIntValue = ch;\n        state.advance();\n        return true;\n    }\n    return false;\n};\n// https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator\nfunction isClassSetReservedPunctuator(ch) {\n    return ch === 0x21 /* ! */  || ch === 0x23 /* # */  || ch === 0x25 /* % */  || ch === 0x26 /* & */  || ch === 0x2C /* , */  || ch === 0x2D /* - */  || ch >= 0x3A /* : */  && ch <= 0x3E /* > */  || ch === 0x40 /* @ */  || ch === 0x60 /* ` */  || ch === 0x7E /* ~ */ ;\n}\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter\npp$1.regexp_eatClassControlLetter = function(state) {\n    var ch = state.current();\n    if (isDecimalDigit(ch) || ch === 0x5F /* _ */ ) {\n        state.lastIntValue = ch % 0x20;\n        state.advance();\n        return true;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\npp$1.regexp_eatHexEscapeSequence = function(state) {\n    var start = state.pos;\n    if (state.eat(0x78 /* x */ )) {\n        if (this.regexp_eatFixedHexDigits(state, 2)) {\n            return true;\n        }\n        if (state.switchU) {\n            state.raise(\"Invalid escape\");\n        }\n        state.pos = start;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits\npp$1.regexp_eatDecimalDigits = function(state) {\n    var start = state.pos;\n    var ch = 0;\n    state.lastIntValue = 0;\n    while(isDecimalDigit(ch = state.current())){\n        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */ );\n        state.advance();\n    }\n    return state.pos !== start;\n};\nfunction isDecimalDigit(ch) {\n    return ch >= 0x30 /* 0 */  && ch <= 0x39 /* 9 */ ;\n}\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits\npp$1.regexp_eatHexDigits = function(state) {\n    var start = state.pos;\n    var ch = 0;\n    state.lastIntValue = 0;\n    while(isHexDigit(ch = state.current())){\n        state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n        state.advance();\n    }\n    return state.pos !== start;\n};\nfunction isHexDigit(ch) {\n    return ch >= 0x30 /* 0 */  && ch <= 0x39 /* 9 */  || ch >= 0x41 /* A */  && ch <= 0x46 /* F */  || ch >= 0x61 /* a */  && ch <= 0x66 /* f */ ;\n}\nfunction hexToInt(ch) {\n    if (ch >= 0x41 /* A */  && ch <= 0x46 /* F */ ) {\n        return 10 + (ch - 0x41 /* A */ );\n    }\n    if (ch >= 0x61 /* a */  && ch <= 0x66 /* f */ ) {\n        return 10 + (ch - 0x61 /* a */ );\n    }\n    return ch - 0x30 /* 0 */ ;\n}\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence\n// Allows only 0-377(octal) i.e. 0-255(decimal).\npp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {\n    if (this.regexp_eatOctalDigit(state)) {\n        var n1 = state.lastIntValue;\n        if (this.regexp_eatOctalDigit(state)) {\n            var n2 = state.lastIntValue;\n            if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\n                state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\n            } else {\n                state.lastIntValue = n1 * 8 + n2;\n            }\n        } else {\n            state.lastIntValue = n1;\n        }\n        return true;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit\npp$1.regexp_eatOctalDigit = function(state) {\n    var ch = state.current();\n    if (isOctalDigit(ch)) {\n        state.lastIntValue = ch - 0x30; /* 0 */ \n        state.advance();\n        return true;\n    }\n    state.lastIntValue = 0;\n    return false;\n};\nfunction isOctalDigit(ch) {\n    return ch >= 0x30 /* 0 */  && ch <= 0x37 /* 7 */ ;\n}\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit\n// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\npp$1.regexp_eatFixedHexDigits = function(state, length) {\n    var start = state.pos;\n    state.lastIntValue = 0;\n    for(var i = 0; i < length; ++i){\n        var ch = state.current();\n        if (!isHexDigit(ch)) {\n            state.pos = start;\n            return false;\n        }\n        state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n        state.advance();\n    }\n    return true;\n};\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\nvar Token = function Token(p) {\n    this.type = p.type;\n    this.value = p.value;\n    this.start = p.start;\n    this.end = p.end;\n    if (p.options.locations) {\n        this.loc = new SourceLocation(p, p.startLoc, p.endLoc);\n    }\n    if (p.options.ranges) {\n        this.range = [\n            p.start,\n            p.end\n        ];\n    }\n};\n// ## Tokenizer\nvar pp = Parser.prototype;\n// Move to the next token\npp.next = function(ignoreEscapeSequenceInKeyword) {\n    if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {\n        this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + this.type.keyword);\n    }\n    if (this.options.onToken) {\n        this.options.onToken(new Token(this));\n    }\n    this.lastTokEnd = this.end;\n    this.lastTokStart = this.start;\n    this.lastTokEndLoc = this.endLoc;\n    this.lastTokStartLoc = this.startLoc;\n    this.nextToken();\n};\npp.getToken = function() {\n    this.next();\n    return new Token(this);\n};\n// If we're in an ES6 environment, make parsers iterable\nif (typeof Symbol !== \"undefined\") {\n    pp[Symbol.iterator] = function() {\n        var this$1$1 = this;\n        return {\n            next: function() {\n                var token = this$1$1.getToken();\n                return {\n                    done: token.type === types$1.eof,\n                    value: token\n                };\n            }\n        };\n    };\n}\n// Toggle strict mode. Re-reads the next number or string to please\n// pedantic tests (`\"use strict\"; 010;` should fail).\n// Read a single token, updating the parser object's token-related\n// properties.\npp.nextToken = function() {\n    var curContext = this.curContext();\n    if (!curContext || !curContext.preserveSpace) {\n        this.skipSpace();\n    }\n    this.start = this.pos;\n    if (this.options.locations) {\n        this.startLoc = this.curPosition();\n    }\n    if (this.pos >= this.input.length) {\n        return this.finishToken(types$1.eof);\n    }\n    if (curContext.override) {\n        return curContext.override(this);\n    } else {\n        this.readToken(this.fullCharCodeAtPos());\n    }\n};\npp.readToken = function(code) {\n    // Identifier or keyword. '\\uXXXX' sequences are allowed in\n    // identifiers, so '\\' also dispatches to that.\n    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */ ) {\n        return this.readWord();\n    }\n    return this.getTokenFromCode(code);\n};\npp.fullCharCodeAtPos = function() {\n    var code = this.input.charCodeAt(this.pos);\n    if (code <= 0xd7ff || code >= 0xdc00) {\n        return code;\n    }\n    var next = this.input.charCodeAt(this.pos + 1);\n    return next <= 0xdbff || next >= 0xe000 ? code : (code << 10) + next - 0x35fdc00;\n};\npp.skipBlockComment = function() {\n    var startLoc = this.options.onComment && this.curPosition();\n    var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\n    if (end === -1) {\n        this.raise(this.pos - 2, \"Unterminated comment\");\n    }\n    this.pos = end + 2;\n    if (this.options.locations) {\n        for(var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1;){\n            ++this.curLine;\n            pos = this.lineStart = nextBreak;\n        }\n    }\n    if (this.options.onComment) {\n        this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());\n    }\n};\npp.skipLineComment = function(startSkip) {\n    var start = this.pos;\n    var startLoc = this.options.onComment && this.curPosition();\n    var ch = this.input.charCodeAt(this.pos += startSkip);\n    while(this.pos < this.input.length && !isNewLine(ch)){\n        ch = this.input.charCodeAt(++this.pos);\n    }\n    if (this.options.onComment) {\n        this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());\n    }\n};\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments, and.\npp.skipSpace = function() {\n    loop: while(this.pos < this.input.length){\n        var ch = this.input.charCodeAt(this.pos);\n        switch(ch){\n            case 32:\n            case 160:\n                ++this.pos;\n                break;\n            case 13:\n                if (this.input.charCodeAt(this.pos + 1) === 10) {\n                    ++this.pos;\n                }\n            case 10:\n            case 8232:\n            case 8233:\n                ++this.pos;\n                if (this.options.locations) {\n                    ++this.curLine;\n                    this.lineStart = this.pos;\n                }\n                break;\n            case 47:\n                switch(this.input.charCodeAt(this.pos + 1)){\n                    case 42:\n                        this.skipBlockComment();\n                        break;\n                    case 47:\n                        this.skipLineComment(2);\n                        break;\n                    default:\n                        break loop;\n                }\n                break;\n            default:\n                if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n                    ++this.pos;\n                } else {\n                    break loop;\n                }\n        }\n    }\n};\n// Called at the end of every token. Sets `end`, `val`, and\n// maintains `context` and `exprAllowed`, and skips the space after\n// the token, so that the next one's `start` will point at the\n// right position.\npp.finishToken = function(type, val) {\n    this.end = this.pos;\n    if (this.options.locations) {\n        this.endLoc = this.curPosition();\n    }\n    var prevType = this.type;\n    this.type = type;\n    this.value = val;\n    this.updateContext(prevType);\n};\n// ### Token reading\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\n//\npp.readToken_dot = function() {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next >= 48 && next <= 57) {\n        return this.readNumber(true);\n    }\n    var next2 = this.input.charCodeAt(this.pos + 2);\n    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {\n        this.pos += 3;\n        return this.finishToken(types$1.ellipsis);\n    } else {\n        ++this.pos;\n        return this.finishToken(types$1.dot);\n    }\n};\npp.readToken_slash = function() {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (this.exprAllowed) {\n        ++this.pos;\n        return this.readRegexp();\n    }\n    if (next === 61) {\n        return this.finishOp(types$1.assign, 2);\n    }\n    return this.finishOp(types$1.slash, 1);\n};\npp.readToken_mult_modulo_exp = function(code) {\n    var next = this.input.charCodeAt(this.pos + 1);\n    var size = 1;\n    var tokentype = code === 42 ? types$1.star : types$1.modulo;\n    // exponentiation operator ** and **=\n    if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\n        ++size;\n        tokentype = types$1.starstar;\n        next = this.input.charCodeAt(this.pos + 2);\n    }\n    if (next === 61) {\n        return this.finishOp(types$1.assign, size + 1);\n    }\n    return this.finishOp(tokentype, size);\n};\npp.readToken_pipe_amp = function(code) {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === code) {\n        if (this.options.ecmaVersion >= 12) {\n            var next2 = this.input.charCodeAt(this.pos + 2);\n            if (next2 === 61) {\n                return this.finishOp(types$1.assign, 3);\n            }\n        }\n        return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);\n    }\n    if (next === 61) {\n        return this.finishOp(types$1.assign, 2);\n    }\n    return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);\n};\npp.readToken_caret = function() {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 61) {\n        return this.finishOp(types$1.assign, 2);\n    }\n    return this.finishOp(types$1.bitwiseXOR, 1);\n};\npp.readToken_plus_min = function(code) {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === code) {\n        if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\n            // A `-->` line comment\n            this.skipLineComment(3);\n            this.skipSpace();\n            return this.nextToken();\n        }\n        return this.finishOp(types$1.incDec, 2);\n    }\n    if (next === 61) {\n        return this.finishOp(types$1.assign, 2);\n    }\n    return this.finishOp(types$1.plusMin, 1);\n};\npp.readToken_lt_gt = function(code) {\n    var next = this.input.charCodeAt(this.pos + 1);\n    var size = 1;\n    if (next === code) {\n        size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n        if (this.input.charCodeAt(this.pos + size) === 61) {\n            return this.finishOp(types$1.assign, size + 1);\n        }\n        return this.finishOp(types$1.bitShift, size);\n    }\n    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {\n        // `<!--`, an XML-style comment that should be interpreted as a line comment\n        this.skipLineComment(4);\n        this.skipSpace();\n        return this.nextToken();\n    }\n    if (next === 61) {\n        size = 2;\n    }\n    return this.finishOp(types$1.relational, size);\n};\npp.readToken_eq_excl = function(code) {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 61) {\n        return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);\n    }\n    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {\n        this.pos += 2;\n        return this.finishToken(types$1.arrow);\n    }\n    return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);\n};\npp.readToken_question = function() {\n    var ecmaVersion = this.options.ecmaVersion;\n    if (ecmaVersion >= 11) {\n        var next = this.input.charCodeAt(this.pos + 1);\n        if (next === 46) {\n            var next2 = this.input.charCodeAt(this.pos + 2);\n            if (next2 < 48 || next2 > 57) {\n                return this.finishOp(types$1.questionDot, 2);\n            }\n        }\n        if (next === 63) {\n            if (ecmaVersion >= 12) {\n                var next2$1 = this.input.charCodeAt(this.pos + 2);\n                if (next2$1 === 61) {\n                    return this.finishOp(types$1.assign, 3);\n                }\n            }\n            return this.finishOp(types$1.coalesce, 2);\n        }\n    }\n    return this.finishOp(types$1.question, 1);\n};\npp.readToken_numberSign = function() {\n    var ecmaVersion = this.options.ecmaVersion;\n    var code = 35; // '#'\n    if (ecmaVersion >= 13) {\n        ++this.pos;\n        code = this.fullCharCodeAtPos();\n        if (isIdentifierStart(code, true) || code === 92 /* '\\' */ ) {\n            return this.finishToken(types$1.privateId, this.readWord1());\n        }\n    }\n    this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n};\npp.getTokenFromCode = function(code) {\n    switch(code){\n        // The interpretation of a dot depends on whether it is followed\n        // by a digit or another two dots.\n        case 46:\n            return this.readToken_dot();\n        // Punctuation tokens.\n        case 40:\n            ++this.pos;\n            return this.finishToken(types$1.parenL);\n        case 41:\n            ++this.pos;\n            return this.finishToken(types$1.parenR);\n        case 59:\n            ++this.pos;\n            return this.finishToken(types$1.semi);\n        case 44:\n            ++this.pos;\n            return this.finishToken(types$1.comma);\n        case 91:\n            ++this.pos;\n            return this.finishToken(types$1.bracketL);\n        case 93:\n            ++this.pos;\n            return this.finishToken(types$1.bracketR);\n        case 123:\n            ++this.pos;\n            return this.finishToken(types$1.braceL);\n        case 125:\n            ++this.pos;\n            return this.finishToken(types$1.braceR);\n        case 58:\n            ++this.pos;\n            return this.finishToken(types$1.colon);\n        case 96:\n            if (this.options.ecmaVersion < 6) {\n                break;\n            }\n            ++this.pos;\n            return this.finishToken(types$1.backQuote);\n        case 48:\n            var next = this.input.charCodeAt(this.pos + 1);\n            if (next === 120 || next === 88) {\n                return this.readRadixNumber(16);\n            } // '0x', '0X' - hex number\n            if (this.options.ecmaVersion >= 6) {\n                if (next === 111 || next === 79) {\n                    return this.readRadixNumber(8);\n                } // '0o', '0O' - octal number\n                if (next === 98 || next === 66) {\n                    return this.readRadixNumber(2);\n                } // '0b', '0B' - binary number\n            }\n        // Anything else beginning with a digit is an integer, octal\n        // number, or float.\n        case 49:\n        case 50:\n        case 51:\n        case 52:\n        case 53:\n        case 54:\n        case 55:\n        case 56:\n        case 57:\n            return this.readNumber(false);\n        // Quotes produce strings.\n        case 34:\n        case 39:\n            return this.readString(code);\n        // Operators are parsed inline in tiny state machines. '=' (61) is\n        // often referred to. `finishOp` simply skips the amount of\n        // characters it is given as second argument, and returns a token\n        // of the type given by its first argument.\n        case 47:\n            return this.readToken_slash();\n        case 37:\n        case 42:\n            return this.readToken_mult_modulo_exp(code);\n        case 124:\n        case 38:\n            return this.readToken_pipe_amp(code);\n        case 94:\n            return this.readToken_caret();\n        case 43:\n        case 45:\n            return this.readToken_plus_min(code);\n        case 60:\n        case 62:\n            return this.readToken_lt_gt(code);\n        case 61:\n        case 33:\n            return this.readToken_eq_excl(code);\n        case 63:\n            return this.readToken_question();\n        case 126:\n            return this.finishOp(types$1.prefix, 1);\n        case 35:\n            return this.readToken_numberSign();\n    }\n    this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n};\npp.finishOp = function(type, size) {\n    var str = this.input.slice(this.pos, this.pos + size);\n    this.pos += size;\n    return this.finishToken(type, str);\n};\npp.readRegexp = function() {\n    var escaped, inClass, start = this.pos;\n    for(;;){\n        if (this.pos >= this.input.length) {\n            this.raise(start, \"Unterminated regular expression\");\n        }\n        var ch = this.input.charAt(this.pos);\n        if (lineBreak.test(ch)) {\n            this.raise(start, \"Unterminated regular expression\");\n        }\n        if (!escaped) {\n            if (ch === \"[\") {\n                inClass = true;\n            } else if (ch === \"]\" && inClass) {\n                inClass = false;\n            } else if (ch === \"/\" && !inClass) {\n                break;\n            }\n            escaped = ch === \"\\\\\";\n        } else {\n            escaped = false;\n        }\n        ++this.pos;\n    }\n    var pattern = this.input.slice(start, this.pos);\n    ++this.pos;\n    var flagsStart = this.pos;\n    var flags = this.readWord1();\n    if (this.containsEsc) {\n        this.unexpected(flagsStart);\n    }\n    // Validate pattern\n    var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\n    state.reset(start, pattern, flags);\n    this.validateRegExpFlags(state);\n    this.validateRegExpPattern(state);\n    // Create Literal#value property value.\n    var value = null;\n    try {\n        value = new RegExp(pattern, flags);\n    } catch (e) {\n    // ESTree requires null if it failed to instantiate RegExp object.\n    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral\n    }\n    return this.finishToken(types$1.regexp, {\n        pattern: pattern,\n        flags: flags,\n        value: value\n    });\n};\n// Read an integer in the given radix. Return null if zero digits\n// were read, the integer value otherwise. When `len` is given, this\n// will return `null` unless the integer has exactly `len` digits.\npp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {\n    // `len` is used for character escape sequences. In that case, disallow separators.\n    var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;\n    // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)\n    // and isn't fraction part nor exponent part. In that case, if the first digit\n    // is zero then disallow separators.\n    var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;\n    var start = this.pos, total = 0, lastCode = 0;\n    for(var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos){\n        var code = this.input.charCodeAt(this.pos), val = void 0;\n        if (allowSeparators && code === 95) {\n            if (isLegacyOctalNumericLiteral) {\n                this.raiseRecoverable(this.pos, \"Numeric separator is not allowed in legacy octal numeric literals\");\n            }\n            if (lastCode === 95) {\n                this.raiseRecoverable(this.pos, \"Numeric separator must be exactly one underscore\");\n            }\n            if (i === 0) {\n                this.raiseRecoverable(this.pos, \"Numeric separator is not allowed at the first of digits\");\n            }\n            lastCode = code;\n            continue;\n        }\n        if (code >= 97) {\n            val = code - 97 + 10;\n        } else if (code >= 65) {\n            val = code - 65 + 10;\n        } else if (code >= 48 && code <= 57) {\n            val = code - 48;\n        } else {\n            val = Infinity;\n        }\n        if (val >= radix) {\n            break;\n        }\n        lastCode = code;\n        total = total * radix + val;\n    }\n    if (allowSeparators && lastCode === 95) {\n        this.raiseRecoverable(this.pos - 1, \"Numeric separator is not allowed at the last of digits\");\n    }\n    if (this.pos === start || len != null && this.pos - start !== len) {\n        return null;\n    }\n    return total;\n};\nfunction stringToNumber(str, isLegacyOctalNumericLiteral) {\n    if (isLegacyOctalNumericLiteral) {\n        return parseInt(str, 8);\n    }\n    // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.\n    return parseFloat(str.replace(/_/g, \"\"));\n}\nfunction stringToBigInt(str) {\n    if (typeof BigInt !== \"function\") {\n        return null;\n    }\n    // `BigInt(value)` throws syntax error if the string contains numeric separators.\n    return BigInt(str.replace(/_/g, \"\"));\n}\npp.readRadixNumber = function(radix) {\n    var start = this.pos;\n    this.pos += 2; // 0x\n    var val = this.readInt(radix);\n    if (val == null) {\n        this.raise(this.start + 2, \"Expected number in radix \" + radix);\n    }\n    if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {\n        val = stringToBigInt(this.input.slice(start, this.pos));\n        ++this.pos;\n    } else if (isIdentifierStart(this.fullCharCodeAtPos())) {\n        this.raise(this.pos, \"Identifier directly after number\");\n    }\n    return this.finishToken(types$1.num, val);\n};\n// Read an integer, octal integer, or floating-point number.\npp.readNumber = function(startsWithDot) {\n    var start = this.pos;\n    if (!startsWithDot && this.readInt(10, undefined, true) === null) {\n        this.raise(start, \"Invalid number\");\n    }\n    var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n    if (octal && this.strict) {\n        this.raise(start, \"Invalid number\");\n    }\n    var next = this.input.charCodeAt(this.pos);\n    if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {\n        var val$1 = stringToBigInt(this.input.slice(start, this.pos));\n        ++this.pos;\n        if (isIdentifierStart(this.fullCharCodeAtPos())) {\n            this.raise(this.pos, \"Identifier directly after number\");\n        }\n        return this.finishToken(types$1.num, val$1);\n    }\n    if (octal && /[89]/.test(this.input.slice(start, this.pos))) {\n        octal = false;\n    }\n    if (next === 46 && !octal) {\n        ++this.pos;\n        this.readInt(10);\n        next = this.input.charCodeAt(this.pos);\n    }\n    if ((next === 69 || next === 101) && !octal) {\n        next = this.input.charCodeAt(++this.pos);\n        if (next === 43 || next === 45) {\n            ++this.pos;\n        } // '+-'\n        if (this.readInt(10) === null) {\n            this.raise(start, \"Invalid number\");\n        }\n    }\n    if (isIdentifierStart(this.fullCharCodeAtPos())) {\n        this.raise(this.pos, \"Identifier directly after number\");\n    }\n    var val = stringToNumber(this.input.slice(start, this.pos), octal);\n    return this.finishToken(types$1.num, val);\n};\n// Read a string value, interpreting backslash-escapes.\npp.readCodePoint = function() {\n    var ch = this.input.charCodeAt(this.pos), code;\n    if (ch === 123) {\n        if (this.options.ecmaVersion < 6) {\n            this.unexpected();\n        }\n        var codePos = ++this.pos;\n        code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n        ++this.pos;\n        if (code > 0x10FFFF) {\n            this.invalidStringToken(codePos, \"Code point out of bounds\");\n        }\n    } else {\n        code = this.readHexChar(4);\n    }\n    return code;\n};\npp.readString = function(quote) {\n    var out = \"\", chunkStart = ++this.pos;\n    for(;;){\n        if (this.pos >= this.input.length) {\n            this.raise(this.start, \"Unterminated string constant\");\n        }\n        var ch = this.input.charCodeAt(this.pos);\n        if (ch === quote) {\n            break;\n        }\n        if (ch === 92) {\n            out += this.input.slice(chunkStart, this.pos);\n            out += this.readEscapedChar(false);\n            chunkStart = this.pos;\n        } else if (ch === 0x2028 || ch === 0x2029) {\n            if (this.options.ecmaVersion < 10) {\n                this.raise(this.start, \"Unterminated string constant\");\n            }\n            ++this.pos;\n            if (this.options.locations) {\n                this.curLine++;\n                this.lineStart = this.pos;\n            }\n        } else {\n            if (isNewLine(ch)) {\n                this.raise(this.start, \"Unterminated string constant\");\n            }\n            ++this.pos;\n        }\n    }\n    out += this.input.slice(chunkStart, this.pos++);\n    return this.finishToken(types$1.string, out);\n};\n// Reads template string tokens.\nvar INVALID_TEMPLATE_ESCAPE_ERROR = {};\npp.tryReadTemplateToken = function() {\n    this.inTemplateElement = true;\n    try {\n        this.readTmplToken();\n    } catch (err) {\n        if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\n            this.readInvalidTemplateToken();\n        } else {\n            throw err;\n        }\n    }\n    this.inTemplateElement = false;\n};\npp.invalidStringToken = function(position, message) {\n    if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\n        throw INVALID_TEMPLATE_ESCAPE_ERROR;\n    } else {\n        this.raise(position, message);\n    }\n};\npp.readTmplToken = function() {\n    var out = \"\", chunkStart = this.pos;\n    for(;;){\n        if (this.pos >= this.input.length) {\n            this.raise(this.start, \"Unterminated template\");\n        }\n        var ch = this.input.charCodeAt(this.pos);\n        if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {\n            if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {\n                if (ch === 36) {\n                    this.pos += 2;\n                    return this.finishToken(types$1.dollarBraceL);\n                } else {\n                    ++this.pos;\n                    return this.finishToken(types$1.backQuote);\n                }\n            }\n            out += this.input.slice(chunkStart, this.pos);\n            return this.finishToken(types$1.template, out);\n        }\n        if (ch === 92) {\n            out += this.input.slice(chunkStart, this.pos);\n            out += this.readEscapedChar(true);\n            chunkStart = this.pos;\n        } else if (isNewLine(ch)) {\n            out += this.input.slice(chunkStart, this.pos);\n            ++this.pos;\n            switch(ch){\n                case 13:\n                    if (this.input.charCodeAt(this.pos) === 10) {\n                        ++this.pos;\n                    }\n                case 10:\n                    out += \"\\n\";\n                    break;\n                default:\n                    out += String.fromCharCode(ch);\n                    break;\n            }\n            if (this.options.locations) {\n                ++this.curLine;\n                this.lineStart = this.pos;\n            }\n            chunkStart = this.pos;\n        } else {\n            ++this.pos;\n        }\n    }\n};\n// Reads a template token to search for the end, without validating any escape sequences\npp.readInvalidTemplateToken = function() {\n    for(; this.pos < this.input.length; this.pos++){\n        switch(this.input[this.pos]){\n            case \"\\\\\":\n                ++this.pos;\n                break;\n            case \"$\":\n                if (this.input[this.pos + 1] !== \"{\") {\n                    break;\n                }\n            // fall through\n            case \"`\":\n                return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));\n            case \"\\r\":\n                if (this.input[this.pos + 1] === \"\\n\") {\n                    ++this.pos;\n                }\n            // fall through\n            case \"\\n\":\n            case \"\\u2028\":\n            case \"\\u2029\":\n                ++this.curLine;\n                this.lineStart = this.pos + 1;\n                break;\n        }\n    }\n    this.raise(this.start, \"Unterminated template\");\n};\n// Used to read escaped characters\npp.readEscapedChar = function(inTemplate) {\n    var ch = this.input.charCodeAt(++this.pos);\n    ++this.pos;\n    switch(ch){\n        case 110:\n            return \"\\n\" // 'n' -> '\\n'\n            ;\n        case 114:\n            return \"\\r\" // 'r' -> '\\r'\n            ;\n        case 120:\n            return String.fromCharCode(this.readHexChar(2)) // 'x'\n            ;\n        case 117:\n            return codePointToString(this.readCodePoint()) // 'u'\n            ;\n        case 116:\n            return \"\t\" // 't' -> '\\t'\n            ;\n        case 98:\n            return \"\\b\" // 'b' -> '\\b'\n            ;\n        case 118:\n            return \"\\v\" // 'v' -> '\\u000b'\n            ;\n        case 102:\n            return \"\\f\" // 'f' -> '\\f'\n            ;\n        case 13:\n            if (this.input.charCodeAt(this.pos) === 10) {\n                ++this.pos;\n            } // '\\r\\n'\n        case 10:\n            if (this.options.locations) {\n                this.lineStart = this.pos;\n                ++this.curLine;\n            }\n            return \"\";\n        case 56:\n        case 57:\n            if (this.strict) {\n                this.invalidStringToken(this.pos - 1, \"Invalid escape sequence\");\n            }\n            if (inTemplate) {\n                var codePos = this.pos - 1;\n                this.invalidStringToken(codePos, \"Invalid escape sequence in template string\");\n            }\n        default:\n            if (ch >= 48 && ch <= 55) {\n                var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n                var octal = parseInt(octalStr, 8);\n                if (octal > 255) {\n                    octalStr = octalStr.slice(0, -1);\n                    octal = parseInt(octalStr, 8);\n                }\n                this.pos += octalStr.length - 1;\n                ch = this.input.charCodeAt(this.pos);\n                if ((octalStr !== \"0\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {\n                    this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? \"Octal literal in template string\" : \"Octal literal in strict mode\");\n                }\n                return String.fromCharCode(octal);\n            }\n            if (isNewLine(ch)) {\n                // Unicode new line characters after \\ get removed from output in both\n                // template literals and strings\n                if (this.options.locations) {\n                    this.lineStart = this.pos;\n                    ++this.curLine;\n                }\n                return \"\";\n            }\n            return String.fromCharCode(ch);\n    }\n};\n// Used to read character escape sequences ('\\x', '\\u', '\\U').\npp.readHexChar = function(len) {\n    var codePos = this.pos;\n    var n = this.readInt(16, len);\n    if (n === null) {\n        this.invalidStringToken(codePos, \"Bad character escape sequence\");\n    }\n    return n;\n};\n// Read an identifier, and return it as a string. Sets `this.containsEsc`\n// to whether the word contained a '\\u' escape.\n//\n// Incrementally adds only escaped chars, adding other chunks as-is\n// as a micro-optimization.\npp.readWord1 = function() {\n    this.containsEsc = false;\n    var word = \"\", first = true, chunkStart = this.pos;\n    var astral = this.options.ecmaVersion >= 6;\n    while(this.pos < this.input.length){\n        var ch = this.fullCharCodeAtPos();\n        if (isIdentifierChar(ch, astral)) {\n            this.pos += ch <= 0xffff ? 1 : 2;\n        } else if (ch === 92) {\n            this.containsEsc = true;\n            word += this.input.slice(chunkStart, this.pos);\n            var escStart = this.pos;\n            if (this.input.charCodeAt(++this.pos) !== 117) {\n                this.invalidStringToken(this.pos, \"Expecting Unicode escape sequence \\\\uXXXX\");\n            }\n            ++this.pos;\n            var esc = this.readCodePoint();\n            if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {\n                this.invalidStringToken(escStart, \"Invalid Unicode escape\");\n            }\n            word += codePointToString(esc);\n            chunkStart = this.pos;\n        } else {\n            break;\n        }\n        first = false;\n    }\n    return word + this.input.slice(chunkStart, this.pos);\n};\n// Read an identifier or keyword token. Will check for reserved\n// words when necessary.\npp.readWord = function() {\n    var word = this.readWord1();\n    var type = types$1.name;\n    if (this.keywords.test(word)) {\n        type = keywords[word];\n    }\n    return this.finishToken(type, word);\n};\n// Acorn is a tiny, fast JavaScript parser written in JavaScript.\n//\n// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and\n// various contributors and released under an MIT license.\n//\n// Git repositories for Acorn are available at\n//\n//     http://marijnhaverbeke.nl/git/acorn\n//     https://github.com/acornjs/acorn.git\n//\n// Please use the [github bug tracker][ghbt] to report issues.\n//\n// [ghbt]: https://github.com/acornjs/acorn/issues\n//\n// [walk]: util/walk.js\nvar version = \"8.14.1\";\nParser.acorn = {\n    Parser: Parser,\n    version: version,\n    defaultOptions: defaultOptions,\n    Position: Position,\n    SourceLocation: SourceLocation,\n    getLineInfo: getLineInfo,\n    Node: Node,\n    TokenType: TokenType,\n    tokTypes: types$1,\n    keywordTypes: keywords,\n    TokContext: TokContext,\n    tokContexts: types,\n    isIdentifierChar: isIdentifierChar,\n    isIdentifierStart: isIdentifierStart,\n    Token: Token,\n    isNewLine: isNewLine,\n    lineBreak: lineBreak,\n    lineBreakG: lineBreakG,\n    nonASCIIwhitespace: nonASCIIwhitespace\n};\n// The main exported interface (under `self.acorn` when in the\n// browser) is a `parse` function that takes a code string and returns\n// an abstract syntax tree as specified by the [ESTree spec][estree].\n//\n// [estree]: https://github.com/estree/estree\nfunction parse(input, options) {\n    return Parser.parse(input, options);\n}\n// This function tries to parse a single expression at a given\n// offset in a string. Useful for parsing mixed-language formats\n// that embed JavaScript expressions.\nfunction parseExpressionAt(input, pos, options) {\n    return Parser.parseExpressionAt(input, pos, options);\n}\n// Acorn is organized as a tokenizer and a recursive-descent parser.\n// The `tokenizer` export provides an interface to the tokenizer.\nfunction tokenizer(input, options) {\n    return Parser.tokenizer(input, options);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWNvcm4vZGlzdC9hY29ybi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLG1EQUFtRDtBQUNuRCxJQUFJQSx3QkFBd0I7SUFBQztJQUFLO0lBQUc7SUFBSztJQUFHO0lBQUs7SUFBRztJQUFLO0lBQUc7SUFBTTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFLO0lBQUc7SUFBSztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUs7SUFBRztJQUFJO0lBQUc7SUFBSTtJQUFJO0lBQUk7SUFBRztJQUFLO0lBQUc7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBSTtJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUs7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUc7SUFBSztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBSTtJQUFJO0lBQUk7SUFBRztJQUFJO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFJO0lBQUk7SUFBRztJQUFHO0lBQUs7SUFBSTtJQUFLO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBSztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBSTtJQUFHO0lBQUk7SUFBSztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUs7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFJO0lBQU07SUFBRztJQUFHO0lBQUk7SUFBTztJQUFJO0lBQU07SUFBRztJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUc7SUFBSztJQUFHO0lBQUs7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUc7SUFBTztJQUFHO0lBQU07SUFBRztJQUFLO0lBQUk7SUFBRztJQUFJO0lBQUs7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBSztJQUFHO0lBQU07SUFBSTtJQUFLO0lBQUk7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBSTtJQUFNO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUs7SUFBRztJQUFLO0lBQUc7SUFBSTtJQUFHO0lBQUs7SUFBRztJQUFJO0lBQUk7SUFBSztJQUFJO0lBQUs7SUFBRztJQUFHO0lBQUc7SUFBSztJQUFHO0lBQUs7SUFBRztJQUFHO0lBQUc7SUFBTTtJQUFHO0lBQVE7Q0FBSTtBQUUxb0MsbURBQW1EO0FBQ25ELElBQUlDLDZCQUE2QjtJQUFDO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUk7SUFBSztJQUFJO0lBQUk7SUFBSztJQUFJO0lBQUc7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUc7SUFBSTtJQUFJO0lBQUk7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFLO0lBQUk7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUc7SUFBSTtJQUFJO0lBQUk7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFJO0lBQUs7SUFBSTtJQUFJO0lBQUk7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFHO0lBQUc7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFJO0lBQUk7SUFBRztJQUFJO0lBQUk7SUFBRztJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUs7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUs7SUFBSTtJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUc7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFJO0lBQUc7SUFBSTtJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUs7SUFBSTtJQUFJO0lBQUc7SUFBSTtJQUFJO0lBQUk7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUc7SUFBSztJQUFJO0lBQUs7SUFBSTtJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBSTtJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUk7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFHO0lBQUk7SUFBSTtJQUFLO0lBQUk7SUFBSTtJQUFHO0lBQUc7SUFBSTtJQUFJO0lBQUc7SUFBSTtJQUFJO0lBQUs7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUk7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFJO0lBQUc7SUFBSztJQUFJO0lBQUk7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUs7SUFBRztJQUFJO0lBQUs7SUFBSztJQUFLO0lBQUk7SUFBSztJQUFNO0lBQUk7SUFBSTtJQUFNO0lBQUk7SUFBRztJQUFJO0lBQU07SUFBRztJQUFLO0lBQU07SUFBSTtJQUFNO0lBQUs7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBRztJQUFJO0lBQUk7SUFBRztJQUFJO0lBQUs7SUFBSTtJQUFLO0lBQUk7SUFBSztJQUFJO0lBQUc7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFJO0lBQU07SUFBRztJQUFNO0lBQUk7SUFBRztJQUFNO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUs7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBSztJQUFNO0lBQUs7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBTTtJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFLO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBTTtJQUFJO0lBQUc7SUFBRztJQUFLO0lBQUk7SUFBSztJQUFJO0lBQUk7SUFBRztJQUFJO0lBQUc7SUFBSztJQUFJO0lBQUk7SUFBSTtJQUFLO0lBQUk7SUFBSztJQUFJO0lBQUc7SUFBRztJQUFLO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFLO0lBQUk7SUFBSTtJQUFHO0lBQUc7SUFBTTtJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7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MkNBQTJDO0FBQzNDLEVBQUU7QUFDRiw4REFBOEQ7QUFDOUQsRUFBRTtBQUNGLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0YsdUJBQXVCO0FBR3ZCLElBQUlHLFVBQVU7QUFFZHB0QixPQUFPcXRCLEtBQUssR0FBRztJQUNicnRCLFFBQVFBO0lBQ1JvdEIsU0FBU0E7SUFDVC93QixnQkFBZ0JBO0lBQ2hCZCxVQUFVQTtJQUNWTSxnQkFBZ0JBO0lBQ2hCSSxhQUFhQTtJQUNibWhCLE1BQU1BO0lBQ052cEIsV0FBV0E7SUFDWHk1QixVQUFVeDRCO0lBQ1Z5NEIsY0FBYzU0QjtJQUNkd2YsWUFBWUE7SUFDWnFaLGFBQWFqWjtJQUNiM2dCLGtCQUFrQkE7SUFDbEJMLG1CQUFtQkE7SUFDbkJrMUIsT0FBT0E7SUFDUDV1QixXQUFXQTtJQUNYSCxXQUFXQTtJQUNYQyxZQUFZQTtJQUNaUSxvQkFBb0JBO0FBQ3RCO0FBRUEsOERBQThEO0FBQzlELHNFQUFzRTtBQUN0RSxxRUFBcUU7QUFDckUsRUFBRTtBQUNGLDZDQUE2QztBQUU3QyxTQUFTMEksTUFBTTNHLEtBQUssRUFBRXJILE9BQU87SUFDM0IsT0FBT21MLE9BQU82QyxLQUFLLENBQUMzRyxPQUFPckg7QUFDN0I7QUFFQSw4REFBOEQ7QUFDOUQsZ0VBQWdFO0FBQ2hFLHFDQUFxQztBQUVyQyxTQUFTZ1Asa0JBQWtCM0gsS0FBSyxFQUFFOUksR0FBRyxFQUFFeUIsT0FBTztJQUM1QyxPQUFPbUwsT0FBTzZELGlCQUFpQixDQUFDM0gsT0FBTzlJLEtBQUt5QjtBQUM5QztBQUVBLG9FQUFvRTtBQUNwRSxpRUFBaUU7QUFFakUsU0FBU21QLFVBQVU5SCxLQUFLLEVBQUVySCxPQUFPO0lBQy9CLE9BQU9tTCxPQUFPZ0UsU0FBUyxDQUFDOUgsT0FBT3JIO0FBQ2pDO0FBRTJUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc29sYW5hLWxpcXVpZGl0eS1wb29sLy4vbm9kZV9tb2R1bGVzL2Fjb3JuL2Rpc3QvYWNvcm4ubWpzPzA4NjEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQuIERvIG5vdCBtb2RpZnkgbWFudWFsbHkhXG52YXIgYXN0cmFsSWRlbnRpZmllckNvZGVzID0gWzUwOSwgMCwgMjI3LCAwLCAxNTAsIDQsIDI5NCwgOSwgMTM2OCwgMiwgMiwgMSwgNiwgMywgNDEsIDIsIDUsIDAsIDE2NiwgMSwgNTc0LCAzLCA5LCA5LCA3LCA5LCAzMiwgNCwgMzE4LCAxLCA4MCwgMywgNzEsIDEwLCA1MCwgMywgMTIzLCAyLCA1NCwgMTQsIDMyLCAxMCwgMywgMSwgMTEsIDMsIDQ2LCAxMCwgOCwgMCwgNDYsIDksIDcsIDIsIDM3LCAxMywgMiwgOSwgNiwgMSwgNDUsIDAsIDEzLCAyLCA0OSwgMTMsIDksIDMsIDIsIDExLCA4MywgMTEsIDcsIDAsIDMsIDAsIDE1OCwgMTEsIDYsIDksIDcsIDMsIDU2LCAxLCAyLCA2LCAzLCAxLCAzLCAyLCAxMCwgMCwgMTEsIDEsIDMsIDYsIDQsIDQsIDY4LCA4LCAyLCAwLCAzLCAwLCAyLCAzLCAyLCA0LCAyLCAwLCAxNSwgMSwgODMsIDE3LCAxMCwgOSwgNSwgMCwgODIsIDE5LCAxMywgOSwgMjE0LCA2LCAzLCA4LCAyOCwgMSwgODMsIDE2LCAxNiwgOSwgODIsIDEyLCA5LCA5LCA3LCAxOSwgNTgsIDE0LCA1LCA5LCAyNDMsIDE0LCAxNjYsIDksIDcxLCA1LCAyLCAxLCAzLCAzLCAyLCAwLCAyLCAxLCAxMywgOSwgMTIwLCA2LCAzLCA2LCA0LCAwLCAyOSwgOSwgNDEsIDYsIDIsIDMsIDksIDAsIDEwLCAxMCwgNDcsIDE1LCAzNDMsIDksIDU0LCA3LCAyLCA3LCAxNywgOSwgNTcsIDIxLCAyLCAxMywgMTIzLCA1LCA0LCAwLCAyLCAxLCAyLCA2LCAyLCAwLCA5LCA5LCA0OSwgNCwgMiwgMSwgMiwgNCwgOSwgOSwgMzMwLCAzLCAxMCwgMSwgMiwgMCwgNDksIDYsIDQsIDQsIDE0LCAxMCwgNTM1MCwgMCwgNywgMTQsIDExNDY1LCAyNywgMjM0MywgOSwgODcsIDksIDM5LCA0LCA2MCwgNiwgMjYsIDksIDUzNSwgOSwgNDcwLCAwLCAyLCA1NCwgOCwgMywgODIsIDAsIDEyLCAxLCAxOTYyOCwgMSwgNDE3OCwgOSwgNTE5LCA0NSwgMywgMjIsIDU0MywgNCwgNCwgNSwgOSwgNywgMywgNiwgMzEsIDMsIDE0OSwgMiwgMTQxOCwgNDksIDUxMywgNTQsIDUsIDQ5LCA5LCAwLCAxNSwgMCwgMjMsIDQsIDIsIDE0LCAxMzYxLCA2LCAyLCAxNiwgMywgNiwgMiwgMSwgMiwgNCwgMTAxLCAwLCAxNjEsIDYsIDEwLCA5LCAzNTcsIDAsIDYyLCAxMywgNDk5LCAxMywgMjQ1LCAxLCAyLCA5LCA3MjYsIDYsIDExMCwgNiwgNiwgOSwgNDc1OSwgOSwgNzg3NzE5LCAyMzldO1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZC4gRG8gbm90IG1vZGlmeSBtYW51YWxseSFcbnZhciBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcyA9IFswLCAxMSwgMiwgMjUsIDIsIDE4LCAyLCAxLCAyLCAxNCwgMywgMTMsIDM1LCAxMjIsIDcwLCA1MiwgMjY4LCAyOCwgNCwgNDgsIDQ4LCAzMSwgMTQsIDI5LCA2LCAzNywgMTEsIDI5LCAzLCAzNSwgNSwgNywgMiwgNCwgNDMsIDE1NywgMTksIDM1LCA1LCAzNSwgNSwgMzksIDksIDUxLCAxMywgMTAsIDIsIDE0LCAyLCA2LCAyLCAxLCAyLCAxMCwgMiwgMTQsIDIsIDYsIDIsIDEsIDQsIDUxLCAxMywgMzEwLCAxMCwgMjEsIDExLCA3LCAyNSwgNSwgMiwgNDEsIDIsIDgsIDcwLCA1LCAzLCAwLCAyLCA0MywgMiwgMSwgNCwgMCwgMywgMjIsIDExLCAyMiwgMTAsIDMwLCA2NiwgMTgsIDIsIDEsIDExLCAyMSwgMTEsIDI1LCA3MSwgNTUsIDcsIDEsIDY1LCAwLCAxNiwgMywgMiwgMiwgMiwgMjgsIDQzLCAyOCwgNCwgMjgsIDM2LCA3LCAyLCAyNywgMjgsIDUzLCAxMSwgMjEsIDExLCAxOCwgMTQsIDE3LCAxMTEsIDcyLCA1NiwgNTAsIDE0LCA1MCwgMTQsIDM1LCAzOSwgMjcsIDEwLCAyMiwgMjUxLCA0MSwgNywgMSwgMTcsIDIsIDYwLCAyOCwgMTEsIDAsIDksIDIxLCA0MywgMTcsIDQ3LCAyMCwgMjgsIDIyLCAxMywgNTIsIDU4LCAxLCAzLCAwLCAxNCwgNDQsIDMzLCAyNCwgMjcsIDM1LCAzMCwgMCwgMywgMCwgOSwgMzQsIDQsIDAsIDEzLCA0NywgMTUsIDMsIDIyLCAwLCAyLCAwLCAzNiwgMTcsIDIsIDI0LCAyMCwgMSwgNjQsIDYsIDIsIDAsIDIsIDMsIDIsIDE0LCAyLCA5LCA4LCA0NiwgMzksIDcsIDMsIDEsIDMsIDIxLCAyLCA2LCAyLCAxLCAyLCA0LCA0LCAwLCAxOSwgMCwgMTMsIDQsIDMxLCA5LCAyLCAwLCAzLCAwLCAyLCAzNywgMiwgMCwgMjYsIDAsIDIsIDAsIDQ1LCA1MiwgMTksIDMsIDIxLCAyLCAzMSwgNDcsIDIxLCAxLCAyLCAwLCAxODUsIDQ2LCA0MiwgMywgMzcsIDQ3LCAyMSwgMCwgNjAsIDQyLCAxNCwgMCwgNzIsIDI2LCAzOCwgNiwgMTg2LCA0MywgMTE3LCA2MywgMzIsIDcsIDMsIDAsIDMsIDcsIDIsIDEsIDIsIDIzLCAxNiwgMCwgMiwgMCwgOTUsIDcsIDMsIDM4LCAxNywgMCwgMiwgMCwgMjksIDAsIDExLCAzOSwgOCwgMCwgMjIsIDAsIDEyLCA0NSwgMjAsIDAsIDE5LCA3MiwgMjAwLCAzMiwgMzIsIDgsIDIsIDM2LCAxOCwgMCwgNTAsIDI5LCAxMTMsIDYsIDIsIDEsIDIsIDM3LCAyMiwgMCwgMjYsIDUsIDIsIDEsIDIsIDMxLCAxNSwgMCwgMzI4LCAxOCwgMTYsIDAsIDIsIDEyLCAyLCAzMywgMTI1LCAwLCA4MCwgOTIxLCAxMDMsIDExMCwgMTgsIDE5NSwgMjYzNywgOTYsIDE2LCAxMDcxLCAxOCwgNSwgMjYsIDM5OTQsIDYsIDU4MiwgNjg0MiwgMjksIDE3NjMsIDU2OCwgOCwgMzAsIDE4LCA3OCwgMTgsIDI5LCAxOSwgNDcsIDE3LCAzLCAzMiwgMjAsIDYsIDE4LCA0MzMsIDQ0LCAyMTIsIDYzLCAxMjksIDc0LCA2LCAwLCA2NywgMTIsIDY1LCAxLCAyLCAwLCAyOSwgNjEzNSwgOSwgMTIzNywgNDIsIDksIDg5MzYsIDMsIDIsIDYsIDIsIDEsIDIsIDI5MCwgMTYsIDAsIDMwLCAyLCAzLCAwLCAxNSwgMywgOSwgMzk1LCAyMzA5LCAxMDYsIDYsIDEyLCA0LCA4LCA4LCA5LCA1OTkxLCA4NCwgMiwgNzAsIDIsIDEsIDMsIDAsIDMsIDEsIDMsIDMsIDIsIDExLCAyLCAwLCAyLCA2LCAyLCA2NCwgMiwgMywgMywgNywgMiwgNiwgMiwgMjcsIDIsIDMsIDIsIDQsIDIsIDAsIDQsIDYsIDIsIDMzOSwgMywgMjQsIDIsIDI0LCAyLCAzMCwgMiwgMjQsIDIsIDMwLCAyLCAyNCwgMiwgMzAsIDIsIDI0LCAyLCAzMCwgMiwgMjQsIDIsIDcsIDE4NDUsIDMwLCA3LCA1LCAyNjIsIDYxLCAxNDcsIDQ0LCAxMSwgNiwgMTcsIDAsIDMyMiwgMjksIDE5LCA0MywgNDg1LCAyNywgMjI5LCAyOSwgMywgMCwgNDk2LCA2LCAyLCAzLCAyLCAxLCAyLCAxNCwgMiwgMTk2LCA2MCwgNjcsIDgsIDAsIDEyMDUsIDMsIDIsIDI2LCAyLCAxLCAyLCAwLCAzLCAwLCAyLCA5LCAyLCAzLCAyLCAwLCAyLCAwLCA3LCAwLCA1LCAwLCAyLCAwLCAyLCAwLCAyLCAyLCAyLCAxLCAyLCAwLCAzLCAwLCAyLCAwLCAyLCAwLCAyLCAwLCAyLCAwLCAyLCAxLCAyLCAwLCAzLCAzLCAyLCA2LCAyLCAzLCAyLCAzLCAyLCAwLCAyLCA5LCAyLCAxNiwgNiwgMiwgMiwgNCwgMiwgMTYsIDQ0MjEsIDQyNzE5LCAzMywgNDE1MywgNywgMjIxLCAzLCA1NzYxLCAxNSwgNzQ3MiwgMTYsIDYyMSwgMjQ2NywgNTQxLCAxNTA3LCA0OTM4LCA2LCA0MTkxXTtcblxuLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQuIERvIG5vdCBtb2RpZnkgbWFudWFsbHkhXG52YXIgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBcIlxcdTIwMGNcXHUyMDBkXFx4YjdcXHUwMzAwLVxcdTAzNmZcXHUwMzg3XFx1MDQ4My1cXHUwNDg3XFx1MDU5MS1cXHUwNWJkXFx1MDViZlxcdTA1YzFcXHUwNWMyXFx1MDVjNFxcdTA1YzVcXHUwNWM3XFx1MDYxMC1cXHUwNjFhXFx1MDY0Yi1cXHUwNjY5XFx1MDY3MFxcdTA2ZDYtXFx1MDZkY1xcdTA2ZGYtXFx1MDZlNFxcdTA2ZTdcXHUwNmU4XFx1MDZlYS1cXHUwNmVkXFx1MDZmMC1cXHUwNmY5XFx1MDcxMVxcdTA3MzAtXFx1MDc0YVxcdTA3YTYtXFx1MDdiMFxcdTA3YzAtXFx1MDdjOVxcdTA3ZWItXFx1MDdmM1xcdTA3ZmRcXHUwODE2LVxcdTA4MTlcXHUwODFiLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MmRcXHUwODU5LVxcdTA4NWJcXHUwODk3LVxcdTA4OWZcXHUwOGNhLVxcdTA4ZTFcXHUwOGUzLVxcdTA5MDNcXHUwOTNhLVxcdTA5M2NcXHUwOTNlLVxcdTA5NGZcXHUwOTUxLVxcdTA5NTdcXHUwOTYyXFx1MDk2M1xcdTA5NjYtXFx1MDk2ZlxcdTA5ODEtXFx1MDk4M1xcdTA5YmNcXHUwOWJlLVxcdTA5YzRcXHUwOWM3XFx1MDljOFxcdTA5Y2ItXFx1MDljZFxcdTA5ZDdcXHUwOWUyXFx1MDllM1xcdTA5ZTYtXFx1MDllZlxcdTA5ZmVcXHUwYTAxLVxcdTBhMDNcXHUwYTNjXFx1MGEzZS1cXHUwYTQyXFx1MGE0N1xcdTBhNDhcXHUwYTRiLVxcdTBhNGRcXHUwYTUxXFx1MGE2Ni1cXHUwYTcxXFx1MGE3NVxcdTBhODEtXFx1MGE4M1xcdTBhYmNcXHUwYWJlLVxcdTBhYzVcXHUwYWM3LVxcdTBhYzlcXHUwYWNiLVxcdTBhY2RcXHUwYWUyXFx1MGFlM1xcdTBhZTYtXFx1MGFlZlxcdTBhZmEtXFx1MGFmZlxcdTBiMDEtXFx1MGIwM1xcdTBiM2NcXHUwYjNlLVxcdTBiNDRcXHUwYjQ3XFx1MGI0OFxcdTBiNGItXFx1MGI0ZFxcdTBiNTUtXFx1MGI1N1xcdTBiNjJcXHUwYjYzXFx1MGI2Ni1cXHUwYjZmXFx1MGI4MlxcdTBiYmUtXFx1MGJjMlxcdTBiYzYtXFx1MGJjOFxcdTBiY2EtXFx1MGJjZFxcdTBiZDdcXHUwYmU2LVxcdTBiZWZcXHUwYzAwLVxcdTBjMDRcXHUwYzNjXFx1MGMzZS1cXHUwYzQ0XFx1MGM0Ni1cXHUwYzQ4XFx1MGM0YS1cXHUwYzRkXFx1MGM1NVxcdTBjNTZcXHUwYzYyXFx1MGM2M1xcdTBjNjYtXFx1MGM2ZlxcdTBjODEtXFx1MGM4M1xcdTBjYmNcXHUwY2JlLVxcdTBjYzRcXHUwY2M2LVxcdTBjYzhcXHUwY2NhLVxcdTBjY2RcXHUwY2Q1XFx1MGNkNlxcdTBjZTJcXHUwY2UzXFx1MGNlNi1cXHUwY2VmXFx1MGNmM1xcdTBkMDAtXFx1MGQwM1xcdTBkM2JcXHUwZDNjXFx1MGQzZS1cXHUwZDQ0XFx1MGQ0Ni1cXHUwZDQ4XFx1MGQ0YS1cXHUwZDRkXFx1MGQ1N1xcdTBkNjJcXHUwZDYzXFx1MGQ2Ni1cXHUwZDZmXFx1MGQ4MS1cXHUwZDgzXFx1MGRjYVxcdTBkY2YtXFx1MGRkNFxcdTBkZDZcXHUwZGQ4LVxcdTBkZGZcXHUwZGU2LVxcdTBkZWZcXHUwZGYyXFx1MGRmM1xcdTBlMzFcXHUwZTM0LVxcdTBlM2FcXHUwZTQ3LVxcdTBlNGVcXHUwZTUwLVxcdTBlNTlcXHUwZWIxXFx1MGViNC1cXHUwZWJjXFx1MGVjOC1cXHUwZWNlXFx1MGVkMC1cXHUwZWQ5XFx1MGYxOFxcdTBmMTlcXHUwZjIwLVxcdTBmMjlcXHUwZjM1XFx1MGYzN1xcdTBmMzlcXHUwZjNlXFx1MGYzZlxcdTBmNzEtXFx1MGY4NFxcdTBmODZcXHUwZjg3XFx1MGY4ZC1cXHUwZjk3XFx1MGY5OS1cXHUwZmJjXFx1MGZjNlxcdTEwMmItXFx1MTAzZVxcdTEwNDAtXFx1MTA0OVxcdTEwNTYtXFx1MTA1OVxcdTEwNWUtXFx1MTA2MFxcdTEwNjItXFx1MTA2NFxcdTEwNjctXFx1MTA2ZFxcdTEwNzEtXFx1MTA3NFxcdTEwODItXFx1MTA4ZFxcdTEwOGYtXFx1MTA5ZFxcdTEzNWQtXFx1MTM1ZlxcdTEzNjktXFx1MTM3MVxcdTE3MTItXFx1MTcxNVxcdTE3MzItXFx1MTczNFxcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN2I0LVxcdTE3ZDNcXHUxN2RkXFx1MTdlMC1cXHUxN2U5XFx1MTgwYi1cXHUxODBkXFx1MTgwZi1cXHUxODE5XFx1MThhOVxcdTE5MjAtXFx1MTkyYlxcdTE5MzAtXFx1MTkzYlxcdTE5NDYtXFx1MTk0ZlxcdTE5ZDAtXFx1MTlkYVxcdTFhMTctXFx1MWExYlxcdTFhNTUtXFx1MWE1ZVxcdTFhNjAtXFx1MWE3Y1xcdTFhN2YtXFx1MWE4OVxcdTFhOTAtXFx1MWE5OVxcdTFhYjAtXFx1MWFiZFxcdTFhYmYtXFx1MWFjZVxcdTFiMDAtXFx1MWIwNFxcdTFiMzQtXFx1MWI0NFxcdTFiNTAtXFx1MWI1OVxcdTFiNmItXFx1MWI3M1xcdTFiODAtXFx1MWI4MlxcdTFiYTEtXFx1MWJhZFxcdTFiYjAtXFx1MWJiOVxcdTFiZTYtXFx1MWJmM1xcdTFjMjQtXFx1MWMzN1xcdTFjNDAtXFx1MWM0OVxcdTFjNTAtXFx1MWM1OVxcdTFjZDAtXFx1MWNkMlxcdTFjZDQtXFx1MWNlOFxcdTFjZWRcXHUxY2Y0XFx1MWNmNy1cXHUxY2Y5XFx1MWRjMC1cXHUxZGZmXFx1MjAwY1xcdTIwMGRcXHUyMDNmXFx1MjA0MFxcdTIwNTRcXHUyMGQwLVxcdTIwZGNcXHUyMGUxXFx1MjBlNS1cXHUyMGYwXFx1MmNlZi1cXHUyY2YxXFx1MmQ3ZlxcdTJkZTAtXFx1MmRmZlxcdTMwMmEtXFx1MzAyZlxcdTMwOTlcXHUzMDlhXFx1MzBmYlxcdWE2MjAtXFx1YTYyOVxcdWE2NmZcXHVhNjc0LVxcdWE2N2RcXHVhNjllXFx1YTY5ZlxcdWE2ZjBcXHVhNmYxXFx1YTgwMlxcdWE4MDZcXHVhODBiXFx1YTgyMy1cXHVhODI3XFx1YTgyY1xcdWE4ODBcXHVhODgxXFx1YThiNC1cXHVhOGM1XFx1YThkMC1cXHVhOGQ5XFx1YThlMC1cXHVhOGYxXFx1YThmZi1cXHVhOTA5XFx1YTkyNi1cXHVhOTJkXFx1YTk0Ny1cXHVhOTUzXFx1YTk4MC1cXHVhOTgzXFx1YTliMy1cXHVhOWMwXFx1YTlkMC1cXHVhOWQ5XFx1YTllNVxcdWE5ZjAtXFx1YTlmOVxcdWFhMjktXFx1YWEzNlxcdWFhNDNcXHVhYTRjXFx1YWE0ZFxcdWFhNTAtXFx1YWE1OVxcdWFhN2ItXFx1YWE3ZFxcdWFhYjBcXHVhYWIyLVxcdWFhYjRcXHVhYWI3XFx1YWFiOFxcdWFhYmVcXHVhYWJmXFx1YWFjMVxcdWFhZWItXFx1YWFlZlxcdWFhZjVcXHVhYWY2XFx1YWJlMy1cXHVhYmVhXFx1YWJlY1xcdWFiZWRcXHVhYmYwLVxcdWFiZjlcXHVmYjFlXFx1ZmUwMC1cXHVmZTBmXFx1ZmUyMC1cXHVmZTJmXFx1ZmUzM1xcdWZlMzRcXHVmZTRkLVxcdWZlNGZcXHVmZjEwLVxcdWZmMTlcXHVmZjNmXFx1ZmY2NVwiO1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZC4gRG8gbm90IG1vZGlmeSBtYW51YWxseSFcbnZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gXCJcXHhhYVxceGI1XFx4YmFcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJjMVxcdTAyYzYtXFx1MDJkMVxcdTAyZTAtXFx1MDJlNFxcdTAyZWNcXHUwMmVlXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdhLVxcdTAzN2RcXHUwMzdmXFx1MDM4NlxcdTAzODgtXFx1MDM4YVxcdTAzOGNcXHUwMzhlLVxcdTAzYTFcXHUwM2EzLVxcdTAzZjVcXHUwM2Y3LVxcdTA0ODFcXHUwNDhhLVxcdTA1MmZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MC1cXHUwNTg4XFx1MDVkMC1cXHUwNWVhXFx1MDVlZi1cXHUwNWYyXFx1MDYyMC1cXHUwNjRhXFx1MDY2ZVxcdTA2NmZcXHUwNjcxLVxcdTA2ZDNcXHUwNmQ1XFx1MDZlNVxcdTA2ZTZcXHUwNmVlXFx1MDZlZlxcdTA2ZmEtXFx1MDZmY1xcdTA2ZmZcXHUwNzEwXFx1MDcxMi1cXHUwNzJmXFx1MDc0ZC1cXHUwN2E1XFx1MDdiMVxcdTA3Y2EtXFx1MDdlYVxcdTA3ZjRcXHUwN2Y1XFx1MDdmYVxcdTA4MDAtXFx1MDgxNVxcdTA4MWFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4NjAtXFx1MDg2YVxcdTA4NzAtXFx1MDg4N1xcdTA4ODktXFx1MDg4ZVxcdTA4YTAtXFx1MDhjOVxcdTA5MDQtXFx1MDkzOVxcdTA5M2RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThjXFx1MDk4ZlxcdTA5OTBcXHUwOTkzLVxcdTA5YThcXHUwOWFhLVxcdTA5YjBcXHUwOWIyXFx1MDliNi1cXHUwOWI5XFx1MDliZFxcdTA5Y2VcXHUwOWRjXFx1MDlkZFxcdTA5ZGYtXFx1MDllMVxcdTA5ZjBcXHUwOWYxXFx1MDlmY1xcdTBhMDUtXFx1MGEwYVxcdTBhMGZcXHUwYTEwXFx1MGExMy1cXHUwYTI4XFx1MGEyYS1cXHUwYTMwXFx1MGEzMlxcdTBhMzNcXHUwYTM1XFx1MGEzNlxcdTBhMzhcXHUwYTM5XFx1MGE1OS1cXHUwYTVjXFx1MGE1ZVxcdTBhNzItXFx1MGE3NFxcdTBhODUtXFx1MGE4ZFxcdTBhOGYtXFx1MGE5MVxcdTBhOTMtXFx1MGFhOFxcdTBhYWEtXFx1MGFiMFxcdTBhYjJcXHUwYWIzXFx1MGFiNS1cXHUwYWI5XFx1MGFiZFxcdTBhZDBcXHUwYWUwXFx1MGFlMVxcdTBhZjlcXHUwYjA1LVxcdTBiMGNcXHUwYjBmXFx1MGIxMFxcdTBiMTMtXFx1MGIyOFxcdTBiMmEtXFx1MGIzMFxcdTBiMzJcXHUwYjMzXFx1MGIzNS1cXHUwYjM5XFx1MGIzZFxcdTBiNWNcXHUwYjVkXFx1MGI1Zi1cXHUwYjYxXFx1MGI3MVxcdTBiODNcXHUwYjg1LVxcdTBiOGFcXHUwYjhlLVxcdTBiOTBcXHUwYjkyLVxcdTBiOTVcXHUwYjk5XFx1MGI5YVxcdTBiOWNcXHUwYjllXFx1MGI5ZlxcdTBiYTNcXHUwYmE0XFx1MGJhOC1cXHUwYmFhXFx1MGJhZS1cXHUwYmI5XFx1MGJkMFxcdTBjMDUtXFx1MGMwY1xcdTBjMGUtXFx1MGMxMFxcdTBjMTItXFx1MGMyOFxcdTBjMmEtXFx1MGMzOVxcdTBjM2RcXHUwYzU4LVxcdTBjNWFcXHUwYzVkXFx1MGM2MFxcdTBjNjFcXHUwYzgwXFx1MGM4NS1cXHUwYzhjXFx1MGM4ZS1cXHUwYzkwXFx1MGM5Mi1cXHUwY2E4XFx1MGNhYS1cXHUwY2IzXFx1MGNiNS1cXHUwY2I5XFx1MGNiZFxcdTBjZGRcXHUwY2RlXFx1MGNlMFxcdTBjZTFcXHUwY2YxXFx1MGNmMlxcdTBkMDQtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2RcXHUwZDRlXFx1MGQ1NC1cXHUwZDU2XFx1MGQ1Zi1cXHUwZDYxXFx1MGQ3YS1cXHUwZDdmXFx1MGQ4NS1cXHUwZDk2XFx1MGQ5YS1cXHUwZGIxXFx1MGRiMy1cXHUwZGJiXFx1MGRiZFxcdTBkYzAtXFx1MGRjNlxcdTBlMDEtXFx1MGUzMFxcdTBlMzJcXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4Ni1cXHUwZThhXFx1MGU4Yy1cXHUwZWEzXFx1MGVhNVxcdTBlYTctXFx1MGViMFxcdTBlYjJcXHUwZWIzXFx1MGViZFxcdTBlYzAtXFx1MGVjNFxcdTBlYzZcXHUwZWRjLVxcdTBlZGZcXHUwZjAwXFx1MGY0MC1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY4OC1cXHUwZjhjXFx1MTAwMC1cXHUxMDJhXFx1MTAzZlxcdTEwNTAtXFx1MTA1NVxcdTEwNWEtXFx1MTA1ZFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNmUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOGVcXHUxMGEwLVxcdTEwYzVcXHUxMGM3XFx1MTBjZFxcdTEwZDAtXFx1MTBmYVxcdTEwZmMtXFx1MTI0OFxcdTEyNGEtXFx1MTI0ZFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVhLVxcdTEyNWRcXHUxMjYwLVxcdTEyODhcXHUxMjhhLVxcdTEyOGRcXHUxMjkwLVxcdTEyYjBcXHUxMmIyLVxcdTEyYjVcXHUxMmI4LVxcdTEyYmVcXHUxMmMwXFx1MTJjMi1cXHUxMmM1XFx1MTJjOC1cXHUxMmQ2XFx1MTJkOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVhXFx1MTM4MC1cXHUxMzhmXFx1MTNhMC1cXHUxM2Y1XFx1MTNmOC1cXHUxM2ZkXFx1MTQwMS1cXHUxNjZjXFx1MTY2Zi1cXHUxNjdmXFx1MTY4MS1cXHUxNjlhXFx1MTZhMC1cXHUxNmVhXFx1MTZlZS1cXHUxNmY4XFx1MTcwMC1cXHUxNzExXFx1MTcxZi1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZjXFx1MTc2ZS1cXHUxNzcwXFx1MTc4MC1cXHUxN2IzXFx1MTdkN1xcdTE3ZGNcXHUxODIwLVxcdTE4NzhcXHUxODgwLVxcdTE4YThcXHUxOGFhXFx1MThiMC1cXHUxOGY1XFx1MTkwMC1cXHUxOTFlXFx1MTk1MC1cXHUxOTZkXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOWFiXFx1MTliMC1cXHUxOWM5XFx1MWEwMC1cXHUxYTE2XFx1MWEyMC1cXHUxYTU0XFx1MWFhN1xcdTFiMDUtXFx1MWIzM1xcdTFiNDUtXFx1MWI0Y1xcdTFiODMtXFx1MWJhMFxcdTFiYWVcXHUxYmFmXFx1MWJiYS1cXHUxYmU1XFx1MWMwMC1cXHUxYzIzXFx1MWM0ZC1cXHUxYzRmXFx1MWM1YS1cXHUxYzdkXFx1MWM4MC1cXHUxYzhhXFx1MWM5MC1cXHUxY2JhXFx1MWNiZC1cXHUxY2JmXFx1MWNlOS1cXHUxY2VjXFx1MWNlZS1cXHUxY2YzXFx1MWNmNVxcdTFjZjZcXHUxY2ZhXFx1MWQwMC1cXHUxZGJmXFx1MWUwMC1cXHUxZjE1XFx1MWYxOC1cXHUxZjFkXFx1MWYyMC1cXHUxZjQ1XFx1MWY0OC1cXHUxZjRkXFx1MWY1MC1cXHUxZjU3XFx1MWY1OVxcdTFmNWJcXHUxZjVkXFx1MWY1Zi1cXHUxZjdkXFx1MWY4MC1cXHUxZmI0XFx1MWZiNi1cXHUxZmJjXFx1MWZiZVxcdTFmYzItXFx1MWZjNFxcdTFmYzYtXFx1MWZjY1xcdTFmZDAtXFx1MWZkM1xcdTFmZDYtXFx1MWZkYlxcdTFmZTAtXFx1MWZlY1xcdTFmZjItXFx1MWZmNFxcdTFmZjYtXFx1MWZmY1xcdTIwNzFcXHUyMDdmXFx1MjA5MC1cXHUyMDljXFx1MjEwMlxcdTIxMDdcXHUyMTBhLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFkXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyYS1cXHUyMTM5XFx1MjEzYy1cXHUyMTNmXFx1MjE0NS1cXHUyMTQ5XFx1MjE0ZVxcdTIxNjAtXFx1MjE4OFxcdTJjMDAtXFx1MmNlNFxcdTJjZWItXFx1MmNlZVxcdTJjZjJcXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5Yi1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJmXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJmXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGJmXFx1NGUwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjFmXFx1YTYyYVxcdWE2MmJcXHVhNjQwLVxcdWE2NmVcXHVhNjdmLVxcdWE2OWRcXHVhNmEwLVxcdWE2ZWZcXHVhNzE3LVxcdWE3MWZcXHVhNzIyLVxcdWE3ODhcXHVhNzhiLVxcdWE3Y2RcXHVhN2QwXFx1YTdkMVxcdWE3ZDNcXHVhN2Q1LVxcdWE3ZGNcXHVhN2YyLVxcdWE4MDFcXHVhODAzLVxcdWE4MDVcXHVhODA3LVxcdWE4MGFcXHVhODBjLVxcdWE4MjJcXHVhODQwLVxcdWE4NzNcXHVhODgyLVxcdWE4YjNcXHVhOGYyLVxcdWE4ZjdcXHVhOGZiXFx1YThmZFxcdWE4ZmVcXHVhOTBhLVxcdWE5MjVcXHVhOTMwLVxcdWE5NDZcXHVhOTYwLVxcdWE5N2NcXHVhOTg0LVxcdWE5YjJcXHVhOWNmXFx1YTllMC1cXHVhOWU0XFx1YTllNi1cXHVhOWVmXFx1YTlmYS1cXHVhOWZlXFx1YWEwMC1cXHVhYTI4XFx1YWE0MC1cXHVhYTQyXFx1YWE0NC1cXHVhYTRiXFx1YWE2MC1cXHVhYTc2XFx1YWE3YVxcdWFhN2UtXFx1YWFhZlxcdWFhYjFcXHVhYWI1XFx1YWFiNlxcdWFhYjktXFx1YWFiZFxcdWFhYzBcXHVhYWMyXFx1YWFkYi1cXHVhYWRkXFx1YWFlMC1cXHVhYWVhXFx1YWFmMi1cXHVhYWY0XFx1YWIwMS1cXHVhYjA2XFx1YWIwOS1cXHVhYjBlXFx1YWIxMS1cXHVhYjE2XFx1YWIyMC1cXHVhYjI2XFx1YWIyOC1cXHVhYjJlXFx1YWIzMC1cXHVhYjVhXFx1YWI1Yy1cXHVhYjY5XFx1YWI3MC1cXHVhYmUyXFx1YWMwMC1cXHVkN2EzXFx1ZDdiMC1cXHVkN2M2XFx1ZDdjYi1cXHVkN2ZiXFx1ZjkwMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIwMC1cXHVmYjA2XFx1ZmIxMy1cXHVmYjE3XFx1ZmIxZFxcdWZiMWYtXFx1ZmIyOFxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwXFx1ZmI0MVxcdWZiNDNcXHVmYjQ0XFx1ZmI0Ni1cXHVmYmIxXFx1ZmJkMy1cXHVmZDNkXFx1ZmQ1MC1cXHVmZDhmXFx1ZmQ5Mi1cXHVmZGM3XFx1ZmRmMC1cXHVmZGZiXFx1ZmU3MC1cXHVmZTc0XFx1ZmU3Ni1cXHVmZWZjXFx1ZmYyMS1cXHVmZjNhXFx1ZmY0MS1cXHVmZjVhXFx1ZmY2Ni1cXHVmZmJlXFx1ZmZjMi1cXHVmZmM3XFx1ZmZjYS1cXHVmZmNmXFx1ZmZkMi1cXHVmZmQ3XFx1ZmZkYS1cXHVmZmRjXCI7XG5cbi8vIFRoZXNlIGFyZSBhIHJ1bi1sZW5ndGggYW5kIG9mZnNldCBlbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuLy8gPjB4ZmZmZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBhIHZhbGlkIHBhcnQgb2YgaWRlbnRpZmllcnMuIFRoZVxuLy8gb2Zmc2V0IHN0YXJ0cyBhdCAweDEwMDAwLCBhbmQgZWFjaCBwYWlyIG9mIG51bWJlcnMgcmVwcmVzZW50cyBhblxuLy8gb2Zmc2V0IHRvIHRoZSBuZXh0IHJhbmdlLCBhbmQgdGhlbiBhIHNpemUgb2YgdGhlIHJhbmdlLlxuXG4vLyBSZXNlcnZlZCB3b3JkIGxpc3RzIGZvciB2YXJpb3VzIGRpYWxlY3RzIG9mIHRoZSBsYW5ndWFnZVxuXG52YXIgcmVzZXJ2ZWRXb3JkcyA9IHtcbiAgMzogXCJhYnN0cmFjdCBib29sZWFuIGJ5dGUgY2hhciBjbGFzcyBkb3VibGUgZW51bSBleHBvcnQgZXh0ZW5kcyBmaW5hbCBmbG9hdCBnb3RvIGltcGxlbWVudHMgaW1wb3J0IGludCBpbnRlcmZhY2UgbG9uZyBuYXRpdmUgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc2hvcnQgc3RhdGljIHN1cGVyIHN5bmNocm9uaXplZCB0aHJvd3MgdHJhbnNpZW50IHZvbGF0aWxlXCIsXG4gIDU6IFwiY2xhc3MgZW51bSBleHRlbmRzIHN1cGVyIGNvbnN0IGV4cG9ydCBpbXBvcnRcIixcbiAgNjogXCJlbnVtXCIsXG4gIHN0cmljdDogXCJpbXBsZW1lbnRzIGludGVyZmFjZSBsZXQgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc3RhdGljIHlpZWxkXCIsXG4gIHN0cmljdEJpbmQ6IFwiZXZhbCBhcmd1bWVudHNcIlxufTtcblxuLy8gQW5kIHRoZSBrZXl3b3Jkc1xuXG52YXIgZWNtYTVBbmRMZXNzS2V5d29yZHMgPSBcImJyZWFrIGNhc2UgY2F0Y2ggY29udGludWUgZGVidWdnZXIgZGVmYXVsdCBkbyBlbHNlIGZpbmFsbHkgZm9yIGZ1bmN0aW9uIGlmIHJldHVybiBzd2l0Y2ggdGhyb3cgdHJ5IHZhciB3aGlsZSB3aXRoIG51bGwgdHJ1ZSBmYWxzZSBpbnN0YW5jZW9mIHR5cGVvZiB2b2lkIGRlbGV0ZSBuZXcgaW4gdGhpc1wiO1xuXG52YXIga2V5d29yZHMkMSA9IHtcbiAgNTogZWNtYTVBbmRMZXNzS2V5d29yZHMsXG4gIFwiNW1vZHVsZVwiOiBlY21hNUFuZExlc3NLZXl3b3JkcyArIFwiIGV4cG9ydCBpbXBvcnRcIixcbiAgNjogZWNtYTVBbmRMZXNzS2V5d29yZHMgKyBcIiBjb25zdCBjbGFzcyBleHRlbmRzIGV4cG9ydCBpbXBvcnQgc3VwZXJcIlxufTtcblxudmFyIGtleXdvcmRSZWxhdGlvbmFsT3BlcmF0b3IgPSAvXmluKHN0YW5jZW9mKT8kLztcblxuLy8gIyMgQ2hhcmFjdGVyIGNhdGVnb3JpZXNcblxudmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0ID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBcIl1cIik7XG52YXIgbm9uQVNDSUlpZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJDaGFycyArIFwiXVwiKTtcblxuLy8gVGhpcyBoYXMgYSBjb21wbGV4aXR5IGxpbmVhciB0byB0aGUgdmFsdWUgb2YgdGhlIGNvZGUuIFRoZVxuLy8gYXNzdW1wdGlvbiBpcyB0aGF0IGxvb2tpbmcgdXAgYXN0cmFsIGlkZW50aWZpZXIgY2hhcmFjdGVycyBpc1xuLy8gcmFyZS5cbmZ1bmN0aW9uIGlzSW5Bc3RyYWxTZXQoY29kZSwgc2V0KSB7XG4gIHZhciBwb3MgPSAweDEwMDAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHBvcyArPSBzZXRbaV07XG4gICAgaWYgKHBvcyA+IGNvZGUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBwb3MgKz0gc2V0W2kgKyAxXTtcbiAgICBpZiAocG9zID49IGNvZGUpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vLyBUZXN0IHdoZXRoZXIgYSBnaXZlbiBjaGFyYWN0ZXIgY29kZSBzdGFydHMgYW4gaWRlbnRpZmllci5cblxuZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnQoY29kZSwgYXN0cmFsKSB7XG4gIGlmIChjb2RlIDwgNjUpIHsgcmV0dXJuIGNvZGUgPT09IDM2IH1cbiAgaWYgKGNvZGUgPCA5MSkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChjb2RlIDwgOTcpIHsgcmV0dXJuIGNvZGUgPT09IDk1IH1cbiAgaWYgKGNvZGUgPCAxMjMpIHsgcmV0dXJuIHRydWUgfVxuICBpZiAoY29kZSA8PSAweGZmZmYpIHsgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpIH1cbiAgaWYgKGFzdHJhbCA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlIH1cbiAgcmV0dXJuIGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMpXG59XG5cbi8vIFRlc3Qgd2hldGhlciBhIGdpdmVuIGNoYXJhY3RlciBpcyBwYXJ0IG9mIGFuIGlkZW50aWZpZXIuXG5cbmZ1bmN0aW9uIGlzSWRlbnRpZmllckNoYXIoY29kZSwgYXN0cmFsKSB7XG4gIGlmIChjb2RlIDwgNDgpIHsgcmV0dXJuIGNvZGUgPT09IDM2IH1cbiAgaWYgKGNvZGUgPCA1OCkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChjb2RlIDwgNjUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKGNvZGUgPCA5MSkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChjb2RlIDwgOTcpIHsgcmV0dXJuIGNvZGUgPT09IDk1IH1cbiAgaWYgKGNvZGUgPCAxMjMpIHsgcmV0dXJuIHRydWUgfVxuICBpZiAoY29kZSA8PSAweGZmZmYpIHsgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXIudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKSB9XG4gIGlmIChhc3RyYWwgPT09IGZhbHNlKSB7IHJldHVybiBmYWxzZSB9XG4gIHJldHVybiBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzKSB8fCBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJDb2Rlcylcbn1cblxuLy8gIyMgVG9rZW4gdHlwZXNcblxuLy8gVGhlIGFzc2lnbm1lbnQgb2YgZmluZS1ncmFpbmVkLCBpbmZvcm1hdGlvbi1jYXJyeWluZyB0eXBlIG9iamVjdHNcbi8vIGFsbG93cyB0aGUgdG9rZW5pemVyIHRvIHN0b3JlIHRoZSBpbmZvcm1hdGlvbiBpdCBoYXMgYWJvdXQgYVxuLy8gdG9rZW4gaW4gYSB3YXkgdGhhdCBpcyB2ZXJ5IGNoZWFwIGZvciB0aGUgcGFyc2VyIHRvIGxvb2sgdXAuXG5cbi8vIEFsbCB0b2tlbiB0eXBlIHZhcmlhYmxlcyBzdGFydCB3aXRoIGFuIHVuZGVyc2NvcmUsIHRvIG1ha2UgdGhlbVxuLy8gZWFzeSB0byByZWNvZ25pemUuXG5cbi8vIFRoZSBgYmVmb3JlRXhwcmAgcHJvcGVydHkgaXMgdXNlZCB0byBkaXNhbWJpZ3VhdGUgYmV0d2VlbiByZWd1bGFyXG4vLyBleHByZXNzaW9ucyBhbmQgZGl2aXNpb25zLiBJdCBpcyBzZXQgb24gYWxsIHRva2VuIHR5cGVzIHRoYXQgY2FuXG4vLyBiZSBmb2xsb3dlZCBieSBhbiBleHByZXNzaW9uICh0aHVzLCBhIHNsYXNoIGFmdGVyIHRoZW0gd291bGQgYmUgYVxuLy8gcmVndWxhciBleHByZXNzaW9uKS5cbi8vXG4vLyBUaGUgYHN0YXJ0c0V4cHJgIHByb3BlcnR5IGlzIHVzZWQgdG8gY2hlY2sgaWYgdGhlIHRva2VuIGVuZHMgYVxuLy8gYHlpZWxkYCBleHByZXNzaW9uLiBJdCBpcyBzZXQgb24gYWxsIHRva2VuIHR5cGVzIHRoYXQgZWl0aGVyIGNhblxuLy8gZGlyZWN0bHkgc3RhcnQgYW4gZXhwcmVzc2lvbiAobGlrZSBhIHF1b3RhdGlvbiBtYXJrKSBvciBjYW5cbi8vIGNvbnRpbnVlIGFuIGV4cHJlc3Npb24gKGxpa2UgdGhlIGJvZHkgb2YgYSBzdHJpbmcpLlxuLy9cbi8vIGBpc0xvb3BgIG1hcmtzIGEga2V5d29yZCBhcyBzdGFydGluZyBhIGxvb3AsIHdoaWNoIGlzIGltcG9ydGFudFxuLy8gdG8ga25vdyB3aGVuIHBhcnNpbmcgYSBsYWJlbCwgaW4gb3JkZXIgdG8gYWxsb3cgb3IgZGlzYWxsb3dcbi8vIGNvbnRpbnVlIGp1bXBzIHRvIHRoYXQgbGFiZWwuXG5cbnZhciBUb2tlblR5cGUgPSBmdW5jdGlvbiBUb2tlblR5cGUobGFiZWwsIGNvbmYpIHtcbiAgaWYgKCBjb25mID09PSB2b2lkIDAgKSBjb25mID0ge307XG5cbiAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICB0aGlzLmtleXdvcmQgPSBjb25mLmtleXdvcmQ7XG4gIHRoaXMuYmVmb3JlRXhwciA9ICEhY29uZi5iZWZvcmVFeHByO1xuICB0aGlzLnN0YXJ0c0V4cHIgPSAhIWNvbmYuc3RhcnRzRXhwcjtcbiAgdGhpcy5pc0xvb3AgPSAhIWNvbmYuaXNMb29wO1xuICB0aGlzLmlzQXNzaWduID0gISFjb25mLmlzQXNzaWduO1xuICB0aGlzLnByZWZpeCA9ICEhY29uZi5wcmVmaXg7XG4gIHRoaXMucG9zdGZpeCA9ICEhY29uZi5wb3N0Zml4O1xuICB0aGlzLmJpbm9wID0gY29uZi5iaW5vcCB8fCBudWxsO1xuICB0aGlzLnVwZGF0ZUNvbnRleHQgPSBudWxsO1xufTtcblxuZnVuY3Rpb24gYmlub3AobmFtZSwgcHJlYykge1xuICByZXR1cm4gbmV3IFRva2VuVHlwZShuYW1lLCB7YmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IHByZWN9KVxufVxudmFyIGJlZm9yZUV4cHIgPSB7YmVmb3JlRXhwcjogdHJ1ZX0sIHN0YXJ0c0V4cHIgPSB7c3RhcnRzRXhwcjogdHJ1ZX07XG5cbi8vIE1hcCBrZXl3b3JkIG5hbWVzIHRvIHRva2VuIHR5cGVzLlxuXG52YXIga2V5d29yZHMgPSB7fTtcblxuLy8gU3VjY2luY3QgZGVmaW5pdGlvbnMgb2Yga2V5d29yZCB0b2tlbiB0eXBlc1xuZnVuY3Rpb24ga3cobmFtZSwgb3B0aW9ucykge1xuICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICBvcHRpb25zLmtleXdvcmQgPSBuYW1lO1xuICByZXR1cm4ga2V5d29yZHNbbmFtZV0gPSBuZXcgVG9rZW5UeXBlKG5hbWUsIG9wdGlvbnMpXG59XG5cbnZhciB0eXBlcyQxID0ge1xuICBudW06IG5ldyBUb2tlblR5cGUoXCJudW1cIiwgc3RhcnRzRXhwciksXG4gIHJlZ2V4cDogbmV3IFRva2VuVHlwZShcInJlZ2V4cFwiLCBzdGFydHNFeHByKSxcbiAgc3RyaW5nOiBuZXcgVG9rZW5UeXBlKFwic3RyaW5nXCIsIHN0YXJ0c0V4cHIpLFxuICBuYW1lOiBuZXcgVG9rZW5UeXBlKFwibmFtZVwiLCBzdGFydHNFeHByKSxcbiAgcHJpdmF0ZUlkOiBuZXcgVG9rZW5UeXBlKFwicHJpdmF0ZUlkXCIsIHN0YXJ0c0V4cHIpLFxuICBlb2Y6IG5ldyBUb2tlblR5cGUoXCJlb2ZcIiksXG5cbiAgLy8gUHVuY3R1YXRpb24gdG9rZW4gdHlwZXMuXG4gIGJyYWNrZXRMOiBuZXcgVG9rZW5UeXBlKFwiW1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBicmFja2V0UjogbmV3IFRva2VuVHlwZShcIl1cIiksXG4gIGJyYWNlTDogbmV3IFRva2VuVHlwZShcIntcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgYnJhY2VSOiBuZXcgVG9rZW5UeXBlKFwifVwiKSxcbiAgcGFyZW5MOiBuZXcgVG9rZW5UeXBlKFwiKFwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBwYXJlblI6IG5ldyBUb2tlblR5cGUoXCIpXCIpLFxuICBjb21tYTogbmV3IFRva2VuVHlwZShcIixcIiwgYmVmb3JlRXhwciksXG4gIHNlbWk6IG5ldyBUb2tlblR5cGUoXCI7XCIsIGJlZm9yZUV4cHIpLFxuICBjb2xvbjogbmV3IFRva2VuVHlwZShcIjpcIiwgYmVmb3JlRXhwciksXG4gIGRvdDogbmV3IFRva2VuVHlwZShcIi5cIiksXG4gIHF1ZXN0aW9uOiBuZXcgVG9rZW5UeXBlKFwiP1wiLCBiZWZvcmVFeHByKSxcbiAgcXVlc3Rpb25Eb3Q6IG5ldyBUb2tlblR5cGUoXCI/LlwiKSxcbiAgYXJyb3c6IG5ldyBUb2tlblR5cGUoXCI9PlwiLCBiZWZvcmVFeHByKSxcbiAgdGVtcGxhdGU6IG5ldyBUb2tlblR5cGUoXCJ0ZW1wbGF0ZVwiKSxcbiAgaW52YWxpZFRlbXBsYXRlOiBuZXcgVG9rZW5UeXBlKFwiaW52YWxpZFRlbXBsYXRlXCIpLFxuICBlbGxpcHNpczogbmV3IFRva2VuVHlwZShcIi4uLlwiLCBiZWZvcmVFeHByKSxcbiAgYmFja1F1b3RlOiBuZXcgVG9rZW5UeXBlKFwiYFwiLCBzdGFydHNFeHByKSxcbiAgZG9sbGFyQnJhY2VMOiBuZXcgVG9rZW5UeXBlKFwiJHtcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcblxuICAvLyBPcGVyYXRvcnMuIFRoZXNlIGNhcnJ5IHNldmVyYWwga2luZHMgb2YgcHJvcGVydGllcyB0byBoZWxwIHRoZVxuICAvLyBwYXJzZXIgdXNlIHRoZW0gcHJvcGVybHkgKHRoZSBwcmVzZW5jZSBvZiB0aGVzZSBwcm9wZXJ0aWVzIGlzXG4gIC8vIHdoYXQgY2F0ZWdvcml6ZXMgdGhlbSBhcyBvcGVyYXRvcnMpLlxuICAvL1xuICAvLyBgYmlub3BgLCB3aGVuIHByZXNlbnQsIHNwZWNpZmllcyB0aGF0IHRoaXMgb3BlcmF0b3IgaXMgYSBiaW5hcnlcbiAgLy8gb3BlcmF0b3IsIGFuZCB3aWxsIHJlZmVyIHRvIGl0cyBwcmVjZWRlbmNlLlxuICAvL1xuICAvLyBgcHJlZml4YCBhbmQgYHBvc3RmaXhgIG1hcmsgdGhlIG9wZXJhdG9yIGFzIGEgcHJlZml4IG9yIHBvc3RmaXhcbiAgLy8gdW5hcnkgb3BlcmF0b3IuXG4gIC8vXG4gIC8vIGBpc0Fzc2lnbmAgbWFya3MgYWxsIG9mIGA9YCwgYCs9YCwgYC09YCBldGNldGVyYSwgd2hpY2ggYWN0IGFzXG4gIC8vIGJpbmFyeSBvcGVyYXRvcnMgd2l0aCBhIHZlcnkgbG93IHByZWNlZGVuY2UsIHRoYXQgc2hvdWxkIHJlc3VsdFxuICAvLyBpbiBBc3NpZ25tZW50RXhwcmVzc2lvbiBub2Rlcy5cblxuICBlcTogbmV3IFRva2VuVHlwZShcIj1cIiwge2JlZm9yZUV4cHI6IHRydWUsIGlzQXNzaWduOiB0cnVlfSksXG4gIGFzc2lnbjogbmV3IFRva2VuVHlwZShcIl89XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBpc0Fzc2lnbjogdHJ1ZX0pLFxuICBpbmNEZWM6IG5ldyBUb2tlblR5cGUoXCIrKy8tLVwiLCB7cHJlZml4OiB0cnVlLCBwb3N0Zml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIHByZWZpeDogbmV3IFRva2VuVHlwZShcIiEvflwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIGxvZ2ljYWxPUjogYmlub3AoXCJ8fFwiLCAxKSxcbiAgbG9naWNhbEFORDogYmlub3AoXCImJlwiLCAyKSxcbiAgYml0d2lzZU9SOiBiaW5vcChcInxcIiwgMyksXG4gIGJpdHdpc2VYT1I6IGJpbm9wKFwiXlwiLCA0KSxcbiAgYml0d2lzZUFORDogYmlub3AoXCImXCIsIDUpLFxuICBlcXVhbGl0eTogYmlub3AoXCI9PS8hPS89PT0vIT09XCIsIDYpLFxuICByZWxhdGlvbmFsOiBiaW5vcChcIjwvPi88PS8+PVwiLCA3KSxcbiAgYml0U2hpZnQ6IGJpbm9wKFwiPDwvPj4vPj4+XCIsIDgpLFxuICBwbHVzTWluOiBuZXcgVG9rZW5UeXBlKFwiKy8tXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogOSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIG1vZHVsbzogYmlub3AoXCIlXCIsIDEwKSxcbiAgc3RhcjogYmlub3AoXCIqXCIsIDEwKSxcbiAgc2xhc2g6IGJpbm9wKFwiL1wiLCAxMCksXG4gIHN0YXJzdGFyOiBuZXcgVG9rZW5UeXBlKFwiKipcIiwge2JlZm9yZUV4cHI6IHRydWV9KSxcbiAgY29hbGVzY2U6IGJpbm9wKFwiPz9cIiwgMSksXG5cbiAgLy8gS2V5d29yZCB0b2tlbiB0eXBlcy5cbiAgX2JyZWFrOiBrdyhcImJyZWFrXCIpLFxuICBfY2FzZToga3coXCJjYXNlXCIsIGJlZm9yZUV4cHIpLFxuICBfY2F0Y2g6IGt3KFwiY2F0Y2hcIiksXG4gIF9jb250aW51ZToga3coXCJjb250aW51ZVwiKSxcbiAgX2RlYnVnZ2VyOiBrdyhcImRlYnVnZ2VyXCIpLFxuICBfZGVmYXVsdDoga3coXCJkZWZhdWx0XCIsIGJlZm9yZUV4cHIpLFxuICBfZG86IGt3KFwiZG9cIiwge2lzTG9vcDogdHJ1ZSwgYmVmb3JlRXhwcjogdHJ1ZX0pLFxuICBfZWxzZToga3coXCJlbHNlXCIsIGJlZm9yZUV4cHIpLFxuICBfZmluYWxseToga3coXCJmaW5hbGx5XCIpLFxuICBfZm9yOiBrdyhcImZvclwiLCB7aXNMb29wOiB0cnVlfSksXG4gIF9mdW5jdGlvbjoga3coXCJmdW5jdGlvblwiLCBzdGFydHNFeHByKSxcbiAgX2lmOiBrdyhcImlmXCIpLFxuICBfcmV0dXJuOiBrdyhcInJldHVyblwiLCBiZWZvcmVFeHByKSxcbiAgX3N3aXRjaDoga3coXCJzd2l0Y2hcIiksXG4gIF90aHJvdzoga3coXCJ0aHJvd1wiLCBiZWZvcmVFeHByKSxcbiAgX3RyeToga3coXCJ0cnlcIiksXG4gIF92YXI6IGt3KFwidmFyXCIpLFxuICBfY29uc3Q6IGt3KFwiY29uc3RcIiksXG4gIF93aGlsZToga3coXCJ3aGlsZVwiLCB7aXNMb29wOiB0cnVlfSksXG4gIF93aXRoOiBrdyhcIndpdGhcIiksXG4gIF9uZXc6IGt3KFwibmV3XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIF90aGlzOiBrdyhcInRoaXNcIiwgc3RhcnRzRXhwciksXG4gIF9zdXBlcjoga3coXCJzdXBlclwiLCBzdGFydHNFeHByKSxcbiAgX2NsYXNzOiBrdyhcImNsYXNzXCIsIHN0YXJ0c0V4cHIpLFxuICBfZXh0ZW5kczoga3coXCJleHRlbmRzXCIsIGJlZm9yZUV4cHIpLFxuICBfZXhwb3J0OiBrdyhcImV4cG9ydFwiKSxcbiAgX2ltcG9ydDoga3coXCJpbXBvcnRcIiwgc3RhcnRzRXhwciksXG4gIF9udWxsOiBrdyhcIm51bGxcIiwgc3RhcnRzRXhwciksXG4gIF90cnVlOiBrdyhcInRydWVcIiwgc3RhcnRzRXhwciksXG4gIF9mYWxzZToga3coXCJmYWxzZVwiLCBzdGFydHNFeHByKSxcbiAgX2luOiBrdyhcImluXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogN30pLFxuICBfaW5zdGFuY2VvZjoga3coXCJpbnN0YW5jZW9mXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogN30pLFxuICBfdHlwZW9mOiBrdyhcInR5cGVvZlwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIF92b2lkOiBrdyhcInZvaWRcIiwge2JlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBfZGVsZXRlOiBrdyhcImRlbGV0ZVwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSlcbn07XG5cbi8vIE1hdGNoZXMgYSB3aG9sZSBsaW5lIGJyZWFrICh3aGVyZSBDUkxGIGlzIGNvbnNpZGVyZWQgYSBzaW5nbGVcbi8vIGxpbmUgYnJlYWspLiBVc2VkIHRvIGNvdW50IGxpbmVzLlxuXG52YXIgbGluZUJyZWFrID0gL1xcclxcbj98XFxufFxcdTIwMjh8XFx1MjAyOS87XG52YXIgbGluZUJyZWFrRyA9IG5ldyBSZWdFeHAobGluZUJyZWFrLnNvdXJjZSwgXCJnXCIpO1xuXG5mdW5jdGlvbiBpc05ld0xpbmUoY29kZSkge1xuICByZXR1cm4gY29kZSA9PT0gMTAgfHwgY29kZSA9PT0gMTMgfHwgY29kZSA9PT0gMHgyMDI4IHx8IGNvZGUgPT09IDB4MjAyOVxufVxuXG5mdW5jdGlvbiBuZXh0TGluZUJyZWFrKGNvZGUsIGZyb20sIGVuZCkge1xuICBpZiAoIGVuZCA9PT0gdm9pZCAwICkgZW5kID0gY29kZS5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IGZyb207IGkgPCBlbmQ7IGkrKykge1xuICAgIHZhciBuZXh0ID0gY29kZS5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChpc05ld0xpbmUobmV4dCkpXG4gICAgICB7IHJldHVybiBpIDwgZW5kIC0gMSAmJiBuZXh0ID09PSAxMyAmJiBjb2RlLmNoYXJDb2RlQXQoaSArIDEpID09PSAxMCA/IGkgKyAyIDogaSArIDEgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG52YXIgbm9uQVNDSUl3aGl0ZXNwYWNlID0gL1tcXHUxNjgwXFx1MjAwMC1cXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1ZmVmZl0vO1xuXG52YXIgc2tpcFdoaXRlU3BhY2UgPSAvKD86XFxzfFxcL1xcLy4qfFxcL1xcKlteXSo/XFwqXFwvKSovZztcblxudmFyIHJlZiA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgaGFzT3duUHJvcGVydHkgPSByZWYuaGFzT3duUHJvcGVydHk7XG52YXIgdG9TdHJpbmcgPSByZWYudG9TdHJpbmc7XG5cbnZhciBoYXNPd24gPSBPYmplY3QuaGFzT3duIHx8IChmdW5jdGlvbiAob2JqLCBwcm9wTmFtZSkgeyByZXR1cm4gKFxuICBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcE5hbWUpXG4pOyB9KTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IChmdW5jdGlvbiAob2JqKSB7IHJldHVybiAoXG4gIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiXG4pOyB9KTtcblxudmFyIHJlZ2V4cENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gd29yZHNSZWdleHAod29yZHMpIHtcbiAgcmV0dXJuIHJlZ2V4cENhY2hlW3dvcmRzXSB8fCAocmVnZXhwQ2FjaGVbd29yZHNdID0gbmV3IFJlZ0V4cChcIl4oPzpcIiArIHdvcmRzLnJlcGxhY2UoLyAvZywgXCJ8XCIpICsgXCIpJFwiKSlcbn1cblxuZnVuY3Rpb24gY29kZVBvaW50VG9TdHJpbmcoY29kZSkge1xuICAvLyBVVEYtMTYgRGVjb2RpbmdcbiAgaWYgKGNvZGUgPD0gMHhGRkZGKSB7IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpIH1cbiAgY29kZSAtPSAweDEwMDAwO1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoY29kZSA+PiAxMCkgKyAweEQ4MDAsIChjb2RlICYgMTAyMykgKyAweERDMDApXG59XG5cbnZhciBsb25lU3Vycm9nYXRlID0gLyg/OltcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdKS87XG5cbi8vIFRoZXNlIGFyZSB1c2VkIHdoZW4gYG9wdGlvbnMubG9jYXRpb25zYCBpcyBvbiwgZm9yIHRoZVxuLy8gYHN0YXJ0TG9jYCBhbmQgYGVuZExvY2AgcHJvcGVydGllcy5cblxudmFyIFBvc2l0aW9uID0gZnVuY3Rpb24gUG9zaXRpb24obGluZSwgY29sKSB7XG4gIHRoaXMubGluZSA9IGxpbmU7XG4gIHRoaXMuY29sdW1uID0gY29sO1xufTtcblxuUG9zaXRpb24ucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uIG9mZnNldCAobikge1xuICByZXR1cm4gbmV3IFBvc2l0aW9uKHRoaXMubGluZSwgdGhpcy5jb2x1bW4gKyBuKVxufTtcblxudmFyIFNvdXJjZUxvY2F0aW9uID0gZnVuY3Rpb24gU291cmNlTG9jYXRpb24ocCwgc3RhcnQsIGVuZCkge1xuICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gIHRoaXMuZW5kID0gZW5kO1xuICBpZiAocC5zb3VyY2VGaWxlICE9PSBudWxsKSB7IHRoaXMuc291cmNlID0gcC5zb3VyY2VGaWxlOyB9XG59O1xuXG4vLyBUaGUgYGdldExpbmVJbmZvYCBmdW5jdGlvbiBpcyBtb3N0bHkgdXNlZnVsIHdoZW4gdGhlXG4vLyBgbG9jYXRpb25zYCBvcHRpb24gaXMgb2ZmIChmb3IgcGVyZm9ybWFuY2UgcmVhc29ucykgYW5kIHlvdVxuLy8gd2FudCB0byBmaW5kIHRoZSBsaW5lL2NvbHVtbiBwb3NpdGlvbiBmb3IgYSBnaXZlbiBjaGFyYWN0ZXJcbi8vIG9mZnNldC4gYGlucHV0YCBzaG91bGQgYmUgdGhlIGNvZGUgc3RyaW5nIHRoYXQgdGhlIG9mZnNldCByZWZlcnNcbi8vIGludG8uXG5cbmZ1bmN0aW9uIGdldExpbmVJbmZvKGlucHV0LCBvZmZzZXQpIHtcbiAgZm9yICh2YXIgbGluZSA9IDEsIGN1ciA9IDA7Oykge1xuICAgIHZhciBuZXh0QnJlYWsgPSBuZXh0TGluZUJyZWFrKGlucHV0LCBjdXIsIG9mZnNldCk7XG4gICAgaWYgKG5leHRCcmVhayA8IDApIHsgcmV0dXJuIG5ldyBQb3NpdGlvbihsaW5lLCBvZmZzZXQgLSBjdXIpIH1cbiAgICArK2xpbmU7XG4gICAgY3VyID0gbmV4dEJyZWFrO1xuICB9XG59XG5cbi8vIEEgc2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgZ2l2ZW4gdG8gY29uZmlndXJlIHRoZSBwYXJzZXIgcHJvY2Vzcy5cbi8vIFRoZXNlIG9wdGlvbnMgYXJlIHJlY29nbml6ZWQgKG9ubHkgYGVjbWFWZXJzaW9uYCBpcyByZXF1aXJlZCk6XG5cbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgLy8gYGVjbWFWZXJzaW9uYCBpbmRpY2F0ZXMgdGhlIEVDTUFTY3JpcHQgdmVyc2lvbiB0byBwYXJzZS4gTXVzdCBiZVxuICAvLyBlaXRoZXIgMywgNSwgNiAob3IgMjAxNSksIDcgKDIwMTYpLCA4ICgyMDE3KSwgOSAoMjAxOCksIDEwXG4gIC8vICgyMDE5KSwgMTEgKDIwMjApLCAxMiAoMjAyMSksIDEzICgyMDIyKSwgMTQgKDIwMjMpLCBvciBgXCJsYXRlc3RcImBcbiAgLy8gKHRoZSBsYXRlc3QgdmVyc2lvbiB0aGUgbGlicmFyeSBzdXBwb3J0cykuIFRoaXMgaW5mbHVlbmNlc1xuICAvLyBzdXBwb3J0IGZvciBzdHJpY3QgbW9kZSwgdGhlIHNldCBvZiByZXNlcnZlZCB3b3JkcywgYW5kIHN1cHBvcnRcbiAgLy8gZm9yIG5ldyBzeW50YXggZmVhdHVyZXMuXG4gIGVjbWFWZXJzaW9uOiBudWxsLFxuICAvLyBgc291cmNlVHlwZWAgaW5kaWNhdGVzIHRoZSBtb2RlIHRoZSBjb2RlIHNob3VsZCBiZSBwYXJzZWQgaW4uXG4gIC8vIENhbiBiZSBlaXRoZXIgYFwic2NyaXB0XCJgIG9yIGBcIm1vZHVsZVwiYC4gVGhpcyBpbmZsdWVuY2VzIGdsb2JhbFxuICAvLyBzdHJpY3QgbW9kZSBhbmQgcGFyc2luZyBvZiBgaW1wb3J0YCBhbmQgYGV4cG9ydGAgZGVjbGFyYXRpb25zLlxuICBzb3VyY2VUeXBlOiBcInNjcmlwdFwiLFxuICAvLyBgb25JbnNlcnRlZFNlbWljb2xvbmAgY2FuIGJlIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIGEgc2VtaWNvbG9uIGlzIGF1dG9tYXRpY2FsbHkgaW5zZXJ0ZWQuIEl0IHdpbGwgYmUgcGFzc2VkIHRoZVxuICAvLyBwb3NpdGlvbiBvZiB0aGUgaW5zZXJ0ZWQgc2VtaWNvbG9uIGFzIGFuIG9mZnNldCwgYW5kIGlmXG4gIC8vIGBsb2NhdGlvbnNgIGlzIGVuYWJsZWQsIGl0IGlzIGdpdmVuIHRoZSBsb2NhdGlvbiBhcyBhIGB7bGluZSxcbiAgLy8gY29sdW1ufWAgb2JqZWN0IGFzIHNlY29uZCBhcmd1bWVudC5cbiAgb25JbnNlcnRlZFNlbWljb2xvbjogbnVsbCxcbiAgLy8gYG9uVHJhaWxpbmdDb21tYWAgaXMgc2ltaWxhciB0byBgb25JbnNlcnRlZFNlbWljb2xvbmAsIGJ1dCBmb3JcbiAgLy8gdHJhaWxpbmcgY29tbWFzLlxuICBvblRyYWlsaW5nQ29tbWE6IG51bGwsXG4gIC8vIEJ5IGRlZmF1bHQsIHJlc2VydmVkIHdvcmRzIGFyZSBvbmx5IGVuZm9yY2VkIGlmIGVjbWFWZXJzaW9uID49IDUuXG4gIC8vIFNldCBgYWxsb3dSZXNlcnZlZGAgdG8gYSBib29sZWFuIHZhbHVlIHRvIGV4cGxpY2l0bHkgdHVybiB0aGlzIG9uXG4gIC8vIGFuIG9mZi4gV2hlbiB0aGlzIG9wdGlvbiBoYXMgdGhlIHZhbHVlIFwibmV2ZXJcIiwgcmVzZXJ2ZWQgd29yZHNcbiAgLy8gYW5kIGtleXdvcmRzIGNhbiBhbHNvIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5IG5hbWVzLlxuICBhbGxvd1Jlc2VydmVkOiBudWxsLFxuICAvLyBXaGVuIGVuYWJsZWQsIGEgcmV0dXJuIGF0IHRoZSB0b3AgbGV2ZWwgaXMgbm90IGNvbnNpZGVyZWQgYW5cbiAgLy8gZXJyb3IuXG4gIGFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uOiBmYWxzZSxcbiAgLy8gV2hlbiBlbmFibGVkLCBpbXBvcnQvZXhwb3J0IHN0YXRlbWVudHMgYXJlIG5vdCBjb25zdHJhaW5lZCB0b1xuICAvLyBhcHBlYXJpbmcgYXQgdGhlIHRvcCBvZiB0aGUgcHJvZ3JhbSwgYW5kIGFuIGltcG9ydC5tZXRhIGV4cHJlc3Npb25cbiAgLy8gaW4gYSBzY3JpcHQgaXNuJ3QgY29uc2lkZXJlZCBhbiBlcnJvci5cbiAgYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlOiBmYWxzZSxcbiAgLy8gQnkgZGVmYXVsdCwgYXdhaXQgaWRlbnRpZmllcnMgYXJlIGFsbG93ZWQgdG8gYXBwZWFyIGF0IHRoZSB0b3AtbGV2ZWwgc2NvcGUgb25seSBpZiBlY21hVmVyc2lvbiA+PSAyMDIyLlxuICAvLyBXaGVuIGVuYWJsZWQsIGF3YWl0IGlkZW50aWZpZXJzIGFyZSBhbGxvd2VkIHRvIGFwcGVhciBhdCB0aGUgdG9wLWxldmVsIHNjb3BlLFxuICAvLyBidXQgdGhleSBhcmUgc3RpbGwgbm90IGFsbG93ZWQgaW4gbm9uLWFzeW5jIGZ1bmN0aW9ucy5cbiAgYWxsb3dBd2FpdE91dHNpZGVGdW5jdGlvbjogbnVsbCxcbiAgLy8gV2hlbiBlbmFibGVkLCBzdXBlciBpZGVudGlmaWVycyBhcmUgbm90IGNvbnN0cmFpbmVkIHRvXG4gIC8vIGFwcGVhcmluZyBpbiBtZXRob2RzIGFuZCBkbyBub3QgcmFpc2UgYW4gZXJyb3Igd2hlbiB0aGV5IGFwcGVhciBlbHNld2hlcmUuXG4gIGFsbG93U3VwZXJPdXRzaWRlTWV0aG9kOiBudWxsLFxuICAvLyBXaGVuIGVuYWJsZWQsIGhhc2hiYW5nIGRpcmVjdGl2ZSBpbiB0aGUgYmVnaW5uaW5nIG9mIGZpbGUgaXNcbiAgLy8gYWxsb3dlZCBhbmQgdHJlYXRlZCBhcyBhIGxpbmUgY29tbWVudC4gRW5hYmxlZCBieSBkZWZhdWx0IHdoZW5cbiAgLy8gYGVjbWFWZXJzaW9uYCA+PSAyMDIzLlxuICBhbGxvd0hhc2hCYW5nOiBmYWxzZSxcbiAgLy8gQnkgZGVmYXVsdCwgdGhlIHBhcnNlciB3aWxsIHZlcmlmeSB0aGF0IHByaXZhdGUgcHJvcGVydGllcyBhcmVcbiAgLy8gb25seSB1c2VkIGluIHBsYWNlcyB3aGVyZSB0aGV5IGFyZSB2YWxpZCBhbmQgaGF2ZSBiZWVuIGRlY2xhcmVkLlxuICAvLyBTZXQgdGhpcyB0byBmYWxzZSB0byB0dXJuIHN1Y2ggY2hlY2tzIG9mZi5cbiAgY2hlY2tQcml2YXRlRmllbGRzOiB0cnVlLFxuICAvLyBXaGVuIGBsb2NhdGlvbnNgIGlzIG9uLCBgbG9jYCBwcm9wZXJ0aWVzIGhvbGRpbmcgb2JqZWN0cyB3aXRoXG4gIC8vIGBzdGFydGAgYW5kIGBlbmRgIHByb3BlcnRpZXMgaW4gYHtsaW5lLCBjb2x1bW59YCBmb3JtICh3aXRoXG4gIC8vIGxpbmUgYmVpbmcgMS1iYXNlZCBhbmQgY29sdW1uIDAtYmFzZWQpIHdpbGwgYmUgYXR0YWNoZWQgdG8gdGhlXG4gIC8vIG5vZGVzLlxuICBsb2NhdGlvbnM6IGZhbHNlLFxuICAvLyBBIGZ1bmN0aW9uIGNhbiBiZSBwYXNzZWQgYXMgYG9uVG9rZW5gIG9wdGlvbiwgd2hpY2ggd2lsbFxuICAvLyBjYXVzZSBBY29ybiB0byBjYWxsIHRoYXQgZnVuY3Rpb24gd2l0aCBvYmplY3QgaW4gdGhlIHNhbWVcbiAgLy8gZm9ybWF0IGFzIHRva2VucyByZXR1cm5lZCBmcm9tIGB0b2tlbml6ZXIoKS5nZXRUb2tlbigpYC4gTm90ZVxuICAvLyB0aGF0IHlvdSBhcmUgbm90IGFsbG93ZWQgdG8gY2FsbCB0aGUgcGFyc2VyIGZyb20gdGhlXG4gIC8vIGNhbGxiYWNr4oCUdGhhdCB3aWxsIGNvcnJ1cHQgaXRzIGludGVybmFsIHN0YXRlLlxuICBvblRva2VuOiBudWxsLFxuICAvLyBBIGZ1bmN0aW9uIGNhbiBiZSBwYXNzZWQgYXMgYG9uQ29tbWVudGAgb3B0aW9uLCB3aGljaCB3aWxsXG4gIC8vIGNhdXNlIEFjb3JuIHRvIGNhbGwgdGhhdCBmdW5jdGlvbiB3aXRoIGAoYmxvY2ssIHRleHQsIHN0YXJ0LFxuICAvLyBlbmQpYCBwYXJhbWV0ZXJzIHdoZW5ldmVyIGEgY29tbWVudCBpcyBza2lwcGVkLiBgYmxvY2tgIGlzIGFcbiAgLy8gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBpcyBhIGJsb2NrIChgLyogKi9gKSBjb21tZW50LFxuICAvLyBgdGV4dGAgaXMgdGhlIGNvbnRlbnQgb2YgdGhlIGNvbW1lbnQsIGFuZCBgc3RhcnRgIGFuZCBgZW5kYCBhcmVcbiAgLy8gY2hhcmFjdGVyIG9mZnNldHMgdGhhdCBkZW5vdGUgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIGNvbW1lbnQuXG4gIC8vIFdoZW4gdGhlIGBsb2NhdGlvbnNgIG9wdGlvbiBpcyBvbiwgdHdvIG1vcmUgcGFyYW1ldGVycyBhcmVcbiAgLy8gcGFzc2VkLCB0aGUgZnVsbCBge2xpbmUsIGNvbHVtbn1gIGxvY2F0aW9ucyBvZiB0aGUgc3RhcnQgYW5kXG4gIC8vIGVuZCBvZiB0aGUgY29tbWVudHMuIE5vdGUgdGhhdCB5b3UgYXJlIG5vdCBhbGxvd2VkIHRvIGNhbGwgdGhlXG4gIC8vIHBhcnNlciBmcm9tIHRoZSBjYWxsYmFja+KAlHRoYXQgd2lsbCBjb3JydXB0IGl0cyBpbnRlcm5hbCBzdGF0ZS5cbiAgLy8gV2hlbiB0aGlzIG9wdGlvbiBoYXMgYW4gYXJyYXkgYXMgdmFsdWUsIG9iamVjdHMgcmVwcmVzZW50aW5nIHRoZVxuICAvLyBjb21tZW50cyBhcmUgcHVzaGVkIHRvIGl0LlxuICBvbkNvbW1lbnQ6IG51bGwsXG4gIC8vIE5vZGVzIGhhdmUgdGhlaXIgc3RhcnQgYW5kIGVuZCBjaGFyYWN0ZXJzIG9mZnNldHMgcmVjb3JkZWQgaW5cbiAgLy8gYHN0YXJ0YCBhbmQgYGVuZGAgcHJvcGVydGllcyAoZGlyZWN0bHkgb24gdGhlIG5vZGUsIHJhdGhlciB0aGFuXG4gIC8vIHRoZSBgbG9jYCBvYmplY3QsIHdoaWNoIGhvbGRzIGxpbmUvY29sdW1uIGRhdGEuIFRvIGFsc28gYWRkIGFcbiAgLy8gW3NlbWktc3RhbmRhcmRpemVkXVtyYW5nZV0gYHJhbmdlYCBwcm9wZXJ0eSBob2xkaW5nIGEgYFtzdGFydCxcbiAgLy8gZW5kXWAgYXJyYXkgd2l0aCB0aGUgc2FtZSBudW1iZXJzLCBzZXQgdGhlIGByYW5nZXNgIG9wdGlvbiB0b1xuICAvLyBgdHJ1ZWAuXG4gIC8vXG4gIC8vIFtyYW5nZV06IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTc0NTY3OFxuICByYW5nZXM6IGZhbHNlLFxuICAvLyBJdCBpcyBwb3NzaWJsZSB0byBwYXJzZSBtdWx0aXBsZSBmaWxlcyBpbnRvIGEgc2luZ2xlIEFTVCBieVxuICAvLyBwYXNzaW5nIHRoZSB0cmVlIHByb2R1Y2VkIGJ5IHBhcnNpbmcgdGhlIGZpcnN0IGZpbGUgYXNcbiAgLy8gYHByb2dyYW1gIG9wdGlvbiBpbiBzdWJzZXF1ZW50IHBhcnNlcy4gVGhpcyB3aWxsIGFkZCB0aGVcbiAgLy8gdG9wbGV2ZWwgZm9ybXMgb2YgdGhlIHBhcnNlZCBmaWxlIHRvIHRoZSBgUHJvZ3JhbWAgKHRvcCkgbm9kZVxuICAvLyBvZiBhbiBleGlzdGluZyBwYXJzZSB0cmVlLlxuICBwcm9ncmFtOiBudWxsLFxuICAvLyBXaGVuIGBsb2NhdGlvbnNgIGlzIG9uLCB5b3UgY2FuIHBhc3MgdGhpcyB0byByZWNvcmQgdGhlIHNvdXJjZVxuICAvLyBmaWxlIGluIGV2ZXJ5IG5vZGUncyBgbG9jYCBvYmplY3QuXG4gIHNvdXJjZUZpbGU6IG51bGwsXG4gIC8vIFRoaXMgdmFsdWUsIGlmIGdpdmVuLCBpcyBzdG9yZWQgaW4gZXZlcnkgbm9kZSwgd2hldGhlclxuICAvLyBgbG9jYXRpb25zYCBpcyBvbiBvciBvZmYuXG4gIGRpcmVjdFNvdXJjZUZpbGU6IG51bGwsXG4gIC8vIFdoZW4gZW5hYmxlZCwgcGFyZW50aGVzaXplZCBleHByZXNzaW9ucyBhcmUgcmVwcmVzZW50ZWQgYnlcbiAgLy8gKG5vbi1zdGFuZGFyZCkgUGFyZW50aGVzaXplZEV4cHJlc3Npb24gbm9kZXNcbiAgcHJlc2VydmVQYXJlbnM6IGZhbHNlXG59O1xuXG4vLyBJbnRlcnByZXQgYW5kIGRlZmF1bHQgYW4gb3B0aW9ucyBvYmplY3RcblxudmFyIHdhcm5lZEFib3V0RWNtYVZlcnNpb24gPSBmYWxzZTtcblxuZnVuY3Rpb24gZ2V0T3B0aW9ucyhvcHRzKSB7XG4gIHZhciBvcHRpb25zID0ge307XG5cbiAgZm9yICh2YXIgb3B0IGluIGRlZmF1bHRPcHRpb25zKVxuICAgIHsgb3B0aW9uc1tvcHRdID0gb3B0cyAmJiBoYXNPd24ob3B0cywgb3B0KSA/IG9wdHNbb3B0XSA6IGRlZmF1bHRPcHRpb25zW29wdF07IH1cblxuICBpZiAob3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gXCJsYXRlc3RcIikge1xuICAgIG9wdGlvbnMuZWNtYVZlcnNpb24gPSAxZTg7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5lY21hVmVyc2lvbiA9PSBudWxsKSB7XG4gICAgaWYgKCF3YXJuZWRBYm91dEVjbWFWZXJzaW9uICYmIHR5cGVvZiBjb25zb2xlID09PSBcIm9iamVjdFwiICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgd2FybmVkQWJvdXRFY21hVmVyc2lvbiA9IHRydWU7XG4gICAgICBjb25zb2xlLndhcm4oXCJTaW5jZSBBY29ybiA4LjAuMCwgb3B0aW9ucy5lY21hVmVyc2lvbiBpcyByZXF1aXJlZC5cXG5EZWZhdWx0aW5nIHRvIDIwMjAsIGJ1dCB0aGlzIHdpbGwgc3RvcCB3b3JraW5nIGluIHRoZSBmdXR1cmUuXCIpO1xuICAgIH1cbiAgICBvcHRpb25zLmVjbWFWZXJzaW9uID0gMTE7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5lY21hVmVyc2lvbiA+PSAyMDE1KSB7XG4gICAgb3B0aW9ucy5lY21hVmVyc2lvbiAtPSAyMDA5O1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuYWxsb3dSZXNlcnZlZCA9PSBudWxsKVxuICAgIHsgb3B0aW9ucy5hbGxvd1Jlc2VydmVkID0gb3B0aW9ucy5lY21hVmVyc2lvbiA8IDU7IH1cblxuICBpZiAoIW9wdHMgfHwgb3B0cy5hbGxvd0hhc2hCYW5nID09IG51bGwpXG4gICAgeyBvcHRpb25zLmFsbG93SGFzaEJhbmcgPSBvcHRpb25zLmVjbWFWZXJzaW9uID49IDE0OyB9XG5cbiAgaWYgKGlzQXJyYXkob3B0aW9ucy5vblRva2VuKSkge1xuICAgIHZhciB0b2tlbnMgPSBvcHRpb25zLm9uVG9rZW47XG4gICAgb3B0aW9ucy5vblRva2VuID0gZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbnMucHVzaCh0b2tlbik7IH07XG4gIH1cbiAgaWYgKGlzQXJyYXkob3B0aW9ucy5vbkNvbW1lbnQpKVxuICAgIHsgb3B0aW9ucy5vbkNvbW1lbnQgPSBwdXNoQ29tbWVudChvcHRpb25zLCBvcHRpb25zLm9uQ29tbWVudCk7IH1cblxuICByZXR1cm4gb3B0aW9uc1xufVxuXG5mdW5jdGlvbiBwdXNoQ29tbWVudChvcHRpb25zLCBhcnJheSkge1xuICByZXR1cm4gZnVuY3Rpb24oYmxvY2ssIHRleHQsIHN0YXJ0LCBlbmQsIHN0YXJ0TG9jLCBlbmRMb2MpIHtcbiAgICB2YXIgY29tbWVudCA9IHtcbiAgICAgIHR5cGU6IGJsb2NrID8gXCJCbG9ja1wiIDogXCJMaW5lXCIsXG4gICAgICB2YWx1ZTogdGV4dCxcbiAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgIGVuZDogZW5kXG4gICAgfTtcbiAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgICB7IGNvbW1lbnQubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKHRoaXMsIHN0YXJ0TG9jLCBlbmRMb2MpOyB9XG4gICAgaWYgKG9wdGlvbnMucmFuZ2VzKVxuICAgICAgeyBjb21tZW50LnJhbmdlID0gW3N0YXJ0LCBlbmRdOyB9XG4gICAgYXJyYXkucHVzaChjb21tZW50KTtcbiAgfVxufVxuXG4vLyBFYWNoIHNjb3BlIGdldHMgYSBiaXRzZXQgdGhhdCBtYXkgY29udGFpbiB0aGVzZSBmbGFnc1xudmFyXG4gICAgU0NPUEVfVE9QID0gMSxcbiAgICBTQ09QRV9GVU5DVElPTiA9IDIsXG4gICAgU0NPUEVfQVNZTkMgPSA0LFxuICAgIFNDT1BFX0dFTkVSQVRPUiA9IDgsXG4gICAgU0NPUEVfQVJST1cgPSAxNixcbiAgICBTQ09QRV9TSU1QTEVfQ0FUQ0ggPSAzMixcbiAgICBTQ09QRV9TVVBFUiA9IDY0LFxuICAgIFNDT1BFX0RJUkVDVF9TVVBFUiA9IDEyOCxcbiAgICBTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0sgPSAyNTYsXG4gICAgU0NPUEVfQ0xBU1NfRklFTERfSU5JVCA9IDUxMixcbiAgICBTQ09QRV9WQVIgPSBTQ09QRV9UT1AgfCBTQ09QRV9GVU5DVElPTiB8IFNDT1BFX0NMQVNTX1NUQVRJQ19CTE9DSztcblxuZnVuY3Rpb24gZnVuY3Rpb25GbGFncyhhc3luYywgZ2VuZXJhdG9yKSB7XG4gIHJldHVybiBTQ09QRV9GVU5DVElPTiB8IChhc3luYyA/IFNDT1BFX0FTWU5DIDogMCkgfCAoZ2VuZXJhdG9yID8gU0NPUEVfR0VORVJBVE9SIDogMClcbn1cblxuLy8gVXNlZCBpbiBjaGVja0xWYWwqIGFuZCBkZWNsYXJlTmFtZSB0byBkZXRlcm1pbmUgdGhlIHR5cGUgb2YgYSBiaW5kaW5nXG52YXJcbiAgICBCSU5EX05PTkUgPSAwLCAvLyBOb3QgYSBiaW5kaW5nXG4gICAgQklORF9WQVIgPSAxLCAvLyBWYXItc3R5bGUgYmluZGluZ1xuICAgIEJJTkRfTEVYSUNBTCA9IDIsIC8vIExldC0gb3IgY29uc3Qtc3R5bGUgYmluZGluZ1xuICAgIEJJTkRfRlVOQ1RJT04gPSAzLCAvLyBGdW5jdGlvbiBkZWNsYXJhdGlvblxuICAgIEJJTkRfU0lNUExFX0NBVENIID0gNCwgLy8gU2ltcGxlIChpZGVudGlmaWVyIHBhdHRlcm4pIGNhdGNoIGJpbmRpbmdcbiAgICBCSU5EX09VVFNJREUgPSA1OyAvLyBTcGVjaWFsIGNhc2UgZm9yIGZ1bmN0aW9uIG5hbWVzIGFzIGJvdW5kIGluc2lkZSB0aGUgZnVuY3Rpb25cblxudmFyIFBhcnNlciA9IGZ1bmN0aW9uIFBhcnNlcihvcHRpb25zLCBpbnB1dCwgc3RhcnRQb3MpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyA9IGdldE9wdGlvbnMob3B0aW9ucyk7XG4gIHRoaXMuc291cmNlRmlsZSA9IG9wdGlvbnMuc291cmNlRmlsZTtcbiAgdGhpcy5rZXl3b3JkcyA9IHdvcmRzUmVnZXhwKGtleXdvcmRzJDFbb3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ID8gNiA6IG9wdGlvbnMuc291cmNlVHlwZSA9PT0gXCJtb2R1bGVcIiA/IFwiNW1vZHVsZVwiIDogNV0pO1xuICB2YXIgcmVzZXJ2ZWQgPSBcIlwiO1xuICBpZiAob3B0aW9ucy5hbGxvd1Jlc2VydmVkICE9PSB0cnVlKSB7XG4gICAgcmVzZXJ2ZWQgPSByZXNlcnZlZFdvcmRzW29wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiA/IDYgOiBvcHRpb25zLmVjbWFWZXJzaW9uID09PSA1ID8gNSA6IDNdO1xuICAgIGlmIChvcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCIpIHsgcmVzZXJ2ZWQgKz0gXCIgYXdhaXRcIjsgfVxuICB9XG4gIHRoaXMucmVzZXJ2ZWRXb3JkcyA9IHdvcmRzUmVnZXhwKHJlc2VydmVkKTtcbiAgdmFyIHJlc2VydmVkU3RyaWN0ID0gKHJlc2VydmVkID8gcmVzZXJ2ZWQgKyBcIiBcIiA6IFwiXCIpICsgcmVzZXJ2ZWRXb3Jkcy5zdHJpY3Q7XG4gIHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdCA9IHdvcmRzUmVnZXhwKHJlc2VydmVkU3RyaWN0KTtcbiAgdGhpcy5yZXNlcnZlZFdvcmRzU3RyaWN0QmluZCA9IHdvcmRzUmVnZXhwKHJlc2VydmVkU3RyaWN0ICsgXCIgXCIgKyByZXNlcnZlZFdvcmRzLnN0cmljdEJpbmQpO1xuICB0aGlzLmlucHV0ID0gU3RyaW5nKGlucHV0KTtcblxuICAvLyBVc2VkIHRvIHNpZ25hbCB0byBjYWxsZXJzIG9mIGByZWFkV29yZDFgIHdoZXRoZXIgdGhlIHdvcmRcbiAgLy8gY29udGFpbmVkIGFueSBlc2NhcGUgc2VxdWVuY2VzLiBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIHdvcmRzIHdpdGhcbiAgLy8gZXNjYXBlIHNlcXVlbmNlcyBtdXN0IG5vdCBiZSBpbnRlcnByZXRlZCBhcyBrZXl3b3Jkcy5cbiAgdGhpcy5jb250YWluc0VzYyA9IGZhbHNlO1xuXG4gIC8vIFNldCB1cCB0b2tlbiBzdGF0ZVxuXG4gIC8vIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSB0b2tlbml6ZXIgaW4gdGhlIGlucHV0LlxuICBpZiAoc3RhcnRQb3MpIHtcbiAgICB0aGlzLnBvcyA9IHN0YXJ0UG9zO1xuICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5pbnB1dC5sYXN0SW5kZXhPZihcIlxcblwiLCBzdGFydFBvcyAtIDEpICsgMTtcbiAgICB0aGlzLmN1ckxpbmUgPSB0aGlzLmlucHV0LnNsaWNlKDAsIHRoaXMubGluZVN0YXJ0KS5zcGxpdChsaW5lQnJlYWspLmxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnBvcyA9IHRoaXMubGluZVN0YXJ0ID0gMDtcbiAgICB0aGlzLmN1ckxpbmUgPSAxO1xuICB9XG5cbiAgLy8gUHJvcGVydGllcyBvZiB0aGUgY3VycmVudCB0b2tlbjpcbiAgLy8gSXRzIHR5cGVcbiAgdGhpcy50eXBlID0gdHlwZXMkMS5lb2Y7XG4gIC8vIEZvciB0b2tlbnMgdGhhdCBpbmNsdWRlIG1vcmUgaW5mb3JtYXRpb24gdGhhbiB0aGVpciB0eXBlLCB0aGUgdmFsdWVcbiAgdGhpcy52YWx1ZSA9IG51bGw7XG4gIC8vIEl0cyBzdGFydCBhbmQgZW5kIG9mZnNldFxuICB0aGlzLnN0YXJ0ID0gdGhpcy5lbmQgPSB0aGlzLnBvcztcbiAgLy8gQW5kLCBpZiBsb2NhdGlvbnMgYXJlIHVzZWQsIHRoZSB7bGluZSwgY29sdW1ufSBvYmplY3RcbiAgLy8gY29ycmVzcG9uZGluZyB0byB0aG9zZSBvZmZzZXRzXG4gIHRoaXMuc3RhcnRMb2MgPSB0aGlzLmVuZExvYyA9IHRoaXMuY3VyUG9zaXRpb24oKTtcblxuICAvLyBQb3NpdGlvbiBpbmZvcm1hdGlvbiBmb3IgdGhlIHByZXZpb3VzIHRva2VuXG4gIHRoaXMubGFzdFRva0VuZExvYyA9IHRoaXMubGFzdFRva1N0YXJ0TG9jID0gbnVsbDtcbiAgdGhpcy5sYXN0VG9rU3RhcnQgPSB0aGlzLmxhc3RUb2tFbmQgPSB0aGlzLnBvcztcblxuICAvLyBUaGUgY29udGV4dCBzdGFjayBpcyB1c2VkIHRvIHN1cGVyZmljaWFsbHkgdHJhY2sgc3ludGFjdGljXG4gIC8vIGNvbnRleHQgdG8gcHJlZGljdCB3aGV0aGVyIGEgcmVndWxhciBleHByZXNzaW9uIGlzIGFsbG93ZWQgaW4gYVxuICAvLyBnaXZlbiBwb3NpdGlvbi5cbiAgdGhpcy5jb250ZXh0ID0gdGhpcy5pbml0aWFsQ29udGV4dCgpO1xuICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcblxuICAvLyBGaWd1cmUgb3V0IGlmIGl0J3MgYSBtb2R1bGUgY29kZS5cbiAgdGhpcy5pbk1vZHVsZSA9IG9wdGlvbnMuc291cmNlVHlwZSA9PT0gXCJtb2R1bGVcIjtcbiAgdGhpcy5zdHJpY3QgPSB0aGlzLmluTW9kdWxlIHx8IHRoaXMuc3RyaWN0RGlyZWN0aXZlKHRoaXMucG9zKTtcblxuICAvLyBVc2VkIHRvIHNpZ25pZnkgdGhlIHN0YXJ0IG9mIGEgcG90ZW50aWFsIGFycm93IGZ1bmN0aW9uXG4gIHRoaXMucG90ZW50aWFsQXJyb3dBdCA9IC0xO1xuICB0aGlzLnBvdGVudGlhbEFycm93SW5Gb3JBd2FpdCA9IGZhbHNlO1xuXG4gIC8vIFBvc2l0aW9ucyB0byBkZWxheWVkLWNoZWNrIHRoYXQgeWllbGQvYXdhaXQgZG9lcyBub3QgZXhpc3QgaW4gZGVmYXVsdCBwYXJhbWV0ZXJzLlxuICB0aGlzLnlpZWxkUG9zID0gdGhpcy5hd2FpdFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG4gIC8vIExhYmVscyBpbiBzY29wZS5cbiAgdGhpcy5sYWJlbHMgPSBbXTtcbiAgLy8gVGh1cy1mYXIgdW5kZWZpbmVkIGV4cG9ydHMuXG4gIHRoaXMudW5kZWZpbmVkRXhwb3J0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy8gSWYgZW5hYmxlZCwgc2tpcCBsZWFkaW5nIGhhc2hiYW5nIGxpbmUuXG4gIGlmICh0aGlzLnBvcyA9PT0gMCAmJiBvcHRpb25zLmFsbG93SGFzaEJhbmcgJiYgdGhpcy5pbnB1dC5zbGljZSgwLCAyKSA9PT0gXCIjIVwiKVxuICAgIHsgdGhpcy5za2lwTGluZUNvbW1lbnQoMik7IH1cblxuICAvLyBTY29wZSB0cmFja2luZyBmb3IgZHVwbGljYXRlIHZhcmlhYmxlIG5hbWVzIChzZWUgc2NvcGUuanMpXG4gIHRoaXMuc2NvcGVTdGFjayA9IFtdO1xuICB0aGlzLmVudGVyU2NvcGUoU0NPUEVfVE9QKTtcblxuICAvLyBGb3IgUmVnRXhwIHZhbGlkYXRpb25cbiAgdGhpcy5yZWdleHBTdGF0ZSA9IG51bGw7XG5cbiAgLy8gVGhlIHN0YWNrIG9mIHByaXZhdGUgbmFtZXMuXG4gIC8vIEVhY2ggZWxlbWVudCBoYXMgdHdvIHByb3BlcnRpZXM6ICdkZWNsYXJlZCcgYW5kICd1c2VkJy5cbiAgLy8gV2hlbiBpdCBleGl0ZWQgZnJvbSB0aGUgb3V0ZXJtb3N0IGNsYXNzIGRlZmluaXRpb24sIGFsbCB1c2VkIHByaXZhdGUgbmFtZXMgbXVzdCBiZSBkZWNsYXJlZC5cbiAgdGhpcy5wcml2YXRlTmFtZVN0YWNrID0gW107XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBpbkZ1bmN0aW9uOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGluR2VuZXJhdG9yOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGluQXN5bmM6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sY2FuQXdhaXQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sYWxsb3dTdXBlcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxhbGxvd0RpcmVjdFN1cGVyOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LHRyZWF0RnVuY3Rpb25zQXNWYXI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sYWxsb3dOZXdEb3RUYXJnZXQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0saW5DbGFzc1N0YXRpY0Jsb2NrOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAoKSB7XG4gIHZhciBub2RlID0gdGhpcy5vcHRpb25zLnByb2dyYW0gfHwgdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0VG9rZW4oKTtcbiAgcmV0dXJuIHRoaXMucGFyc2VUb3BMZXZlbChub2RlKVxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzLmluRnVuY3Rpb24uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFZhclNjb3BlKCkuZmxhZ3MgJiBTQ09QRV9GVU5DVElPTikgPiAwIH07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5pbkdlbmVyYXRvci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VmFyU2NvcGUoKS5mbGFncyAmIFNDT1BFX0dFTkVSQVRPUikgPiAwIH07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5pbkFzeW5jLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRWYXJTY29wZSgpLmZsYWdzICYgU0NPUEVfQVNZTkMpID4gMCB9O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMuY2FuQXdhaXQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHJlZiA9IHRoaXMuc2NvcGVTdGFja1tpXTtcbiAgICAgIHZhciBmbGFncyA9IHJlZi5mbGFncztcbiAgICBpZiAoZmxhZ3MgJiAoU0NPUEVfQ0xBU1NfU1RBVElDX0JMT0NLIHwgU0NPUEVfQ0xBU1NfRklFTERfSU5JVCkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAoZmxhZ3MgJiBTQ09QRV9GVU5DVElPTikgeyByZXR1cm4gKGZsYWdzICYgU0NPUEVfQVNZTkMpID4gMCB9XG4gIH1cbiAgcmV0dXJuICh0aGlzLmluTW9kdWxlICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMykgfHwgdGhpcy5vcHRpb25zLmFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb25cbn07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5hbGxvd1N1cGVyLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlZiA9IHRoaXMuY3VycmVudFRoaXNTY29wZSgpO1xuICAgIHZhciBmbGFncyA9IHJlZi5mbGFncztcbiAgcmV0dXJuIChmbGFncyAmIFNDT1BFX1NVUEVSKSA+IDAgfHwgdGhpcy5vcHRpb25zLmFsbG93U3VwZXJPdXRzaWRlTWV0aG9kXG59O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMuYWxsb3dEaXJlY3RTdXBlci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VGhpc1Njb3BlKCkuZmxhZ3MgJiBTQ09QRV9ESVJFQ1RfU1VQRVIpID4gMCB9O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMudHJlYXRGdW5jdGlvbnNBc1Zhci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXJJblNjb3BlKHRoaXMuY3VycmVudFNjb3BlKCkpIH07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5hbGxvd05ld0RvdFRhcmdldC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgcmVmID0gdGhpcy5zY29wZVN0YWNrW2ldO1xuICAgICAgdmFyIGZsYWdzID0gcmVmLmZsYWdzO1xuICAgIGlmIChmbGFncyAmIChTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0sgfCBTQ09QRV9DTEFTU19GSUVMRF9JTklUKSB8fFxuICAgICAgICAoKGZsYWdzICYgU0NPUEVfRlVOQ1RJT04pICYmICEoZmxhZ3MgJiBTQ09QRV9BUlJPVykpKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5pbkNsYXNzU3RhdGljQmxvY2suZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKHRoaXMuY3VycmVudFZhclNjb3BlKCkuZmxhZ3MgJiBTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0spID4gMFxufTtcblxuUGFyc2VyLmV4dGVuZCA9IGZ1bmN0aW9uIGV4dGVuZCAoKSB7XG4gICAgdmFyIHBsdWdpbnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgcGx1Z2luc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gIHZhciBjbHMgPSB0aGlzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHsgY2xzID0gcGx1Z2luc1tpXShjbHMpOyB9XG4gIHJldHVybiBjbHNcbn07XG5cblBhcnNlci5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlIChpbnB1dCwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IHRoaXMob3B0aW9ucywgaW5wdXQpLnBhcnNlKClcbn07XG5cblBhcnNlci5wYXJzZUV4cHJlc3Npb25BdCA9IGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbkF0IChpbnB1dCwgcG9zLCBvcHRpb25zKSB7XG4gIHZhciBwYXJzZXIgPSBuZXcgdGhpcyhvcHRpb25zLCBpbnB1dCwgcG9zKTtcbiAgcGFyc2VyLm5leHRUb2tlbigpO1xuICByZXR1cm4gcGFyc2VyLnBhcnNlRXhwcmVzc2lvbigpXG59O1xuXG5QYXJzZXIudG9rZW5pemVyID0gZnVuY3Rpb24gdG9rZW5pemVyIChpbnB1dCwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IHRoaXMob3B0aW9ucywgaW5wdXQpXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggUGFyc2VyLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbnZhciBwcCQ5ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuLy8gIyMgUGFyc2VyIHV0aWxpdGllc1xuXG52YXIgbGl0ZXJhbCA9IC9eKD86JygoPzpcXFxcW15dfFteJ1xcXFxdKSo/KSd8XCIoKD86XFxcXFteXXxbXlwiXFxcXF0pKj8pXCIpLztcbnBwJDkuc3RyaWN0RGlyZWN0aXZlID0gZnVuY3Rpb24oc3RhcnQpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgZm9yICg7Oykge1xuICAgIC8vIFRyeSB0byBmaW5kIHN0cmluZyBsaXRlcmFsLlxuICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHN0YXJ0O1xuICAgIHN0YXJ0ICs9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dClbMF0ubGVuZ3RoO1xuICAgIHZhciBtYXRjaCA9IGxpdGVyYWwuZXhlYyh0aGlzLmlucHV0LnNsaWNlKHN0YXJ0KSk7XG4gICAgaWYgKCFtYXRjaCkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmICgobWF0Y2hbMV0gfHwgbWF0Y2hbMl0pID09PSBcInVzZSBzdHJpY3RcIikge1xuICAgICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gc3RhcnQgKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICB2YXIgc3BhY2VBZnRlciA9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dCksIGVuZCA9IHNwYWNlQWZ0ZXIuaW5kZXggKyBzcGFjZUFmdGVyWzBdLmxlbmd0aDtcbiAgICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQXQoZW5kKTtcbiAgICAgIHJldHVybiBuZXh0ID09PSBcIjtcIiB8fCBuZXh0ID09PSBcIn1cIiB8fFxuICAgICAgICAobGluZUJyZWFrLnRlc3Qoc3BhY2VBZnRlclswXSkgJiZcbiAgICAgICAgICEoL1soYC5bK1xcLS8qJTw+PSw/XiZdLy50ZXN0KG5leHQpIHx8IG5leHQgPT09IFwiIVwiICYmIHRoaXMuaW5wdXQuY2hhckF0KGVuZCArIDEpID09PSBcIj1cIikpXG4gICAgfVxuICAgIHN0YXJ0ICs9IG1hdGNoWzBdLmxlbmd0aDtcblxuICAgIC8vIFNraXAgc2VtaWNvbG9uLCBpZiBhbnkuXG4gICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gc3RhcnQ7XG4gICAgc3RhcnQgKz0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KVswXS5sZW5ndGg7XG4gICAgaWYgKHRoaXMuaW5wdXRbc3RhcnRdID09PSBcIjtcIilcbiAgICAgIHsgc3RhcnQrKzsgfVxuICB9XG59O1xuXG4vLyBQcmVkaWNhdGUgdGhhdCB0ZXN0cyB3aGV0aGVyIHRoZSBuZXh0IHRva2VuIGlzIG9mIHRoZSBnaXZlblxuLy8gdHlwZSwgYW5kIGlmIHllcywgY29uc3VtZXMgaXQgYXMgYSBzaWRlIGVmZmVjdC5cblxucHAkOS5lYXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59O1xuXG4vLyBUZXN0cyB3aGV0aGVyIHBhcnNlZCB0b2tlbiBpcyBhIGNvbnRleHR1YWwga2V5d29yZC5cblxucHAkOS5pc0NvbnRleHR1YWwgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiB0aGlzLnR5cGUgPT09IHR5cGVzJDEubmFtZSAmJiB0aGlzLnZhbHVlID09PSBuYW1lICYmICF0aGlzLmNvbnRhaW5zRXNjXG59O1xuXG4vLyBDb25zdW1lcyBjb250ZXh0dWFsIGtleXdvcmQgaWYgcG9zc2libGUuXG5cbnBwJDkuZWF0Q29udGV4dHVhbCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYgKCF0aGlzLmlzQ29udGV4dHVhbChuYW1lKSkgeyByZXR1cm4gZmFsc2UgfVxuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIHRydWVcbn07XG5cbi8vIEFzc2VydHMgdGhhdCBmb2xsb3dpbmcgdG9rZW4gaXMgZ2l2ZW4gY29udGV4dHVhbCBrZXl3b3JkLlxuXG5wcCQ5LmV4cGVjdENvbnRleHR1YWwgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmICghdGhpcy5lYXRDb250ZXh0dWFsKG5hbWUpKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG59O1xuXG4vLyBUZXN0IHdoZXRoZXIgYSBzZW1pY29sb24gY2FuIGJlIGluc2VydGVkIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuXG5wcCQ5LmNhbkluc2VydFNlbWljb2xvbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50eXBlID09PSB0eXBlcyQxLmVvZiB8fFxuICAgIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5icmFjZVIgfHxcbiAgICBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpXG59O1xuXG5wcCQ5Lmluc2VydFNlbWljb2xvbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMub25JbnNlcnRlZFNlbWljb2xvbilcbiAgICAgIHsgdGhpcy5vcHRpb25zLm9uSW5zZXJ0ZWRTZW1pY29sb24odGhpcy5sYXN0VG9rRW5kLCB0aGlzLmxhc3RUb2tFbmRMb2MpOyB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufTtcblxuLy8gQ29uc3VtZSBhIHNlbWljb2xvbiwgb3IsIGZhaWxpbmcgdGhhdCwgc2VlIGlmIHdlIGFyZSBhbGxvd2VkIHRvXG4vLyBwcmV0ZW5kIHRoYXQgdGhlcmUgaXMgYSBzZW1pY29sb24gYXQgdGhpcyBwb3NpdGlvbi5cblxucHAkOS5zZW1pY29sb24gPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmVhdCh0eXBlcyQxLnNlbWkpICYmICF0aGlzLmluc2VydFNlbWljb2xvbigpKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG59O1xuXG5wcCQ5LmFmdGVyVHJhaWxpbmdDb21tYSA9IGZ1bmN0aW9uKHRva1R5cGUsIG5vdE5leHQpIHtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdG9rVHlwZSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMub25UcmFpbGluZ0NvbW1hKVxuICAgICAgeyB0aGlzLm9wdGlvbnMub25UcmFpbGluZ0NvbW1hKHRoaXMubGFzdFRva1N0YXJ0LCB0aGlzLmxhc3RUb2tTdGFydExvYyk7IH1cbiAgICBpZiAoIW5vdE5leHQpXG4gICAgICB7IHRoaXMubmV4dCgpOyB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufTtcblxuLy8gRXhwZWN0IGEgdG9rZW4gb2YgYSBnaXZlbiB0eXBlLiBJZiBmb3VuZCwgY29uc3VtZSBpdCwgb3RoZXJ3aXNlLFxuLy8gcmFpc2UgYW4gdW5leHBlY3RlZCB0b2tlbiBlcnJvci5cblxucHAkOS5leHBlY3QgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHRoaXMuZWF0KHR5cGUpIHx8IHRoaXMudW5leHBlY3RlZCgpO1xufTtcblxuLy8gUmFpc2UgYW4gdW5leHBlY3RlZCB0b2tlbiBlcnJvci5cblxucHAkOS51bmV4cGVjdGVkID0gZnVuY3Rpb24ocG9zKSB7XG4gIHRoaXMucmFpc2UocG9zICE9IG51bGwgPyBwb3MgOiB0aGlzLnN0YXJ0LCBcIlVuZXhwZWN0ZWQgdG9rZW5cIik7XG59O1xuXG52YXIgRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IGZ1bmN0aW9uIERlc3RydWN0dXJpbmdFcnJvcnMoKSB7XG4gIHRoaXMuc2hvcnRoYW5kQXNzaWduID1cbiAgdGhpcy50cmFpbGluZ0NvbW1hID1cbiAgdGhpcy5wYXJlbnRoZXNpemVkQXNzaWduID1cbiAgdGhpcy5wYXJlbnRoZXNpemVkQmluZCA9XG4gIHRoaXMuZG91YmxlUHJvdG8gPVxuICAgIC0xO1xufTtcblxucHAkOS5jaGVja1BhdHRlcm5FcnJvcnMgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBpc0Fzc2lnbikge1xuICBpZiAoIXJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgcmV0dXJuIH1cbiAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA+IC0xKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSwgXCJDb21tYSBpcyBub3QgcGVybWl0dGVkIGFmdGVyIHRoZSByZXN0IGVsZW1lbnRcIik7IH1cbiAgdmFyIHBhcmVucyA9IGlzQXNzaWduID8gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduIDogcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZDtcbiAgaWYgKHBhcmVucyA+IC0xKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShwYXJlbnMsIGlzQXNzaWduID8gXCJBc3NpZ25pbmcgdG8gcnZhbHVlXCIgOiBcIlBhcmVudGhlc2l6ZWQgcGF0dGVyblwiKTsgfVxufTtcblxucHAkOS5jaGVja0V4cHJlc3Npb25FcnJvcnMgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBhbmRUaHJvdykge1xuICBpZiAoIXJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgcmV0dXJuIGZhbHNlIH1cbiAgdmFyIHNob3J0aGFuZEFzc2lnbiA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduO1xuICB2YXIgZG91YmxlUHJvdG8gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvO1xuICBpZiAoIWFuZFRocm93KSB7IHJldHVybiBzaG9ydGhhbmRBc3NpZ24gPj0gMCB8fCBkb3VibGVQcm90byA+PSAwIH1cbiAgaWYgKHNob3J0aGFuZEFzc2lnbiA+PSAwKVxuICAgIHsgdGhpcy5yYWlzZShzaG9ydGhhbmRBc3NpZ24sIFwiU2hvcnRoYW5kIHByb3BlcnR5IGFzc2lnbm1lbnRzIGFyZSB2YWxpZCBvbmx5IGluIGRlc3RydWN0dXJpbmcgcGF0dGVybnNcIik7IH1cbiAgaWYgKGRvdWJsZVByb3RvID49IDApXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZG91YmxlUHJvdG8sIFwiUmVkZWZpbml0aW9uIG9mIF9fcHJvdG9fXyBwcm9wZXJ0eVwiKTsgfVxufTtcblxucHAkOS5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMueWllbGRQb3MgJiYgKCF0aGlzLmF3YWl0UG9zIHx8IHRoaXMueWllbGRQb3MgPCB0aGlzLmF3YWl0UG9zKSlcbiAgICB7IHRoaXMucmFpc2UodGhpcy55aWVsZFBvcywgXCJZaWVsZCBleHByZXNzaW9uIGNhbm5vdCBiZSBhIGRlZmF1bHQgdmFsdWVcIik7IH1cbiAgaWYgKHRoaXMuYXdhaXRQb3MpXG4gICAgeyB0aGlzLnJhaXNlKHRoaXMuYXdhaXRQb3MsIFwiQXdhaXQgZXhwcmVzc2lvbiBjYW5ub3QgYmUgYSBkZWZhdWx0IHZhbHVlXCIpOyB9XG59O1xuXG5wcCQ5LmlzU2ltcGxlQXNzaWduVGFyZ2V0ID0gZnVuY3Rpb24oZXhwcikge1xuICBpZiAoZXhwci50eXBlID09PSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIpXG4gICAgeyByZXR1cm4gdGhpcy5pc1NpbXBsZUFzc2lnblRhcmdldChleHByLmV4cHJlc3Npb24pIH1cbiAgcmV0dXJuIGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgfHwgZXhwci50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIlxufTtcblxudmFyIHBwJDggPSBQYXJzZXIucHJvdG90eXBlO1xuXG4vLyAjIyMgU3RhdGVtZW50IHBhcnNpbmdcblxuLy8gUGFyc2UgYSBwcm9ncmFtLiBJbml0aWFsaXplcyB0aGUgcGFyc2VyLCByZWFkcyBhbnkgbnVtYmVyIG9mXG4vLyBzdGF0ZW1lbnRzLCBhbmQgd3JhcHMgdGhlbSBpbiBhIFByb2dyYW0gbm9kZS4gIE9wdGlvbmFsbHkgdGFrZXMgYVxuLy8gYHByb2dyYW1gIGFyZ3VtZW50LiAgSWYgcHJlc2VudCwgdGhlIHN0YXRlbWVudHMgd2lsbCBiZSBhcHBlbmRlZFxuLy8gdG8gaXRzIGJvZHkgaW5zdGVhZCBvZiBjcmVhdGluZyBhIG5ldyBub2RlLlxuXG5wcCQ4LnBhcnNlVG9wTGV2ZWwgPSBmdW5jdGlvbihub2RlKSB7XG4gIHZhciBleHBvcnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKCFub2RlLmJvZHkpIHsgbm9kZS5ib2R5ID0gW107IH1cbiAgd2hpbGUgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5lb2YpIHtcbiAgICB2YXIgc3RtdCA9IHRoaXMucGFyc2VTdGF0ZW1lbnQobnVsbCwgdHJ1ZSwgZXhwb3J0cyk7XG4gICAgbm9kZS5ib2R5LnB1c2goc3RtdCk7XG4gIH1cbiAgaWYgKHRoaXMuaW5Nb2R1bGUpXG4gICAgeyBmb3IgKHZhciBpID0gMCwgbGlzdCA9IE9iamVjdC5rZXlzKHRoaXMudW5kZWZpbmVkRXhwb3J0cyk7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAge1xuICAgICAgICB2YXIgbmFtZSA9IGxpc3RbaV07XG5cbiAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMudW5kZWZpbmVkRXhwb3J0c1tuYW1lXS5zdGFydCwgKFwiRXhwb3J0ICdcIiArIG5hbWUgKyBcIicgaXMgbm90IGRlZmluZWRcIikpO1xuICAgICAgfSB9XG4gIHRoaXMuYWRhcHREaXJlY3RpdmVQcm9sb2d1ZShub2RlLmJvZHkpO1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5zb3VyY2VUeXBlID0gdGhpcy5vcHRpb25zLnNvdXJjZVR5cGU7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJQcm9ncmFtXCIpXG59O1xuXG52YXIgbG9vcExhYmVsID0ge2tpbmQ6IFwibG9vcFwifSwgc3dpdGNoTGFiZWwgPSB7a2luZDogXCJzd2l0Y2hcIn07XG5cbnBwJDguaXNMZXQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2IHx8ICF0aGlzLmlzQ29udGV4dHVhbChcImxldFwiKSkgeyByZXR1cm4gZmFsc2UgfVxuICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSB0aGlzLnBvcztcbiAgdmFyIHNraXAgPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpO1xuICB2YXIgbmV4dCA9IHRoaXMucG9zICsgc2tpcFswXS5sZW5ndGgsIG5leHRDaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChuZXh0KTtcbiAgLy8gRm9yIGFtYmlndW91cyBjYXNlcywgZGV0ZXJtaW5lIGlmIGEgTGV4aWNhbERlY2xhcmF0aW9uIChvciBvbmx5IGFcbiAgLy8gU3RhdGVtZW50KSBpcyBhbGxvd2VkIGhlcmUuIElmIGNvbnRleHQgaXMgbm90IGVtcHR5IHRoZW4gb25seSBhIFN0YXRlbWVudFxuICAvLyBpcyBhbGxvd2VkLiBIb3dldmVyLCBgbGV0IFtgIGlzIGFuIGV4cGxpY2l0IG5lZ2F0aXZlIGxvb2thaGVhZCBmb3JcbiAgLy8gRXhwcmVzc2lvblN0YXRlbWVudCwgc28gc3BlY2lhbC1jYXNlIGl0IGZpcnN0LlxuICBpZiAobmV4dENoID09PSA5MSB8fCBuZXh0Q2ggPT09IDkyKSB7IHJldHVybiB0cnVlIH0gLy8gJ1snLCAnXFwnXG4gIGlmIChjb250ZXh0KSB7IHJldHVybiBmYWxzZSB9XG5cbiAgaWYgKG5leHRDaCA9PT0gMTIzIHx8IG5leHRDaCA+IDB4ZDdmZiAmJiBuZXh0Q2ggPCAweGRjMDApIHsgcmV0dXJuIHRydWUgfSAvLyAneycsIGFzdHJhbFxuICBpZiAoaXNJZGVudGlmaWVyU3RhcnQobmV4dENoLCB0cnVlKSkge1xuICAgIHZhciBwb3MgPSBuZXh0ICsgMTtcbiAgICB3aGlsZSAoaXNJZGVudGlmaWVyQ2hhcihuZXh0Q2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zKSwgdHJ1ZSkpIHsgKytwb3M7IH1cbiAgICBpZiAobmV4dENoID09PSA5MiB8fCBuZXh0Q2ggPiAweGQ3ZmYgJiYgbmV4dENoIDwgMHhkYzAwKSB7IHJldHVybiB0cnVlIH1cbiAgICB2YXIgaWRlbnQgPSB0aGlzLmlucHV0LnNsaWNlKG5leHQsIHBvcyk7XG4gICAgaWYgKCFrZXl3b3JkUmVsYXRpb25hbE9wZXJhdG9yLnRlc3QoaWRlbnQpKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGNoZWNrICdhc3luYyBbbm8gTGluZVRlcm1pbmF0b3IgaGVyZV0gZnVuY3Rpb24nXG4vLyAtICdhc3luYyAvKmZvbyovIGZ1bmN0aW9uJyBpcyBPSy5cbi8vIC0gJ2FzeW5jIC8qXFxuKi8gZnVuY3Rpb24nIGlzIGludmFsaWQuXG5wcCQ4LmlzQXN5bmNGdW5jdGlvbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgOCB8fCAhdGhpcy5pc0NvbnRleHR1YWwoXCJhc3luY1wiKSlcbiAgICB7IHJldHVybiBmYWxzZSB9XG5cbiAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gdGhpcy5wb3M7XG4gIHZhciBza2lwID0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KTtcbiAgdmFyIG5leHQgPSB0aGlzLnBvcyArIHNraXBbMF0ubGVuZ3RoLCBhZnRlcjtcbiAgcmV0dXJuICFsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMucG9zLCBuZXh0KSkgJiZcbiAgICB0aGlzLmlucHV0LnNsaWNlKG5leHQsIG5leHQgKyA4KSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgKG5leHQgKyA4ID09PSB0aGlzLmlucHV0Lmxlbmd0aCB8fFxuICAgICAhKGlzSWRlbnRpZmllckNoYXIoYWZ0ZXIgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQobmV4dCArIDgpKSB8fCBhZnRlciA+IDB4ZDdmZiAmJiBhZnRlciA8IDB4ZGMwMCkpXG59O1xuXG4vLyBQYXJzZSBhIHNpbmdsZSBzdGF0ZW1lbnQuXG4vL1xuLy8gSWYgZXhwZWN0aW5nIGEgc3RhdGVtZW50IGFuZCBmaW5kaW5nIGEgc2xhc2ggb3BlcmF0b3IsIHBhcnNlIGFcbi8vIHJlZ3VsYXIgZXhwcmVzc2lvbiBsaXRlcmFsLiBUaGlzIGlzIHRvIGhhbmRsZSBjYXNlcyBsaWtlXG4vLyBgaWYgKGZvbykgL2JsYWgvLmV4ZWMoZm9vKWAsIHdoZXJlIGxvb2tpbmcgYXQgdGhlIHByZXZpb3VzIHRva2VuXG4vLyBkb2VzIG5vdCBoZWxwLlxuXG5wcCQ4LnBhcnNlU3RhdGVtZW50ID0gZnVuY3Rpb24oY29udGV4dCwgdG9wTGV2ZWwsIGV4cG9ydHMpIHtcbiAgdmFyIHN0YXJ0dHlwZSA9IHRoaXMudHlwZSwgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIGtpbmQ7XG5cbiAgaWYgKHRoaXMuaXNMZXQoY29udGV4dCkpIHtcbiAgICBzdGFydHR5cGUgPSB0eXBlcyQxLl92YXI7XG4gICAga2luZCA9IFwibGV0XCI7XG4gIH1cblxuICAvLyBNb3N0IHR5cGVzIG9mIHN0YXRlbWVudHMgYXJlIHJlY29nbml6ZWQgYnkgdGhlIGtleXdvcmQgdGhleVxuICAvLyBzdGFydCB3aXRoLiBNYW55IGFyZSB0cml2aWFsIHRvIHBhcnNlLCBzb21lIHJlcXVpcmUgYSBiaXQgb2ZcbiAgLy8gY29tcGxleGl0eS5cblxuICBzd2l0Y2ggKHN0YXJ0dHlwZSkge1xuICBjYXNlIHR5cGVzJDEuX2JyZWFrOiBjYXNlIHR5cGVzJDEuX2NvbnRpbnVlOiByZXR1cm4gdGhpcy5wYXJzZUJyZWFrQ29udGludWVTdGF0ZW1lbnQobm9kZSwgc3RhcnR0eXBlLmtleXdvcmQpXG4gIGNhc2UgdHlwZXMkMS5fZGVidWdnZXI6IHJldHVybiB0aGlzLnBhcnNlRGVidWdnZXJTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcyQxLl9kbzogcmV0dXJuIHRoaXMucGFyc2VEb1N0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzJDEuX2ZvcjogcmV0dXJuIHRoaXMucGFyc2VGb3JTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcyQxLl9mdW5jdGlvbjpcbiAgICAvLyBGdW5jdGlvbiBhcyBzb2xlIGJvZHkgb2YgZWl0aGVyIGFuIGlmIHN0YXRlbWVudCBvciBhIGxhYmVsZWQgc3RhdGVtZW50XG4gICAgLy8gd29ya3MsIGJ1dCBub3Qgd2hlbiBpdCBpcyBwYXJ0IG9mIGEgbGFiZWxlZCBzdGF0ZW1lbnQgdGhhdCBpcyB0aGUgc29sZVxuICAgIC8vIGJvZHkgb2YgYW4gaWYgc3RhdGVtZW50LlxuICAgIGlmICgoY29udGV4dCAmJiAodGhpcy5zdHJpY3QgfHwgY29udGV4dCAhPT0gXCJpZlwiICYmIGNvbnRleHQgIT09IFwibGFiZWxcIikpICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlLCBmYWxzZSwgIWNvbnRleHQpXG4gIGNhc2UgdHlwZXMkMS5fY2xhc3M6XG4gICAgaWYgKGNvbnRleHQpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKG5vZGUsIHRydWUpXG4gIGNhc2UgdHlwZXMkMS5faWY6IHJldHVybiB0aGlzLnBhcnNlSWZTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcyQxLl9yZXR1cm46IHJldHVybiB0aGlzLnBhcnNlUmV0dXJuU3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMkMS5fc3dpdGNoOiByZXR1cm4gdGhpcy5wYXJzZVN3aXRjaFN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzJDEuX3Rocm93OiByZXR1cm4gdGhpcy5wYXJzZVRocm93U3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMkMS5fdHJ5OiByZXR1cm4gdGhpcy5wYXJzZVRyeVN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzJDEuX2NvbnN0OiBjYXNlIHR5cGVzJDEuX3ZhcjpcbiAgICBraW5kID0ga2luZCB8fCB0aGlzLnZhbHVlO1xuICAgIGlmIChjb250ZXh0ICYmIGtpbmQgIT09IFwidmFyXCIpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZVZhclN0YXRlbWVudChub2RlLCBraW5kKVxuICBjYXNlIHR5cGVzJDEuX3doaWxlOiByZXR1cm4gdGhpcy5wYXJzZVdoaWxlU3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMkMS5fd2l0aDogcmV0dXJuIHRoaXMucGFyc2VXaXRoU3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMkMS5icmFjZUw6IHJldHVybiB0aGlzLnBhcnNlQmxvY2sodHJ1ZSwgbm9kZSlcbiAgY2FzZSB0eXBlcyQxLnNlbWk6IHJldHVybiB0aGlzLnBhcnNlRW1wdHlTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcyQxLl9leHBvcnQ6XG4gIGNhc2UgdHlwZXMkMS5faW1wb3J0OlxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPiAxMCAmJiBzdGFydHR5cGUgPT09IHR5cGVzJDEuX2ltcG9ydCkge1xuICAgICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gdGhpcy5wb3M7XG4gICAgICB2YXIgc2tpcCA9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dCk7XG4gICAgICB2YXIgbmV4dCA9IHRoaXMucG9zICsgc2tpcFswXS5sZW5ndGgsIG5leHRDaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChuZXh0KTtcbiAgICAgIGlmIChuZXh0Q2ggPT09IDQwIHx8IG5leHRDaCA9PT0gNDYpIC8vICcoJyBvciAnLidcbiAgICAgICAgeyByZXR1cm4gdGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgdGhpcy5wYXJzZUV4cHJlc3Npb24oKSkgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5vcHRpb25zLmFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZSkge1xuICAgICAgaWYgKCF0b3BMZXZlbClcbiAgICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ2ltcG9ydCcgYW5kICdleHBvcnQnIG1heSBvbmx5IGFwcGVhciBhdCB0aGUgdG9wIGxldmVsXCIpOyB9XG4gICAgICBpZiAoIXRoaXMuaW5Nb2R1bGUpXG4gICAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIidpbXBvcnQnIGFuZCAnZXhwb3J0JyBtYXkgYXBwZWFyIG9ubHkgd2l0aCAnc291cmNlVHlwZTogbW9kdWxlJ1wiKTsgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhcnR0eXBlID09PSB0eXBlcyQxLl9pbXBvcnQgPyB0aGlzLnBhcnNlSW1wb3J0KG5vZGUpIDogdGhpcy5wYXJzZUV4cG9ydChub2RlLCBleHBvcnRzKVxuXG4gICAgLy8gSWYgdGhlIHN0YXRlbWVudCBkb2VzIG5vdCBzdGFydCB3aXRoIGEgc3RhdGVtZW50IGtleXdvcmQgb3IgYVxuICAgIC8vIGJyYWNlLCBpdCdzIGFuIEV4cHJlc3Npb25TdGF0ZW1lbnQgb3IgTGFiZWxlZFN0YXRlbWVudC4gV2VcbiAgICAvLyBzaW1wbHkgc3RhcnQgcGFyc2luZyBhbiBleHByZXNzaW9uLCBhbmQgYWZ0ZXJ3YXJkcywgaWYgdGhlXG4gICAgLy8gbmV4dCB0b2tlbiBpcyBhIGNvbG9uIGFuZCB0aGUgZXhwcmVzc2lvbiB3YXMgYSBzaW1wbGVcbiAgICAvLyBJZGVudGlmaWVyIG5vZGUsIHdlIHN3aXRjaCB0byBpbnRlcnByZXRpbmcgaXQgYXMgYSBsYWJlbC5cbiAgZGVmYXVsdDpcbiAgICBpZiAodGhpcy5pc0FzeW5jRnVuY3Rpb24oKSkge1xuICAgICAgaWYgKGNvbnRleHQpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlLCB0cnVlLCAhY29udGV4dClcbiAgICB9XG5cbiAgICB2YXIgbWF5YmVOYW1lID0gdGhpcy52YWx1ZSwgZXhwciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgaWYgKHN0YXJ0dHlwZSA9PT0gdHlwZXMkMS5uYW1lICYmIGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgdGhpcy5lYXQodHlwZXMkMS5jb2xvbikpXG4gICAgICB7IHJldHVybiB0aGlzLnBhcnNlTGFiZWxlZFN0YXRlbWVudChub2RlLCBtYXliZU5hbWUsIGV4cHIsIGNvbnRleHQpIH1cbiAgICBlbHNlIHsgcmV0dXJuIHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIpIH1cbiAgfVxufTtcblxucHAkOC5wYXJzZUJyZWFrQ29udGludWVTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBrZXl3b3JkKSB7XG4gIHZhciBpc0JyZWFrID0ga2V5d29yZCA9PT0gXCJicmVha1wiO1xuICB0aGlzLm5leHQoKTtcbiAgaWYgKHRoaXMuZWF0KHR5cGVzJDEuc2VtaSkgfHwgdGhpcy5pbnNlcnRTZW1pY29sb24oKSkgeyBub2RlLmxhYmVsID0gbnVsbDsgfVxuICBlbHNlIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzJDEubmFtZSkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICBlbHNlIHtcbiAgICBub2RlLmxhYmVsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgfVxuXG4gIC8vIFZlcmlmeSB0aGF0IHRoZXJlIGlzIGFuIGFjdHVhbCBkZXN0aW5hdGlvbiB0byBicmVhayBvclxuICAvLyBjb250aW51ZSB0by5cbiAgdmFyIGkgPSAwO1xuICBmb3IgKDsgaSA8IHRoaXMubGFiZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGxhYiA9IHRoaXMubGFiZWxzW2ldO1xuICAgIGlmIChub2RlLmxhYmVsID09IG51bGwgfHwgbGFiLm5hbWUgPT09IG5vZGUubGFiZWwubmFtZSkge1xuICAgICAgaWYgKGxhYi5raW5kICE9IG51bGwgJiYgKGlzQnJlYWsgfHwgbGFiLmtpbmQgPT09IFwibG9vcFwiKSkgeyBicmVhayB9XG4gICAgICBpZiAobm9kZS5sYWJlbCAmJiBpc0JyZWFrKSB7IGJyZWFrIH1cbiAgICB9XG4gIH1cbiAgaWYgKGkgPT09IHRoaXMubGFiZWxzLmxlbmd0aCkgeyB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiVW5zeW50YWN0aWMgXCIgKyBrZXl3b3JkKTsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzQnJlYWsgPyBcIkJyZWFrU3RhdGVtZW50XCIgOiBcIkNvbnRpbnVlU3RhdGVtZW50XCIpXG59O1xuXG5wcCQ4LnBhcnNlRGVidWdnZXJTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICB0aGlzLnNlbWljb2xvbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVidWdnZXJTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDgucGFyc2VEb1N0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHRoaXMubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcImRvXCIpO1xuICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgdGhpcy5leHBlY3QodHlwZXMkMS5fd2hpbGUpO1xuICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNilcbiAgICB7IHRoaXMuZWF0KHR5cGVzJDEuc2VtaSk7IH1cbiAgZWxzZVxuICAgIHsgdGhpcy5zZW1pY29sb24oKTsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRG9XaGlsZVN0YXRlbWVudFwiKVxufTtcblxuLy8gRGlzYW1iaWd1YXRpbmcgYmV0d2VlbiBhIGBmb3JgIGFuZCBhIGBmb3JgL2BpbmAgb3IgYGZvcmAvYG9mYFxuLy8gbG9vcCBpcyBub24tdHJpdmlhbC4gQmFzaWNhbGx5LCB3ZSBoYXZlIHRvIHBhcnNlIHRoZSBpbml0IGB2YXJgXG4vLyBzdGF0ZW1lbnQgb3IgZXhwcmVzc2lvbiwgZGlzYWxsb3dpbmcgdGhlIGBpbmAgb3BlcmF0b3IgKHNlZVxuLy8gdGhlIHNlY29uZCBwYXJhbWV0ZXIgdG8gYHBhcnNlRXhwcmVzc2lvbmApLCBhbmQgdGhlbiBjaGVja1xuLy8gd2hldGhlciB0aGUgbmV4dCB0b2tlbiBpcyBgaW5gIG9yIGBvZmAuIFdoZW4gdGhlcmUgaXMgbm8gaW5pdFxuLy8gcGFydCAoc2VtaWNvbG9uIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBvcGVuaW5nIHBhcmVudGhlc2lzKSwgaXRcbi8vIGlzIGEgcmVndWxhciBgZm9yYCBsb29wLlxuXG5wcCQ4LnBhcnNlRm9yU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgdmFyIGF3YWl0QXQgPSAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy5jYW5Bd2FpdCAmJiB0aGlzLmVhdENvbnRleHR1YWwoXCJhd2FpdFwiKSkgPyB0aGlzLmxhc3RUb2tTdGFydCA6IC0xO1xuICB0aGlzLmxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gIHRoaXMuZW50ZXJTY29wZSgwKTtcbiAgdGhpcy5leHBlY3QodHlwZXMkMS5wYXJlbkwpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnNlbWkpIHtcbiAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIG51bGwpXG4gIH1cbiAgdmFyIGlzTGV0ID0gdGhpcy5pc0xldCgpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLl92YXIgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLl9jb25zdCB8fCBpc0xldCkge1xuICAgIHZhciBpbml0JDEgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBraW5kID0gaXNMZXQgPyBcImxldFwiIDogdGhpcy52YWx1ZTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLnBhcnNlVmFyKGluaXQkMSwgdHJ1ZSwga2luZCk7XG4gICAgdGhpcy5maW5pc2hOb2RlKGluaXQkMSwgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpO1xuICAgIGlmICgodGhpcy50eXBlID09PSB0eXBlcyQxLl9pbiB8fCAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpICYmIGluaXQkMS5kZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5faW4pIHtcbiAgICAgICAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgICAgICB9IGVsc2UgeyBub2RlLmF3YWl0ID0gYXdhaXRBdCA+IC0xOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZvckluKG5vZGUsIGluaXQkMSlcbiAgICB9XG4gICAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUZvcihub2RlLCBpbml0JDEpXG4gIH1cbiAgdmFyIHN0YXJ0c1dpdGhMZXQgPSB0aGlzLmlzQ29udGV4dHVhbChcImxldFwiKSwgaXNGb3JPZiA9IGZhbHNlO1xuICB2YXIgY29udGFpbnNFc2MgPSB0aGlzLmNvbnRhaW5zRXNjO1xuICB2YXIgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzO1xuICB2YXIgaW5pdFBvcyA9IHRoaXMuc3RhcnQ7XG4gIHZhciBpbml0ID0gYXdhaXRBdCA+IC0xXG4gICAgPyB0aGlzLnBhcnNlRXhwclN1YnNjcmlwdHMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgXCJhd2FpdFwiKVxuICAgIDogdGhpcy5wYXJzZUV4cHJlc3Npb24odHJ1ZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2luIHx8IChpc0Zvck9mID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpIHtcbiAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IC8vIGltcGxpZXMgYGVjbWFWZXJzaW9uID49IDlgIChzZWUgZGVjbGFyYXRpb24gb2YgYXdhaXRBdClcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2luKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgICAgbm9kZS5hd2FpdCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChpc0Zvck9mICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KSB7XG4gICAgICBpZiAoaW5pdC5zdGFydCA9PT0gaW5pdFBvcyAmJiAhY29udGFpbnNFc2MgJiYgaW5pdC50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBpbml0Lm5hbWUgPT09IFwiYXN5bmNcIikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHsgbm9kZS5hd2FpdCA9IGZhbHNlOyB9XG4gICAgfVxuICAgIGlmIChzdGFydHNXaXRoTGV0ICYmIGlzRm9yT2YpIHsgdGhpcy5yYWlzZShpbml0LnN0YXJ0LCBcIlRoZSBsZWZ0LWhhbmQgc2lkZSBvZiBhIGZvci1vZiBsb29wIG1heSBub3Qgc3RhcnQgd2l0aCAnbGV0Jy5cIik7IH1cbiAgICB0aGlzLnRvQXNzaWduYWJsZShpbml0LCBmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgdGhpcy5jaGVja0xWYWxQYXR0ZXJuKGluaXQpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlRm9ySW4obm9kZSwgaW5pdClcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgfVxuICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICByZXR1cm4gdGhpcy5wYXJzZUZvcihub2RlLCBpbml0KVxufTtcblxucHAkOC5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwgaXNBc3luYywgZGVjbGFyYXRpb25Qb3NpdGlvbikge1xuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihub2RlLCBGVU5DX1NUQVRFTUVOVCB8IChkZWNsYXJhdGlvblBvc2l0aW9uID8gMCA6IEZVTkNfSEFOR0lOR19TVEFURU1FTlQpLCBmYWxzZSwgaXNBc3luYylcbn07XG5cbnBwJDgucGFyc2VJZlN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUudGVzdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgLy8gYWxsb3cgZnVuY3Rpb24gZGVjbGFyYXRpb25zIGluIGJyYW5jaGVzLCBidXQgb25seSBpbiBub24tc3RyaWN0IG1vZGVcbiAgbm9kZS5jb25zZXF1ZW50ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcImlmXCIpO1xuICBub2RlLmFsdGVybmF0ZSA9IHRoaXMuZWF0KHR5cGVzJDEuX2Vsc2UpID8gdGhpcy5wYXJzZVN0YXRlbWVudChcImlmXCIpIDogbnVsbDtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIklmU3RhdGVtZW50XCIpXG59O1xuXG5wcCQ4LnBhcnNlUmV0dXJuU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICBpZiAoIXRoaXMuaW5GdW5jdGlvbiAmJiAhdGhpcy5vcHRpb25zLmFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uKVxuICAgIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIidyZXR1cm4nIG91dHNpZGUgb2YgZnVuY3Rpb25cIik7IH1cbiAgdGhpcy5uZXh0KCk7XG5cbiAgLy8gSW4gYHJldHVybmAgKGFuZCBgYnJlYWtgL2Bjb250aW51ZWApLCB0aGUga2V5d29yZHMgd2l0aFxuICAvLyBvcHRpb25hbCBhcmd1bWVudHMsIHdlIGVhZ2VybHkgbG9vayBmb3IgYSBzZW1pY29sb24gb3IgdGhlXG4gIC8vIHBvc3NpYmlsaXR5IHRvIGluc2VydCBvbmUuXG5cbiAgaWYgKHRoaXMuZWF0KHR5cGVzJDEuc2VtaSkgfHwgdGhpcy5pbnNlcnRTZW1pY29sb24oKSkgeyBub2RlLmFyZ3VtZW50ID0gbnVsbDsgfVxuICBlbHNlIHsgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7IHRoaXMuc2VtaWNvbG9uKCk7IH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlJldHVyblN0YXRlbWVudFwiKVxufTtcblxucHAkOC5wYXJzZVN3aXRjaFN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUuZGlzY3JpbWluYW50ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICBub2RlLmNhc2VzID0gW107XG4gIHRoaXMuZXhwZWN0KHR5cGVzJDEuYnJhY2VMKTtcbiAgdGhpcy5sYWJlbHMucHVzaChzd2l0Y2hMYWJlbCk7XG4gIHRoaXMuZW50ZXJTY29wZSgwKTtcblxuICAvLyBTdGF0ZW1lbnRzIHVuZGVyIG11c3QgYmUgZ3JvdXBlZCAoYnkgbGFiZWwpIGluIFN3aXRjaENhc2VcbiAgLy8gbm9kZXMuIGBjdXJgIGlzIHVzZWQgdG8ga2VlcCB0aGUgbm9kZSB0aGF0IHdlIGFyZSBjdXJyZW50bHlcbiAgLy8gYWRkaW5nIHN0YXRlbWVudHMgdG8uXG5cbiAgdmFyIGN1cjtcbiAgZm9yICh2YXIgc2F3RGVmYXVsdCA9IGZhbHNlOyB0aGlzLnR5cGUgIT09IHR5cGVzJDEuYnJhY2VSOykge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2Nhc2UgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLl9kZWZhdWx0KSB7XG4gICAgICB2YXIgaXNDYXNlID0gdGhpcy50eXBlID09PSB0eXBlcyQxLl9jYXNlO1xuICAgICAgaWYgKGN1cikgeyB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7IH1cbiAgICAgIG5vZGUuY2FzZXMucHVzaChjdXIgPSB0aGlzLnN0YXJ0Tm9kZSgpKTtcbiAgICAgIGN1ci5jb25zZXF1ZW50ID0gW107XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGlmIChpc0Nhc2UpIHtcbiAgICAgICAgY3VyLnRlc3QgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHNhd0RlZmF1bHQpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMubGFzdFRva1N0YXJ0LCBcIk11bHRpcGxlIGRlZmF1bHQgY2xhdXNlc1wiKTsgfVxuICAgICAgICBzYXdEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgY3VyLnRlc3QgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5leHBlY3QodHlwZXMkMS5jb2xvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghY3VyKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICBjdXIuY29uc2VxdWVudC5wdXNoKHRoaXMucGFyc2VTdGF0ZW1lbnQobnVsbCkpO1xuICAgIH1cbiAgfVxuICB0aGlzLmV4aXRTY29wZSgpO1xuICBpZiAoY3VyKSB7IHRoaXMuZmluaXNoTm9kZShjdXIsIFwiU3dpdGNoQ2FzZVwiKTsgfVxuICB0aGlzLm5leHQoKTsgLy8gQ2xvc2luZyBicmFjZVxuICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlN3aXRjaFN0YXRlbWVudFwiKVxufTtcblxucHAkOC5wYXJzZVRocm93U3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgaWYgKGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSkpXG4gICAgeyB0aGlzLnJhaXNlKHRoaXMubGFzdFRva0VuZCwgXCJJbGxlZ2FsIG5ld2xpbmUgYWZ0ZXIgdGhyb3dcIik7IH1cbiAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUaHJvd1N0YXRlbWVudFwiKVxufTtcblxuLy8gUmV1c2VkIGVtcHR5IGFycmF5IGFkZGVkIGZvciBub2RlIGZpZWxkcyB0aGF0IGFyZSBhbHdheXMgZW1wdHkuXG5cbnZhciBlbXB0eSQxID0gW107XG5cbnBwJDgucGFyc2VDYXRjaENsYXVzZVBhcmFtID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXJhbSA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICB2YXIgc2ltcGxlID0gcGFyYW0udHlwZSA9PT0gXCJJZGVudGlmaWVyXCI7XG4gIHRoaXMuZW50ZXJTY29wZShzaW1wbGUgPyBTQ09QRV9TSU1QTEVfQ0FUQ0ggOiAwKTtcbiAgdGhpcy5jaGVja0xWYWxQYXR0ZXJuKHBhcmFtLCBzaW1wbGUgPyBCSU5EX1NJTVBMRV9DQVRDSCA6IEJJTkRfTEVYSUNBTCk7XG4gIHRoaXMuZXhwZWN0KHR5cGVzJDEucGFyZW5SKTtcblxuICByZXR1cm4gcGFyYW1cbn07XG5cbnBwJDgucGFyc2VUcnlTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLmJsb2NrID0gdGhpcy5wYXJzZUJsb2NrKCk7XG4gIG5vZGUuaGFuZGxlciA9IG51bGw7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2NhdGNoKSB7XG4gICAgdmFyIGNsYXVzZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzJDEucGFyZW5MKSkge1xuICAgICAgY2xhdXNlLnBhcmFtID0gdGhpcy5wYXJzZUNhdGNoQ2xhdXNlUGFyYW0oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDEwKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICBjbGF1c2UucGFyYW0gPSBudWxsO1xuICAgICAgdGhpcy5lbnRlclNjb3BlKDApO1xuICAgIH1cbiAgICBjbGF1c2UuYm9keSA9IHRoaXMucGFyc2VCbG9jayhmYWxzZSk7XG4gICAgdGhpcy5leGl0U2NvcGUoKTtcbiAgICBub2RlLmhhbmRsZXIgPSB0aGlzLmZpbmlzaE5vZGUoY2xhdXNlLCBcIkNhdGNoQ2xhdXNlXCIpO1xuICB9XG4gIG5vZGUuZmluYWxpemVyID0gdGhpcy5lYXQodHlwZXMkMS5fZmluYWxseSkgPyB0aGlzLnBhcnNlQmxvY2soKSA6IG51bGw7XG4gIGlmICghbm9kZS5oYW5kbGVyICYmICFub2RlLmZpbmFsaXplcilcbiAgICB7IHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJNaXNzaW5nIGNhdGNoIG9yIGZpbmFsbHkgY2xhdXNlXCIpOyB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUcnlTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDgucGFyc2VWYXJTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBraW5kLCBhbGxvd01pc3NpbmdJbml0aWFsaXplcikge1xuICB0aGlzLm5leHQoKTtcbiAgdGhpcy5wYXJzZVZhcihub2RlLCBmYWxzZSwga2luZCwgYWxsb3dNaXNzaW5nSW5pdGlhbGl6ZXIpO1xuICB0aGlzLnNlbWljb2xvbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKVxufTtcblxucHAkOC5wYXJzZVdoaWxlU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICB0aGlzLmxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJ3aGlsZVwiKTtcbiAgdGhpcy5sYWJlbHMucG9wKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJXaGlsZVN0YXRlbWVudFwiKVxufTtcblxucHAkOC5wYXJzZVdpdGhTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIGlmICh0aGlzLnN0cmljdCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ3dpdGgnIGluIHN0cmljdCBtb2RlXCIpOyB9XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLm9iamVjdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcIndpdGhcIik7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJXaXRoU3RhdGVtZW50XCIpXG59O1xuXG5wcCQ4LnBhcnNlRW1wdHlTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW1wdHlTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDgucGFyc2VMYWJlbGVkU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwgbWF5YmVOYW1lLCBleHByLCBjb250ZXh0KSB7XG4gIGZvciAodmFyIGkkMSA9IDAsIGxpc3QgPSB0aGlzLmxhYmVsczsgaSQxIDwgbGlzdC5sZW5ndGg7IGkkMSArPSAxKVxuICAgIHtcbiAgICB2YXIgbGFiZWwgPSBsaXN0W2kkMV07XG5cbiAgICBpZiAobGFiZWwubmFtZSA9PT0gbWF5YmVOYW1lKVxuICAgICAgeyB0aGlzLnJhaXNlKGV4cHIuc3RhcnQsIFwiTGFiZWwgJ1wiICsgbWF5YmVOYW1lICsgXCInIGlzIGFscmVhZHkgZGVjbGFyZWRcIik7XG4gIH0gfVxuICB2YXIga2luZCA9IHRoaXMudHlwZS5pc0xvb3AgPyBcImxvb3BcIiA6IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5fc3dpdGNoID8gXCJzd2l0Y2hcIiA6IG51bGw7XG4gIGZvciAodmFyIGkgPSB0aGlzLmxhYmVscy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYWJlbCQxID0gdGhpcy5sYWJlbHNbaV07XG4gICAgaWYgKGxhYmVsJDEuc3RhdGVtZW50U3RhcnQgPT09IG5vZGUuc3RhcnQpIHtcbiAgICAgIC8vIFVwZGF0ZSBpbmZvcm1hdGlvbiBhYm91dCBwcmV2aW91cyBsYWJlbHMgb24gdGhpcyBub2RlXG4gICAgICBsYWJlbCQxLnN0YXRlbWVudFN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgIGxhYmVsJDEua2luZCA9IGtpbmQ7XG4gICAgfSBlbHNlIHsgYnJlYWsgfVxuICB9XG4gIHRoaXMubGFiZWxzLnB1c2goe25hbWU6IG1heWJlTmFtZSwga2luZDoga2luZCwgc3RhdGVtZW50U3RhcnQ6IHRoaXMuc3RhcnR9KTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChjb250ZXh0ID8gY29udGV4dC5pbmRleE9mKFwibGFiZWxcIikgPT09IC0xID8gY29udGV4dCArIFwibGFiZWxcIiA6IGNvbnRleHQgOiBcImxhYmVsXCIpO1xuICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgbm9kZS5sYWJlbCA9IGV4cHI7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJMYWJlbGVkU3RhdGVtZW50XCIpXG59O1xuXG5wcCQ4LnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGV4cHIpIHtcbiAgbm9kZS5leHByZXNzaW9uID0gZXhwcjtcbiAgdGhpcy5zZW1pY29sb24oKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIilcbn07XG5cbi8vIFBhcnNlIGEgc2VtaWNvbG9uLWVuY2xvc2VkIGJsb2NrIG9mIHN0YXRlbWVudHMsIGhhbmRsaW5nIGBcInVzZVxuLy8gc3RyaWN0XCJgIGRlY2xhcmF0aW9ucyB3aGVuIGBhbGxvd1N0cmljdGAgaXMgdHJ1ZSAodXNlZCBmb3Jcbi8vIGZ1bmN0aW9uIGJvZGllcykuXG5cbnBwJDgucGFyc2VCbG9jayA9IGZ1bmN0aW9uKGNyZWF0ZU5ld0xleGljYWxTY29wZSwgbm9kZSwgZXhpdFN0cmljdCkge1xuICBpZiAoIGNyZWF0ZU5ld0xleGljYWxTY29wZSA9PT0gdm9pZCAwICkgY3JlYXRlTmV3TGV4aWNhbFNjb3BlID0gdHJ1ZTtcbiAgaWYgKCBub2RlID09PSB2b2lkIDAgKSBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcblxuICBub2RlLmJvZHkgPSBbXTtcbiAgdGhpcy5leHBlY3QodHlwZXMkMS5icmFjZUwpO1xuICBpZiAoY3JlYXRlTmV3TGV4aWNhbFNjb3BlKSB7IHRoaXMuZW50ZXJTY29wZSgwKTsgfVxuICB3aGlsZSAodGhpcy50eXBlICE9PSB0eXBlcyQxLmJyYWNlUikge1xuICAgIHZhciBzdG10ID0gdGhpcy5wYXJzZVN0YXRlbWVudChudWxsKTtcbiAgICBub2RlLmJvZHkucHVzaChzdG10KTtcbiAgfVxuICBpZiAoZXhpdFN0cmljdCkgeyB0aGlzLnN0cmljdCA9IGZhbHNlOyB9XG4gIHRoaXMubmV4dCgpO1xuICBpZiAoY3JlYXRlTmV3TGV4aWNhbFNjb3BlKSB7IHRoaXMuZXhpdFNjb3BlKCk7IH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkJsb2NrU3RhdGVtZW50XCIpXG59O1xuXG4vLyBQYXJzZSBhIHJlZ3VsYXIgYGZvcmAgbG9vcC4gVGhlIGRpc2FtYmlndWF0aW9uIGNvZGUgaW5cbi8vIGBwYXJzZVN0YXRlbWVudGAgd2lsbCBhbHJlYWR5IGhhdmUgcGFyc2VkIHRoZSBpbml0IHN0YXRlbWVudCBvclxuLy8gZXhwcmVzc2lvbi5cblxucHAkOC5wYXJzZUZvciA9IGZ1bmN0aW9uKG5vZGUsIGluaXQpIHtcbiAgbm9kZS5pbml0ID0gaW5pdDtcbiAgdGhpcy5leHBlY3QodHlwZXMkMS5zZW1pKTtcbiAgbm9kZS50ZXN0ID0gdGhpcy50eXBlID09PSB0eXBlcyQxLnNlbWkgPyBudWxsIDogdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgdGhpcy5leHBlY3QodHlwZXMkMS5zZW1pKTtcbiAgbm9kZS51cGRhdGUgPSB0aGlzLnR5cGUgPT09IHR5cGVzJDEucGFyZW5SID8gbnVsbCA6IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gIHRoaXMuZXhwZWN0KHR5cGVzJDEucGFyZW5SKTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcImZvclwiKTtcbiAgdGhpcy5leGl0U2NvcGUoKTtcbiAgdGhpcy5sYWJlbHMucG9wKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJGb3JTdGF0ZW1lbnRcIilcbn07XG5cbi8vIFBhcnNlIGEgYGZvcmAvYGluYCBhbmQgYGZvcmAvYG9mYCBsb29wLCB3aGljaCBhcmUgYWxtb3N0XG4vLyBzYW1lIGZyb20gcGFyc2VyJ3MgcGVyc3BlY3RpdmUuXG5cbnBwJDgucGFyc2VGb3JJbiA9IGZ1bmN0aW9uKG5vZGUsIGluaXQpIHtcbiAgdmFyIGlzRm9ySW4gPSB0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2luO1xuICB0aGlzLm5leHQoKTtcblxuICBpZiAoXG4gICAgaW5pdC50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiAmJlxuICAgIGluaXQuZGVjbGFyYXRpb25zWzBdLmluaXQgIT0gbnVsbCAmJlxuICAgIChcbiAgICAgICFpc0ZvckluIHx8XG4gICAgICB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA4IHx8XG4gICAgICB0aGlzLnN0cmljdCB8fFxuICAgICAgaW5pdC5raW5kICE9PSBcInZhclwiIHx8XG4gICAgICBpbml0LmRlY2xhcmF0aW9uc1swXS5pZC50eXBlICE9PSBcIklkZW50aWZpZXJcIlxuICAgIClcbiAgKSB7XG4gICAgdGhpcy5yYWlzZShcbiAgICAgIGluaXQuc3RhcnQsXG4gICAgICAoKGlzRm9ySW4gPyBcImZvci1pblwiIDogXCJmb3Itb2ZcIikgKyBcIiBsb29wIHZhcmlhYmxlIGRlY2xhcmF0aW9uIG1heSBub3QgaGF2ZSBhbiBpbml0aWFsaXplclwiKVxuICAgICk7XG4gIH1cbiAgbm9kZS5sZWZ0ID0gaW5pdDtcbiAgbm9kZS5yaWdodCA9IGlzRm9ySW4gPyB0aGlzLnBhcnNlRXhwcmVzc2lvbigpIDogdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gIHRoaXMuZXhwZWN0KHR5cGVzJDEucGFyZW5SKTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcImZvclwiKTtcbiAgdGhpcy5leGl0U2NvcGUoKTtcbiAgdGhpcy5sYWJlbHMucG9wKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNGb3JJbiA/IFwiRm9ySW5TdGF0ZW1lbnRcIiA6IFwiRm9yT2ZTdGF0ZW1lbnRcIilcbn07XG5cbi8vIFBhcnNlIGEgbGlzdCBvZiB2YXJpYWJsZSBkZWNsYXJhdGlvbnMuXG5cbnBwJDgucGFyc2VWYXIgPSBmdW5jdGlvbihub2RlLCBpc0Zvciwga2luZCwgYWxsb3dNaXNzaW5nSW5pdGlhbGl6ZXIpIHtcbiAgbm9kZS5kZWNsYXJhdGlvbnMgPSBbXTtcbiAgbm9kZS5raW5kID0ga2luZDtcbiAgZm9yICg7Oykge1xuICAgIHZhciBkZWNsID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLnBhcnNlVmFySWQoZGVjbCwga2luZCk7XG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzJDEuZXEpKSB7XG4gICAgICBkZWNsLmluaXQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oaXNGb3IpO1xuICAgIH0gZWxzZSBpZiAoIWFsbG93TWlzc2luZ0luaXRpYWxpemVyICYmIGtpbmQgPT09IFwiY29uc3RcIiAmJiAhKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5faW4gfHwgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpKSkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfSBlbHNlIGlmICghYWxsb3dNaXNzaW5nSW5pdGlhbGl6ZXIgJiYgZGVjbC5pZC50eXBlICE9PSBcIklkZW50aWZpZXJcIiAmJiAhKGlzRm9yICYmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2luIHx8IHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpKSkge1xuICAgICAgdGhpcy5yYWlzZSh0aGlzLmxhc3RUb2tFbmQsIFwiQ29tcGxleCBiaW5kaW5nIHBhdHRlcm5zIHJlcXVpcmUgYW4gaW5pdGlhbGl6YXRpb24gdmFsdWVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlY2wuaW5pdCA9IG51bGw7XG4gICAgfVxuICAgIG5vZGUuZGVjbGFyYXRpb25zLnB1c2godGhpcy5maW5pc2hOb2RlKGRlY2wsIFwiVmFyaWFibGVEZWNsYXJhdG9yXCIpKTtcbiAgICBpZiAoIXRoaXMuZWF0KHR5cGVzJDEuY29tbWEpKSB7IGJyZWFrIH1cbiAgfVxuICByZXR1cm4gbm9kZVxufTtcblxucHAkOC5wYXJzZVZhcklkID0gZnVuY3Rpb24oZGVjbCwga2luZCkge1xuICBkZWNsLmlkID0gdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gIHRoaXMuY2hlY2tMVmFsUGF0dGVybihkZWNsLmlkLCBraW5kID09PSBcInZhclwiID8gQklORF9WQVIgOiBCSU5EX0xFWElDQUwsIGZhbHNlKTtcbn07XG5cbnZhciBGVU5DX1NUQVRFTUVOVCA9IDEsIEZVTkNfSEFOR0lOR19TVEFURU1FTlQgPSAyLCBGVU5DX05VTExBQkxFX0lEID0gNDtcblxuLy8gUGFyc2UgYSBmdW5jdGlvbiBkZWNsYXJhdGlvbiBvciBsaXRlcmFsIChkZXBlbmRpbmcgb24gdGhlXG4vLyBgc3RhdGVtZW50ICYgRlVOQ19TVEFURU1FTlRgKS5cblxuLy8gUmVtb3ZlIGBhbGxvd0V4cHJlc3Npb25Cb2R5YCBmb3IgNy4wLjAsIGFzIGl0IGlzIG9ubHkgY2FsbGVkIHdpdGggZmFsc2VcbnBwJDgucGFyc2VGdW5jdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIHN0YXRlbWVudCwgYWxsb3dFeHByZXNzaW9uQm9keSwgaXNBc3luYywgZm9ySW5pdCkge1xuICB0aGlzLmluaXRGdW5jdGlvbihub2RlKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5IHx8IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmICFpc0FzeW5jKSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zdGFyICYmIChzdGF0ZW1lbnQgJiBGVU5DX0hBTkdJTkdfU1RBVEVNRU5UKSlcbiAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICBub2RlLmdlbmVyYXRvciA9IHRoaXMuZWF0KHR5cGVzJDEuc3Rhcik7XG4gIH1cbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KVxuICAgIHsgbm9kZS5hc3luYyA9ICEhaXNBc3luYzsgfVxuXG4gIGlmIChzdGF0ZW1lbnQgJiBGVU5DX1NUQVRFTUVOVCkge1xuICAgIG5vZGUuaWQgPSAoc3RhdGVtZW50ICYgRlVOQ19OVUxMQUJMRV9JRCkgJiYgdGhpcy50eXBlICE9PSB0eXBlcyQxLm5hbWUgPyBudWxsIDogdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgaWYgKG5vZGUuaWQgJiYgIShzdGF0ZW1lbnQgJiBGVU5DX0hBTkdJTkdfU1RBVEVNRU5UKSlcbiAgICAgIC8vIElmIGl0IGlzIGEgcmVndWxhciBmdW5jdGlvbiBkZWNsYXJhdGlvbiBpbiBzbG9wcHkgbW9kZSwgdGhlbiBpdCBpc1xuICAgICAgLy8gc3ViamVjdCB0byBBbm5leCBCIHNlbWFudGljcyAoQklORF9GVU5DVElPTikuIE90aGVyd2lzZSwgdGhlIGJpbmRpbmdcbiAgICAgIC8vIG1vZGUgZGVwZW5kcyBvbiBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHNjb3BlIChzZWVcbiAgICAgIC8vIHRyZWF0RnVuY3Rpb25zQXNWYXIpLlxuICAgICAgeyB0aGlzLmNoZWNrTFZhbFNpbXBsZShub2RlLmlkLCAodGhpcy5zdHJpY3QgfHwgbm9kZS5nZW5lcmF0b3IgfHwgbm9kZS5hc3luYykgPyB0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXIgPyBCSU5EX1ZBUiA6IEJJTkRfTEVYSUNBTCA6IEJJTkRfRlVOQ1RJT04pOyB9XG4gIH1cblxuICB2YXIgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIG9sZEF3YWl0SWRlbnRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3M7XG4gIHRoaXMueWllbGRQb3MgPSAwO1xuICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgdGhpcy5hd2FpdElkZW50UG9zID0gMDtcbiAgdGhpcy5lbnRlclNjb3BlKGZ1bmN0aW9uRmxhZ3Mobm9kZS5hc3luYywgbm9kZS5nZW5lcmF0b3IpKTtcblxuICBpZiAoIShzdGF0ZW1lbnQgJiBGVU5DX1NUQVRFTUVOVCkpXG4gICAgeyBub2RlLmlkID0gdGhpcy50eXBlID09PSB0eXBlcyQxLm5hbWUgPyB0aGlzLnBhcnNlSWRlbnQoKSA6IG51bGw7IH1cblxuICB0aGlzLnBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSk7XG4gIHRoaXMucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgYWxsb3dFeHByZXNzaW9uQm9keSwgZmFsc2UsIGZvckluaXQpO1xuXG4gIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICB0aGlzLmF3YWl0SWRlbnRQb3MgPSBvbGRBd2FpdElkZW50UG9zO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIChzdGF0ZW1lbnQgJiBGVU5DX1NUQVRFTUVOVCkgPyBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiA6IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpXG59O1xuXG5wcCQ4LnBhcnNlRnVuY3Rpb25QYXJhbXMgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMuZXhwZWN0KHR5cGVzJDEucGFyZW5MKTtcbiAgbm9kZS5wYXJhbXMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QodHlwZXMkMS5wYXJlblIsIGZhbHNlLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCk7XG4gIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG59O1xuXG4vLyBQYXJzZSBhIGNsYXNzIGRlY2xhcmF0aW9uIG9yIGxpdGVyYWwgKGRlcGVuZGluZyBvbiB0aGVcbi8vIGBpc1N0YXRlbWVudGAgcGFyYW1ldGVyKS5cblxucHAkOC5wYXJzZUNsYXNzID0gZnVuY3Rpb24obm9kZSwgaXNTdGF0ZW1lbnQpIHtcbiAgdGhpcy5uZXh0KCk7XG5cbiAgLy8gZWNtYS0yNjIgMTQuNiBDbGFzcyBEZWZpbml0aW9uc1xuICAvLyBBIGNsYXNzIGRlZmluaXRpb24gaXMgYWx3YXlzIHN0cmljdCBtb2RlIGNvZGUuXG4gIHZhciBvbGRTdHJpY3QgPSB0aGlzLnN0cmljdDtcbiAgdGhpcy5zdHJpY3QgPSB0cnVlO1xuXG4gIHRoaXMucGFyc2VDbGFzc0lkKG5vZGUsIGlzU3RhdGVtZW50KTtcbiAgdGhpcy5wYXJzZUNsYXNzU3VwZXIobm9kZSk7XG4gIHZhciBwcml2YXRlTmFtZU1hcCA9IHRoaXMuZW50ZXJDbGFzc0JvZHkoKTtcbiAgdmFyIGNsYXNzQm9keSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHZhciBoYWRDb25zdHJ1Y3RvciA9IGZhbHNlO1xuICBjbGFzc0JvZHkuYm9keSA9IFtdO1xuICB0aGlzLmV4cGVjdCh0eXBlcyQxLmJyYWNlTCk7XG4gIHdoaWxlICh0aGlzLnR5cGUgIT09IHR5cGVzJDEuYnJhY2VSKSB7XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLnBhcnNlQ2xhc3NFbGVtZW50KG5vZGUuc3VwZXJDbGFzcyAhPT0gbnVsbCk7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGNsYXNzQm9keS5ib2R5LnB1c2goZWxlbWVudCk7XG4gICAgICBpZiAoZWxlbWVudC50eXBlID09PSBcIk1ldGhvZERlZmluaXRpb25cIiAmJiBlbGVtZW50LmtpbmQgPT09IFwiY29uc3RydWN0b3JcIikge1xuICAgICAgICBpZiAoaGFkQ29uc3RydWN0b3IpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGVsZW1lbnQuc3RhcnQsIFwiRHVwbGljYXRlIGNvbnN0cnVjdG9yIGluIHRoZSBzYW1lIGNsYXNzXCIpOyB9XG4gICAgICAgIGhhZENvbnN0cnVjdG9yID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5rZXkgJiYgZWxlbWVudC5rZXkudHlwZSA9PT0gXCJQcml2YXRlSWRlbnRpZmllclwiICYmIGlzUHJpdmF0ZU5hbWVDb25mbGljdGVkKHByaXZhdGVOYW1lTWFwLCBlbGVtZW50KSkge1xuICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZWxlbWVudC5rZXkuc3RhcnQsIChcIklkZW50aWZpZXIgJyNcIiArIChlbGVtZW50LmtleS5uYW1lKSArIFwiJyBoYXMgYWxyZWFkeSBiZWVuIGRlY2xhcmVkXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdGhpcy5zdHJpY3QgPSBvbGRTdHJpY3Q7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLmJvZHkgPSB0aGlzLmZpbmlzaE5vZGUoY2xhc3NCb2R5LCBcIkNsYXNzQm9keVwiKTtcbiAgdGhpcy5leGl0Q2xhc3NCb2R5KCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNTdGF0ZW1lbnQgPyBcIkNsYXNzRGVjbGFyYXRpb25cIiA6IFwiQ2xhc3NFeHByZXNzaW9uXCIpXG59O1xuXG5wcCQ4LnBhcnNlQ2xhc3NFbGVtZW50ID0gZnVuY3Rpb24oY29uc3RydWN0b3JBbGxvd3NTdXBlcikge1xuICBpZiAodGhpcy5lYXQodHlwZXMkMS5zZW1pKSkgeyByZXR1cm4gbnVsbCB9XG5cbiAgdmFyIGVjbWFWZXJzaW9uID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uO1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHZhciBrZXlOYW1lID0gXCJcIjtcbiAgdmFyIGlzR2VuZXJhdG9yID0gZmFsc2U7XG4gIHZhciBpc0FzeW5jID0gZmFsc2U7XG4gIHZhciBraW5kID0gXCJtZXRob2RcIjtcbiAgdmFyIGlzU3RhdGljID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbChcInN0YXRpY1wiKSkge1xuICAgIC8vIFBhcnNlIHN0YXRpYyBpbml0IGJsb2NrXG4gICAgaWYgKGVjbWFWZXJzaW9uID49IDEzICYmIHRoaXMuZWF0KHR5cGVzJDEuYnJhY2VMKSkge1xuICAgICAgdGhpcy5wYXJzZUNsYXNzU3RhdGljQmxvY2sobm9kZSk7XG4gICAgICByZXR1cm4gbm9kZVxuICAgIH1cbiAgICBpZiAodGhpcy5pc0NsYXNzRWxlbWVudE5hbWVTdGFydCgpIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zdGFyKSB7XG4gICAgICBpc1N0YXRpYyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleU5hbWUgPSBcInN0YXRpY1wiO1xuICAgIH1cbiAgfVxuICBub2RlLnN0YXRpYyA9IGlzU3RhdGljO1xuICBpZiAoIWtleU5hbWUgJiYgZWNtYVZlcnNpb24gPj0gOCAmJiB0aGlzLmVhdENvbnRleHR1YWwoXCJhc3luY1wiKSkge1xuICAgIGlmICgodGhpcy5pc0NsYXNzRWxlbWVudE5hbWVTdGFydCgpIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zdGFyKSAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgaXNBc3luYyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleU5hbWUgPSBcImFzeW5jXCI7XG4gICAgfVxuICB9XG4gIGlmICgha2V5TmFtZSAmJiAoZWNtYVZlcnNpb24gPj0gOSB8fCAhaXNBc3luYykgJiYgdGhpcy5lYXQodHlwZXMkMS5zdGFyKSkge1xuICAgIGlzR2VuZXJhdG9yID0gdHJ1ZTtcbiAgfVxuICBpZiAoIWtleU5hbWUgJiYgIWlzQXN5bmMgJiYgIWlzR2VuZXJhdG9yKSB7XG4gICAgdmFyIGxhc3RWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbChcImdldFwiKSB8fCB0aGlzLmVhdENvbnRleHR1YWwoXCJzZXRcIikpIHtcbiAgICAgIGlmICh0aGlzLmlzQ2xhc3NFbGVtZW50TmFtZVN0YXJ0KCkpIHtcbiAgICAgICAga2luZCA9IGxhc3RWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleU5hbWUgPSBsYXN0VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUGFyc2UgZWxlbWVudCBuYW1lXG4gIGlmIChrZXlOYW1lKSB7XG4gICAgLy8gJ2FzeW5jJywgJ2dldCcsICdzZXQnLCBvciAnc3RhdGljJyB3ZXJlIG5vdCBhIGtleXdvcmQgY29udGV4dHVhbGx5LlxuICAgIC8vIFRoZSBsYXN0IHRva2VuIGlzIGFueSBvZiB0aG9zZS4gTWFrZSBpdCB0aGUgZWxlbWVudCBuYW1lLlxuICAgIG5vZGUuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICBub2RlLmtleSA9IHRoaXMuc3RhcnROb2RlQXQodGhpcy5sYXN0VG9rU3RhcnQsIHRoaXMubGFzdFRva1N0YXJ0TG9jKTtcbiAgICBub2RlLmtleS5uYW1lID0ga2V5TmFtZTtcbiAgICB0aGlzLmZpbmlzaE5vZGUobm9kZS5rZXksIFwiSWRlbnRpZmllclwiKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnBhcnNlQ2xhc3NFbGVtZW50TmFtZShub2RlKTtcbiAgfVxuXG4gIC8vIFBhcnNlIGVsZW1lbnQgdmFsdWVcbiAgaWYgKGVjbWFWZXJzaW9uIDwgMTMgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLnBhcmVuTCB8fCBraW5kICE9PSBcIm1ldGhvZFwiIHx8IGlzR2VuZXJhdG9yIHx8IGlzQXN5bmMpIHtcbiAgICB2YXIgaXNDb25zdHJ1Y3RvciA9ICFub2RlLnN0YXRpYyAmJiBjaGVja0tleU5hbWUobm9kZSwgXCJjb25zdHJ1Y3RvclwiKTtcbiAgICB2YXIgYWxsb3dzRGlyZWN0U3VwZXIgPSBpc0NvbnN0cnVjdG9yICYmIGNvbnN0cnVjdG9yQWxsb3dzU3VwZXI7XG4gICAgLy8gQ291bGRuJ3QgbW92ZSB0aGlzIGNoZWNrIGludG8gdGhlICdwYXJzZUNsYXNzTWV0aG9kJyBtZXRob2QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gICAgaWYgKGlzQ29uc3RydWN0b3IgJiYga2luZCAhPT0gXCJtZXRob2RcIikgeyB0aGlzLnJhaXNlKG5vZGUua2V5LnN0YXJ0LCBcIkNvbnN0cnVjdG9yIGNhbid0IGhhdmUgZ2V0L3NldCBtb2RpZmllclwiKTsgfVxuICAgIG5vZGUua2luZCA9IGlzQ29uc3RydWN0b3IgPyBcImNvbnN0cnVjdG9yXCIgOiBraW5kO1xuICAgIHRoaXMucGFyc2VDbGFzc01ldGhvZChub2RlLCBpc0dlbmVyYXRvciwgaXNBc3luYywgYWxsb3dzRGlyZWN0U3VwZXIpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucGFyc2VDbGFzc0ZpZWxkKG5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGVcbn07XG5cbnBwJDguaXNDbGFzc0VsZW1lbnROYW1lU3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChcbiAgICB0aGlzLnR5cGUgPT09IHR5cGVzJDEubmFtZSB8fFxuICAgIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5wcml2YXRlSWQgfHxcbiAgICB0aGlzLnR5cGUgPT09IHR5cGVzJDEubnVtIHx8XG4gICAgdGhpcy50eXBlID09PSB0eXBlcyQxLnN0cmluZyB8fFxuICAgIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5icmFja2V0TCB8fFxuICAgIHRoaXMudHlwZS5rZXl3b3JkXG4gIClcbn07XG5cbnBwJDgucGFyc2VDbGFzc0VsZW1lbnROYW1lID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnByaXZhdGVJZCkge1xuICAgIGlmICh0aGlzLnZhbHVlID09PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgIHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJDbGFzc2VzIGNhbid0IGhhdmUgYW4gZWxlbWVudCBuYW1lZCAnI2NvbnN0cnVjdG9yJ1wiKTtcbiAgICB9XG4gICAgZWxlbWVudC5jb21wdXRlZCA9IGZhbHNlO1xuICAgIGVsZW1lbnQua2V5ID0gdGhpcy5wYXJzZVByaXZhdGVJZGVudCgpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUoZWxlbWVudCk7XG4gIH1cbn07XG5cbnBwJDgucGFyc2VDbGFzc01ldGhvZCA9IGZ1bmN0aW9uKG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGFsbG93c0RpcmVjdFN1cGVyKSB7XG4gIC8vIENoZWNrIGtleSBhbmQgZmxhZ3NcbiAgdmFyIGtleSA9IG1ldGhvZC5rZXk7XG4gIGlmIChtZXRob2Qua2luZCA9PT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgaWYgKGlzR2VuZXJhdG9yKSB7IHRoaXMucmFpc2Uoa2V5LnN0YXJ0LCBcIkNvbnN0cnVjdG9yIGNhbid0IGJlIGEgZ2VuZXJhdG9yXCIpOyB9XG4gICAgaWYgKGlzQXN5bmMpIHsgdGhpcy5yYWlzZShrZXkuc3RhcnQsIFwiQ29uc3RydWN0b3IgY2FuJ3QgYmUgYW4gYXN5bmMgbWV0aG9kXCIpOyB9XG4gIH0gZWxzZSBpZiAobWV0aG9kLnN0YXRpYyAmJiBjaGVja0tleU5hbWUobWV0aG9kLCBcInByb3RvdHlwZVwiKSkge1xuICAgIHRoaXMucmFpc2Uoa2V5LnN0YXJ0LCBcIkNsYXNzZXMgbWF5IG5vdCBoYXZlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIHByb3RvdHlwZVwiKTtcbiAgfVxuXG4gIC8vIFBhcnNlIHZhbHVlXG4gIHZhciB2YWx1ZSA9IG1ldGhvZC52YWx1ZSA9IHRoaXMucGFyc2VNZXRob2QoaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGFsbG93c0RpcmVjdFN1cGVyKTtcblxuICAvLyBDaGVjayB2YWx1ZVxuICBpZiAobWV0aG9kLmtpbmQgPT09IFwiZ2V0XCIgJiYgdmFsdWUucGFyYW1zLmxlbmd0aCAhPT0gMClcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh2YWx1ZS5zdGFydCwgXCJnZXR0ZXIgc2hvdWxkIGhhdmUgbm8gcGFyYW1zXCIpOyB9XG4gIGlmIChtZXRob2Qua2luZCA9PT0gXCJzZXRcIiAmJiB2YWx1ZS5wYXJhbXMubGVuZ3RoICE9PSAxKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHZhbHVlLnN0YXJ0LCBcInNldHRlciBzaG91bGQgaGF2ZSBleGFjdGx5IG9uZSBwYXJhbVwiKTsgfVxuICBpZiAobWV0aG9kLmtpbmQgPT09IFwic2V0XCIgJiYgdmFsdWUucGFyYW1zWzBdLnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIilcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh2YWx1ZS5wYXJhbXNbMF0uc3RhcnQsIFwiU2V0dGVyIGNhbm5vdCB1c2UgcmVzdCBwYXJhbXNcIik7IH1cblxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG1ldGhvZCwgXCJNZXRob2REZWZpbml0aW9uXCIpXG59O1xuXG5wcCQ4LnBhcnNlQ2xhc3NGaWVsZCA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gIGlmIChjaGVja0tleU5hbWUoZmllbGQsIFwiY29uc3RydWN0b3JcIikpIHtcbiAgICB0aGlzLnJhaXNlKGZpZWxkLmtleS5zdGFydCwgXCJDbGFzc2VzIGNhbid0IGhhdmUgYSBmaWVsZCBuYW1lZCAnY29uc3RydWN0b3InXCIpO1xuICB9IGVsc2UgaWYgKGZpZWxkLnN0YXRpYyAmJiBjaGVja0tleU5hbWUoZmllbGQsIFwicHJvdG90eXBlXCIpKSB7XG4gICAgdGhpcy5yYWlzZShmaWVsZC5rZXkuc3RhcnQsIFwiQ2xhc3NlcyBjYW4ndCBoYXZlIGEgc3RhdGljIGZpZWxkIG5hbWVkICdwcm90b3R5cGUnXCIpO1xuICB9XG5cbiAgaWYgKHRoaXMuZWF0KHR5cGVzJDEuZXEpKSB7XG4gICAgLy8gVG8gcmFpc2UgU3ludGF4RXJyb3IgaWYgJ2FyZ3VtZW50cycgZXhpc3RzIGluIHRoZSBpbml0aWFsaXplci5cbiAgICB0aGlzLmVudGVyU2NvcGUoU0NPUEVfQ0xBU1NfRklFTERfSU5JVCB8IFNDT1BFX1NVUEVSKTtcbiAgICBmaWVsZC52YWx1ZSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgIHRoaXMuZXhpdFNjb3BlKCk7XG4gIH0gZWxzZSB7XG4gICAgZmllbGQudmFsdWUgPSBudWxsO1xuICB9XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG5cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShmaWVsZCwgXCJQcm9wZXJ0eURlZmluaXRpb25cIilcbn07XG5cbnBwJDgucGFyc2VDbGFzc1N0YXRpY0Jsb2NrID0gZnVuY3Rpb24obm9kZSkge1xuICBub2RlLmJvZHkgPSBbXTtcblxuICB2YXIgb2xkTGFiZWxzID0gdGhpcy5sYWJlbHM7XG4gIHRoaXMubGFiZWxzID0gW107XG4gIHRoaXMuZW50ZXJTY29wZShTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0sgfCBTQ09QRV9TVVBFUik7XG4gIHdoaWxlICh0aGlzLnR5cGUgIT09IHR5cGVzJDEuYnJhY2VSKSB7XG4gICAgdmFyIHN0bXQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KG51bGwpO1xuICAgIG5vZGUuYm9keS5wdXNoKHN0bXQpO1xuICB9XG4gIHRoaXMubmV4dCgpO1xuICB0aGlzLmV4aXRTY29wZSgpO1xuICB0aGlzLmxhYmVscyA9IG9sZExhYmVscztcblxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3RhdGljQmxvY2tcIilcbn07XG5cbnBwJDgucGFyc2VDbGFzc0lkID0gZnVuY3Rpb24obm9kZSwgaXNTdGF0ZW1lbnQpIHtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5uYW1lKSB7XG4gICAgbm9kZS5pZCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgIGlmIChpc1N0YXRlbWVudClcbiAgICAgIHsgdGhpcy5jaGVja0xWYWxTaW1wbGUobm9kZS5pZCwgQklORF9MRVhJQ0FMLCBmYWxzZSk7IH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNTdGF0ZW1lbnQgPT09IHRydWUpXG4gICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgbm9kZS5pZCA9IG51bGw7XG4gIH1cbn07XG5cbnBwJDgucGFyc2VDbGFzc1N1cGVyID0gZnVuY3Rpb24obm9kZSkge1xuICBub2RlLnN1cGVyQ2xhc3MgPSB0aGlzLmVhdCh0eXBlcyQxLl9leHRlbmRzKSA/IHRoaXMucGFyc2VFeHByU3Vic2NyaXB0cyhudWxsLCBmYWxzZSkgOiBudWxsO1xufTtcblxucHAkOC5lbnRlckNsYXNzQm9keSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZWxlbWVudCA9IHtkZWNsYXJlZDogT2JqZWN0LmNyZWF0ZShudWxsKSwgdXNlZDogW119O1xuICB0aGlzLnByaXZhdGVOYW1lU3RhY2sucHVzaChlbGVtZW50KTtcbiAgcmV0dXJuIGVsZW1lbnQuZGVjbGFyZWRcbn07XG5cbnBwJDguZXhpdENsYXNzQm9keSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVmID0gdGhpcy5wcml2YXRlTmFtZVN0YWNrLnBvcCgpO1xuICB2YXIgZGVjbGFyZWQgPSByZWYuZGVjbGFyZWQ7XG4gIHZhciB1c2VkID0gcmVmLnVzZWQ7XG4gIGlmICghdGhpcy5vcHRpb25zLmNoZWNrUHJpdmF0ZUZpZWxkcykgeyByZXR1cm4gfVxuICB2YXIgbGVuID0gdGhpcy5wcml2YXRlTmFtZVN0YWNrLmxlbmd0aDtcbiAgdmFyIHBhcmVudCA9IGxlbiA9PT0gMCA/IG51bGwgOiB0aGlzLnByaXZhdGVOYW1lU3RhY2tbbGVuIC0gMV07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdXNlZC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBpZCA9IHVzZWRbaV07XG4gICAgaWYgKCFoYXNPd24oZGVjbGFyZWQsIGlkLm5hbWUpKSB7XG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHBhcmVudC51c2VkLnB1c2goaWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGlkLnN0YXJ0LCAoXCJQcml2YXRlIGZpZWxkICcjXCIgKyAoaWQubmFtZSkgKyBcIicgbXVzdCBiZSBkZWNsYXJlZCBpbiBhbiBlbmNsb3NpbmcgY2xhc3NcIikpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gaXNQcml2YXRlTmFtZUNvbmZsaWN0ZWQocHJpdmF0ZU5hbWVNYXAsIGVsZW1lbnQpIHtcbiAgdmFyIG5hbWUgPSBlbGVtZW50LmtleS5uYW1lO1xuICB2YXIgY3VyciA9IHByaXZhdGVOYW1lTWFwW25hbWVdO1xuXG4gIHZhciBuZXh0ID0gXCJ0cnVlXCI7XG4gIGlmIChlbGVtZW50LnR5cGUgPT09IFwiTWV0aG9kRGVmaW5pdGlvblwiICYmIChlbGVtZW50LmtpbmQgPT09IFwiZ2V0XCIgfHwgZWxlbWVudC5raW5kID09PSBcInNldFwiKSkge1xuICAgIG5leHQgPSAoZWxlbWVudC5zdGF0aWMgPyBcInNcIiA6IFwiaVwiKSArIGVsZW1lbnQua2luZDtcbiAgfVxuXG4gIC8vIGBjbGFzcyB7IGdldCAjYSgpe307IHN0YXRpYyBzZXQgI2EoXyl7fSB9YCBpcyBhbHNvIGNvbmZsaWN0LlxuICBpZiAoXG4gICAgY3VyciA9PT0gXCJpZ2V0XCIgJiYgbmV4dCA9PT0gXCJpc2V0XCIgfHxcbiAgICBjdXJyID09PSBcImlzZXRcIiAmJiBuZXh0ID09PSBcImlnZXRcIiB8fFxuICAgIGN1cnIgPT09IFwic2dldFwiICYmIG5leHQgPT09IFwic3NldFwiIHx8XG4gICAgY3VyciA9PT0gXCJzc2V0XCIgJiYgbmV4dCA9PT0gXCJzZ2V0XCJcbiAgKSB7XG4gICAgcHJpdmF0ZU5hbWVNYXBbbmFtZV0gPSBcInRydWVcIjtcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmICghY3Vycikge1xuICAgIHByaXZhdGVOYW1lTWFwW25hbWVdID0gbmV4dDtcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrS2V5TmFtZShub2RlLCBuYW1lKSB7XG4gIHZhciBjb21wdXRlZCA9IG5vZGUuY29tcHV0ZWQ7XG4gIHZhciBrZXkgPSBub2RlLmtleTtcbiAgcmV0dXJuICFjb21wdXRlZCAmJiAoXG4gICAga2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGtleS5uYW1lID09PSBuYW1lIHx8XG4gICAga2V5LnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmIGtleS52YWx1ZSA9PT0gbmFtZVxuICApXG59XG5cbi8vIFBhcnNlcyBtb2R1bGUgZXhwb3J0IGRlY2xhcmF0aW9uLlxuXG5wcCQ4LnBhcnNlRXhwb3J0QWxsRGVjbGFyYXRpb24gPSBmdW5jdGlvbihub2RlLCBleHBvcnRzKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTEpIHtcbiAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKFwiYXNcIikpIHtcbiAgICAgIG5vZGUuZXhwb3J0ZWQgPSB0aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpO1xuICAgICAgdGhpcy5jaGVja0V4cG9ydChleHBvcnRzLCBub2RlLmV4cG9ydGVkLCB0aGlzLmxhc3RUb2tTdGFydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuZXhwb3J0ZWQgPSBudWxsO1xuICAgIH1cbiAgfVxuICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJmcm9tXCIpO1xuICBpZiAodGhpcy50eXBlICE9PSB0eXBlcyQxLnN0cmluZykgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDE2KVxuICAgIHsgbm9kZS5hdHRyaWJ1dGVzID0gdGhpcy5wYXJzZVdpdGhDbGF1c2UoKTsgfVxuICB0aGlzLnNlbWljb2xvbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIilcbn07XG5cbnBwJDgucGFyc2VFeHBvcnQgPSBmdW5jdGlvbihub2RlLCBleHBvcnRzKSB7XG4gIHRoaXMubmV4dCgpO1xuICAvLyBleHBvcnQgKiBmcm9tICcuLi4nXG4gIGlmICh0aGlzLmVhdCh0eXBlcyQxLnN0YXIpKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VFeHBvcnRBbGxEZWNsYXJhdGlvbihub2RlLCBleHBvcnRzKVxuICB9XG4gIGlmICh0aGlzLmVhdCh0eXBlcyQxLl9kZWZhdWx0KSkgeyAvLyBleHBvcnQgZGVmYXVsdCAuLi5cbiAgICB0aGlzLmNoZWNrRXhwb3J0KGV4cG9ydHMsIFwiZGVmYXVsdFwiLCB0aGlzLmxhc3RUb2tTdGFydCk7XG4gICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIpXG4gIH1cbiAgLy8gZXhwb3J0IHZhcnxjb25zdHxsZXR8ZnVuY3Rpb258Y2xhc3MgLi4uXG4gIGlmICh0aGlzLnNob3VsZFBhcnNlRXhwb3J0U3RhdGVtZW50KCkpIHtcbiAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUpO1xuICAgIGlmIChub2RlLmRlY2xhcmF0aW9uLnR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKVxuICAgICAgeyB0aGlzLmNoZWNrVmFyaWFibGVFeHBvcnQoZXhwb3J0cywgbm9kZS5kZWNsYXJhdGlvbi5kZWNsYXJhdGlvbnMpOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLmNoZWNrRXhwb3J0KGV4cG9ydHMsIG5vZGUuZGVjbGFyYXRpb24uaWQsIG5vZGUuZGVjbGFyYXRpb24uaWQuc3RhcnQpOyB9XG4gICAgbm9kZS5zcGVjaWZpZXJzID0gW107XG4gICAgbm9kZS5zb3VyY2UgPSBudWxsO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTYpXG4gICAgICB7IG5vZGUuYXR0cmlidXRlcyA9IFtdOyB9XG4gIH0gZWxzZSB7IC8vIGV4cG9ydCB7IHgsIHkgYXMgeiB9IFtmcm9tICcuLi4nXVxuICAgIG5vZGUuZGVjbGFyYXRpb24gPSBudWxsO1xuICAgIG5vZGUuc3BlY2lmaWVycyA9IHRoaXMucGFyc2VFeHBvcnRTcGVjaWZpZXJzKGV4cG9ydHMpO1xuICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoXCJmcm9tXCIpKSB7XG4gICAgICBpZiAodGhpcy50eXBlICE9PSB0eXBlcyQxLnN0cmluZykgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTYpXG4gICAgICAgIHsgbm9kZS5hdHRyaWJ1dGVzID0gdGhpcy5wYXJzZVdpdGhDbGF1c2UoKTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG5vZGUuc3BlY2lmaWVyczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgLy8gY2hlY2sgZm9yIGtleXdvcmRzIHVzZWQgYXMgbG9jYWwgbmFtZXNcbiAgICAgICAgdmFyIHNwZWMgPSBsaXN0W2ldO1xuXG4gICAgICAgIHRoaXMuY2hlY2tVbnJlc2VydmVkKHNwZWMubG9jYWwpO1xuICAgICAgICAvLyBjaGVjayBpZiBleHBvcnQgaXMgZGVmaW5lZFxuICAgICAgICB0aGlzLmNoZWNrTG9jYWxFeHBvcnQoc3BlYy5sb2NhbCk7XG5cbiAgICAgICAgaWYgKHNwZWMubG9jYWwudHlwZSA9PT0gXCJMaXRlcmFsXCIpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKHNwZWMubG9jYWwuc3RhcnQsIFwiQSBzdHJpbmcgbGl0ZXJhbCBjYW5ub3QgYmUgdXNlZCBhcyBhbiBleHBvcnRlZCBiaW5kaW5nIHdpdGhvdXQgYGZyb21gLlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBub2RlLnNvdXJjZSA9IG51bGw7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDE2KVxuICAgICAgICB7IG5vZGUuYXR0cmlidXRlcyA9IFtdOyB9XG4gICAgfVxuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIilcbn07XG5cbnBwJDgucGFyc2VFeHBvcnREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgcmV0dXJuIHRoaXMucGFyc2VTdGF0ZW1lbnQobnVsbClcbn07XG5cbnBwJDgucGFyc2VFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGlzQXN5bmM7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2Z1bmN0aW9uIHx8IChpc0FzeW5jID0gdGhpcy5pc0FzeW5jRnVuY3Rpb24oKSkpIHtcbiAgICB2YXIgZk5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmIChpc0FzeW5jKSB7IHRoaXMubmV4dCgpOyB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihmTm9kZSwgRlVOQ19TVEFURU1FTlQgfCBGVU5DX05VTExBQkxFX0lELCBmYWxzZSwgaXNBc3luYylcbiAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2NsYXNzKSB7XG4gICAgdmFyIGNOb2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKGNOb2RlLCBcIm51bGxhYmxlSURcIilcbiAgfSBlbHNlIHtcbiAgICB2YXIgZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiBkZWNsYXJhdGlvblxuICB9XG59O1xuXG5wcCQ4LmNoZWNrRXhwb3J0ID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgcG9zKSB7XG4gIGlmICghZXhwb3J0cykgeyByZXR1cm4gfVxuICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIpXG4gICAgeyBuYW1lID0gbmFtZS50eXBlID09PSBcIklkZW50aWZpZXJcIiA/IG5hbWUubmFtZSA6IG5hbWUudmFsdWU7IH1cbiAgaWYgKGhhc093bihleHBvcnRzLCBuYW1lKSlcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShwb3MsIFwiRHVwbGljYXRlIGV4cG9ydCAnXCIgKyBuYW1lICsgXCInXCIpOyB9XG4gIGV4cG9ydHNbbmFtZV0gPSB0cnVlO1xufTtcblxucHAkOC5jaGVja1BhdHRlcm5FeHBvcnQgPSBmdW5jdGlvbihleHBvcnRzLCBwYXQpIHtcbiAgdmFyIHR5cGUgPSBwYXQudHlwZTtcbiAgaWYgKHR5cGUgPT09IFwiSWRlbnRpZmllclwiKVxuICAgIHsgdGhpcy5jaGVja0V4cG9ydChleHBvcnRzLCBwYXQsIHBhdC5zdGFydCk7IH1cbiAgZWxzZSBpZiAodHlwZSA9PT0gXCJPYmplY3RQYXR0ZXJuXCIpXG4gICAgeyBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHBhdC5wcm9wZXJ0aWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgIHtcbiAgICAgICAgdmFyIHByb3AgPSBsaXN0W2ldO1xuXG4gICAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHByb3ApO1xuICAgICAgfSB9XG4gIGVsc2UgaWYgKHR5cGUgPT09IFwiQXJyYXlQYXR0ZXJuXCIpXG4gICAgeyBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSBwYXQuZWxlbWVudHM7IGkkMSA8IGxpc3QkMS5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICB2YXIgZWx0ID0gbGlzdCQxW2kkMV07XG5cbiAgICAgICAgaWYgKGVsdCkgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBlbHQpOyB9XG4gICAgfSB9XG4gIGVsc2UgaWYgKHR5cGUgPT09IFwiUHJvcGVydHlcIilcbiAgICB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHBhdC52YWx1ZSk7IH1cbiAgZWxzZSBpZiAodHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiKVxuICAgIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcGF0LmxlZnQpOyB9XG4gIGVsc2UgaWYgKHR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIilcbiAgICB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHBhdC5hcmd1bWVudCk7IH1cbn07XG5cbnBwJDguY2hlY2tWYXJpYWJsZUV4cG9ydCA9IGZ1bmN0aW9uKGV4cG9ydHMsIGRlY2xzKSB7XG4gIGlmICghZXhwb3J0cykgeyByZXR1cm4gfVxuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGRlY2xzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICB7XG4gICAgdmFyIGRlY2wgPSBsaXN0W2ldO1xuXG4gICAgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgZGVjbC5pZCk7XG4gIH1cbn07XG5cbnBwJDguc2hvdWxkUGFyc2VFeHBvcnRTdGF0ZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudHlwZS5rZXl3b3JkID09PSBcInZhclwiIHx8XG4gICAgdGhpcy50eXBlLmtleXdvcmQgPT09IFwiY29uc3RcIiB8fFxuICAgIHRoaXMudHlwZS5rZXl3b3JkID09PSBcImNsYXNzXCIgfHxcbiAgICB0aGlzLnR5cGUua2V5d29yZCA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgdGhpcy5pc0xldCgpIHx8XG4gICAgdGhpcy5pc0FzeW5jRnVuY3Rpb24oKVxufTtcblxuLy8gUGFyc2VzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgbW9kdWxlIGV4cG9ydHMuXG5cbnBwJDgucGFyc2VFeHBvcnRTcGVjaWZpZXIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgbm9kZS5sb2NhbCA9IHRoaXMucGFyc2VNb2R1bGVFeHBvcnROYW1lKCk7XG5cbiAgbm9kZS5leHBvcnRlZCA9IHRoaXMuZWF0Q29udGV4dHVhbChcImFzXCIpID8gdGhpcy5wYXJzZU1vZHVsZUV4cG9ydE5hbWUoKSA6IG5vZGUubG9jYWw7XG4gIHRoaXMuY2hlY2tFeHBvcnQoXG4gICAgZXhwb3J0cyxcbiAgICBub2RlLmV4cG9ydGVkLFxuICAgIG5vZGUuZXhwb3J0ZWQuc3RhcnRcbiAgKTtcblxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0U3BlY2lmaWVyXCIpXG59O1xuXG5wcCQ4LnBhcnNlRXhwb3J0U3BlY2lmaWVycyA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiAgdmFyIG5vZGVzID0gW10sIGZpcnN0ID0gdHJ1ZTtcbiAgLy8gZXhwb3J0IHsgeCwgeSBhcyB6IH0gW2Zyb20gJy4uLiddXG4gIHRoaXMuZXhwZWN0KHR5cGVzJDEuYnJhY2VMKTtcbiAgd2hpbGUgKCF0aGlzLmVhdCh0eXBlcyQxLmJyYWNlUikpIHtcbiAgICBpZiAoIWZpcnN0KSB7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmNvbW1hKTtcbiAgICAgIGlmICh0aGlzLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcyQxLmJyYWNlUikpIHsgYnJlYWsgfVxuICAgIH0gZWxzZSB7IGZpcnN0ID0gZmFsc2U7IH1cblxuICAgIG5vZGVzLnB1c2godGhpcy5wYXJzZUV4cG9ydFNwZWNpZmllcihleHBvcnRzKSk7XG4gIH1cbiAgcmV0dXJuIG5vZGVzXG59O1xuXG4vLyBQYXJzZXMgaW1wb3J0IGRlY2xhcmF0aW9uLlxuXG5wcCQ4LnBhcnNlSW1wb3J0ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcblxuICAvLyBpbXBvcnQgJy4uLidcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zdHJpbmcpIHtcbiAgICBub2RlLnNwZWNpZmllcnMgPSBlbXB0eSQxO1xuICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZUV4cHJBdG9tKCk7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5zcGVjaWZpZXJzID0gdGhpcy5wYXJzZUltcG9ydFNwZWNpZmllcnMoKTtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJmcm9tXCIpO1xuICAgIG5vZGUuc291cmNlID0gdGhpcy50eXBlID09PSB0eXBlcyQxLnN0cmluZyA/IHRoaXMucGFyc2VFeHByQXRvbSgpIDogdGhpcy51bmV4cGVjdGVkKCk7XG4gIH1cbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxNilcbiAgICB7IG5vZGUuYXR0cmlidXRlcyA9IHRoaXMucGFyc2VXaXRoQ2xhdXNlKCk7IH1cbiAgdGhpcy5zZW1pY29sb24oKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydERlY2xhcmF0aW9uXCIpXG59O1xuXG4vLyBQYXJzZXMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBtb2R1bGUgaW1wb3J0cy5cblxucHAkOC5wYXJzZUltcG9ydFNwZWNpZmllciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIG5vZGUuaW1wb3J0ZWQgPSB0aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpO1xuXG4gIGlmICh0aGlzLmVhdENvbnRleHR1YWwoXCJhc1wiKSkge1xuICAgIG5vZGUubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmNoZWNrVW5yZXNlcnZlZChub2RlLmltcG9ydGVkKTtcbiAgICBub2RlLmxvY2FsID0gbm9kZS5pbXBvcnRlZDtcbiAgfVxuICB0aGlzLmNoZWNrTFZhbFNpbXBsZShub2RlLmxvY2FsLCBCSU5EX0xFWElDQUwpO1xuXG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnRTcGVjaWZpZXJcIilcbn07XG5cbnBwJDgucGFyc2VJbXBvcnREZWZhdWx0U3BlY2lmaWVyID0gZnVuY3Rpb24oKSB7XG4gIC8vIGltcG9ydCBkZWZhdWx0T2JqLCB7IHgsIHkgYXMgeiB9IGZyb20gJy4uLidcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICBub2RlLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gIHRoaXMuY2hlY2tMVmFsU2ltcGxlKG5vZGUubG9jYWwsIEJJTkRfTEVYSUNBTCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIpXG59O1xuXG5wcCQ4LnBhcnNlSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0KCk7XG4gIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImFzXCIpO1xuICBub2RlLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gIHRoaXMuY2hlY2tMVmFsU2ltcGxlKG5vZGUubG9jYWwsIEJJTkRfTEVYSUNBTCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIilcbn07XG5cbnBwJDgucGFyc2VJbXBvcnRTcGVjaWZpZXJzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBub2RlcyA9IFtdLCBmaXJzdCA9IHRydWU7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEubmFtZSkge1xuICAgIG5vZGVzLnB1c2godGhpcy5wYXJzZUltcG9ydERlZmF1bHRTcGVjaWZpZXIoKSk7XG4gICAgaWYgKCF0aGlzLmVhdCh0eXBlcyQxLmNvbW1hKSkgeyByZXR1cm4gbm9kZXMgfVxuICB9XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuc3Rhcikge1xuICAgIG5vZGVzLnB1c2godGhpcy5wYXJzZUltcG9ydE5hbWVzcGFjZVNwZWNpZmllcigpKTtcbiAgICByZXR1cm4gbm9kZXNcbiAgfVxuICB0aGlzLmV4cGVjdCh0eXBlcyQxLmJyYWNlTCk7XG4gIHdoaWxlICghdGhpcy5lYXQodHlwZXMkMS5icmFjZVIpKSB7XG4gICAgaWYgKCFmaXJzdCkge1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMkMS5jb21tYSk7XG4gICAgICBpZiAodGhpcy5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMkMS5icmFjZVIpKSB7IGJyZWFrIH1cbiAgICB9IGVsc2UgeyBmaXJzdCA9IGZhbHNlOyB9XG5cbiAgICBub2Rlcy5wdXNoKHRoaXMucGFyc2VJbXBvcnRTcGVjaWZpZXIoKSk7XG4gIH1cbiAgcmV0dXJuIG5vZGVzXG59O1xuXG5wcCQ4LnBhcnNlV2l0aENsYXVzZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZXMgPSBbXTtcbiAgaWYgKCF0aGlzLmVhdCh0eXBlcyQxLl93aXRoKSkge1xuICAgIHJldHVybiBub2Rlc1xuICB9XG4gIHRoaXMuZXhwZWN0KHR5cGVzJDEuYnJhY2VMKTtcbiAgdmFyIGF0dHJpYnV0ZUtleXMgPSB7fTtcbiAgdmFyIGZpcnN0ID0gdHJ1ZTtcbiAgd2hpbGUgKCF0aGlzLmVhdCh0eXBlcyQxLmJyYWNlUikpIHtcbiAgICBpZiAoIWZpcnN0KSB7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmNvbW1hKTtcbiAgICAgIGlmICh0aGlzLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcyQxLmJyYWNlUikpIHsgYnJlYWsgfVxuICAgIH0gZWxzZSB7IGZpcnN0ID0gZmFsc2U7IH1cblxuICAgIHZhciBhdHRyID0gdGhpcy5wYXJzZUltcG9ydEF0dHJpYnV0ZSgpO1xuICAgIHZhciBrZXlOYW1lID0gYXR0ci5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgPyBhdHRyLmtleS5uYW1lIDogYXR0ci5rZXkudmFsdWU7XG4gICAgaWYgKGhhc093bihhdHRyaWJ1dGVLZXlzLCBrZXlOYW1lKSlcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGF0dHIua2V5LnN0YXJ0LCBcIkR1cGxpY2F0ZSBhdHRyaWJ1dGUga2V5ICdcIiArIGtleU5hbWUgKyBcIidcIik7IH1cbiAgICBhdHRyaWJ1dGVLZXlzW2tleU5hbWVdID0gdHJ1ZTtcbiAgICBub2Rlcy5wdXNoKGF0dHIpO1xuICB9XG4gIHJldHVybiBub2Rlc1xufTtcblxucHAkOC5wYXJzZUltcG9ydEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIG5vZGUua2V5ID0gdGhpcy50eXBlID09PSB0eXBlcyQxLnN0cmluZyA/IHRoaXMucGFyc2VFeHByQXRvbSgpIDogdGhpcy5wYXJzZUlkZW50KHRoaXMub3B0aW9ucy5hbGxvd1Jlc2VydmVkICE9PSBcIm5ldmVyXCIpO1xuICB0aGlzLmV4cGVjdCh0eXBlcyQxLmNvbG9uKTtcbiAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5zdHJpbmcpIHtcbiAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxuICBub2RlLnZhbHVlID0gdGhpcy5wYXJzZUV4cHJBdG9tKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnRBdHRyaWJ1dGVcIilcbn07XG5cbnBwJDgucGFyc2VNb2R1bGVFeHBvcnROYW1lID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTMgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLnN0cmluZykge1xuICAgIHZhciBzdHJpbmdMaXRlcmFsID0gdGhpcy5wYXJzZUxpdGVyYWwodGhpcy52YWx1ZSk7XG4gICAgaWYgKGxvbmVTdXJyb2dhdGUudGVzdChzdHJpbmdMaXRlcmFsLnZhbHVlKSkge1xuICAgICAgdGhpcy5yYWlzZShzdHJpbmdMaXRlcmFsLnN0YXJ0LCBcIkFuIGV4cG9ydCBuYW1lIGNhbm5vdCBpbmNsdWRlIGEgbG9uZSBzdXJyb2dhdGUuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nTGl0ZXJhbFxuICB9XG4gIHJldHVybiB0aGlzLnBhcnNlSWRlbnQodHJ1ZSlcbn07XG5cbi8vIFNldCBgRXhwcmVzc2lvblN0YXRlbWVudCNkaXJlY3RpdmVgIHByb3BlcnR5IGZvciBkaXJlY3RpdmUgcHJvbG9ndWVzLlxucHAkOC5hZGFwdERpcmVjdGl2ZVByb2xvZ3VlID0gZnVuY3Rpb24oc3RhdGVtZW50cykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlbWVudHMubGVuZ3RoICYmIHRoaXMuaXNEaXJlY3RpdmVDYW5kaWRhdGUoc3RhdGVtZW50c1tpXSk7ICsraSkge1xuICAgIHN0YXRlbWVudHNbaV0uZGlyZWN0aXZlID0gc3RhdGVtZW50c1tpXS5leHByZXNzaW9uLnJhdy5zbGljZSgxLCAtMSk7XG4gIH1cbn07XG5wcCQ4LmlzRGlyZWN0aXZlQ2FuZGlkYXRlID0gZnVuY3Rpb24oc3RhdGVtZW50KSB7XG4gIHJldHVybiAoXG4gICAgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDUgJiZcbiAgICBzdGF0ZW1lbnQudHlwZSA9PT0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCIgJiZcbiAgICBzdGF0ZW1lbnQuZXhwcmVzc2lvbi50eXBlID09PSBcIkxpdGVyYWxcIiAmJlxuICAgIHR5cGVvZiBzdGF0ZW1lbnQuZXhwcmVzc2lvbi52YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgIC8vIFJlamVjdCBwYXJlbnRoZXNpemVkIHN0cmluZ3MuXG4gICAgKHRoaXMuaW5wdXRbc3RhdGVtZW50LnN0YXJ0XSA9PT0gXCJcXFwiXCIgfHwgdGhpcy5pbnB1dFtzdGF0ZW1lbnQuc3RhcnRdID09PSBcIidcIilcbiAgKVxufTtcblxudmFyIHBwJDcgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4vLyBDb252ZXJ0IGV4aXN0aW5nIGV4cHJlc3Npb24gYXRvbSB0byBhc3NpZ25hYmxlIHBhdHRlcm5cbi8vIGlmIHBvc3NpYmxlLlxuXG5wcCQ3LnRvQXNzaWduYWJsZSA9IGZ1bmN0aW9uKG5vZGUsIGlzQmluZGluZywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgbm9kZSkge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICAgIGlmICh0aGlzLmluQXN5bmMgJiYgbm9kZS5uYW1lID09PSBcImF3YWl0XCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIkNhbm5vdCB1c2UgJ2F3YWl0JyBhcyBpZGVudGlmaWVyIGluc2lkZSBhbiBhc3luYyBmdW5jdGlvblwiKTsgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgIGNhc2UgXCJSZXN0RWxlbWVudFwiOlxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJPYmplY3RFeHByZXNzaW9uXCI6XG4gICAgICBub2RlLnR5cGUgPSBcIk9iamVjdFBhdHRlcm5cIjtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpOyB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG5vZGUucHJvcGVydGllczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHByb3AgPSBsaXN0W2ldO1xuXG4gICAgICB0aGlzLnRvQXNzaWduYWJsZShwcm9wLCBpc0JpbmRpbmcpO1xuICAgICAgICAvLyBFYXJseSBlcnJvcjpcbiAgICAgICAgLy8gICBBc3NpZ25tZW50UmVzdFByb3BlcnR5W1lpZWxkLCBBd2FpdF0gOlxuICAgICAgICAvLyAgICAgYC4uLmAgRGVzdHJ1Y3R1cmluZ0Fzc2lnbm1lbnRUYXJnZXRbWWllbGQsIEF3YWl0XVxuICAgICAgICAvL1xuICAgICAgICAvLyAgIEl0IGlzIGEgU3ludGF4IEVycm9yIGlmIHxEZXN0cnVjdHVyaW5nQXNzaWdubWVudFRhcmdldHwgaXMgYW4gfEFycmF5TGl0ZXJhbHwgb3IgYW4gfE9iamVjdExpdGVyYWx8LlxuICAgICAgICBpZiAoXG4gICAgICAgICAgcHJvcC50eXBlID09PSBcIlJlc3RFbGVtZW50XCIgJiZcbiAgICAgICAgICAocHJvcC5hcmd1bWVudC50eXBlID09PSBcIkFycmF5UGF0dGVyblwiIHx8IHByb3AuYXJndW1lbnQudHlwZSA9PT0gXCJPYmplY3RQYXR0ZXJuXCIpXG4gICAgICAgICkge1xuICAgICAgICAgIHRoaXMucmFpc2UocHJvcC5hcmd1bWVudC5zdGFydCwgXCJVbmV4cGVjdGVkIHRva2VuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIlByb3BlcnR5XCI6XG4gICAgICAvLyBBc3NpZ25tZW50UHJvcGVydHkgaGFzIHR5cGUgPT09IFwiUHJvcGVydHlcIlxuICAgICAgaWYgKG5vZGUua2luZCAhPT0gXCJpbml0XCIpIHsgdGhpcy5yYWlzZShub2RlLmtleS5zdGFydCwgXCJPYmplY3QgcGF0dGVybiBjYW4ndCBjb250YWluIGdldHRlciBvciBzZXR0ZXJcIik7IH1cbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUudmFsdWUsIGlzQmluZGluZyk7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIkFycmF5RXhwcmVzc2lvblwiOlxuICAgICAgbm9kZS50eXBlID0gXCJBcnJheVBhdHRlcm5cIjtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpOyB9XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZUxpc3Qobm9kZS5lbGVtZW50cywgaXNCaW5kaW5nKTtcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiU3ByZWFkRWxlbWVudFwiOlxuICAgICAgbm9kZS50eXBlID0gXCJSZXN0RWxlbWVudFwiO1xuICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS5hcmd1bWVudCwgaXNCaW5kaW5nKTtcbiAgICAgIGlmIChub2RlLmFyZ3VtZW50LnR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIilcbiAgICAgICAgeyB0aGlzLnJhaXNlKG5vZGUuYXJndW1lbnQuc3RhcnQsIFwiUmVzdCBlbGVtZW50cyBjYW5ub3QgaGF2ZSBhIGRlZmF1bHQgdmFsdWVcIik7IH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgIGlmIChub2RlLm9wZXJhdG9yICE9PSBcIj1cIikgeyB0aGlzLnJhaXNlKG5vZGUubGVmdC5lbmQsIFwiT25seSAnPScgb3BlcmF0b3IgY2FuIGJlIHVzZWQgZm9yIHNwZWNpZnlpbmcgZGVmYXVsdCB2YWx1ZS5cIik7IH1cbiAgICAgIG5vZGUudHlwZSA9IFwiQXNzaWdubWVudFBhdHRlcm5cIjtcbiAgICAgIGRlbGV0ZSBub2RlLm9wZXJhdG9yO1xuICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS5sZWZ0LCBpc0JpbmRpbmcpO1xuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS5leHByZXNzaW9uLCBpc0JpbmRpbmcsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJDaGFpbkV4cHJlc3Npb25cIjpcbiAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIk9wdGlvbmFsIGNoYWluaW5nIGNhbm5vdCBhcHBlYXIgaW4gbGVmdC1oYW5kIHNpZGVcIik7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgIGlmICghaXNCaW5kaW5nKSB7IGJyZWFrIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiQXNzaWduaW5nIHRvIHJ2YWx1ZVwiKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTsgfVxuICByZXR1cm4gbm9kZVxufTtcblxuLy8gQ29udmVydCBsaXN0IG9mIGV4cHJlc3Npb24gYXRvbXMgdG8gYmluZGluZyBsaXN0LlxuXG5wcCQ3LnRvQXNzaWduYWJsZUxpc3QgPSBmdW5jdGlvbihleHByTGlzdCwgaXNCaW5kaW5nKSB7XG4gIHZhciBlbmQgPSBleHByTGlzdC5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZW5kOyBpKyspIHtcbiAgICB2YXIgZWx0ID0gZXhwckxpc3RbaV07XG4gICAgaWYgKGVsdCkgeyB0aGlzLnRvQXNzaWduYWJsZShlbHQsIGlzQmluZGluZyk7IH1cbiAgfVxuICBpZiAoZW5kKSB7XG4gICAgdmFyIGxhc3QgPSBleHByTGlzdFtlbmQgLSAxXTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID09PSA2ICYmIGlzQmluZGluZyAmJiBsYXN0ICYmIGxhc3QudHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiICYmIGxhc3QuYXJndW1lbnQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIpXG4gICAgICB7IHRoaXMudW5leHBlY3RlZChsYXN0LmFyZ3VtZW50LnN0YXJ0KTsgfVxuICB9XG4gIHJldHVybiBleHByTGlzdFxufTtcblxuLy8gUGFyc2VzIHNwcmVhZCBlbGVtZW50LlxuXG5wcCQ3LnBhcnNlU3ByZWFkID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlNwcmVhZEVsZW1lbnRcIilcbn07XG5cbnBwJDcucGFyc2VSZXN0QmluZGluZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dCgpO1xuXG4gIC8vIFJlc3RFbGVtZW50IGluc2lkZSBvZiBhIGZ1bmN0aW9uIHBhcmFtZXRlciBtdXN0IGJlIGFuIGlkZW50aWZpZXJcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gNiAmJiB0aGlzLnR5cGUgIT09IHR5cGVzJDEubmFtZSlcbiAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG5cbiAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuXG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJSZXN0RWxlbWVudFwiKVxufTtcblxuLy8gUGFyc2VzIGx2YWx1ZSAoYXNzaWduYWJsZSkgYXRvbS5cblxucHAkNy5wYXJzZUJpbmRpbmdBdG9tID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgY2FzZSB0eXBlcyQxLmJyYWNrZXRMOlxuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBub2RlLmVsZW1lbnRzID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KHR5cGVzJDEuYnJhY2tldFIsIHRydWUsIHRydWUpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycmF5UGF0dGVyblwiKVxuXG4gICAgY2FzZSB0eXBlcyQxLmJyYWNlTDpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqKHRydWUpXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzLnBhcnNlSWRlbnQoKVxufTtcblxucHAkNy5wYXJzZUJpbmRpbmdMaXN0ID0gZnVuY3Rpb24oY2xvc2UsIGFsbG93RW1wdHksIGFsbG93VHJhaWxpbmdDb21tYSwgYWxsb3dNb2RpZmllcnMpIHtcbiAgdmFyIGVsdHMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICB3aGlsZSAoIXRoaXMuZWF0KGNsb3NlKSkge1xuICAgIGlmIChmaXJzdCkgeyBmaXJzdCA9IGZhbHNlOyB9XG4gICAgZWxzZSB7IHRoaXMuZXhwZWN0KHR5cGVzJDEuY29tbWEpOyB9XG4gICAgaWYgKGFsbG93RW1wdHkgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLmNvbW1hKSB7XG4gICAgICBlbHRzLnB1c2gobnVsbCk7XG4gICAgfSBlbHNlIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEoY2xvc2UpKSB7XG4gICAgICBicmVha1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmVsbGlwc2lzKSB7XG4gICAgICB2YXIgcmVzdCA9IHRoaXMucGFyc2VSZXN0QmluZGluZygpO1xuICAgICAgdGhpcy5wYXJzZUJpbmRpbmdMaXN0SXRlbShyZXN0KTtcbiAgICAgIGVsdHMucHVzaChyZXN0KTtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuY29tbWEpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpOyB9XG4gICAgICB0aGlzLmV4cGVjdChjbG9zZSk7XG4gICAgICBicmVha1xuICAgIH0gZWxzZSB7XG4gICAgICBlbHRzLnB1c2godGhpcy5wYXJzZUFzc2lnbmFibGVMaXN0SXRlbShhbGxvd01vZGlmaWVycykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWx0c1xufTtcblxucHAkNy5wYXJzZUFzc2lnbmFibGVMaXN0SXRlbSA9IGZ1bmN0aW9uKGFsbG93TW9kaWZpZXJzKSB7XG4gIHZhciBlbGVtID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdCh0aGlzLnN0YXJ0LCB0aGlzLnN0YXJ0TG9jKTtcbiAgdGhpcy5wYXJzZUJpbmRpbmdMaXN0SXRlbShlbGVtKTtcbiAgcmV0dXJuIGVsZW1cbn07XG5cbnBwJDcucGFyc2VCaW5kaW5nTGlzdEl0ZW0gPSBmdW5jdGlvbihwYXJhbSkge1xuICByZXR1cm4gcGFyYW1cbn07XG5cbi8vIFBhcnNlcyBhc3NpZ25tZW50IHBhdHRlcm4gYXJvdW5kIGdpdmVuIGF0b20gaWYgcG9zc2libGUuXG5cbnBwJDcucGFyc2VNYXliZURlZmF1bHQgPSBmdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIGxlZnQpIHtcbiAgbGVmdCA9IGxlZnQgfHwgdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2IHx8ICF0aGlzLmVhdCh0eXBlcyQxLmVxKSkgeyByZXR1cm4gbGVmdCB9XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICBub2RlLmxlZnQgPSBsZWZ0O1xuICBub2RlLnJpZ2h0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50UGF0dGVyblwiKVxufTtcblxuLy8gVGhlIGZvbGxvd2luZyB0aHJlZSBmdW5jdGlvbnMgYWxsIHZlcmlmeSB0aGF0IGEgbm9kZSBpcyBhbiBsdmFsdWUg4oCUXG4vLyBzb21ldGhpbmcgdGhhdCBjYW4gYmUgYm91bmQsIG9yIGFzc2lnbmVkIHRvLiBJbiBvcmRlciB0byBkbyBzbywgdGhleSBwZXJmb3JtXG4vLyBhIHZhcmlldHkgb2YgY2hlY2tzOlxuLy9cbi8vIC0gQ2hlY2sgdGhhdCBub25lIG9mIHRoZSBib3VuZC9hc3NpZ25lZC10byBpZGVudGlmaWVycyBhcmUgcmVzZXJ2ZWQgd29yZHMuXG4vLyAtIFJlY29yZCBuYW1lIGRlY2xhcmF0aW9ucyBmb3IgYmluZGluZ3MgaW4gdGhlIGFwcHJvcHJpYXRlIHNjb3BlLlxuLy8gLSBDaGVjayBkdXBsaWNhdGUgYXJndW1lbnQgbmFtZXMsIGlmIGNoZWNrQ2xhc2hlcyBpcyBzZXQuXG4vL1xuLy8gSWYgYSBjb21wbGV4IGJpbmRpbmcgcGF0dGVybiBpcyBlbmNvdW50ZXJlZCAoZS5nLiwgb2JqZWN0IGFuZCBhcnJheVxuLy8gZGVzdHJ1Y3R1cmluZyksIHRoZSBlbnRpcmUgcGF0dGVybiBpcyByZWN1cnNpdmVseSBjaGVja2VkLlxuLy9cbi8vIFRoZXJlIGFyZSB0aHJlZSB2ZXJzaW9ucyBvZiBjaGVja0xWYWwqKCkgYXBwcm9wcmlhdGUgZm9yIGRpZmZlcmVudFxuLy8gY2lyY3Vtc3RhbmNlczpcbi8vXG4vLyAtIGNoZWNrTFZhbFNpbXBsZSgpIHNoYWxsIGJlIHVzZWQgaWYgdGhlIHN5bnRhY3RpYyBjb25zdHJ1Y3Qgc3VwcG9ydHNcbi8vICAgbm90aGluZyBvdGhlciB0aGFuIGlkZW50aWZpZXJzIGFuZCBtZW1iZXIgZXhwcmVzc2lvbnMuIFBhcmVudGhlc2l6ZWRcbi8vICAgZXhwcmVzc2lvbnMgYXJlIGFsc28gY29ycmVjdGx5IGhhbmRsZWQuIFRoaXMgaXMgZ2VuZXJhbGx5IGFwcHJvcHJpYXRlIGZvclxuLy8gICBjb25zdHJ1Y3RzIGZvciB3aGljaCB0aGUgc3BlYyBzYXlzXG4vL1xuLy8gICA+IEl0IGlzIGEgU3ludGF4IEVycm9yIGlmIEFzc2lnbm1lbnRUYXJnZXRUeXBlIG9mIFt0aGUgcHJvZHVjdGlvbl0gaXMgbm90XG4vLyAgID4gc2ltcGxlLlxuLy9cbi8vICAgSXQgaXMgYWxzbyBhcHByb3ByaWF0ZSBmb3IgY2hlY2tpbmcgaWYgYW4gaWRlbnRpZmllciBpcyB2YWxpZCBhbmQgbm90XG4vLyAgIGRlZmluZWQgZWxzZXdoZXJlLCBsaWtlIGltcG9ydCBkZWNsYXJhdGlvbnMgb3IgZnVuY3Rpb24vY2xhc3MgaWRlbnRpZmllcnMuXG4vL1xuLy8gICBFeGFtcGxlcyB3aGVyZSB0aGlzIGlzIHVzZWQgaW5jbHVkZTpcbi8vICAgICBhICs9IOKApjtcbi8vICAgICBpbXBvcnQgYSBmcm9tICfigKYnO1xuLy8gICB3aGVyZSBhIGlzIHRoZSBub2RlIHRvIGJlIGNoZWNrZWQuXG4vL1xuLy8gLSBjaGVja0xWYWxQYXR0ZXJuKCkgc2hhbGwgYmUgdXNlZCBpZiB0aGUgc3ludGFjdGljIGNvbnN0cnVjdCBzdXBwb3J0c1xuLy8gICBhbnl0aGluZyBjaGVja0xWYWxTaW1wbGUoKSBzdXBwb3J0cywgYXMgd2VsbCBhcyBvYmplY3QgYW5kIGFycmF5XG4vLyAgIGRlc3RydWN0dXJpbmcgcGF0dGVybnMuIFRoaXMgaXMgZ2VuZXJhbGx5IGFwcHJvcHJpYXRlIGZvciBjb25zdHJ1Y3RzIGZvclxuLy8gICB3aGljaCB0aGUgc3BlYyBzYXlzXG4vL1xuLy8gICA+IEl0IGlzIGEgU3ludGF4IEVycm9yIGlmIFt0aGUgcHJvZHVjdGlvbl0gaXMgbmVpdGhlciBhbiBPYmplY3RMaXRlcmFsIG5vclxuLy8gICA+IGFuIEFycmF5TGl0ZXJhbCBhbmQgQXNzaWdubWVudFRhcmdldFR5cGUgb2YgW3RoZSBwcm9kdWN0aW9uXSBpcyBub3Rcbi8vICAgPiBzaW1wbGUuXG4vL1xuLy8gICBFeGFtcGxlcyB3aGVyZSB0aGlzIGlzIHVzZWQgaW5jbHVkZTpcbi8vICAgICAoYSA9IOKApik7XG4vLyAgICAgY29uc3QgYSA9IOKApjtcbi8vICAgICB0cnkgeyDigKYgfSBjYXRjaCAoYSkgeyDigKYgfVxuLy8gICB3aGVyZSBhIGlzIHRoZSBub2RlIHRvIGJlIGNoZWNrZWQuXG4vL1xuLy8gLSBjaGVja0xWYWxJbm5lclBhdHRlcm4oKSBzaGFsbCBiZSB1c2VkIGlmIHRoZSBzeW50YWN0aWMgY29uc3RydWN0IHN1cHBvcnRzXG4vLyAgIGFueXRoaW5nIGNoZWNrTFZhbFBhdHRlcm4oKSBzdXBwb3J0cywgYXMgd2VsbCBhcyBkZWZhdWx0IGFzc2lnbm1lbnRcbi8vICAgcGF0dGVybnMsIHJlc3QgZWxlbWVudHMsIGFuZCBvdGhlciBjb25zdHJ1Y3RzIHRoYXQgbWF5IGFwcGVhciB3aXRoaW4gYW5cbi8vICAgb2JqZWN0IG9yIGFycmF5IGRlc3RydWN0dXJpbmcgcGF0dGVybi5cbi8vXG4vLyAgIEFzIGEgc3BlY2lhbCBjYXNlLCBmdW5jdGlvbiBwYXJhbWV0ZXJzIGFsc28gdXNlIGNoZWNrTFZhbElubmVyUGF0dGVybigpLFxuLy8gICBhcyB0aGV5IGFsc28gc3VwcG9ydCBkZWZhdWx0cyBhbmQgcmVzdCBjb25zdHJ1Y3RzLlxuLy9cbi8vIFRoZXNlIGZ1bmN0aW9ucyBkZWxpYmVyYXRlbHkgc3VwcG9ydCBib3RoIGFzc2lnbm1lbnQgYW5kIGJpbmRpbmcgY29uc3RydWN0cyxcbi8vIGFzIHRoZSBsb2dpYyBmb3IgYm90aCBpcyBleGNlZWRpbmdseSBzaW1pbGFyLiBJZiB0aGUgbm9kZSBpcyB0aGUgdGFyZ2V0IG9mXG4vLyBhbiBhc3NpZ25tZW50LCB0aGVuIGJpbmRpbmdUeXBlIHNob3VsZCBiZSBzZXQgdG8gQklORF9OT05FLiBPdGhlcndpc2UsIGl0XG4vLyBzaG91bGQgYmUgc2V0IHRvIHRoZSBhcHByb3ByaWF0ZSBCSU5EXyogY29uc3RhbnQsIGxpa2UgQklORF9WQVIgb3Jcbi8vIEJJTkRfTEVYSUNBTC5cbi8vXG4vLyBJZiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYSBub24tQklORF9OT05FIGJpbmRpbmdUeXBlLCB0aGVuXG4vLyBhZGRpdGlvbmFsbHkgYSBjaGVja0NsYXNoZXMgb2JqZWN0IG1heSBiZSBzcGVjaWZpZWQgdG8gYWxsb3cgY2hlY2tpbmcgZm9yXG4vLyBkdXBsaWNhdGUgYXJndW1lbnQgbmFtZXMuIGNoZWNrQ2xhc2hlcyBpcyBpZ25vcmVkIGlmIHRoZSBwcm92aWRlZCBjb25zdHJ1Y3Rcbi8vIGlzIGFuIGFzc2lnbm1lbnQgKGkuZS4sIGJpbmRpbmdUeXBlIGlzIEJJTkRfTk9ORSkuXG5cbnBwJDcuY2hlY2tMVmFsU2ltcGxlID0gZnVuY3Rpb24oZXhwciwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcykge1xuICBpZiAoIGJpbmRpbmdUeXBlID09PSB2b2lkIDAgKSBiaW5kaW5nVHlwZSA9IEJJTkRfTk9ORTtcblxuICB2YXIgaXNCaW5kID0gYmluZGluZ1R5cGUgIT09IEJJTkRfTk9ORTtcblxuICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgIGlmICh0aGlzLnN0cmljdCAmJiB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3RCaW5kLnRlc3QoZXhwci5uYW1lKSlcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIChpc0JpbmQgPyBcIkJpbmRpbmcgXCIgOiBcIkFzc2lnbmluZyB0byBcIikgKyBleHByLm5hbWUgKyBcIiBpbiBzdHJpY3QgbW9kZVwiKTsgfVxuICAgIGlmIChpc0JpbmQpIHtcbiAgICAgIGlmIChiaW5kaW5nVHlwZSA9PT0gQklORF9MRVhJQ0FMICYmIGV4cHIubmFtZSA9PT0gXCJsZXRcIilcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXhwci5zdGFydCwgXCJsZXQgaXMgZGlzYWxsb3dlZCBhcyBhIGxleGljYWxseSBib3VuZCBuYW1lXCIpOyB9XG4gICAgICBpZiAoY2hlY2tDbGFzaGVzKSB7XG4gICAgICAgIGlmIChoYXNPd24oY2hlY2tDbGFzaGVzLCBleHByLm5hbWUpKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIFwiQXJndW1lbnQgbmFtZSBjbGFzaFwiKTsgfVxuICAgICAgICBjaGVja0NsYXNoZXNbZXhwci5uYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoYmluZGluZ1R5cGUgIT09IEJJTkRfT1VUU0lERSkgeyB0aGlzLmRlY2xhcmVOYW1lKGV4cHIubmFtZSwgYmluZGluZ1R5cGUsIGV4cHIuc3RhcnQpOyB9XG4gICAgfVxuICAgIGJyZWFrXG5cbiAgY2FzZSBcIkNoYWluRXhwcmVzc2lvblwiOlxuICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCBcIk9wdGlvbmFsIGNoYWluaW5nIGNhbm5vdCBhcHBlYXIgaW4gbGVmdC1oYW5kIHNpZGVcIik7XG4gICAgYnJlYWtcblxuICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgIGlmIChpc0JpbmQpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIFwiQmluZGluZyBtZW1iZXIgZXhwcmVzc2lvblwiKTsgfVxuICAgIGJyZWFrXG5cbiAgY2FzZSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI6XG4gICAgaWYgKGlzQmluZCkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXhwci5zdGFydCwgXCJCaW5kaW5nIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvblwiKTsgfVxuICAgIHJldHVybiB0aGlzLmNoZWNrTFZhbFNpbXBsZShleHByLmV4cHJlc3Npb24sIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpXG5cbiAgZGVmYXVsdDpcbiAgICB0aGlzLnJhaXNlKGV4cHIuc3RhcnQsIChpc0JpbmQgPyBcIkJpbmRpbmdcIiA6IFwiQXNzaWduaW5nIHRvXCIpICsgXCIgcnZhbHVlXCIpO1xuICB9XG59O1xuXG5wcCQ3LmNoZWNrTFZhbFBhdHRlcm4gPSBmdW5jdGlvbihleHByLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKSB7XG4gIGlmICggYmluZGluZ1R5cGUgPT09IHZvaWQgMCApIGJpbmRpbmdUeXBlID0gQklORF9OT05FO1xuXG4gIHN3aXRjaCAoZXhwci50eXBlKSB7XG4gIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBleHByLnByb3BlcnRpZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB2YXIgcHJvcCA9IGxpc3RbaV07XG5cbiAgICB0aGlzLmNoZWNrTFZhbElubmVyUGF0dGVybihwcm9wLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICB9XG4gICAgYnJlYWtcblxuICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gZXhwci5lbGVtZW50czsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgIHZhciBlbGVtID0gbGlzdCQxW2kkMV07XG5cbiAgICBpZiAoZWxlbSkgeyB0aGlzLmNoZWNrTFZhbElubmVyUGF0dGVybihlbGVtLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTsgfVxuICAgIH1cbiAgICBicmVha1xuXG4gIGRlZmF1bHQ6XG4gICAgdGhpcy5jaGVja0xWYWxTaW1wbGUoZXhwciwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gIH1cbn07XG5cbnBwJDcuY2hlY2tMVmFsSW5uZXJQYXR0ZXJuID0gZnVuY3Rpb24oZXhwciwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcykge1xuICBpZiAoIGJpbmRpbmdUeXBlID09PSB2b2lkIDAgKSBiaW5kaW5nVHlwZSA9IEJJTkRfTk9ORTtcblxuICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICBjYXNlIFwiUHJvcGVydHlcIjpcbiAgICAvLyBBc3NpZ25tZW50UHJvcGVydHkgaGFzIHR5cGUgPT09IFwiUHJvcGVydHlcIlxuICAgIHRoaXMuY2hlY2tMVmFsSW5uZXJQYXR0ZXJuKGV4cHIudmFsdWUsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICAgIGJyZWFrXG5cbiAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgdGhpcy5jaGVja0xWYWxQYXR0ZXJuKGV4cHIubGVmdCwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgYnJlYWtcblxuICBjYXNlIFwiUmVzdEVsZW1lbnRcIjpcbiAgICB0aGlzLmNoZWNrTFZhbFBhdHRlcm4oZXhwci5hcmd1bWVudCwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgYnJlYWtcblxuICBkZWZhdWx0OlxuICAgIHRoaXMuY2hlY2tMVmFsUGF0dGVybihleHByLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgfVxufTtcblxuLy8gVGhlIGFsZ29yaXRobSB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIGEgcmVnZXhwIGNhbiBhcHBlYXIgYXQgYVxuLy8gZ2l2ZW4gcG9pbnQgaW4gdGhlIHByb2dyYW0gaXMgbG9vc2VseSBiYXNlZCBvbiBzd2VldC5qcycgYXBwcm9hY2guXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc3dlZXQuanMvd2lraS9kZXNpZ25cblxuXG52YXIgVG9rQ29udGV4dCA9IGZ1bmN0aW9uIFRva0NvbnRleHQodG9rZW4sIGlzRXhwciwgcHJlc2VydmVTcGFjZSwgb3ZlcnJpZGUsIGdlbmVyYXRvcikge1xuICB0aGlzLnRva2VuID0gdG9rZW47XG4gIHRoaXMuaXNFeHByID0gISFpc0V4cHI7XG4gIHRoaXMucHJlc2VydmVTcGFjZSA9ICEhcHJlc2VydmVTcGFjZTtcbiAgdGhpcy5vdmVycmlkZSA9IG92ZXJyaWRlO1xuICB0aGlzLmdlbmVyYXRvciA9ICEhZ2VuZXJhdG9yO1xufTtcblxudmFyIHR5cGVzID0ge1xuICBiX3N0YXQ6IG5ldyBUb2tDb250ZXh0KFwie1wiLCBmYWxzZSksXG4gIGJfZXhwcjogbmV3IFRva0NvbnRleHQoXCJ7XCIsIHRydWUpLFxuICBiX3RtcGw6IG5ldyBUb2tDb250ZXh0KFwiJHtcIiwgZmFsc2UpLFxuICBwX3N0YXQ6IG5ldyBUb2tDb250ZXh0KFwiKFwiLCBmYWxzZSksXG4gIHBfZXhwcjogbmV3IFRva0NvbnRleHQoXCIoXCIsIHRydWUpLFxuICBxX3RtcGw6IG5ldyBUb2tDb250ZXh0KFwiYFwiLCB0cnVlLCB0cnVlLCBmdW5jdGlvbiAocCkgeyByZXR1cm4gcC50cnlSZWFkVGVtcGxhdGVUb2tlbigpOyB9KSxcbiAgZl9zdGF0OiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIGZhbHNlKSxcbiAgZl9leHByOiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIHRydWUpLFxuICBmX2V4cHJfZ2VuOiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIHRydWUsIGZhbHNlLCBudWxsLCB0cnVlKSxcbiAgZl9nZW46IG5ldyBUb2tDb250ZXh0KFwiZnVuY3Rpb25cIiwgZmFsc2UsIGZhbHNlLCBudWxsLCB0cnVlKVxufTtcblxudmFyIHBwJDYgPSBQYXJzZXIucHJvdG90eXBlO1xuXG5wcCQ2LmluaXRpYWxDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBbdHlwZXMuYl9zdGF0XVxufTtcblxucHAkNi5jdXJDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmNvbnRleHRbdGhpcy5jb250ZXh0Lmxlbmd0aCAtIDFdXG59O1xuXG5wcCQ2LmJyYWNlSXNCbG9jayA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzLmN1ckNvbnRleHQoKTtcbiAgaWYgKHBhcmVudCA9PT0gdHlwZXMuZl9leHByIHx8IHBhcmVudCA9PT0gdHlwZXMuZl9zdGF0KVxuICAgIHsgcmV0dXJuIHRydWUgfVxuICBpZiAocHJldlR5cGUgPT09IHR5cGVzJDEuY29sb24gJiYgKHBhcmVudCA9PT0gdHlwZXMuYl9zdGF0IHx8IHBhcmVudCA9PT0gdHlwZXMuYl9leHByKSlcbiAgICB7IHJldHVybiAhcGFyZW50LmlzRXhwciB9XG5cbiAgLy8gVGhlIGNoZWNrIGZvciBgdHQubmFtZSAmJiBleHByQWxsb3dlZGAgZGV0ZWN0cyB3aGV0aGVyIHdlIGFyZVxuICAvLyBhZnRlciBhIGB5aWVsZGAgb3IgYG9mYCBjb25zdHJ1Y3QuIFNlZSB0aGUgYHVwZGF0ZUNvbnRleHRgIGZvclxuICAvLyBgdHQubmFtZWAuXG4gIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMkMS5fcmV0dXJuIHx8IHByZXZUeXBlID09PSB0eXBlcyQxLm5hbWUgJiYgdGhpcy5leHByQWxsb3dlZClcbiAgICB7IHJldHVybiBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpIH1cbiAgaWYgKHByZXZUeXBlID09PSB0eXBlcyQxLl9lbHNlIHx8IHByZXZUeXBlID09PSB0eXBlcyQxLnNlbWkgfHwgcHJldlR5cGUgPT09IHR5cGVzJDEuZW9mIHx8IHByZXZUeXBlID09PSB0eXBlcyQxLnBhcmVuUiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMkMS5hcnJvdylcbiAgICB7IHJldHVybiB0cnVlIH1cbiAgaWYgKHByZXZUeXBlID09PSB0eXBlcyQxLmJyYWNlTClcbiAgICB7IHJldHVybiBwYXJlbnQgPT09IHR5cGVzLmJfc3RhdCB9XG4gIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMkMS5fdmFyIHx8IHByZXZUeXBlID09PSB0eXBlcyQxLl9jb25zdCB8fCBwcmV2VHlwZSA9PT0gdHlwZXMkMS5uYW1lKVxuICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgcmV0dXJuICF0aGlzLmV4cHJBbGxvd2VkXG59O1xuXG5wcCQ2LmluR2VuZXJhdG9yQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBpID0gdGhpcy5jb250ZXh0Lmxlbmd0aCAtIDE7IGkgPj0gMTsgaS0tKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHRbaV07XG4gICAgaWYgKGNvbnRleHQudG9rZW4gPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHsgcmV0dXJuIGNvbnRleHQuZ2VuZXJhdG9yIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbnBwJDYudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gIHZhciB1cGRhdGUsIHR5cGUgPSB0aGlzLnR5cGU7XG4gIGlmICh0eXBlLmtleXdvcmQgJiYgcHJldlR5cGUgPT09IHR5cGVzJDEuZG90KVxuICAgIHsgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlOyB9XG4gIGVsc2UgaWYgKHVwZGF0ZSA9IHR5cGUudXBkYXRlQ29udGV4dClcbiAgICB7IHVwZGF0ZS5jYWxsKHRoaXMsIHByZXZUeXBlKTsgfVxuICBlbHNlXG4gICAgeyB0aGlzLmV4cHJBbGxvd2VkID0gdHlwZS5iZWZvcmVFeHByOyB9XG59O1xuXG4vLyBVc2VkIHRvIGhhbmRsZSBlZGdlIGNhc2VzIHdoZW4gdG9rZW4gY29udGV4dCBjb3VsZCBub3QgYmUgaW5mZXJyZWQgY29ycmVjdGx5IGR1cmluZyB0b2tlbml6YXRpb24gcGhhc2VcblxucHAkNi5vdmVycmlkZUNvbnRleHQgPSBmdW5jdGlvbih0b2tlbkN0eCkge1xuICBpZiAodGhpcy5jdXJDb250ZXh0KCkgIT09IHRva2VuQ3R4KSB7XG4gICAgdGhpcy5jb250ZXh0W3RoaXMuY29udGV4dC5sZW5ndGggLSAxXSA9IHRva2VuQ3R4O1xuICB9XG59O1xuXG4vLyBUb2tlbi1zcGVjaWZpYyBjb250ZXh0IHVwZGF0ZSBjb2RlXG5cbnR5cGVzJDEucGFyZW5SLnVwZGF0ZUNvbnRleHQgPSB0eXBlcyQxLmJyYWNlUi51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmNvbnRleHQubGVuZ3RoID09PSAxKSB7XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG91dCA9IHRoaXMuY29udGV4dC5wb3AoKTtcbiAgaWYgKG91dCA9PT0gdHlwZXMuYl9zdGF0ICYmIHRoaXMuY3VyQ29udGV4dCgpLnRva2VuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBvdXQgPSB0aGlzLmNvbnRleHQucG9wKCk7XG4gIH1cbiAgdGhpcy5leHByQWxsb3dlZCA9ICFvdXQuaXNFeHByO1xufTtcblxudHlwZXMkMS5icmFjZUwudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gIHRoaXMuY29udGV4dC5wdXNoKHRoaXMuYnJhY2VJc0Jsb2NrKHByZXZUeXBlKSA/IHR5cGVzLmJfc3RhdCA6IHR5cGVzLmJfZXhwcik7XG4gIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xufTtcblxudHlwZXMkMS5kb2xsYXJCcmFjZUwudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmNvbnRleHQucHVzaCh0eXBlcy5iX3RtcGwpO1xuICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbn07XG5cbnR5cGVzJDEucGFyZW5MLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICB2YXIgc3RhdGVtZW50UGFyZW5zID0gcHJldlR5cGUgPT09IHR5cGVzJDEuX2lmIHx8IHByZXZUeXBlID09PSB0eXBlcyQxLl9mb3IgfHwgcHJldlR5cGUgPT09IHR5cGVzJDEuX3dpdGggfHwgcHJldlR5cGUgPT09IHR5cGVzJDEuX3doaWxlO1xuICB0aGlzLmNvbnRleHQucHVzaChzdGF0ZW1lbnRQYXJlbnMgPyB0eXBlcy5wX3N0YXQgOiB0eXBlcy5wX2V4cHIpO1xuICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbn07XG5cbnR5cGVzJDEuaW5jRGVjLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgLy8gdG9rRXhwckFsbG93ZWQgc3RheXMgdW5jaGFuZ2VkXG59O1xuXG50eXBlcyQxLl9mdW5jdGlvbi51cGRhdGVDb250ZXh0ID0gdHlwZXMkMS5fY2xhc3MudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gIGlmIChwcmV2VHlwZS5iZWZvcmVFeHByICYmIHByZXZUeXBlICE9PSB0eXBlcyQxLl9lbHNlICYmXG4gICAgICAhKHByZXZUeXBlID09PSB0eXBlcyQxLnNlbWkgJiYgdGhpcy5jdXJDb250ZXh0KCkgIT09IHR5cGVzLnBfc3RhdCkgJiZcbiAgICAgICEocHJldlR5cGUgPT09IHR5cGVzJDEuX3JldHVybiAmJiBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpKSAmJlxuICAgICAgISgocHJldlR5cGUgPT09IHR5cGVzJDEuY29sb24gfHwgcHJldlR5cGUgPT09IHR5cGVzJDEuYnJhY2VMKSAmJiB0aGlzLmN1ckNvbnRleHQoKSA9PT0gdHlwZXMuYl9zdGF0KSlcbiAgICB7IHRoaXMuY29udGV4dC5wdXNoKHR5cGVzLmZfZXhwcik7IH1cbiAgZWxzZVxuICAgIHsgdGhpcy5jb250ZXh0LnB1c2godHlwZXMuZl9zdGF0KTsgfVxuICB0aGlzLmV4cHJBbGxvd2VkID0gZmFsc2U7XG59O1xuXG50eXBlcyQxLmNvbG9uLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuY3VyQ29udGV4dCgpLnRva2VuID09PSBcImZ1bmN0aW9uXCIpIHsgdGhpcy5jb250ZXh0LnBvcCgpOyB9XG4gIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xufTtcblxudHlwZXMkMS5iYWNrUXVvdGUudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5jdXJDb250ZXh0KCkgPT09IHR5cGVzLnFfdG1wbClcbiAgICB7IHRoaXMuY29udGV4dC5wb3AoKTsgfVxuICBlbHNlXG4gICAgeyB0aGlzLmNvbnRleHQucHVzaCh0eXBlcy5xX3RtcGwpOyB9XG4gIHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTtcbn07XG5cbnR5cGVzJDEuc3Rhci51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgaWYgKHByZXZUeXBlID09PSB0eXBlcyQxLl9mdW5jdGlvbikge1xuICAgIHZhciBpbmRleCA9IHRoaXMuY29udGV4dC5sZW5ndGggLSAxO1xuICAgIGlmICh0aGlzLmNvbnRleHRbaW5kZXhdID09PSB0eXBlcy5mX2V4cHIpXG4gICAgICB7IHRoaXMuY29udGV4dFtpbmRleF0gPSB0eXBlcy5mX2V4cHJfZ2VuOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLmNvbnRleHRbaW5kZXhdID0gdHlwZXMuZl9nZW47IH1cbiAgfVxuICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbn07XG5cbnR5cGVzJDEubmFtZS51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgdmFyIGFsbG93ZWQgPSBmYWxzZTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHByZXZUeXBlICE9PSB0eXBlcyQxLmRvdCkge1xuICAgIGlmICh0aGlzLnZhbHVlID09PSBcIm9mXCIgJiYgIXRoaXMuZXhwckFsbG93ZWQgfHxcbiAgICAgICAgdGhpcy52YWx1ZSA9PT0gXCJ5aWVsZFwiICYmIHRoaXMuaW5HZW5lcmF0b3JDb250ZXh0KCkpXG4gICAgICB7IGFsbG93ZWQgPSB0cnVlOyB9XG4gIH1cbiAgdGhpcy5leHByQWxsb3dlZCA9IGFsbG93ZWQ7XG59O1xuXG4vLyBBIHJlY3Vyc2l2ZSBkZXNjZW50IHBhcnNlciBvcGVyYXRlcyBieSBkZWZpbmluZyBmdW5jdGlvbnMgZm9yIGFsbFxuLy8gc3ludGFjdGljIGVsZW1lbnRzLCBhbmQgcmVjdXJzaXZlbHkgY2FsbGluZyB0aG9zZSwgZWFjaCBmdW5jdGlvblxuLy8gYWR2YW5jaW5nIHRoZSBpbnB1dCBzdHJlYW0gYW5kIHJldHVybmluZyBhbiBBU1Qgbm9kZS4gUHJlY2VkZW5jZVxuLy8gb2YgY29uc3RydWN0cyAoZm9yIGV4YW1wbGUsIHRoZSBmYWN0IHRoYXQgYCF4WzFdYCBtZWFucyBgISh4WzFdKWBcbi8vIGluc3RlYWQgb2YgYCgheClbMV1gIGlzIGhhbmRsZWQgYnkgdGhlIGZhY3QgdGhhdCB0aGUgcGFyc2VyXG4vLyBmdW5jdGlvbiB0aGF0IHBhcnNlcyB1bmFyeSBwcmVmaXggb3BlcmF0b3JzIGlzIGNhbGxlZCBmaXJzdCwgYW5kXG4vLyBpbiB0dXJuIGNhbGxzIHRoZSBmdW5jdGlvbiB0aGF0IHBhcnNlcyBgW11gIHN1YnNjcmlwdHMg4oCUIHRoYXRcbi8vIHdheSwgaXQnbGwgcmVjZWl2ZSB0aGUgbm9kZSBmb3IgYHhbMV1gIGFscmVhZHkgcGFyc2VkLCBhbmQgd3JhcHNcbi8vICp0aGF0KiBpbiB0aGUgdW5hcnkgb3BlcmF0b3Igbm9kZS5cbi8vXG4vLyBBY29ybiB1c2VzIGFuIFtvcGVyYXRvciBwcmVjZWRlbmNlIHBhcnNlcl1bb3BwXSB0byBoYW5kbGUgYmluYXJ5XG4vLyBvcGVyYXRvciBwcmVjZWRlbmNlLCBiZWNhdXNlIGl0IGlzIG11Y2ggbW9yZSBjb21wYWN0IHRoYW4gdXNpbmdcbi8vIHRoZSB0ZWNobmlxdWUgb3V0bGluZWQgYWJvdmUsIHdoaWNoIHVzZXMgZGlmZmVyZW50LCBuZXN0aW5nXG4vLyBmdW5jdGlvbnMgdG8gc3BlY2lmeSBwcmVjZWRlbmNlLCBmb3IgYWxsIG9mIHRoZSB0ZW4gYmluYXJ5XG4vLyBwcmVjZWRlbmNlIGxldmVscyB0aGF0IEphdmFTY3JpcHQgZGVmaW5lcy5cbi8vXG4vLyBbb3BwXTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9PcGVyYXRvci1wcmVjZWRlbmNlX3BhcnNlclxuXG5cbnZhciBwcCQ1ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuLy8gQ2hlY2sgaWYgcHJvcGVydHkgbmFtZSBjbGFzaGVzIHdpdGggYWxyZWFkeSBhZGRlZC5cbi8vIE9iamVjdC9jbGFzcyBnZXR0ZXJzIGFuZCBzZXR0ZXJzIGFyZSBub3QgYWxsb3dlZCB0byBjbGFzaCDigJRcbi8vIGVpdGhlciB3aXRoIGVhY2ggb3RoZXIgb3Igd2l0aCBhbiBpbml0IHByb3BlcnR5IOKAlCBhbmQgaW5cbi8vIHN0cmljdCBtb2RlLCBpbml0IHByb3BlcnRpZXMgYXJlIGFsc28gbm90IGFsbG93ZWQgdG8gYmUgcmVwZWF0ZWQuXG5cbnBwJDUuY2hlY2tQcm9wQ2xhc2ggPSBmdW5jdGlvbihwcm9wLCBwcm9wSGFzaCwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgcHJvcC50eXBlID09PSBcIlNwcmVhZEVsZW1lbnRcIilcbiAgICB7IHJldHVybiB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiAocHJvcC5jb21wdXRlZCB8fCBwcm9wLm1ldGhvZCB8fCBwcm9wLnNob3J0aGFuZCkpXG4gICAgeyByZXR1cm4gfVxuICB2YXIga2V5ID0gcHJvcC5rZXk7XG4gIHZhciBuYW1lO1xuICBzd2l0Y2ggKGtleS50eXBlKSB7XG4gIGNhc2UgXCJJZGVudGlmaWVyXCI6IG5hbWUgPSBrZXkubmFtZTsgYnJlYWtcbiAgY2FzZSBcIkxpdGVyYWxcIjogbmFtZSA9IFN0cmluZyhrZXkudmFsdWUpOyBicmVha1xuICBkZWZhdWx0OiByZXR1cm5cbiAgfVxuICB2YXIga2luZCA9IHByb3Aua2luZDtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgaWYgKG5hbWUgPT09IFwiX19wcm90b19fXCIgJiYga2luZCA9PT0gXCJpbml0XCIpIHtcbiAgICAgIGlmIChwcm9wSGFzaC5wcm90bykge1xuICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvIDwgMCkge1xuICAgICAgICAgICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5kb3VibGVQcm90byA9IGtleS5zdGFydDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGtleS5zdGFydCwgXCJSZWRlZmluaXRpb24gb2YgX19wcm90b19fIHByb3BlcnR5XCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcm9wSGFzaC5wcm90byA9IHRydWU7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG4gIG5hbWUgPSBcIiRcIiArIG5hbWU7XG4gIHZhciBvdGhlciA9IHByb3BIYXNoW25hbWVdO1xuICBpZiAob3RoZXIpIHtcbiAgICB2YXIgcmVkZWZpbml0aW9uO1xuICAgIGlmIChraW5kID09PSBcImluaXRcIikge1xuICAgICAgcmVkZWZpbml0aW9uID0gdGhpcy5zdHJpY3QgJiYgb3RoZXIuaW5pdCB8fCBvdGhlci5nZXQgfHwgb3RoZXIuc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZWRlZmluaXRpb24gPSBvdGhlci5pbml0IHx8IG90aGVyW2tpbmRdO1xuICAgIH1cbiAgICBpZiAocmVkZWZpbml0aW9uKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoa2V5LnN0YXJ0LCBcIlJlZGVmaW5pdGlvbiBvZiBwcm9wZXJ0eVwiKTsgfVxuICB9IGVsc2Uge1xuICAgIG90aGVyID0gcHJvcEhhc2hbbmFtZV0gPSB7XG4gICAgICBpbml0OiBmYWxzZSxcbiAgICAgIGdldDogZmFsc2UsXG4gICAgICBzZXQ6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBvdGhlcltraW5kXSA9IHRydWU7XG59O1xuXG4vLyAjIyMgRXhwcmVzc2lvbiBwYXJzaW5nXG5cbi8vIFRoZXNlIG5lc3QsIGZyb20gdGhlIG1vc3QgZ2VuZXJhbCBleHByZXNzaW9uIHR5cGUgYXQgdGhlIHRvcCB0b1xuLy8gJ2F0b21pYycsIG5vbmRpdmlzaWJsZSBleHByZXNzaW9uIHR5cGVzIGF0IHRoZSBib3R0b20uIE1vc3Qgb2Zcbi8vIHRoZSBmdW5jdGlvbnMgd2lsbCBzaW1wbHkgbGV0IHRoZSBmdW5jdGlvbihzKSBiZWxvdyB0aGVtIHBhcnNlLFxuLy8gYW5kLCAqaWYqIHRoZSBzeW50YWN0aWMgY29uc3RydWN0IHRoZXkgaGFuZGxlIGlzIHByZXNlbnQsIHdyYXBcbi8vIHRoZSBBU1Qgbm9kZSB0aGF0IHRoZSBpbm5lciBwYXJzZXIgZ2F2ZSB0aGVtIGluIGFub3RoZXIgbm9kZS5cblxuLy8gUGFyc2UgYSBmdWxsIGV4cHJlc3Npb24uIFRoZSBvcHRpb25hbCBhcmd1bWVudHMgYXJlIHVzZWQgdG9cbi8vIGZvcmJpZCB0aGUgYGluYCBvcGVyYXRvciAoaW4gZm9yIGxvb3BzIGluaXRhbGl6YXRpb24gZXhwcmVzc2lvbnMpXG4vLyBhbmQgcHJvdmlkZSByZWZlcmVuY2UgZm9yIHN0b3JpbmcgJz0nIG9wZXJhdG9yIGluc2lkZSBzaG9ydGhhbmRcbi8vIHByb3BlcnR5IGFzc2lnbm1lbnQgaW4gY29udGV4dHMgd2hlcmUgYm90aCBvYmplY3QgZXhwcmVzc2lvblxuLy8gYW5kIG9iamVjdCBwYXR0ZXJuIG1pZ2h0IGFwcGVhciAoc28gaXQncyBwb3NzaWJsZSB0byByYWlzZVxuLy8gZGVsYXllZCBzeW50YXggZXJyb3IgYXQgY29ycmVjdCBwb3NpdGlvbikuXG5cbnBwJDUucGFyc2VFeHByZXNzaW9uID0gZnVuY3Rpb24oZm9ySW5pdCwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gIHZhciBleHByID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmNvbW1hKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZS5leHByZXNzaW9ucyA9IFtleHByXTtcbiAgICB3aGlsZSAodGhpcy5lYXQodHlwZXMkMS5jb21tYSkpIHsgbm9kZS5leHByZXNzaW9ucy5wdXNoKHRoaXMucGFyc2VNYXliZUFzc2lnbihmb3JJbml0LCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSk7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU2VxdWVuY2VFeHByZXNzaW9uXCIpXG4gIH1cbiAgcmV0dXJuIGV4cHJcbn07XG5cbi8vIFBhcnNlIGFuIGFzc2lnbm1lbnQgZXhwcmVzc2lvbi4gVGhpcyBpbmNsdWRlcyBhcHBsaWNhdGlvbnMgb2Zcbi8vIG9wZXJhdG9ycyBsaWtlIGArPWAuXG5cbnBwJDUucGFyc2VNYXliZUFzc2lnbiA9IGZ1bmN0aW9uKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGFmdGVyTGVmdFBhcnNlKSB7XG4gIGlmICh0aGlzLmlzQ29udGV4dHVhbChcInlpZWxkXCIpKSB7XG4gICAgaWYgKHRoaXMuaW5HZW5lcmF0b3IpIHsgcmV0dXJuIHRoaXMucGFyc2VZaWVsZChmb3JJbml0KSB9XG4gICAgLy8gVGhlIHRva2VuaXplciB3aWxsIGFzc3VtZSBhbiBleHByZXNzaW9uIGlzIGFsbG93ZWQgYWZ0ZXJcbiAgICAvLyBgeWllbGRgLCBidXQgdGhpcyBpc24ndCB0aGF0IGtpbmQgb2YgeWllbGRcbiAgICBlbHNlIHsgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlOyB9XG4gIH1cblxuICB2YXIgb3duRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IGZhbHNlLCBvbGRQYXJlbkFzc2lnbiA9IC0xLCBvbGRUcmFpbGluZ0NvbW1hID0gLTEsIG9sZERvdWJsZVByb3RvID0gLTE7XG4gIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgb2xkUGFyZW5Bc3NpZ24gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ247XG4gICAgb2xkVHJhaWxpbmdDb21tYSA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYTtcbiAgICBvbGREb3VibGVQcm90byA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG87XG4gICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzO1xuICAgIG93bkRlc3RydWN0dXJpbmdFcnJvcnMgPSB0cnVlO1xuICB9XG5cbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnBhcmVuTCB8fCB0aGlzLnR5cGUgPT09IHR5cGVzJDEubmFtZSkge1xuICAgIHRoaXMucG90ZW50aWFsQXJyb3dBdCA9IHRoaXMuc3RhcnQ7XG4gICAgdGhpcy5wb3RlbnRpYWxBcnJvd0luRm9yQXdhaXQgPSBmb3JJbml0ID09PSBcImF3YWl0XCI7XG4gIH1cbiAgdmFyIGxlZnQgPSB0aGlzLnBhcnNlTWF5YmVDb25kaXRpb25hbChmb3JJbml0LCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgaWYgKGFmdGVyTGVmdFBhcnNlKSB7IGxlZnQgPSBhZnRlckxlZnRQYXJzZS5jYWxsKHRoaXMsIGxlZnQsIHN0YXJ0UG9zLCBzdGFydExvYyk7IH1cbiAgaWYgKHRoaXMudHlwZS5pc0Fzc2lnbikge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnZhbHVlO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuZXEpXG4gICAgICB7IGxlZnQgPSB0aGlzLnRvQXNzaWduYWJsZShsZWZ0LCBmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7IH1cbiAgICBpZiAoIW93bkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG8gPSAtMTtcbiAgICB9XG4gICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID49IGxlZnQuc3RhcnQpXG4gICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID0gLTE7IH0gLy8gcmVzZXQgYmVjYXVzZSBzaG9ydGhhbmQgZGVmYXVsdCB3YXMgdXNlZCBjb3JyZWN0bHlcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmVxKVxuICAgICAgeyB0aGlzLmNoZWNrTFZhbFBhdHRlcm4obGVmdCk7IH1cbiAgICBlbHNlXG4gICAgICB7IHRoaXMuY2hlY2tMVmFsU2ltcGxlKGxlZnQpOyB9XG4gICAgbm9kZS5sZWZ0ID0gbGVmdDtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLnJpZ2h0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZvckluaXQpO1xuICAgIGlmIChvbGREb3VibGVQcm90byA+IC0xKSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG8gPSBvbGREb3VibGVQcm90bzsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKVxuICB9IGVsc2Uge1xuICAgIGlmIChvd25EZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpOyB9XG4gIH1cbiAgaWYgKG9sZFBhcmVuQXNzaWduID4gLTEpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gb2xkUGFyZW5Bc3NpZ247IH1cbiAgaWYgKG9sZFRyYWlsaW5nQ29tbWEgPiAtMSkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSBvbGRUcmFpbGluZ0NvbW1hOyB9XG4gIHJldHVybiBsZWZ0XG59O1xuXG4vLyBQYXJzZSBhIHRlcm5hcnkgY29uZGl0aW9uYWwgKGA/OmApIG9wZXJhdG9yLlxuXG5wcCQ1LnBhcnNlTWF5YmVDb25kaXRpb25hbCA9IGZ1bmN0aW9uKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByT3BzKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpIHsgcmV0dXJuIGV4cHIgfVxuICBpZiAodGhpcy5lYXQodHlwZXMkMS5xdWVzdGlvbikpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlLnRlc3QgPSBleHByO1xuICAgIG5vZGUuY29uc2VxdWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuY29sb24pO1xuICAgIG5vZGUuYWx0ZXJuYXRlID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZvckluaXQpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIilcbiAgfVxuICByZXR1cm4gZXhwclxufTtcblxuLy8gU3RhcnQgdGhlIHByZWNlZGVuY2UgcGFyc2VyLlxuXG5wcCQ1LnBhcnNlRXhwck9wcyA9IGZ1bmN0aW9uKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICB2YXIgZXhwciA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGZhbHNlLCBmYWxzZSwgZm9ySW5pdCk7XG4gIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSkgeyByZXR1cm4gZXhwciB9XG4gIHJldHVybiBleHByLnN0YXJ0ID09PSBzdGFydFBvcyAmJiBleHByLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiA/IGV4cHIgOiB0aGlzLnBhcnNlRXhwck9wKGV4cHIsIHN0YXJ0UG9zLCBzdGFydExvYywgLTEsIGZvckluaXQpXG59O1xuXG4vLyBQYXJzZSBiaW5hcnkgb3BlcmF0b3JzIHdpdGggdGhlIG9wZXJhdG9yIHByZWNlZGVuY2UgcGFyc2luZ1xuLy8gYWxnb3JpdGhtLiBgbGVmdGAgaXMgdGhlIGxlZnQtaGFuZCBzaWRlIG9mIHRoZSBvcGVyYXRvci5cbi8vIGBtaW5QcmVjYCBwcm92aWRlcyBjb250ZXh0IHRoYXQgYWxsb3dzIHRoZSBmdW5jdGlvbiB0byBzdG9wIGFuZFxuLy8gZGVmZXIgZnVydGhlciBwYXJzZXIgdG8gb25lIG9mIGl0cyBjYWxsZXJzIHdoZW4gaXQgZW5jb3VudGVycyBhblxuLy8gb3BlcmF0b3IgdGhhdCBoYXMgYSBsb3dlciBwcmVjZWRlbmNlIHRoYW4gdGhlIHNldCBpdCBpcyBwYXJzaW5nLlxuXG5wcCQ1LnBhcnNlRXhwck9wID0gZnVuY3Rpb24obGVmdCwgbGVmdFN0YXJ0UG9zLCBsZWZ0U3RhcnRMb2MsIG1pblByZWMsIGZvckluaXQpIHtcbiAgdmFyIHByZWMgPSB0aGlzLnR5cGUuYmlub3A7XG4gIGlmIChwcmVjICE9IG51bGwgJiYgKCFmb3JJbml0IHx8IHRoaXMudHlwZSAhPT0gdHlwZXMkMS5faW4pKSB7XG4gICAgaWYgKHByZWMgPiBtaW5QcmVjKSB7XG4gICAgICB2YXIgbG9naWNhbCA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5sb2dpY2FsT1IgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLmxvZ2ljYWxBTkQ7XG4gICAgICB2YXIgY29hbGVzY2UgPSB0aGlzLnR5cGUgPT09IHR5cGVzJDEuY29hbGVzY2U7XG4gICAgICBpZiAoY29hbGVzY2UpIHtcbiAgICAgICAgLy8gSGFuZGxlIHRoZSBwcmVjZWRlbmNlIG9mIGB0dC5jb2FsZXNjZWAgYXMgZXF1YWwgdG8gdGhlIHJhbmdlIG9mIGxvZ2ljYWwgZXhwcmVzc2lvbnMuXG4gICAgICAgIC8vIEluIG90aGVyIHdvcmRzLCBgbm9kZS5yaWdodGAgc2hvdWxkbid0IGNvbnRhaW4gbG9naWNhbCBleHByZXNzaW9ucyBpbiBvcmRlciB0byBjaGVjayB0aGUgbWl4ZWQgZXJyb3IuXG4gICAgICAgIHByZWMgPSB0eXBlcyQxLmxvZ2ljYWxBTkQuYmlub3A7XG4gICAgICB9XG4gICAgICB2YXIgb3AgPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICB2YXIgcmlnaHQgPSB0aGlzLnBhcnNlRXhwck9wKHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIGZhbHNlLCBmYWxzZSwgZm9ySW5pdCksIHN0YXJ0UG9zLCBzdGFydExvYywgcHJlYywgZm9ySW5pdCk7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuYnVpbGRCaW5hcnkobGVmdFN0YXJ0UG9zLCBsZWZ0U3RhcnRMb2MsIGxlZnQsIHJpZ2h0LCBvcCwgbG9naWNhbCB8fCBjb2FsZXNjZSk7XG4gICAgICBpZiAoKGxvZ2ljYWwgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLmNvYWxlc2NlKSB8fCAoY29hbGVzY2UgJiYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5sb2dpY2FsT1IgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLmxvZ2ljYWxBTkQpKSkge1xuICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJMb2dpY2FsIGV4cHJlc3Npb25zIGFuZCBjb2FsZXNjZSBleHByZXNzaW9ucyBjYW5ub3QgYmUgbWl4ZWQuIFdyYXAgZWl0aGVyIGJ5IHBhcmVudGhlc2VzXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHByT3Aobm9kZSwgbGVmdFN0YXJ0UG9zLCBsZWZ0U3RhcnRMb2MsIG1pblByZWMsIGZvckluaXQpXG4gICAgfVxuICB9XG4gIHJldHVybiBsZWZ0XG59O1xuXG5wcCQ1LmJ1aWxkQmluYXJ5ID0gZnVuY3Rpb24oc3RhcnRQb3MsIHN0YXJ0TG9jLCBsZWZ0LCByaWdodCwgb3AsIGxvZ2ljYWwpIHtcbiAgaWYgKHJpZ2h0LnR5cGUgPT09IFwiUHJpdmF0ZUlkZW50aWZpZXJcIikgeyB0aGlzLnJhaXNlKHJpZ2h0LnN0YXJ0LCBcIlByaXZhdGUgaWRlbnRpZmllciBjYW4gb25seSBiZSBsZWZ0IHNpZGUgb2YgYmluYXJ5IGV4cHJlc3Npb25cIik7IH1cbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gIG5vZGUubGVmdCA9IGxlZnQ7XG4gIG5vZGUub3BlcmF0b3IgPSBvcDtcbiAgbm9kZS5yaWdodCA9IHJpZ2h0O1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGxvZ2ljYWwgPyBcIkxvZ2ljYWxFeHByZXNzaW9uXCIgOiBcIkJpbmFyeUV4cHJlc3Npb25cIilcbn07XG5cbi8vIFBhcnNlIHVuYXJ5IG9wZXJhdG9ycywgYm90aCBwcmVmaXggYW5kIHBvc3RmaXguXG5cbnBwJDUucGFyc2VNYXliZVVuYXJ5ID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgc2F3VW5hcnksIGluY0RlYywgZm9ySW5pdCkge1xuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2MsIGV4cHI7XG4gIGlmICh0aGlzLmlzQ29udGV4dHVhbChcImF3YWl0XCIpICYmIHRoaXMuY2FuQXdhaXQpIHtcbiAgICBleHByID0gdGhpcy5wYXJzZUF3YWl0KGZvckluaXQpO1xuICAgIHNhd1VuYXJ5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnR5cGUucHJlZml4KSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCB1cGRhdGUgPSB0aGlzLnR5cGUgPT09IHR5cGVzJDEuaW5jRGVjO1xuICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnZhbHVlO1xuICAgIG5vZGUucHJlZml4ID0gdHJ1ZTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgdHJ1ZSwgdXBkYXRlLCBmb3JJbml0KTtcbiAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgICBpZiAodXBkYXRlKSB7IHRoaXMuY2hlY2tMVmFsU2ltcGxlKG5vZGUuYXJndW1lbnQpOyB9XG4gICAgZWxzZSBpZiAodGhpcy5zdHJpY3QgJiYgbm9kZS5vcGVyYXRvciA9PT0gXCJkZWxldGVcIiAmJiBpc0xvY2FsVmFyaWFibGVBY2Nlc3Mobm9kZS5hcmd1bWVudCkpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIkRlbGV0aW5nIGxvY2FsIHZhcmlhYmxlIGluIHN0cmljdCBtb2RlXCIpOyB9XG4gICAgZWxzZSBpZiAobm9kZS5vcGVyYXRvciA9PT0gXCJkZWxldGVcIiAmJiBpc1ByaXZhdGVGaWVsZEFjY2Vzcyhub2RlLmFyZ3VtZW50KSlcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiUHJpdmF0ZSBmaWVsZHMgY2FuIG5vdCBiZSBkZWxldGVkXCIpOyB9XG4gICAgZWxzZSB7IHNhd1VuYXJ5ID0gdHJ1ZTsgfVxuICAgIGV4cHIgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgdXBkYXRlID8gXCJVcGRhdGVFeHByZXNzaW9uXCIgOiBcIlVuYXJ5RXhwcmVzc2lvblwiKTtcbiAgfSBlbHNlIGlmICghc2F3VW5hcnkgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLnByaXZhdGVJZCkge1xuICAgIGlmICgoZm9ySW5pdCB8fCB0aGlzLnByaXZhdGVOYW1lU3RhY2subGVuZ3RoID09PSAwKSAmJiB0aGlzLm9wdGlvbnMuY2hlY2tQcml2YXRlRmllbGRzKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgZXhwciA9IHRoaXMucGFyc2VQcml2YXRlSWRlbnQoKTtcbiAgICAvLyBvbmx5IGNvdWxkIGJlIHByaXZhdGUgZmllbGRzIGluICdpbicsIHN1Y2ggYXMgI3ggaW4gb2JqXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5faW4pIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgfSBlbHNlIHtcbiAgICBleHByID0gdGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGZvckluaXQpO1xuICAgIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSkgeyByZXR1cm4gZXhwciB9XG4gICAgd2hpbGUgKHRoaXMudHlwZS5wb3N0Zml4ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICB2YXIgbm9kZSQxID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZSQxLm9wZXJhdG9yID0gdGhpcy52YWx1ZTtcbiAgICAgIG5vZGUkMS5wcmVmaXggPSBmYWxzZTtcbiAgICAgIG5vZGUkMS5hcmd1bWVudCA9IGV4cHI7XG4gICAgICB0aGlzLmNoZWNrTFZhbFNpbXBsZShleHByKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgZXhwciA9IHRoaXMuZmluaXNoTm9kZShub2RlJDEsIFwiVXBkYXRlRXhwcmVzc2lvblwiKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWluY0RlYyAmJiB0aGlzLmVhdCh0eXBlcyQxLnN0YXJzdGFyKSkge1xuICAgIGlmIChzYXdVbmFyeSlcbiAgICAgIHsgdGhpcy51bmV4cGVjdGVkKHRoaXMubGFzdFRva1N0YXJ0KTsgfVxuICAgIGVsc2VcbiAgICAgIHsgcmV0dXJuIHRoaXMuYnVpbGRCaW5hcnkoc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByLCB0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCBmYWxzZSwgZmFsc2UsIGZvckluaXQpLCBcIioqXCIsIGZhbHNlKSB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGV4cHJcbiAgfVxufTtcblxuZnVuY3Rpb24gaXNMb2NhbFZhcmlhYmxlQWNjZXNzKG5vZGUpIHtcbiAgcmV0dXJuIChcbiAgICBub2RlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiIHx8XG4gICAgbm9kZS50eXBlID09PSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIgJiYgaXNMb2NhbFZhcmlhYmxlQWNjZXNzKG5vZGUuZXhwcmVzc2lvbilcbiAgKVxufVxuXG5mdW5jdGlvbiBpc1ByaXZhdGVGaWVsZEFjY2Vzcyhub2RlKSB7XG4gIHJldHVybiAoXG4gICAgbm9kZS50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiAmJiBub2RlLnByb3BlcnR5LnR5cGUgPT09IFwiUHJpdmF0ZUlkZW50aWZpZXJcIiB8fFxuICAgIG5vZGUudHlwZSA9PT0gXCJDaGFpbkV4cHJlc3Npb25cIiAmJiBpc1ByaXZhdGVGaWVsZEFjY2Vzcyhub2RlLmV4cHJlc3Npb24pIHx8XG4gICAgbm9kZS50eXBlID09PSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIgJiYgaXNQcml2YXRlRmllbGRBY2Nlc3Mobm9kZS5leHByZXNzaW9uKVxuICApXG59XG5cbi8vIFBhcnNlIGNhbGwsIGRvdCwgYW5kIGBbXWAtc3Vic2NyaXB0IGV4cHJlc3Npb25zLlxuXG5wcCQ1LnBhcnNlRXhwclN1YnNjcmlwdHMgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmb3JJbml0KSB7XG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwckF0b20ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZm9ySW5pdCk7XG4gIGlmIChleHByLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiAmJiB0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva1N0YXJ0LCB0aGlzLmxhc3RUb2tFbmQpICE9PSBcIilcIilcbiAgICB7IHJldHVybiBleHByIH1cbiAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VTdWJzY3JpcHRzKGV4cHIsIHN0YXJ0UG9zLCBzdGFydExvYywgZmFsc2UsIGZvckluaXQpO1xuICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyAmJiByZXN1bHQudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID49IHJlc3VsdC5zdGFydCkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSAtMTsgfVxuICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kID49IHJlc3VsdC5zdGFydCkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kID0gLTE7IH1cbiAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID49IHJlc3VsdC5zdGFydCkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSAtMTsgfVxuICB9XG4gIHJldHVybiByZXN1bHRcbn07XG5cbnBwJDUucGFyc2VTdWJzY3JpcHRzID0gZnVuY3Rpb24oYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzLCBmb3JJbml0KSB7XG4gIHZhciBtYXliZUFzeW5jQXJyb3cgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiBiYXNlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGJhc2UubmFtZSA9PT0gXCJhc3luY1wiICYmXG4gICAgICB0aGlzLmxhc3RUb2tFbmQgPT09IGJhc2UuZW5kICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIGJhc2UuZW5kIC0gYmFzZS5zdGFydCA9PT0gNSAmJlxuICAgICAgdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID09PSBiYXNlLnN0YXJ0O1xuICB2YXIgb3B0aW9uYWxDaGFpbmVkID0gZmFsc2U7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMucGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzLCBtYXliZUFzeW5jQXJyb3csIG9wdGlvbmFsQ2hhaW5lZCwgZm9ySW5pdCk7XG5cbiAgICBpZiAoZWxlbWVudC5vcHRpb25hbCkgeyBvcHRpb25hbENoYWluZWQgPSB0cnVlOyB9XG4gICAgaWYgKGVsZW1lbnQgPT09IGJhc2UgfHwgZWxlbWVudC50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpIHtcbiAgICAgIGlmIChvcHRpb25hbENoYWluZWQpIHtcbiAgICAgICAgdmFyIGNoYWluTm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgICAgY2hhaW5Ob2RlLmV4cHJlc3Npb24gPSBlbGVtZW50O1xuICAgICAgICBlbGVtZW50ID0gdGhpcy5maW5pc2hOb2RlKGNoYWluTm9kZSwgXCJDaGFpbkV4cHJlc3Npb25cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudFxuICAgIH1cblxuICAgIGJhc2UgPSBlbGVtZW50O1xuICB9XG59O1xuXG5wcCQ1LnNob3VsZFBhcnNlQXN5bmNBcnJvdyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgdGhpcy5lYXQodHlwZXMkMS5hcnJvdylcbn07XG5cbnBwJDUucGFyc2VTdWJzY3JpcHRBc3luY0Fycm93ID0gZnVuY3Rpb24oc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByTGlzdCwgZm9ySW5pdCkge1xuICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIGV4cHJMaXN0LCB0cnVlLCBmb3JJbml0KVxufTtcblxucHAkNS5wYXJzZVN1YnNjcmlwdCA9IGZ1bmN0aW9uKGJhc2UsIHN0YXJ0UG9zLCBzdGFydExvYywgbm9DYWxscywgbWF5YmVBc3luY0Fycm93LCBvcHRpb25hbENoYWluZWQsIGZvckluaXQpIHtcbiAgdmFyIG9wdGlvbmFsU3VwcG9ydGVkID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExO1xuICB2YXIgb3B0aW9uYWwgPSBvcHRpb25hbFN1cHBvcnRlZCAmJiB0aGlzLmVhdCh0eXBlcyQxLnF1ZXN0aW9uRG90KTtcbiAgaWYgKG5vQ2FsbHMgJiYgb3B0aW9uYWwpIHsgdGhpcy5yYWlzZSh0aGlzLmxhc3RUb2tTdGFydCwgXCJPcHRpb25hbCBjaGFpbmluZyBjYW5ub3QgYXBwZWFyIGluIHRoZSBjYWxsZWUgb2YgbmV3IGV4cHJlc3Npb25zXCIpOyB9XG5cbiAgdmFyIGNvbXB1dGVkID0gdGhpcy5lYXQodHlwZXMkMS5icmFja2V0TCk7XG4gIGlmIChjb21wdXRlZCB8fCAob3B0aW9uYWwgJiYgdGhpcy50eXBlICE9PSB0eXBlcyQxLnBhcmVuTCAmJiB0aGlzLnR5cGUgIT09IHR5cGVzJDEuYmFja1F1b3RlKSB8fCB0aGlzLmVhdCh0eXBlcyQxLmRvdCkpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlLm9iamVjdCA9IGJhc2U7XG4gICAgaWYgKGNvbXB1dGVkKSB7XG4gICAgICBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuYnJhY2tldFIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnByaXZhdGVJZCAmJiBiYXNlLnR5cGUgIT09IFwiU3VwZXJcIikge1xuICAgICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VQcml2YXRlSWRlbnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudCh0aGlzLm9wdGlvbnMuYWxsb3dSZXNlcnZlZCAhPT0gXCJuZXZlclwiKTtcbiAgICB9XG4gICAgbm9kZS5jb21wdXRlZCA9ICEhY29tcHV0ZWQ7XG4gICAgaWYgKG9wdGlvbmFsU3VwcG9ydGVkKSB7XG4gICAgICBub2RlLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgfVxuICAgIGJhc2UgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIpO1xuICB9IGVsc2UgaWYgKCFub0NhbGxzICYmIHRoaXMuZWF0KHR5cGVzJDEucGFyZW5MKSkge1xuICAgIHZhciByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID0gbmV3IERlc3RydWN0dXJpbmdFcnJvcnMsIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBvbGRBd2FpdElkZW50UG9zID0gdGhpcy5hd2FpdElkZW50UG9zO1xuICAgIHRoaXMueWllbGRQb3MgPSAwO1xuICAgIHRoaXMuYXdhaXRQb3MgPSAwO1xuICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG4gICAgdmFyIGV4cHJMaXN0ID0gdGhpcy5wYXJzZUV4cHJMaXN0KHR5cGVzJDEucGFyZW5SLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCwgZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIGlmIChtYXliZUFzeW5jQXJyb3cgJiYgIW9wdGlvbmFsICYmIHRoaXMuc2hvdWxkUGFyc2VBc3luY0Fycm93KCkpIHtcbiAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGZhbHNlKTtcbiAgICAgIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG4gICAgICBpZiAodGhpcy5hd2FpdElkZW50UG9zID4gMClcbiAgICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuYXdhaXRJZGVudFBvcywgXCJDYW5ub3QgdXNlICdhd2FpdCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cIik7IH1cbiAgICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3M7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVN1YnNjcmlwdEFzeW5jQXJyb3coc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByTGlzdCwgZm9ySW5pdClcbiAgICB9XG4gICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gICAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zIHx8IHRoaXMueWllbGRQb3M7XG4gICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zIHx8IHRoaXMuYXdhaXRQb3M7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gb2xkQXdhaXRJZGVudFBvcyB8fCB0aGlzLmF3YWl0SWRlbnRQb3M7XG4gICAgdmFyIG5vZGUkMSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlJDEuY2FsbGVlID0gYmFzZTtcbiAgICBub2RlJDEuYXJndW1lbnRzID0gZXhwckxpc3Q7XG4gICAgaWYgKG9wdGlvbmFsU3VwcG9ydGVkKSB7XG4gICAgICBub2RlJDEub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICB9XG4gICAgYmFzZSA9IHRoaXMuZmluaXNoTm9kZShub2RlJDEsIFwiQ2FsbEV4cHJlc3Npb25cIik7XG4gIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmJhY2tRdW90ZSkge1xuICAgIGlmIChvcHRpb25hbCB8fCBvcHRpb25hbENoYWluZWQpIHtcbiAgICAgIHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJPcHRpb25hbCBjaGFpbmluZyBjYW5ub3QgYXBwZWFyIGluIHRoZSB0YWcgb2YgdGFnZ2VkIHRlbXBsYXRlIGV4cHJlc3Npb25zXCIpO1xuICAgIH1cbiAgICB2YXIgbm9kZSQyID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUkMi50YWcgPSBiYXNlO1xuICAgIG5vZGUkMi5xdWFzaSA9IHRoaXMucGFyc2VUZW1wbGF0ZSh7aXNUYWdnZWQ6IHRydWV9KTtcbiAgICBiYXNlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUkMiwgXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIik7XG4gIH1cbiAgcmV0dXJuIGJhc2Vcbn07XG5cbi8vIFBhcnNlIGFuIGF0b21pYyBleHByZXNzaW9uIOKAlCBlaXRoZXIgYSBzaW5nbGUgdG9rZW4gdGhhdCBpcyBhblxuLy8gZXhwcmVzc2lvbiwgYW4gZXhwcmVzc2lvbiBzdGFydGVkIGJ5IGEga2V5d29yZCBsaWtlIGBmdW5jdGlvbmAgb3Jcbi8vIGBuZXdgLCBvciBhbiBleHByZXNzaW9uIHdyYXBwZWQgaW4gcHVuY3R1YXRpb24gbGlrZSBgKClgLCBgW11gLFxuLy8gb3IgYHt9YC5cblxucHAkNS5wYXJzZUV4cHJBdG9tID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZm9ySW5pdCwgZm9yTmV3KSB7XG4gIC8vIElmIGEgZGl2aXNpb24gb3BlcmF0b3IgYXBwZWFycyBpbiBhbiBleHByZXNzaW9uIHBvc2l0aW9uLCB0aGVcbiAgLy8gdG9rZW5pemVyIGdvdCBjb25mdXNlZCwgYW5kIHdlIGZvcmNlIGl0IHRvIHJlYWQgYSByZWdleHAgaW5zdGVhZC5cbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zbGFzaCkgeyB0aGlzLnJlYWRSZWdleHAoKTsgfVxuXG4gIHZhciBub2RlLCBjYW5CZUFycm93ID0gdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID09PSB0aGlzLnN0YXJ0O1xuICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICBjYXNlIHR5cGVzJDEuX3N1cGVyOlxuICAgIGlmICghdGhpcy5hbGxvd1N1cGVyKVxuICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ3N1cGVyJyBrZXl3b3JkIG91dHNpZGUgYSBtZXRob2RcIik7IH1cbiAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnBhcmVuTCAmJiAhdGhpcy5hbGxvd0RpcmVjdFN1cGVyKVxuICAgICAgeyB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwic3VwZXIoKSBjYWxsIG91dHNpZGUgY29uc3RydWN0b3Igb2YgYSBzdWJjbGFzc1wiKTsgfVxuICAgIC8vIFRoZSBgc3VwZXJgIGtleXdvcmQgY2FuIGFwcGVhciBhdCBiZWxvdzpcbiAgICAvLyBTdXBlclByb3BlcnR5OlxuICAgIC8vICAgICBzdXBlciBbIEV4cHJlc3Npb24gXVxuICAgIC8vICAgICBzdXBlciAuIElkZW50aWZpZXJOYW1lXG4gICAgLy8gU3VwZXJDYWxsOlxuICAgIC8vICAgICBzdXBlciAoIEFyZ3VtZW50cyApXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5kb3QgJiYgdGhpcy50eXBlICE9PSB0eXBlcyQxLmJyYWNrZXRMICYmIHRoaXMudHlwZSAhPT0gdHlwZXMkMS5wYXJlbkwpXG4gICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlN1cGVyXCIpXG5cbiAgY2FzZSB0eXBlcyQxLl90aGlzOlxuICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUaGlzRXhwcmVzc2lvblwiKVxuXG4gIGNhc2UgdHlwZXMkMS5uYW1lOlxuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYywgY29udGFpbnNFc2MgPSB0aGlzLmNvbnRhaW5zRXNjO1xuICAgIHZhciBpZCA9IHRoaXMucGFyc2VJZGVudChmYWxzZSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmICFjb250YWluc0VzYyAmJiBpZC5uYW1lID09PSBcImFzeW5jXCIgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgdGhpcy5lYXQodHlwZXMkMS5fZnVuY3Rpb24pKSB7XG4gICAgICB0aGlzLm92ZXJyaWRlQ29udGV4dCh0eXBlcy5mX2V4cHIpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIDAsIGZhbHNlLCB0cnVlLCBmb3JJbml0KVxuICAgIH1cbiAgICBpZiAoY2FuQmVBcnJvdyAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzJDEuYXJyb3cpKVxuICAgICAgICB7IHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgW2lkXSwgZmFsc2UsIGZvckluaXQpIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiBpZC5uYW1lID09PSBcImFzeW5jXCIgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLm5hbWUgJiYgIWNvbnRhaW5zRXNjICYmXG4gICAgICAgICAgKCF0aGlzLnBvdGVudGlhbEFycm93SW5Gb3JBd2FpdCB8fCB0aGlzLnZhbHVlICE9PSBcIm9mXCIgfHwgdGhpcy5jb250YWluc0VzYykpIHtcbiAgICAgICAgaWQgPSB0aGlzLnBhcnNlSWRlbnQoZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSB8fCAhdGhpcy5lYXQodHlwZXMkMS5hcnJvdykpXG4gICAgICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIFtpZF0sIHRydWUsIGZvckluaXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpZFxuXG4gIGNhc2UgdHlwZXMkMS5yZWdleHA6XG4gICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICBub2RlID0gdGhpcy5wYXJzZUxpdGVyYWwodmFsdWUudmFsdWUpO1xuICAgIG5vZGUucmVnZXggPSB7cGF0dGVybjogdmFsdWUucGF0dGVybiwgZmxhZ3M6IHZhbHVlLmZsYWdzfTtcbiAgICByZXR1cm4gbm9kZVxuXG4gIGNhc2UgdHlwZXMkMS5udW06IGNhc2UgdHlwZXMkMS5zdHJpbmc6XG4gICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsKHRoaXMudmFsdWUpXG5cbiAgY2FzZSB0eXBlcyQxLl9udWxsOiBjYXNlIHR5cGVzJDEuX3RydWU6IGNhc2UgdHlwZXMkMS5fZmFsc2U6XG4gICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS52YWx1ZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5fbnVsbCA/IG51bGwgOiB0aGlzLnR5cGUgPT09IHR5cGVzJDEuX3RydWU7XG4gICAgbm9kZS5yYXcgPSB0aGlzLnR5cGUua2V5d29yZDtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTGl0ZXJhbFwiKVxuXG4gIGNhc2UgdHlwZXMkMS5wYXJlbkw6XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydCwgZXhwciA9IHRoaXMucGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbihjYW5CZUFycm93LCBmb3JJbml0KTtcbiAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA8IDAgJiYgIXRoaXMuaXNTaW1wbGVBc3NpZ25UYXJnZXQoZXhwcikpXG4gICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gc3RhcnQ7IH1cbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kIDwgMClcbiAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kID0gc3RhcnQ7IH1cbiAgICB9XG4gICAgcmV0dXJuIGV4cHJcblxuICBjYXNlIHR5cGVzJDEuYnJhY2tldEw6XG4gICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5lbGVtZW50cyA9IHRoaXMucGFyc2VFeHByTGlzdCh0eXBlcyQxLmJyYWNrZXRSLCB0cnVlLCB0cnVlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyYXlFeHByZXNzaW9uXCIpXG5cbiAgY2FzZSB0eXBlcyQxLmJyYWNlTDpcbiAgICB0aGlzLm92ZXJyaWRlQ29udGV4dCh0eXBlcy5iX2V4cHIpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlT2JqKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKVxuXG4gIGNhc2UgdHlwZXMkMS5fZnVuY3Rpb246XG4gICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihub2RlLCAwKVxuXG4gIGNhc2UgdHlwZXMkMS5fY2xhc3M6XG4gICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzcyh0aGlzLnN0YXJ0Tm9kZSgpLCBmYWxzZSlcblxuICBjYXNlIHR5cGVzJDEuX25ldzpcbiAgICByZXR1cm4gdGhpcy5wYXJzZU5ldygpXG5cbiAgY2FzZSB0eXBlcyQxLmJhY2tRdW90ZTpcbiAgICByZXR1cm4gdGhpcy5wYXJzZVRlbXBsYXRlKClcblxuICBjYXNlIHR5cGVzJDEuX2ltcG9ydDpcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJJbXBvcnQoZm9yTmV3KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy51bmV4cGVjdGVkKClcbiAgICB9XG5cbiAgZGVmYXVsdDpcbiAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJBdG9tRGVmYXVsdCgpXG4gIH1cbn07XG5cbnBwJDUucGFyc2VFeHByQXRvbURlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy51bmV4cGVjdGVkKCk7XG59O1xuXG5wcCQ1LnBhcnNlRXhwckltcG9ydCA9IGZ1bmN0aW9uKGZvck5ldykge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG5cbiAgLy8gQ29uc3VtZSBgaW1wb3J0YCBhcyBhbiBpZGVudGlmaWVyIGZvciBgaW1wb3J0Lm1ldGFgLlxuICAvLyBCZWNhdXNlIGB0aGlzLnBhcnNlSWRlbnQodHJ1ZSlgIGRvZXNuJ3QgY2hlY2sgZXNjYXBlIHNlcXVlbmNlcywgaXQgbmVlZHMgdGhlIGNoZWNrIG9mIGB0aGlzLmNvbnRhaW5zRXNjYC5cbiAgaWYgKHRoaXMuY29udGFpbnNFc2MpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiRXNjYXBlIHNlcXVlbmNlIGluIGtleXdvcmQgaW1wb3J0XCIpOyB9XG4gIHRoaXMubmV4dCgpO1xuXG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEucGFyZW5MICYmICFmb3JOZXcpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUR5bmFtaWNJbXBvcnQobm9kZSlcbiAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuZG90KSB7XG4gICAgdmFyIG1ldGEgPSB0aGlzLnN0YXJ0Tm9kZUF0KG5vZGUuc3RhcnQsIG5vZGUubG9jICYmIG5vZGUubG9jLnN0YXJ0KTtcbiAgICBtZXRhLm5hbWUgPSBcImltcG9ydFwiO1xuICAgIG5vZGUubWV0YSA9IHRoaXMuZmluaXNoTm9kZShtZXRhLCBcIklkZW50aWZpZXJcIik7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VJbXBvcnRNZXRhKG5vZGUpXG4gIH0gZWxzZSB7XG4gICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH1cbn07XG5cbnBwJDUucGFyc2VEeW5hbWljSW1wb3J0ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTsgLy8gc2tpcCBgKGBcblxuICAvLyBQYXJzZSBub2RlLnNvdXJjZS5cbiAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcblxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDE2KSB7XG4gICAgaWYgKCF0aGlzLmVhdCh0eXBlcyQxLnBhcmVuUikpIHtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuY29tbWEpO1xuICAgICAgaWYgKCF0aGlzLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcyQxLnBhcmVuUikpIHtcbiAgICAgICAgbm9kZS5vcHRpb25zID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICAgIGlmICghdGhpcy5lYXQodHlwZXMkMS5wYXJlblIpKSB7XG4gICAgICAgICAgdGhpcy5leHBlY3QodHlwZXMkMS5jb21tYSk7XG4gICAgICAgICAgaWYgKCF0aGlzLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcyQxLnBhcmVuUikpIHtcbiAgICAgICAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5vcHRpb25zID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5vcHRpb25zID0gbnVsbDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVmVyaWZ5IGVuZGluZy5cbiAgICBpZiAoIXRoaXMuZWF0KHR5cGVzJDEucGFyZW5SKSkge1xuICAgICAgdmFyIGVycm9yUG9zID0gdGhpcy5zdGFydDtcbiAgICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLmNvbW1hKSAmJiB0aGlzLmVhdCh0eXBlcyQxLnBhcmVuUikpIHtcbiAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGVycm9yUG9zLCBcIlRyYWlsaW5nIGNvbW1hIGlzIG5vdCBhbGxvd2VkIGluIGltcG9ydCgpXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKGVycm9yUG9zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RXhwcmVzc2lvblwiKVxufTtcblxucHAkNS5wYXJzZUltcG9ydE1ldGEgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpOyAvLyBza2lwIGAuYFxuXG4gIHZhciBjb250YWluc0VzYyA9IHRoaXMuY29udGFpbnNFc2M7XG4gIG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlSWRlbnQodHJ1ZSk7XG5cbiAgaWYgKG5vZGUucHJvcGVydHkubmFtZSAhPT0gXCJtZXRhXCIpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5wcm9wZXJ0eS5zdGFydCwgXCJUaGUgb25seSB2YWxpZCBtZXRhIHByb3BlcnR5IGZvciBpbXBvcnQgaXMgJ2ltcG9ydC5tZXRhJ1wiKTsgfVxuICBpZiAoY29udGFpbnNFc2MpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCInaW1wb3J0Lm1ldGEnIG11c3Qgbm90IGNvbnRhaW4gZXNjYXBlZCBjaGFyYWN0ZXJzXCIpOyB9XG4gIGlmICh0aGlzLm9wdGlvbnMuc291cmNlVHlwZSAhPT0gXCJtb2R1bGVcIiAmJiAhdGhpcy5vcHRpb25zLmFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZSlcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIkNhbm5vdCB1c2UgJ2ltcG9ydC5tZXRhJyBvdXRzaWRlIGEgbW9kdWxlXCIpOyB9XG5cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1ldGFQcm9wZXJ0eVwiKVxufTtcblxucHAkNS5wYXJzZUxpdGVyYWwgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIG5vZGUudmFsdWUgPSB2YWx1ZTtcbiAgbm9kZS5yYXcgPSB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgaWYgKG5vZGUucmF3LmNoYXJDb2RlQXQobm9kZS5yYXcubGVuZ3RoIC0gMSkgPT09IDExMCkgeyBub2RlLmJpZ2ludCA9IG5vZGUucmF3LnNsaWNlKDAsIC0xKS5yZXBsYWNlKC9fL2csIFwiXCIpOyB9XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTGl0ZXJhbFwiKVxufTtcblxucHAkNS5wYXJzZVBhcmVuRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmV4cGVjdCh0eXBlcyQxLnBhcmVuTCk7XG4gIHZhciB2YWwgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICB0aGlzLmV4cGVjdCh0eXBlcyQxLnBhcmVuUik7XG4gIHJldHVybiB2YWxcbn07XG5cbnBwJDUuc2hvdWxkUGFyc2VBcnJvdyA9IGZ1bmN0aW9uKGV4cHJMaXN0KSB7XG4gIHJldHVybiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKVxufTtcblxucHAkNS5wYXJzZVBhcmVuQW5kRGlzdGluZ3Vpc2hFeHByZXNzaW9uID0gZnVuY3Rpb24oY2FuQmVBcnJvdywgZm9ySW5pdCkge1xuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2MsIHZhbCwgYWxsb3dUcmFpbGluZ0NvbW1hID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDg7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgIHRoaXMubmV4dCgpO1xuXG4gICAgdmFyIGlubmVyU3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBpbm5lclN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICB2YXIgZXhwckxpc3QgPSBbXSwgZmlyc3QgPSB0cnVlLCBsYXN0SXNDb21tYSA9IGZhbHNlO1xuICAgIHZhciByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID0gbmV3IERlc3RydWN0dXJpbmdFcnJvcnMsIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBzcHJlYWRTdGFydDtcbiAgICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgICAvLyBEbyBub3Qgc2F2ZSBhd2FpdElkZW50UG9zIHRvIGFsbG93IGNoZWNraW5nIGF3YWl0cyBuZXN0ZWQgaW4gcGFyYW1ldGVyc1xuICAgIHdoaWxlICh0aGlzLnR5cGUgIT09IHR5cGVzJDEucGFyZW5SKSB7XG4gICAgICBmaXJzdCA/IGZpcnN0ID0gZmFsc2UgOiB0aGlzLmV4cGVjdCh0eXBlcyQxLmNvbW1hKTtcbiAgICAgIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMkMS5wYXJlblIsIHRydWUpKSB7XG4gICAgICAgIGxhc3RJc0NvbW1hID0gdHJ1ZTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmVsbGlwc2lzKSB7XG4gICAgICAgIHNwcmVhZFN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgICAgZXhwckxpc3QucHVzaCh0aGlzLnBhcnNlUGFyZW5JdGVtKHRoaXMucGFyc2VSZXN0QmluZGluZygpKSk7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuY29tbWEpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoXG4gICAgICAgICAgICB0aGlzLnN0YXJ0LFxuICAgICAgICAgICAgXCJDb21tYSBpcyBub3QgcGVybWl0dGVkIGFmdGVyIHRoZSByZXN0IGVsZW1lbnRcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4cHJMaXN0LnB1c2godGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0aGlzLnBhcnNlUGFyZW5JdGVtKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBpbm5lckVuZFBvcyA9IHRoaXMubGFzdFRva0VuZCwgaW5uZXJFbmRMb2MgPSB0aGlzLmxhc3RUb2tFbmRMb2M7XG4gICAgdGhpcy5leHBlY3QodHlwZXMkMS5wYXJlblIpO1xuXG4gICAgaWYgKGNhbkJlQXJyb3cgJiYgdGhpcy5zaG91bGRQYXJzZUFycm93KGV4cHJMaXN0KSAmJiB0aGlzLmVhdCh0eXBlcyQxLmFycm93KSkge1xuICAgICAgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZmFsc2UpO1xuICAgICAgdGhpcy5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKTtcbiAgICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlUGFyZW5BcnJvd0xpc3Qoc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByTGlzdCwgZm9ySW5pdClcbiAgICB9XG5cbiAgICBpZiAoIWV4cHJMaXN0Lmxlbmd0aCB8fCBsYXN0SXNDb21tYSkgeyB0aGlzLnVuZXhwZWN0ZWQodGhpcy5sYXN0VG9rU3RhcnQpOyB9XG4gICAgaWYgKHNwcmVhZFN0YXJ0KSB7IHRoaXMudW5leHBlY3RlZChzcHJlYWRTdGFydCk7IH1cbiAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3MgfHwgdGhpcy55aWVsZFBvcztcbiAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3MgfHwgdGhpcy5hd2FpdFBvcztcblxuICAgIGlmIChleHByTGlzdC5sZW5ndGggPiAxKSB7XG4gICAgICB2YWwgPSB0aGlzLnN0YXJ0Tm9kZUF0KGlubmVyU3RhcnRQb3MsIGlubmVyU3RhcnRMb2MpO1xuICAgICAgdmFsLmV4cHJlc3Npb25zID0gZXhwckxpc3Q7XG4gICAgICB0aGlzLmZpbmlzaE5vZGVBdCh2YWwsIFwiU2VxdWVuY2VFeHByZXNzaW9uXCIsIGlubmVyRW5kUG9zLCBpbm5lckVuZExvYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbCA9IGV4cHJMaXN0WzBdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWwgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLnByZXNlcnZlUGFyZW5zKSB7XG4gICAgdmFyIHBhciA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBwYXIuZXhwcmVzc2lvbiA9IHZhbDtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHBhciwgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWxcbiAgfVxufTtcblxucHAkNS5wYXJzZVBhcmVuSXRlbSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgcmV0dXJuIGl0ZW1cbn07XG5cbnBwJDUucGFyc2VQYXJlbkFycm93TGlzdCA9IGZ1bmN0aW9uKHN0YXJ0UG9zLCBzdGFydExvYywgZXhwckxpc3QsIGZvckluaXQpIHtcbiAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBleHByTGlzdCwgZmFsc2UsIGZvckluaXQpXG59O1xuXG4vLyBOZXcncyBwcmVjZWRlbmNlIGlzIHNsaWdodGx5IHRyaWNreS4gSXQgbXVzdCBhbGxvdyBpdHMgYXJndW1lbnQgdG9cbi8vIGJlIGEgYFtdYCBvciBkb3Qgc3Vic2NyaXB0IGV4cHJlc3Npb24sIGJ1dCBub3QgYSBjYWxsIOKAlCBhdCBsZWFzdCxcbi8vIG5vdCB3aXRob3V0IHdyYXBwaW5nIGl0IGluIHBhcmVudGhlc2VzLiBUaHVzLCBpdCB1c2VzIHRoZSBub0NhbGxzXG4vLyBhcmd1bWVudCB0byBwYXJzZVN1YnNjcmlwdHMgdG8gcHJldmVudCBpdCBmcm9tIGNvbnN1bWluZyB0aGVcbi8vIGFyZ3VtZW50IGxpc3QuXG5cbnZhciBlbXB0eSA9IFtdO1xuXG5wcCQ1LnBhcnNlTmV3ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmNvbnRhaW5zRXNjKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCBcIkVzY2FwZSBzZXF1ZW5jZSBpbiBrZXl3b3JkIG5ld1wiKTsgfVxuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dCgpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLmRvdCkge1xuICAgIHZhciBtZXRhID0gdGhpcy5zdGFydE5vZGVBdChub2RlLnN0YXJ0LCBub2RlLmxvYyAmJiBub2RlLmxvYy5zdGFydCk7XG4gICAgbWV0YS5uYW1lID0gXCJuZXdcIjtcbiAgICBub2RlLm1ldGEgPSB0aGlzLmZpbmlzaE5vZGUobWV0YSwgXCJJZGVudGlmaWVyXCIpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHZhciBjb250YWluc0VzYyA9IHRoaXMuY29udGFpbnNFc2M7XG4gICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcbiAgICBpZiAobm9kZS5wcm9wZXJ0eS5uYW1lICE9PSBcInRhcmdldFwiKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5wcm9wZXJ0eS5zdGFydCwgXCJUaGUgb25seSB2YWxpZCBtZXRhIHByb3BlcnR5IGZvciBuZXcgaXMgJ25ldy50YXJnZXQnXCIpOyB9XG4gICAgaWYgKGNvbnRhaW5zRXNjKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCInbmV3LnRhcmdldCcgbXVzdCBub3QgY29udGFpbiBlc2NhcGVkIGNoYXJhY3RlcnNcIik7IH1cbiAgICBpZiAoIXRoaXMuYWxsb3dOZXdEb3RUYXJnZXQpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIiduZXcudGFyZ2V0JyBjYW4gb25seSBiZSB1c2VkIGluIGZ1bmN0aW9ucyBhbmQgY2xhc3Mgc3RhdGljIGJsb2NrXCIpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1ldGFQcm9wZXJ0eVwiKVxuICB9XG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgbm9kZS5jYWxsZWUgPSB0aGlzLnBhcnNlU3Vic2NyaXB0cyh0aGlzLnBhcnNlRXhwckF0b20obnVsbCwgZmFsc2UsIHRydWUpLCBzdGFydFBvcywgc3RhcnRMb2MsIHRydWUsIGZhbHNlKTtcbiAgaWYgKHRoaXMuZWF0KHR5cGVzJDEucGFyZW5MKSkgeyBub2RlLmFyZ3VtZW50cyA9IHRoaXMucGFyc2VFeHByTGlzdCh0eXBlcyQxLnBhcmVuUiwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgsIGZhbHNlKTsgfVxuICBlbHNlIHsgbm9kZS5hcmd1bWVudHMgPSBlbXB0eTsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTmV3RXhwcmVzc2lvblwiKVxufTtcblxuLy8gUGFyc2UgdGVtcGxhdGUgZXhwcmVzc2lvbi5cblxucHAkNS5wYXJzZVRlbXBsYXRlRWxlbWVudCA9IGZ1bmN0aW9uKHJlZikge1xuICB2YXIgaXNUYWdnZWQgPSByZWYuaXNUYWdnZWQ7XG5cbiAgdmFyIGVsZW0gPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmludmFsaWRUZW1wbGF0ZSkge1xuICAgIGlmICghaXNUYWdnZWQpIHtcbiAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCBcIkJhZCBlc2NhcGUgc2VxdWVuY2UgaW4gdW50YWdnZWQgdGVtcGxhdGUgbGl0ZXJhbFwiKTtcbiAgICB9XG4gICAgZWxlbS52YWx1ZSA9IHtcbiAgICAgIHJhdzogdGhpcy52YWx1ZS5yZXBsYWNlKC9cXHJcXG4/L2csIFwiXFxuXCIpLFxuICAgICAgY29va2VkOiBudWxsXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtLnZhbHVlID0ge1xuICAgICAgcmF3OiB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKS5yZXBsYWNlKC9cXHJcXG4/L2csIFwiXFxuXCIpLFxuICAgICAgY29va2VkOiB0aGlzLnZhbHVlXG4gICAgfTtcbiAgfVxuICB0aGlzLm5leHQoKTtcbiAgZWxlbS50YWlsID0gdGhpcy50eXBlID09PSB0eXBlcyQxLmJhY2tRdW90ZTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShlbGVtLCBcIlRlbXBsYXRlRWxlbWVudFwiKVxufTtcblxucHAkNS5wYXJzZVRlbXBsYXRlID0gZnVuY3Rpb24ocmVmKSB7XG4gIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSB7fTtcbiAgdmFyIGlzVGFnZ2VkID0gcmVmLmlzVGFnZ2VkOyBpZiAoIGlzVGFnZ2VkID09PSB2b2lkIDAgKSBpc1RhZ2dlZCA9IGZhbHNlO1xuXG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUuZXhwcmVzc2lvbnMgPSBbXTtcbiAgdmFyIGN1ckVsdCA9IHRoaXMucGFyc2VUZW1wbGF0ZUVsZW1lbnQoe2lzVGFnZ2VkOiBpc1RhZ2dlZH0pO1xuICBub2RlLnF1YXNpcyA9IFtjdXJFbHRdO1xuICB3aGlsZSAoIWN1ckVsdC50YWlsKSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5lb2YpIHsgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJVbnRlcm1pbmF0ZWQgdGVtcGxhdGUgbGl0ZXJhbFwiKTsgfVxuICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuZG9sbGFyQnJhY2VMKTtcbiAgICBub2RlLmV4cHJlc3Npb25zLnB1c2godGhpcy5wYXJzZUV4cHJlc3Npb24oKSk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMkMS5icmFjZVIpO1xuICAgIG5vZGUucXVhc2lzLnB1c2goY3VyRWx0ID0gdGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudCh7aXNUYWdnZWQ6IGlzVGFnZ2VkfSkpO1xuICB9XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGVtcGxhdGVMaXRlcmFsXCIpXG59O1xuXG5wcCQ1LmlzQXN5bmNQcm9wID0gZnVuY3Rpb24ocHJvcCkge1xuICByZXR1cm4gIXByb3AuY29tcHV0ZWQgJiYgcHJvcC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgcHJvcC5rZXkubmFtZSA9PT0gXCJhc3luY1wiICYmXG4gICAgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5uYW1lIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5udW0gfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLnN0cmluZyB8fCB0aGlzLnR5cGUgPT09IHR5cGVzJDEuYnJhY2tldEwgfHwgdGhpcy50eXBlLmtleXdvcmQgfHwgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zdGFyKSkgJiZcbiAgICAhbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKVxufTtcblxuLy8gUGFyc2UgYW4gb2JqZWN0IGxpdGVyYWwgb3IgYmluZGluZyBwYXR0ZXJuLlxuXG5wcCQ1LnBhcnNlT2JqID0gZnVuY3Rpb24oaXNQYXR0ZXJuLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwgZmlyc3QgPSB0cnVlLCBwcm9wSGFzaCA9IHt9O1xuICBub2RlLnByb3BlcnRpZXMgPSBbXTtcbiAgdGhpcy5uZXh0KCk7XG4gIHdoaWxlICghdGhpcy5lYXQodHlwZXMkMS5icmFjZVIpKSB7XG4gICAgaWYgKCFmaXJzdCkge1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMkMS5jb21tYSk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDUgJiYgdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMkMS5icmFjZVIpKSB7IGJyZWFrIH1cbiAgICB9IGVsc2UgeyBmaXJzdCA9IGZhbHNlOyB9XG5cbiAgICB2YXIgcHJvcCA9IHRoaXMucGFyc2VQcm9wZXJ0eShpc1BhdHRlcm4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIGlmICghaXNQYXR0ZXJuKSB7IHRoaXMuY2hlY2tQcm9wQ2xhc2gocHJvcCwgcHJvcEhhc2gsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpOyB9XG4gICAgbm9kZS5wcm9wZXJ0aWVzLnB1c2gocHJvcCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc1BhdHRlcm4gPyBcIk9iamVjdFBhdHRlcm5cIiA6IFwiT2JqZWN0RXhwcmVzc2lvblwiKVxufTtcblxucHAkNS5wYXJzZVByb3BlcnR5ID0gZnVuY3Rpb24oaXNQYXR0ZXJuLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIHZhciBwcm9wID0gdGhpcy5zdGFydE5vZGUoKSwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIHN0YXJ0UG9zLCBzdGFydExvYztcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHRoaXMuZWF0KHR5cGVzJDEuZWxsaXBzaXMpKSB7XG4gICAgaWYgKGlzUGF0dGVybikge1xuICAgICAgcHJvcC5hcmd1bWVudCA9IHRoaXMucGFyc2VJZGVudChmYWxzZSk7XG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmNvbW1hKSB7XG4gICAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCBcIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcCwgXCJSZXN0RWxlbWVudFwiKVxuICAgIH1cbiAgICAvLyBQYXJzZSBhcmd1bWVudC5cbiAgICBwcm9wLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAvLyBUbyBkaXNhbGxvdyB0cmFpbGluZyBjb21tYSB2aWEgYHRoaXMudG9Bc3NpZ25hYmxlKClgLlxuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuY29tbWEgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPCAwKSB7XG4gICAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSB0aGlzLnN0YXJ0O1xuICAgIH1cbiAgICAvLyBGaW5pc2hcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHByb3AsIFwiU3ByZWFkRWxlbWVudFwiKVxuICB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgIHByb3AubWV0aG9kID0gZmFsc2U7XG4gICAgcHJvcC5zaG9ydGhhbmQgPSBmYWxzZTtcbiAgICBpZiAoaXNQYXR0ZXJuIHx8IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgIHN0YXJ0UG9zID0gdGhpcy5zdGFydDtcbiAgICAgIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICB9XG4gICAgaWYgKCFpc1BhdHRlcm4pXG4gICAgICB7IGlzR2VuZXJhdG9yID0gdGhpcy5lYXQodHlwZXMkMS5zdGFyKTsgfVxuICB9XG4gIHZhciBjb250YWluc0VzYyA9IHRoaXMuY29udGFpbnNFc2M7XG4gIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCk7XG4gIGlmICghaXNQYXR0ZXJuICYmICFjb250YWluc0VzYyAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiAhaXNHZW5lcmF0b3IgJiYgdGhpcy5pc0FzeW5jUHJvcChwcm9wKSkge1xuICAgIGlzQXN5bmMgPSB0cnVlO1xuICAgIGlzR2VuZXJhdG9yID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy5lYXQodHlwZXMkMS5zdGFyKTtcbiAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3ApO1xuICB9IGVsc2Uge1xuICAgIGlzQXN5bmMgPSBmYWxzZTtcbiAgfVxuICB0aGlzLnBhcnNlUHJvcGVydHlWYWx1ZShwcm9wLCBpc1BhdHRlcm4sIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBzdGFydFBvcywgc3RhcnRMb2MsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGNvbnRhaW5zRXNjKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wLCBcIlByb3BlcnR5XCIpXG59O1xuXG5wcCQ1LnBhcnNlR2V0dGVyU2V0dGVyID0gZnVuY3Rpb24ocHJvcCkge1xuICB2YXIga2luZCA9IHByb3Aua2V5Lm5hbWU7XG4gIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCk7XG4gIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWV0aG9kKGZhbHNlKTtcbiAgcHJvcC5raW5kID0ga2luZDtcbiAgdmFyIHBhcmFtQ291bnQgPSBwcm9wLmtpbmQgPT09IFwiZ2V0XCIgPyAwIDogMTtcbiAgaWYgKHByb3AudmFsdWUucGFyYW1zLmxlbmd0aCAhPT0gcGFyYW1Db3VudCkge1xuICAgIHZhciBzdGFydCA9IHByb3AudmFsdWUuc3RhcnQ7XG4gICAgaWYgKHByb3Aua2luZCA9PT0gXCJnZXRcIilcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcImdldHRlciBzaG91bGQgaGF2ZSBubyBwYXJhbXNcIik7IH1cbiAgICBlbHNlXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJzZXR0ZXIgc2hvdWxkIGhhdmUgZXhhY3RseSBvbmUgcGFyYW1cIik7IH1cbiAgfSBlbHNlIHtcbiAgICBpZiAocHJvcC5raW5kID09PSBcInNldFwiICYmIHByb3AudmFsdWUucGFyYW1zWzBdLnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIilcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHByb3AudmFsdWUucGFyYW1zWzBdLnN0YXJ0LCBcIlNldHRlciBjYW5ub3QgdXNlIHJlc3QgcGFyYW1zXCIpOyB9XG4gIH1cbn07XG5cbnBwJDUucGFyc2VQcm9wZXJ0eVZhbHVlID0gZnVuY3Rpb24ocHJvcCwgaXNQYXR0ZXJuLCBpc0dlbmVyYXRvciwgaXNBc3luYywgc3RhcnRQb3MsIHN0YXJ0TG9jLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBjb250YWluc0VzYykge1xuICBpZiAoKGlzR2VuZXJhdG9yIHx8IGlzQXN5bmMpICYmIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5jb2xvbilcbiAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG5cbiAgaWYgKHRoaXMuZWF0KHR5cGVzJDEuY29sb24pKSB7XG4gICAgcHJvcC52YWx1ZSA9IGlzUGF0dGVybiA/IHRoaXMucGFyc2VNYXliZURlZmF1bHQodGhpcy5zdGFydCwgdGhpcy5zdGFydExvYykgOiB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIHByb3Aua2luZCA9IFwiaW5pdFwiO1xuICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5wYXJlbkwpIHtcbiAgICBpZiAoaXNQYXR0ZXJuKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgcHJvcC5tZXRob2QgPSB0cnVlO1xuICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWV0aG9kKGlzR2VuZXJhdG9yLCBpc0FzeW5jKTtcbiAgICBwcm9wLmtpbmQgPSBcImluaXRcIjtcbiAgfSBlbHNlIGlmICghaXNQYXR0ZXJuICYmICFjb250YWluc0VzYyAmJlxuICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA1ICYmICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmXG4gICAgICAgICAgICAgKHByb3Aua2V5Lm5hbWUgPT09IFwiZ2V0XCIgfHwgcHJvcC5rZXkubmFtZSA9PT0gXCJzZXRcIikgJiZcbiAgICAgICAgICAgICAodGhpcy50eXBlICE9PSB0eXBlcyQxLmNvbW1hICYmIHRoaXMudHlwZSAhPT0gdHlwZXMkMS5icmFjZVIgJiYgdGhpcy50eXBlICE9PSB0eXBlcyQxLmVxKSkge1xuICAgIGlmIChpc0dlbmVyYXRvciB8fCBpc0FzeW5jKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgdGhpcy5wYXJzZUdldHRlclNldHRlcihwcm9wKTtcbiAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiAhcHJvcC5jb21wdXRlZCAmJiBwcm9wLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgIGlmIChpc0dlbmVyYXRvciB8fCBpc0FzeW5jKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgdGhpcy5jaGVja1VucmVzZXJ2ZWQocHJvcC5rZXkpO1xuICAgIGlmIChwcm9wLmtleS5uYW1lID09PSBcImF3YWl0XCIgJiYgIXRoaXMuYXdhaXRJZGVudFBvcylcbiAgICAgIHsgdGhpcy5hd2FpdElkZW50UG9zID0gc3RhcnRQb3M7IH1cbiAgICBpZiAoaXNQYXR0ZXJuKSB7XG4gICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChzdGFydFBvcywgc3RhcnRMb2MsIHRoaXMuY29weU5vZGUocHJvcC5rZXkpKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5lcSAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ24gPCAwKVxuICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID0gdGhpcy5zdGFydDsgfVxuICAgICAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNYXliZURlZmF1bHQoc3RhcnRQb3MsIHN0YXJ0TG9jLCB0aGlzLmNvcHlOb2RlKHByb3Aua2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3AudmFsdWUgPSB0aGlzLmNvcHlOb2RlKHByb3Aua2V5KTtcbiAgICB9XG4gICAgcHJvcC5raW5kID0gXCJpbml0XCI7XG4gICAgcHJvcC5zaG9ydGhhbmQgPSB0cnVlO1xuICB9IGVsc2UgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxufTtcblxucHAkNS5wYXJzZVByb3BlcnR5TmFtZSA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzJDEuYnJhY2tldEwpKSB7XG4gICAgICBwcm9wLmNvbXB1dGVkID0gdHJ1ZTtcbiAgICAgIHByb3Aua2V5ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmJyYWNrZXRSKTtcbiAgICAgIHJldHVybiBwcm9wLmtleVxuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9wLmtleSA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5udW0gfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLnN0cmluZyA/IHRoaXMucGFyc2VFeHByQXRvbSgpIDogdGhpcy5wYXJzZUlkZW50KHRoaXMub3B0aW9ucy5hbGxvd1Jlc2VydmVkICE9PSBcIm5ldmVyXCIpXG59O1xuXG4vLyBJbml0aWFsaXplIGVtcHR5IGZ1bmN0aW9uIG5vZGUuXG5cbnBwJDUuaW5pdEZ1bmN0aW9uID0gZnVuY3Rpb24obm9kZSkge1xuICBub2RlLmlkID0gbnVsbDtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7IG5vZGUuZ2VuZXJhdG9yID0gbm9kZS5leHByZXNzaW9uID0gZmFsc2U7IH1cbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KSB7IG5vZGUuYXN5bmMgPSBmYWxzZTsgfVxufTtcblxuLy8gUGFyc2Ugb2JqZWN0IG9yIGNsYXNzIG1ldGhvZC5cblxucHAkNS5wYXJzZU1ldGhvZCA9IGZ1bmN0aW9uKGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd0RpcmVjdFN1cGVyKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIG9sZEF3YWl0SWRlbnRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3M7XG5cbiAgdGhpcy5pbml0RnVuY3Rpb24obm9kZSk7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNilcbiAgICB7IG5vZGUuZ2VuZXJhdG9yID0gaXNHZW5lcmF0b3I7IH1cbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KVxuICAgIHsgbm9kZS5hc3luYyA9ICEhaXNBc3luYzsgfVxuXG4gIHRoaXMueWllbGRQb3MgPSAwO1xuICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgdGhpcy5hd2FpdElkZW50UG9zID0gMDtcbiAgdGhpcy5lbnRlclNjb3BlKGZ1bmN0aW9uRmxhZ3MoaXNBc3luYywgbm9kZS5nZW5lcmF0b3IpIHwgU0NPUEVfU1VQRVIgfCAoYWxsb3dEaXJlY3RTdXBlciA/IFNDT1BFX0RJUkVDVF9TVVBFUiA6IDApKTtcblxuICB0aGlzLmV4cGVjdCh0eXBlcyQxLnBhcmVuTCk7XG4gIG5vZGUucGFyYW1zID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KHR5cGVzJDEucGFyZW5SLCBmYWxzZSwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpO1xuICB0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpO1xuICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGZhbHNlLCB0cnVlLCBmYWxzZSk7XG5cbiAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zO1xuICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3M7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJGdW5jdGlvbkV4cHJlc3Npb25cIilcbn07XG5cbi8vIFBhcnNlIGFycm93IGZ1bmN0aW9uIGV4cHJlc3Npb24gd2l0aCBnaXZlbiBwYXJhbWV0ZXJzLlxuXG5wcCQ1LnBhcnNlQXJyb3dFeHByZXNzaW9uID0gZnVuY3Rpb24obm9kZSwgcGFyYW1zLCBpc0FzeW5jLCBmb3JJbml0KSB7XG4gIHZhciBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgb2xkQXdhaXRJZGVudFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcztcblxuICB0aGlzLmVudGVyU2NvcGUoZnVuY3Rpb25GbGFncyhpc0FzeW5jLCBmYWxzZSkgfCBTQ09QRV9BUlJPVyk7XG4gIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpIHsgbm9kZS5hc3luYyA9ICEhaXNBc3luYzsgfVxuXG4gIHRoaXMueWllbGRQb3MgPSAwO1xuICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgdGhpcy5hd2FpdElkZW50UG9zID0gMDtcblxuICBub2RlLnBhcmFtcyA9IHRoaXMudG9Bc3NpZ25hYmxlTGlzdChwYXJhbXMsIHRydWUpO1xuICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIHRydWUsIGZhbHNlLCBmb3JJbml0KTtcblxuICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgdGhpcy5hd2FpdElkZW50UG9zID0gb2xkQXdhaXRJZGVudFBvcztcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpXG59O1xuXG4vLyBQYXJzZSBmdW5jdGlvbiBib2R5IGFuZCBjaGVjayBwYXJhbWV0ZXJzLlxuXG5wcCQ1LnBhcnNlRnVuY3Rpb25Cb2R5ID0gZnVuY3Rpb24obm9kZSwgaXNBcnJvd0Z1bmN0aW9uLCBpc01ldGhvZCwgZm9ySW5pdCkge1xuICB2YXIgaXNFeHByZXNzaW9uID0gaXNBcnJvd0Z1bmN0aW9uICYmIHRoaXMudHlwZSAhPT0gdHlwZXMkMS5icmFjZUw7XG4gIHZhciBvbGRTdHJpY3QgPSB0aGlzLnN0cmljdCwgdXNlU3RyaWN0ID0gZmFsc2U7XG5cbiAgaWYgKGlzRXhwcmVzc2lvbikge1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmb3JJbml0KTtcbiAgICBub2RlLmV4cHJlc3Npb24gPSB0cnVlO1xuICAgIHRoaXMuY2hlY2tQYXJhbXMobm9kZSwgZmFsc2UpO1xuICB9IGVsc2Uge1xuICAgIHZhciBub25TaW1wbGUgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNyAmJiAhdGhpcy5pc1NpbXBsZVBhcmFtTGlzdChub2RlLnBhcmFtcyk7XG4gICAgaWYgKCFvbGRTdHJpY3QgfHwgbm9uU2ltcGxlKSB7XG4gICAgICB1c2VTdHJpY3QgPSB0aGlzLnN0cmljdERpcmVjdGl2ZSh0aGlzLmVuZCk7XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgc3RyaWN0IG1vZGUgZnVuY3Rpb24sIHZlcmlmeSB0aGF0IGFyZ3VtZW50IG5hbWVzXG4gICAgICAvLyBhcmUgbm90IHJlcGVhdGVkLCBhbmQgaXQgZG9lcyBub3QgdHJ5IHRvIGJpbmQgdGhlIHdvcmRzIGBldmFsYFxuICAgICAgLy8gb3IgYGFyZ3VtZW50c2AuXG4gICAgICBpZiAodXNlU3RyaWN0ICYmIG5vblNpbXBsZSlcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJJbGxlZ2FsICd1c2Ugc3RyaWN0JyBkaXJlY3RpdmUgaW4gZnVuY3Rpb24gd2l0aCBub24tc2ltcGxlIHBhcmFtZXRlciBsaXN0XCIpOyB9XG4gICAgfVxuICAgIC8vIFN0YXJ0IGEgbmV3IHNjb3BlIHdpdGggcmVnYXJkIHRvIGxhYmVscyBhbmQgdGhlIGBpbkZ1bmN0aW9uYFxuICAgIC8vIGZsYWcgKHJlc3RvcmUgdGhlbSB0byB0aGVpciBvbGQgdmFsdWUgYWZ0ZXJ3YXJkcykuXG4gICAgdmFyIG9sZExhYmVscyA9IHRoaXMubGFiZWxzO1xuICAgIHRoaXMubGFiZWxzID0gW107XG4gICAgaWYgKHVzZVN0cmljdCkgeyB0aGlzLnN0cmljdCA9IHRydWU7IH1cblxuICAgIC8vIEFkZCB0aGUgcGFyYW1zIHRvIHZhckRlY2xhcmVkTmFtZXMgdG8gZW5zdXJlIHRoYXQgYW4gZXJyb3IgaXMgdGhyb3duXG4gICAgLy8gaWYgYSBsZXQvY29uc3QgZGVjbGFyYXRpb24gaW4gdGhlIGZ1bmN0aW9uIGNsYXNoZXMgd2l0aCBvbmUgb2YgdGhlIHBhcmFtcy5cbiAgICB0aGlzLmNoZWNrUGFyYW1zKG5vZGUsICFvbGRTdHJpY3QgJiYgIXVzZVN0cmljdCAmJiAhaXNBcnJvd0Z1bmN0aW9uICYmICFpc01ldGhvZCAmJiB0aGlzLmlzU2ltcGxlUGFyYW1MaXN0KG5vZGUucGFyYW1zKSk7XG4gICAgLy8gRW5zdXJlIHRoZSBmdW5jdGlvbiBuYW1lIGlzbid0IGEgZm9yYmlkZGVuIGlkZW50aWZpZXIgaW4gc3RyaWN0IG1vZGUsIGUuZy4gJ2V2YWwnXG4gICAgaWYgKHRoaXMuc3RyaWN0ICYmIG5vZGUuaWQpIHsgdGhpcy5jaGVja0xWYWxTaW1wbGUobm9kZS5pZCwgQklORF9PVVRTSURFKTsgfVxuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VCbG9jayhmYWxzZSwgdW5kZWZpbmVkLCB1c2VTdHJpY3QgJiYgIW9sZFN0cmljdCk7XG4gICAgbm9kZS5leHByZXNzaW9uID0gZmFsc2U7XG4gICAgdGhpcy5hZGFwdERpcmVjdGl2ZVByb2xvZ3VlKG5vZGUuYm9keS5ib2R5KTtcbiAgICB0aGlzLmxhYmVscyA9IG9sZExhYmVscztcbiAgfVxuICB0aGlzLmV4aXRTY29wZSgpO1xufTtcblxucHAkNS5pc1NpbXBsZVBhcmFtTGlzdCA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHBhcmFtczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAge1xuICAgIHZhciBwYXJhbSA9IGxpc3RbaV07XG5cbiAgICBpZiAocGFyYW0udHlwZSAhPT0gXCJJZGVudGlmaWVyXCIpIHsgcmV0dXJuIGZhbHNlXG4gIH0gfVxuICByZXR1cm4gdHJ1ZVxufTtcblxuLy8gQ2hlY2tzIGZ1bmN0aW9uIHBhcmFtcyBmb3IgdmFyaW91cyBkaXNhbGxvd2VkIHBhdHRlcm5zIHN1Y2ggYXMgdXNpbmcgXCJldmFsXCJcbi8vIG9yIFwiYXJndW1lbnRzXCIgYW5kIGR1cGxpY2F0ZSBwYXJhbWV0ZXJzLlxuXG5wcCQ1LmNoZWNrUGFyYW1zID0gZnVuY3Rpb24obm9kZSwgYWxsb3dEdXBsaWNhdGVzKSB7XG4gIHZhciBuYW1lSGFzaCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5wYXJhbXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgIHtcbiAgICB2YXIgcGFyYW0gPSBsaXN0W2ldO1xuXG4gICAgdGhpcy5jaGVja0xWYWxJbm5lclBhdHRlcm4ocGFyYW0sIEJJTkRfVkFSLCBhbGxvd0R1cGxpY2F0ZXMgPyBudWxsIDogbmFtZUhhc2gpO1xuICB9XG59O1xuXG4vLyBQYXJzZXMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBleHByZXNzaW9ucywgYW5kIHJldHVybnMgdGhlbSBhc1xuLy8gYW4gYXJyYXkuIGBjbG9zZWAgaXMgdGhlIHRva2VuIHR5cGUgdGhhdCBlbmRzIHRoZSBsaXN0LCBhbmRcbi8vIGBhbGxvd0VtcHR5YCBjYW4gYmUgdHVybmVkIG9uIHRvIGFsbG93IHN1YnNlcXVlbnQgY29tbWFzIHdpdGhcbi8vIG5vdGhpbmcgaW4gYmV0d2VlbiB0aGVtIHRvIGJlIHBhcnNlZCBhcyBgbnVsbGAgKHdoaWNoIGlzIG5lZWRlZFxuLy8gZm9yIGFycmF5IGxpdGVyYWxzKS5cblxucHAkNS5wYXJzZUV4cHJMaXN0ID0gZnVuY3Rpb24oY2xvc2UsIGFsbG93VHJhaWxpbmdDb21tYSwgYWxsb3dFbXB0eSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICB2YXIgZWx0cyA9IFtdLCBmaXJzdCA9IHRydWU7XG4gIHdoaWxlICghdGhpcy5lYXQoY2xvc2UpKSB7XG4gICAgaWYgKCFmaXJzdCkge1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMkMS5jb21tYSk7XG4gICAgICBpZiAoYWxsb3dUcmFpbGluZ0NvbW1hICYmIHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKGNsb3NlKSkgeyBicmVhayB9XG4gICAgfSBlbHNlIHsgZmlyc3QgPSBmYWxzZTsgfVxuXG4gICAgdmFyIGVsdCA9ICh2b2lkIDApO1xuICAgIGlmIChhbGxvd0VtcHR5ICYmIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5jb21tYSlcbiAgICAgIHsgZWx0ID0gbnVsbDsgfVxuICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5lbGxpcHNpcykge1xuICAgICAgZWx0ID0gdGhpcy5wYXJzZVNwcmVhZChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzICYmIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5jb21tYSAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPCAwKVxuICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IHRoaXMuc3RhcnQ7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWx0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICB9XG4gICAgZWx0cy5wdXNoKGVsdCk7XG4gIH1cbiAgcmV0dXJuIGVsdHNcbn07XG5cbnBwJDUuY2hlY2tVbnJlc2VydmVkID0gZnVuY3Rpb24ocmVmKSB7XG4gIHZhciBzdGFydCA9IHJlZi5zdGFydDtcbiAgdmFyIGVuZCA9IHJlZi5lbmQ7XG4gIHZhciBuYW1lID0gcmVmLm5hbWU7XG5cbiAgaWYgKHRoaXMuaW5HZW5lcmF0b3IgJiYgbmFtZSA9PT0gXCJ5aWVsZFwiKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcIkNhbm5vdCB1c2UgJ3lpZWxkJyBhcyBpZGVudGlmaWVyIGluc2lkZSBhIGdlbmVyYXRvclwiKTsgfVxuICBpZiAodGhpcy5pbkFzeW5jICYmIG5hbWUgPT09IFwiYXdhaXRcIilcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJDYW5ub3QgdXNlICdhd2FpdCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cIik7IH1cbiAgaWYgKCEodGhpcy5jdXJyZW50VGhpc1Njb3BlKCkuZmxhZ3MgJiBTQ09QRV9WQVIpICYmIG5hbWUgPT09IFwiYXJndW1lbnRzXCIpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwiQ2Fubm90IHVzZSAnYXJndW1lbnRzJyBpbiBjbGFzcyBmaWVsZCBpbml0aWFsaXplclwiKTsgfVxuICBpZiAodGhpcy5pbkNsYXNzU3RhdGljQmxvY2sgJiYgKG5hbWUgPT09IFwiYXJndW1lbnRzXCIgfHwgbmFtZSA9PT0gXCJhd2FpdFwiKSlcbiAgICB7IHRoaXMucmFpc2Uoc3RhcnQsIChcIkNhbm5vdCB1c2UgXCIgKyBuYW1lICsgXCIgaW4gY2xhc3Mgc3RhdGljIGluaXRpYWxpemF0aW9uIGJsb2NrXCIpKTsgfVxuICBpZiAodGhpcy5rZXl3b3Jkcy50ZXN0KG5hbWUpKVxuICAgIHsgdGhpcy5yYWlzZShzdGFydCwgKFwiVW5leHBlY3RlZCBrZXl3b3JkICdcIiArIG5hbWUgKyBcIidcIikpOyB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2ICYmXG4gICAgdGhpcy5pbnB1dC5zbGljZShzdGFydCwgZW5kKS5pbmRleE9mKFwiXFxcXFwiKSAhPT0gLTEpIHsgcmV0dXJuIH1cbiAgdmFyIHJlID0gdGhpcy5zdHJpY3QgPyB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3QgOiB0aGlzLnJlc2VydmVkV29yZHM7XG4gIGlmIChyZS50ZXN0KG5hbWUpKSB7XG4gICAgaWYgKCF0aGlzLmluQXN5bmMgJiYgbmFtZSA9PT0gXCJhd2FpdFwiKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwiQ2Fubm90IHVzZSBrZXl3b3JkICdhd2FpdCcgb3V0c2lkZSBhbiBhc3luYyBmdW5jdGlvblwiKTsgfVxuICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgKFwiVGhlIGtleXdvcmQgJ1wiICsgbmFtZSArIFwiJyBpcyByZXNlcnZlZFwiKSk7XG4gIH1cbn07XG5cbi8vIFBhcnNlIHRoZSBuZXh0IHRva2VuIGFzIGFuIGlkZW50aWZpZXIuIElmIGBsaWJlcmFsYCBpcyB0cnVlICh1c2VkXG4vLyB3aGVuIHBhcnNpbmcgcHJvcGVydGllcyksIGl0IHdpbGwgYWxzbyBjb252ZXJ0IGtleXdvcmRzIGludG9cbi8vIGlkZW50aWZpZXJzLlxuXG5wcCQ1LnBhcnNlSWRlbnQgPSBmdW5jdGlvbihsaWJlcmFsKSB7XG4gIHZhciBub2RlID0gdGhpcy5wYXJzZUlkZW50Tm9kZSgpO1xuICB0aGlzLm5leHQoISFsaWJlcmFsKTtcbiAgdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSWRlbnRpZmllclwiKTtcbiAgaWYgKCFsaWJlcmFsKSB7XG4gICAgdGhpcy5jaGVja1VucmVzZXJ2ZWQobm9kZSk7XG4gICAgaWYgKG5vZGUubmFtZSA9PT0gXCJhd2FpdFwiICYmICF0aGlzLmF3YWl0SWRlbnRQb3MpXG4gICAgICB7IHRoaXMuYXdhaXRJZGVudFBvcyA9IG5vZGUuc3RhcnQ7IH1cbiAgfVxuICByZXR1cm4gbm9kZVxufTtcblxucHAkNS5wYXJzZUlkZW50Tm9kZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEubmFtZSkge1xuICAgIG5vZGUubmFtZSA9IHRoaXMudmFsdWU7XG4gIH0gZWxzZSBpZiAodGhpcy50eXBlLmtleXdvcmQpIHtcbiAgICBub2RlLm5hbWUgPSB0aGlzLnR5cGUua2V5d29yZDtcblxuICAgIC8vIFRvIGZpeCBodHRwczovL2dpdGh1Yi5jb20vYWNvcm5qcy9hY29ybi9pc3N1ZXMvNTc1XG4gICAgLy8gYGNsYXNzYCBhbmQgYGZ1bmN0aW9uYCBrZXl3b3JkcyBwdXNoIG5ldyBjb250ZXh0IGludG8gdGhpcy5jb250ZXh0LlxuICAgIC8vIEJ1dCB0aGVyZSBpcyBubyBjaGFuY2UgdG8gcG9wIHRoZSBjb250ZXh0IGlmIHRoZSBrZXl3b3JkIGlzIGNvbnN1bWVkIGFzIGFuIGlkZW50aWZpZXIgc3VjaCBhcyBhIHByb3BlcnR5IG5hbWUuXG4gICAgLy8gSWYgdGhlIHByZXZpb3VzIHRva2VuIGlzIGEgZG90LCB0aGlzIGRvZXMgbm90IGFwcGx5IGJlY2F1c2UgdGhlIGNvbnRleHQtbWFuYWdpbmcgY29kZSBhbHJlYWR5IGlnbm9yZWQgdGhlIGtleXdvcmRcbiAgICBpZiAoKG5vZGUubmFtZSA9PT0gXCJjbGFzc1wiIHx8IG5vZGUubmFtZSA9PT0gXCJmdW5jdGlvblwiKSAmJlxuICAgICAgKHRoaXMubGFzdFRva0VuZCAhPT0gdGhpcy5sYXN0VG9rU3RhcnQgKyAxIHx8IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLmxhc3RUb2tTdGFydCkgIT09IDQ2KSkge1xuICAgICAgdGhpcy5jb250ZXh0LnBvcCgpO1xuICAgIH1cbiAgICB0aGlzLnR5cGUgPSB0eXBlcyQxLm5hbWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH1cbiAgcmV0dXJuIG5vZGVcbn07XG5cbnBwJDUucGFyc2VQcml2YXRlSWRlbnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnByaXZhdGVJZCkge1xuICAgIG5vZGUubmFtZSA9IHRoaXMudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH1cbiAgdGhpcy5uZXh0KCk7XG4gIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlByaXZhdGVJZGVudGlmaWVyXCIpO1xuXG4gIC8vIEZvciB2YWxpZGF0aW5nIGV4aXN0ZW5jZVxuICBpZiAodGhpcy5vcHRpb25zLmNoZWNrUHJpdmF0ZUZpZWxkcykge1xuICAgIGlmICh0aGlzLnByaXZhdGVOYW1lU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIChcIlByaXZhdGUgZmllbGQgJyNcIiArIChub2RlLm5hbWUpICsgXCInIG11c3QgYmUgZGVjbGFyZWQgaW4gYW4gZW5jbG9zaW5nIGNsYXNzXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcml2YXRlTmFtZVN0YWNrW3RoaXMucHJpdmF0ZU5hbWVTdGFjay5sZW5ndGggLSAxXS51c2VkLnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5vZGVcbn07XG5cbi8vIFBhcnNlcyB5aWVsZCBleHByZXNzaW9uIGluc2lkZSBnZW5lcmF0b3IuXG5cbnBwJDUucGFyc2VZaWVsZCA9IGZ1bmN0aW9uKGZvckluaXQpIHtcbiAgaWYgKCF0aGlzLnlpZWxkUG9zKSB7IHRoaXMueWllbGRQb3MgPSB0aGlzLnN0YXJ0OyB9XG5cbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHQoKTtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zZW1pIHx8IHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgfHwgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5zdGFyICYmICF0aGlzLnR5cGUuc3RhcnRzRXhwcikpIHtcbiAgICBub2RlLmRlbGVnYXRlID0gZmFsc2U7XG4gICAgbm9kZS5hcmd1bWVudCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5kZWxlZ2F0ZSA9IHRoaXMuZWF0KHR5cGVzJDEuc3Rhcik7XG4gICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmb3JJbml0KTtcbiAgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiWWllbGRFeHByZXNzaW9uXCIpXG59O1xuXG5wcCQ1LnBhcnNlQXdhaXQgPSBmdW5jdGlvbihmb3JJbml0KSB7XG4gIGlmICghdGhpcy5hd2FpdFBvcykgeyB0aGlzLmF3YWl0UG9zID0gdGhpcy5zdGFydDsgfVxuXG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCB0cnVlLCBmYWxzZSwgZm9ySW5pdCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBd2FpdEV4cHJlc3Npb25cIilcbn07XG5cbnZhciBwcCQ0ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHJhaXNlIGV4Y2VwdGlvbnMgb24gcGFyc2UgZXJyb3JzLiBJdFxuLy8gdGFrZXMgYW4gb2Zmc2V0IGludGVnZXIgKGludG8gdGhlIGN1cnJlbnQgYGlucHV0YCkgdG8gaW5kaWNhdGVcbi8vIHRoZSBsb2NhdGlvbiBvZiB0aGUgZXJyb3IsIGF0dGFjaGVzIHRoZSBwb3NpdGlvbiB0byB0aGUgZW5kXG4vLyBvZiB0aGUgZXJyb3IgbWVzc2FnZSwgYW5kIHRoZW4gcmFpc2VzIGEgYFN5bnRheEVycm9yYCB3aXRoIHRoYXRcbi8vIG1lc3NhZ2UuXG5cbnBwJDQucmFpc2UgPSBmdW5jdGlvbihwb3MsIG1lc3NhZ2UpIHtcbiAgdmFyIGxvYyA9IGdldExpbmVJbmZvKHRoaXMuaW5wdXQsIHBvcyk7XG4gIG1lc3NhZ2UgKz0gXCIgKFwiICsgbG9jLmxpbmUgKyBcIjpcIiArIGxvYy5jb2x1bW4gKyBcIilcIjtcbiAgaWYgKHRoaXMuc291cmNlRmlsZSkge1xuICAgIG1lc3NhZ2UgKz0gXCIgaW4gXCIgKyB0aGlzLnNvdXJjZUZpbGU7XG4gIH1cbiAgdmFyIGVyciA9IG5ldyBTeW50YXhFcnJvcihtZXNzYWdlKTtcbiAgZXJyLnBvcyA9IHBvczsgZXJyLmxvYyA9IGxvYzsgZXJyLnJhaXNlZEF0ID0gdGhpcy5wb3M7XG4gIHRocm93IGVyclxufTtcblxucHAkNC5yYWlzZVJlY292ZXJhYmxlID0gcHAkNC5yYWlzZTtcblxucHAkNC5jdXJQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgIHJldHVybiBuZXcgUG9zaXRpb24odGhpcy5jdXJMaW5lLCB0aGlzLnBvcyAtIHRoaXMubGluZVN0YXJ0KVxuICB9XG59O1xuXG52YXIgcHAkMyA9IFBhcnNlci5wcm90b3R5cGU7XG5cbnZhciBTY29wZSA9IGZ1bmN0aW9uIFNjb3BlKGZsYWdzKSB7XG4gIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgLy8gQSBsaXN0IG9mIHZhci1kZWNsYXJlZCBuYW1lcyBpbiB0aGUgY3VycmVudCBsZXhpY2FsIHNjb3BlXG4gIHRoaXMudmFyID0gW107XG4gIC8vIEEgbGlzdCBvZiBsZXhpY2FsbHktZGVjbGFyZWQgbmFtZXMgaW4gdGhlIGN1cnJlbnQgbGV4aWNhbCBzY29wZVxuICB0aGlzLmxleGljYWwgPSBbXTtcbiAgLy8gQSBsaXN0IG9mIGxleGljYWxseS1kZWNsYXJlZCBGdW5jdGlvbkRlY2xhcmF0aW9uIG5hbWVzIGluIHRoZSBjdXJyZW50IGxleGljYWwgc2NvcGVcbiAgdGhpcy5mdW5jdGlvbnMgPSBbXTtcbn07XG5cbi8vIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUga2VlcCB0cmFjayBvZiBkZWNsYXJlZCB2YXJpYWJsZXMgaW4gdGhlIGN1cnJlbnQgc2NvcGUgaW4gb3JkZXIgdG8gZGV0ZWN0IGR1cGxpY2F0ZSB2YXJpYWJsZSBuYW1lcy5cblxucHAkMy5lbnRlclNjb3BlID0gZnVuY3Rpb24oZmxhZ3MpIHtcbiAgdGhpcy5zY29wZVN0YWNrLnB1c2gobmV3IFNjb3BlKGZsYWdzKSk7XG59O1xuXG5wcCQzLmV4aXRTY29wZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNjb3BlU3RhY2sucG9wKCk7XG59O1xuXG4vLyBUaGUgc3BlYyBzYXlzOlxuLy8gPiBBdCB0aGUgdG9wIGxldmVsIG9mIGEgZnVuY3Rpb24sIG9yIHNjcmlwdCwgZnVuY3Rpb24gZGVjbGFyYXRpb25zIGFyZVxuLy8gPiB0cmVhdGVkIGxpa2UgdmFyIGRlY2xhcmF0aW9ucyByYXRoZXIgdGhhbiBsaWtlIGxleGljYWwgZGVjbGFyYXRpb25zLlxucHAkMy50cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZSA9IGZ1bmN0aW9uKHNjb3BlKSB7XG4gIHJldHVybiAoc2NvcGUuZmxhZ3MgJiBTQ09QRV9GVU5DVElPTikgfHwgIXRoaXMuaW5Nb2R1bGUgJiYgKHNjb3BlLmZsYWdzICYgU0NPUEVfVE9QKVxufTtcblxucHAkMy5kZWNsYXJlTmFtZSA9IGZ1bmN0aW9uKG5hbWUsIGJpbmRpbmdUeXBlLCBwb3MpIHtcbiAgdmFyIHJlZGVjbGFyZWQgPSBmYWxzZTtcbiAgaWYgKGJpbmRpbmdUeXBlID09PSBCSU5EX0xFWElDQUwpIHtcbiAgICB2YXIgc2NvcGUgPSB0aGlzLmN1cnJlbnRTY29wZSgpO1xuICAgIHJlZGVjbGFyZWQgPSBzY29wZS5sZXhpY2FsLmluZGV4T2YobmFtZSkgPiAtMSB8fCBzY29wZS5mdW5jdGlvbnMuaW5kZXhPZihuYW1lKSA+IC0xIHx8IHNjb3BlLnZhci5pbmRleE9mKG5hbWUpID4gLTE7XG4gICAgc2NvcGUubGV4aWNhbC5wdXNoKG5hbWUpO1xuICAgIGlmICh0aGlzLmluTW9kdWxlICYmIChzY29wZS5mbGFncyAmIFNDT1BFX1RPUCkpXG4gICAgICB7IGRlbGV0ZSB0aGlzLnVuZGVmaW5lZEV4cG9ydHNbbmFtZV07IH1cbiAgfSBlbHNlIGlmIChiaW5kaW5nVHlwZSA9PT0gQklORF9TSU1QTEVfQ0FUQ0gpIHtcbiAgICB2YXIgc2NvcGUkMSA9IHRoaXMuY3VycmVudFNjb3BlKCk7XG4gICAgc2NvcGUkMS5sZXhpY2FsLnB1c2gobmFtZSk7XG4gIH0gZWxzZSBpZiAoYmluZGluZ1R5cGUgPT09IEJJTkRfRlVOQ1RJT04pIHtcbiAgICB2YXIgc2NvcGUkMiA9IHRoaXMuY3VycmVudFNjb3BlKCk7XG4gICAgaWYgKHRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhcilcbiAgICAgIHsgcmVkZWNsYXJlZCA9IHNjb3BlJDIubGV4aWNhbC5pbmRleE9mKG5hbWUpID4gLTE7IH1cbiAgICBlbHNlXG4gICAgICB7IHJlZGVjbGFyZWQgPSBzY29wZSQyLmxleGljYWwuaW5kZXhPZihuYW1lKSA+IC0xIHx8IHNjb3BlJDIudmFyLmluZGV4T2YobmFtZSkgPiAtMTsgfVxuICAgIHNjb3BlJDIuZnVuY3Rpb25zLnB1c2gobmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdmFyIHNjb3BlJDMgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgICBpZiAoc2NvcGUkMy5sZXhpY2FsLmluZGV4T2YobmFtZSkgPiAtMSAmJiAhKChzY29wZSQzLmZsYWdzICYgU0NPUEVfU0lNUExFX0NBVENIKSAmJiBzY29wZSQzLmxleGljYWxbMF0gPT09IG5hbWUpIHx8XG4gICAgICAgICAgIXRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGUoc2NvcGUkMykgJiYgc2NvcGUkMy5mdW5jdGlvbnMuaW5kZXhPZihuYW1lKSA+IC0xKSB7XG4gICAgICAgIHJlZGVjbGFyZWQgPSB0cnVlO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgc2NvcGUkMy52YXIucHVzaChuYW1lKTtcbiAgICAgIGlmICh0aGlzLmluTW9kdWxlICYmIChzY29wZSQzLmZsYWdzICYgU0NPUEVfVE9QKSlcbiAgICAgICAgeyBkZWxldGUgdGhpcy51bmRlZmluZWRFeHBvcnRzW25hbWVdOyB9XG4gICAgICBpZiAoc2NvcGUkMy5mbGFncyAmIFNDT1BFX1ZBUikgeyBicmVhayB9XG4gICAgfVxuICB9XG4gIGlmIChyZWRlY2xhcmVkKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShwb3MsIChcIklkZW50aWZpZXIgJ1wiICsgbmFtZSArIFwiJyBoYXMgYWxyZWFkeSBiZWVuIGRlY2xhcmVkXCIpKTsgfVxufTtcblxucHAkMy5jaGVja0xvY2FsRXhwb3J0ID0gZnVuY3Rpb24oaWQpIHtcbiAgLy8gc2NvcGUuZnVuY3Rpb25zIG11c3QgYmUgZW1wdHkgYXMgTW9kdWxlIGNvZGUgaXMgYWx3YXlzIHN0cmljdC5cbiAgaWYgKHRoaXMuc2NvcGVTdGFja1swXS5sZXhpY2FsLmluZGV4T2YoaWQubmFtZSkgPT09IC0xICYmXG4gICAgICB0aGlzLnNjb3BlU3RhY2tbMF0udmFyLmluZGV4T2YoaWQubmFtZSkgPT09IC0xKSB7XG4gICAgdGhpcy51bmRlZmluZWRFeHBvcnRzW2lkLm5hbWVdID0gaWQ7XG4gIH1cbn07XG5cbnBwJDMuY3VycmVudFNjb3BlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnNjb3BlU3RhY2tbdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDFdXG59O1xuXG5wcCQzLmN1cnJlbnRWYXJTY29wZSA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBpID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICB2YXIgc2NvcGUgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgaWYgKHNjb3BlLmZsYWdzICYgKFNDT1BFX1ZBUiB8IFNDT1BFX0NMQVNTX0ZJRUxEX0lOSVQgfCBTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0spKSB7IHJldHVybiBzY29wZSB9XG4gIH1cbn07XG5cbi8vIENvdWxkIGJlIHVzZWZ1bCBmb3IgYHRoaXNgLCBgbmV3LnRhcmdldGAsIGBzdXBlcigpYCwgYHN1cGVyLnByb3BlcnR5YCwgYW5kIGBzdXBlcltwcm9wZXJ0eV1gLlxucHAkMy5jdXJyZW50VGhpc1Njb3BlID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTs7IGktLSkge1xuICAgIHZhciBzY29wZSA9IHRoaXMuc2NvcGVTdGFja1tpXTtcbiAgICBpZiAoc2NvcGUuZmxhZ3MgJiAoU0NPUEVfVkFSIHwgU0NPUEVfQ0xBU1NfRklFTERfSU5JVCB8IFNDT1BFX0NMQVNTX1NUQVRJQ19CTE9DSykgJiZcbiAgICAgICAgIShzY29wZS5mbGFncyAmIFNDT1BFX0FSUk9XKSkgeyByZXR1cm4gc2NvcGUgfVxuICB9XG59O1xuXG52YXIgTm9kZSA9IGZ1bmN0aW9uIE5vZGUocGFyc2VyLCBwb3MsIGxvYykge1xuICB0aGlzLnR5cGUgPSBcIlwiO1xuICB0aGlzLnN0YXJ0ID0gcG9zO1xuICB0aGlzLmVuZCA9IDA7XG4gIGlmIChwYXJzZXIub3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgeyB0aGlzLmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbihwYXJzZXIsIGxvYyk7IH1cbiAgaWYgKHBhcnNlci5vcHRpb25zLmRpcmVjdFNvdXJjZUZpbGUpXG4gICAgeyB0aGlzLnNvdXJjZUZpbGUgPSBwYXJzZXIub3B0aW9ucy5kaXJlY3RTb3VyY2VGaWxlOyB9XG4gIGlmIChwYXJzZXIub3B0aW9ucy5yYW5nZXMpXG4gICAgeyB0aGlzLnJhbmdlID0gW3BvcywgMF07IH1cbn07XG5cbi8vIFN0YXJ0IGFuIEFTVCBub2RlLCBhdHRhY2hpbmcgYSBzdGFydCBvZmZzZXQuXG5cbnZhciBwcCQyID0gUGFyc2VyLnByb3RvdHlwZTtcblxucHAkMi5zdGFydE5vZGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHRoaXMuc3RhcnQsIHRoaXMuc3RhcnRMb2MpXG59O1xuXG5wcCQyLnN0YXJ0Tm9kZUF0ID0gZnVuY3Rpb24ocG9zLCBsb2MpIHtcbiAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHBvcywgbG9jKVxufTtcblxuLy8gRmluaXNoIGFuIEFTVCBub2RlLCBhZGRpbmcgYHR5cGVgIGFuZCBgZW5kYCBwcm9wZXJ0aWVzLlxuXG5mdW5jdGlvbiBmaW5pc2hOb2RlQXQobm9kZSwgdHlwZSwgcG9zLCBsb2MpIHtcbiAgbm9kZS50eXBlID0gdHlwZTtcbiAgbm9kZS5lbmQgPSBwb3M7XG4gIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKVxuICAgIHsgbm9kZS5sb2MuZW5kID0gbG9jOyB9XG4gIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKVxuICAgIHsgbm9kZS5yYW5nZVsxXSA9IHBvczsgfVxuICByZXR1cm4gbm9kZVxufVxuXG5wcCQyLmZpbmlzaE5vZGUgPSBmdW5jdGlvbihub2RlLCB0eXBlKSB7XG4gIHJldHVybiBmaW5pc2hOb2RlQXQuY2FsbCh0aGlzLCBub2RlLCB0eXBlLCB0aGlzLmxhc3RUb2tFbmQsIHRoaXMubGFzdFRva0VuZExvYylcbn07XG5cbi8vIEZpbmlzaCBub2RlIGF0IGdpdmVuIHBvc2l0aW9uXG5cbnBwJDIuZmluaXNoTm9kZUF0ID0gZnVuY3Rpb24obm9kZSwgdHlwZSwgcG9zLCBsb2MpIHtcbiAgcmV0dXJuIGZpbmlzaE5vZGVBdC5jYWxsKHRoaXMsIG5vZGUsIHR5cGUsIHBvcywgbG9jKVxufTtcblxucHAkMi5jb3B5Tm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdmFyIG5ld05vZGUgPSBuZXcgTm9kZSh0aGlzLCBub2RlLnN0YXJ0LCB0aGlzLnN0YXJ0TG9jKTtcbiAgZm9yICh2YXIgcHJvcCBpbiBub2RlKSB7IG5ld05vZGVbcHJvcF0gPSBub2RlW3Byb3BdOyB9XG4gIHJldHVybiBuZXdOb2RlXG59O1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBcImJpbi9nZW5lcmF0ZS11bmljb2RlLXNjcmlwdC12YWx1ZXMuanNcIi4gRG8gbm90IG1vZGlmeSBtYW51YWxseSFcbnZhciBzY3JpcHRWYWx1ZXNBZGRlZEluVW5pY29kZSA9IFwiR2FyYSBHYXJheSBHdWtoIEd1cnVuZ19LaGVtYSBIcmt0IEthdGFrYW5hX09yX0hpcmFnYW5hIEthd2kgS2lyYXRfUmFpIEtyYWkgTmFnX011bmRhcmkgTmFnbSBPbF9PbmFsIE9uYW8gU3VudSBTdW51d2FyIFRvZGhyaSBUb2RyIFR1bHVfVGlnYWxhcmkgVHV0ZyBVbmtub3duIFp6enpcIjtcblxuLy8gVGhpcyBmaWxlIGNvbnRhaW5zIFVuaWNvZGUgcHJvcGVydGllcyBleHRyYWN0ZWQgZnJvbSB0aGUgRUNNQVNjcmlwdCBzcGVjaWZpY2F0aW9uLlxuLy8gVGhlIGxpc3RzIGFyZSBleHRyYWN0ZWQgbGlrZSBzbzpcbi8vICQkKCcjdGFibGUtYmluYXJ5LXVuaWNvZGUtcHJvcGVydGllcyA+IGZpZ3VyZSA+IHRhYmxlID4gdGJvZHkgPiB0ciA+IHRkOm50aC1jaGlsZCgxKSBjb2RlJykubWFwKGVsID0+IGVsLmlubmVyVGV4dClcblxuLy8gI3RhYmxlLWJpbmFyeS11bmljb2RlLXByb3BlcnRpZXNcbnZhciBlY21hOUJpbmFyeVByb3BlcnRpZXMgPSBcIkFTQ0lJIEFTQ0lJX0hleF9EaWdpdCBBSGV4IEFscGhhYmV0aWMgQWxwaGEgQW55IEFzc2lnbmVkIEJpZGlfQ29udHJvbCBCaWRpX0MgQmlkaV9NaXJyb3JlZCBCaWRpX00gQ2FzZV9JZ25vcmFibGUgQ0kgQ2FzZWQgQ2hhbmdlc19XaGVuX0Nhc2Vmb2xkZWQgQ1dDRiBDaGFuZ2VzX1doZW5fQ2FzZW1hcHBlZCBDV0NNIENoYW5nZXNfV2hlbl9Mb3dlcmNhc2VkIENXTCBDaGFuZ2VzX1doZW5fTkZLQ19DYXNlZm9sZGVkIENXS0NGIENoYW5nZXNfV2hlbl9UaXRsZWNhc2VkIENXVCBDaGFuZ2VzX1doZW5fVXBwZXJjYXNlZCBDV1UgRGFzaCBEZWZhdWx0X0lnbm9yYWJsZV9Db2RlX1BvaW50IERJIERlcHJlY2F0ZWQgRGVwIERpYWNyaXRpYyBEaWEgRW1vamkgRW1vamlfQ29tcG9uZW50IEVtb2ppX01vZGlmaWVyIEVtb2ppX01vZGlmaWVyX0Jhc2UgRW1vamlfUHJlc2VudGF0aW9uIEV4dGVuZGVyIEV4dCBHcmFwaGVtZV9CYXNlIEdyX0Jhc2UgR3JhcGhlbWVfRXh0ZW5kIEdyX0V4dCBIZXhfRGlnaXQgSGV4IElEU19CaW5hcnlfT3BlcmF0b3IgSURTQiBJRFNfVHJpbmFyeV9PcGVyYXRvciBJRFNUIElEX0NvbnRpbnVlIElEQyBJRF9TdGFydCBJRFMgSWRlb2dyYXBoaWMgSWRlbyBKb2luX0NvbnRyb2wgSm9pbl9DIExvZ2ljYWxfT3JkZXJfRXhjZXB0aW9uIExPRSBMb3dlcmNhc2UgTG93ZXIgTWF0aCBOb25jaGFyYWN0ZXJfQ29kZV9Qb2ludCBOQ2hhciBQYXR0ZXJuX1N5bnRheCBQYXRfU3luIFBhdHRlcm5fV2hpdGVfU3BhY2UgUGF0X1dTIFF1b3RhdGlvbl9NYXJrIFFNYXJrIFJhZGljYWwgUmVnaW9uYWxfSW5kaWNhdG9yIFJJIFNlbnRlbmNlX1Rlcm1pbmFsIFNUZXJtIFNvZnRfRG90dGVkIFNEIFRlcm1pbmFsX1B1bmN0dWF0aW9uIFRlcm0gVW5pZmllZF9JZGVvZ3JhcGggVUlkZW8gVXBwZXJjYXNlIFVwcGVyIFZhcmlhdGlvbl9TZWxlY3RvciBWUyBXaGl0ZV9TcGFjZSBzcGFjZSBYSURfQ29udGludWUgWElEQyBYSURfU3RhcnQgWElEU1wiO1xudmFyIGVjbWExMEJpbmFyeVByb3BlcnRpZXMgPSBlY21hOUJpbmFyeVByb3BlcnRpZXMgKyBcIiBFeHRlbmRlZF9QaWN0b2dyYXBoaWNcIjtcbnZhciBlY21hMTFCaW5hcnlQcm9wZXJ0aWVzID0gZWNtYTEwQmluYXJ5UHJvcGVydGllcztcbnZhciBlY21hMTJCaW5hcnlQcm9wZXJ0aWVzID0gZWNtYTExQmluYXJ5UHJvcGVydGllcyArIFwiIEVCYXNlIEVDb21wIEVNb2QgRVByZXMgRXh0UGljdFwiO1xudmFyIGVjbWExM0JpbmFyeVByb3BlcnRpZXMgPSBlY21hMTJCaW5hcnlQcm9wZXJ0aWVzO1xudmFyIGVjbWExNEJpbmFyeVByb3BlcnRpZXMgPSBlY21hMTNCaW5hcnlQcm9wZXJ0aWVzO1xuXG52YXIgdW5pY29kZUJpbmFyeVByb3BlcnRpZXMgPSB7XG4gIDk6IGVjbWE5QmluYXJ5UHJvcGVydGllcyxcbiAgMTA6IGVjbWExMEJpbmFyeVByb3BlcnRpZXMsXG4gIDExOiBlY21hMTFCaW5hcnlQcm9wZXJ0aWVzLFxuICAxMjogZWNtYTEyQmluYXJ5UHJvcGVydGllcyxcbiAgMTM6IGVjbWExM0JpbmFyeVByb3BlcnRpZXMsXG4gIDE0OiBlY21hMTRCaW5hcnlQcm9wZXJ0aWVzXG59O1xuXG4vLyAjdGFibGUtYmluYXJ5LXVuaWNvZGUtcHJvcGVydGllcy1vZi1zdHJpbmdzXG52YXIgZWNtYTE0QmluYXJ5UHJvcGVydGllc09mU3RyaW5ncyA9IFwiQmFzaWNfRW1vamkgRW1vamlfS2V5Y2FwX1NlcXVlbmNlIFJHSV9FbW9qaV9Nb2RpZmllcl9TZXF1ZW5jZSBSR0lfRW1vamlfRmxhZ19TZXF1ZW5jZSBSR0lfRW1vamlfVGFnX1NlcXVlbmNlIFJHSV9FbW9qaV9aV0pfU2VxdWVuY2UgUkdJX0Vtb2ppXCI7XG5cbnZhciB1bmljb2RlQmluYXJ5UHJvcGVydGllc09mU3RyaW5ncyA9IHtcbiAgOTogXCJcIixcbiAgMTA6IFwiXCIsXG4gIDExOiBcIlwiLFxuICAxMjogXCJcIixcbiAgMTM6IFwiXCIsXG4gIDE0OiBlY21hMTRCaW5hcnlQcm9wZXJ0aWVzT2ZTdHJpbmdzXG59O1xuXG4vLyAjdGFibGUtdW5pY29kZS1nZW5lcmFsLWNhdGVnb3J5LXZhbHVlc1xudmFyIHVuaWNvZGVHZW5lcmFsQ2F0ZWdvcnlWYWx1ZXMgPSBcIkNhc2VkX0xldHRlciBMQyBDbG9zZV9QdW5jdHVhdGlvbiBQZSBDb25uZWN0b3JfUHVuY3R1YXRpb24gUGMgQ29udHJvbCBDYyBjbnRybCBDdXJyZW5jeV9TeW1ib2wgU2MgRGFzaF9QdW5jdHVhdGlvbiBQZCBEZWNpbWFsX051bWJlciBOZCBkaWdpdCBFbmNsb3NpbmdfTWFyayBNZSBGaW5hbF9QdW5jdHVhdGlvbiBQZiBGb3JtYXQgQ2YgSW5pdGlhbF9QdW5jdHVhdGlvbiBQaSBMZXR0ZXIgTCBMZXR0ZXJfTnVtYmVyIE5sIExpbmVfU2VwYXJhdG9yIFpsIExvd2VyY2FzZV9MZXR0ZXIgTGwgTWFyayBNIENvbWJpbmluZ19NYXJrIE1hdGhfU3ltYm9sIFNtIE1vZGlmaWVyX0xldHRlciBMbSBNb2RpZmllcl9TeW1ib2wgU2sgTm9uc3BhY2luZ19NYXJrIE1uIE51bWJlciBOIE9wZW5fUHVuY3R1YXRpb24gUHMgT3RoZXIgQyBPdGhlcl9MZXR0ZXIgTG8gT3RoZXJfTnVtYmVyIE5vIE90aGVyX1B1bmN0dWF0aW9uIFBvIE90aGVyX1N5bWJvbCBTbyBQYXJhZ3JhcGhfU2VwYXJhdG9yIFpwIFByaXZhdGVfVXNlIENvIFB1bmN0dWF0aW9uIFAgcHVuY3QgU2VwYXJhdG9yIFogU3BhY2VfU2VwYXJhdG9yIFpzIFNwYWNpbmdfTWFyayBNYyBTdXJyb2dhdGUgQ3MgU3ltYm9sIFMgVGl0bGVjYXNlX0xldHRlciBMdCBVbmFzc2lnbmVkIENuIFVwcGVyY2FzZV9MZXR0ZXIgTHVcIjtcblxuLy8gI3RhYmxlLXVuaWNvZGUtc2NyaXB0LXZhbHVlc1xudmFyIGVjbWE5U2NyaXB0VmFsdWVzID0gXCJBZGxhbSBBZGxtIEFob20gQW5hdG9saWFuX0hpZXJvZ2x5cGhzIEhsdXcgQXJhYmljIEFyYWIgQXJtZW5pYW4gQXJtbiBBdmVzdGFuIEF2c3QgQmFsaW5lc2UgQmFsaSBCYW11bSBCYW11IEJhc3NhX1ZhaCBCYXNzIEJhdGFrIEJhdGsgQmVuZ2FsaSBCZW5nIEJoYWlrc3VraSBCaGtzIEJvcG9tb2ZvIEJvcG8gQnJhaG1pIEJyYWggQnJhaWxsZSBCcmFpIEJ1Z2luZXNlIEJ1Z2kgQnVoaWQgQnVoZCBDYW5hZGlhbl9BYm9yaWdpbmFsIENhbnMgQ2FyaWFuIENhcmkgQ2F1Y2FzaWFuX0FsYmFuaWFuIEFnaGIgQ2hha21hIENha20gQ2hhbSBDaGFtIENoZXJva2VlIENoZXIgQ29tbW9uIFp5eXkgQ29wdGljIENvcHQgUWFhYyBDdW5laWZvcm0gWHN1eCBDeXByaW90IENwcnQgQ3lyaWxsaWMgQ3lybCBEZXNlcmV0IERzcnQgRGV2YW5hZ2FyaSBEZXZhIER1cGxveWFuIER1cGwgRWd5cHRpYW5fSGllcm9nbHlwaHMgRWd5cCBFbGJhc2FuIEVsYmEgRXRoaW9waWMgRXRoaSBHZW9yZ2lhbiBHZW9yIEdsYWdvbGl0aWMgR2xhZyBHb3RoaWMgR290aCBHcmFudGhhIEdyYW4gR3JlZWsgR3JlayBHdWphcmF0aSBHdWpyIEd1cm11a2hpIEd1cnUgSGFuIEhhbmkgSGFuZ3VsIEhhbmcgSGFudW5vbyBIYW5vIEhhdHJhbiBIYXRyIEhlYnJldyBIZWJyIEhpcmFnYW5hIEhpcmEgSW1wZXJpYWxfQXJhbWFpYyBBcm1pIEluaGVyaXRlZCBaaW5oIFFhYWkgSW5zY3JpcHRpb25hbF9QYWhsYXZpIFBobGkgSW5zY3JpcHRpb25hbF9QYXJ0aGlhbiBQcnRpIEphdmFuZXNlIEphdmEgS2FpdGhpIEt0aGkgS2FubmFkYSBLbmRhIEthdGFrYW5hIEthbmEgS2F5YWhfTGkgS2FsaSBLaGFyb3NodGhpIEtoYXIgS2htZXIgS2htciBLaG9qa2kgS2hvaiBLaHVkYXdhZGkgU2luZCBMYW8gTGFvbyBMYXRpbiBMYXRuIExlcGNoYSBMZXBjIExpbWJ1IExpbWIgTGluZWFyX0EgTGluYSBMaW5lYXJfQiBMaW5iIExpc3UgTGlzdSBMeWNpYW4gTHljaSBMeWRpYW4gTHlkaSBNYWhhamFuaSBNYWhqIE1hbGF5YWxhbSBNbHltIE1hbmRhaWMgTWFuZCBNYW5pY2hhZWFuIE1hbmkgTWFyY2hlbiBNYXJjIE1hc2FyYW1fR29uZGkgR29ubSBNZWV0ZWlfTWF5ZWsgTXRlaSBNZW5kZV9LaWtha3VpIE1lbmQgTWVyb2l0aWNfQ3Vyc2l2ZSBNZXJjIE1lcm9pdGljX0hpZXJvZ2x5cGhzIE1lcm8gTWlhbyBQbHJkIE1vZGkgTW9uZ29saWFuIE1vbmcgTXJvIE1yb28gTXVsdGFuaSBNdWx0IE15YW5tYXIgTXltciBOYWJhdGFlYW4gTmJhdCBOZXdfVGFpX0x1ZSBUYWx1IE5ld2EgTmV3YSBOa28gTmtvbyBOdXNodSBOc2h1IE9naGFtIE9nYW0gT2xfQ2hpa2kgT2xjayBPbGRfSHVuZ2FyaWFuIEh1bmcgT2xkX0l0YWxpYyBJdGFsIE9sZF9Ob3J0aF9BcmFiaWFuIE5hcmIgT2xkX1Blcm1pYyBQZXJtIE9sZF9QZXJzaWFuIFhwZW8gT2xkX1NvdXRoX0FyYWJpYW4gU2FyYiBPbGRfVHVya2ljIE9ya2ggT3JpeWEgT3J5YSBPc2FnZSBPc2dlIE9zbWFueWEgT3NtYSBQYWhhd2hfSG1vbmcgSG1uZyBQYWxteXJlbmUgUGFsbSBQYXVfQ2luX0hhdSBQYXVjIFBoYWdzX1BhIFBoYWcgUGhvZW5pY2lhbiBQaG54IFBzYWx0ZXJfUGFobGF2aSBQaGxwIFJlamFuZyBSam5nIFJ1bmljIFJ1bnIgU2FtYXJpdGFuIFNhbXIgU2F1cmFzaHRyYSBTYXVyIFNoYXJhZGEgU2hyZCBTaGF2aWFuIFNoYXcgU2lkZGhhbSBTaWRkIFNpZ25Xcml0aW5nIFNnbncgU2luaGFsYSBTaW5oIFNvcmFfU29tcGVuZyBTb3JhIFNveW9tYm8gU295byBTdW5kYW5lc2UgU3VuZCBTeWxvdGlfTmFncmkgU3lsbyBTeXJpYWMgU3lyYyBUYWdhbG9nIFRnbGcgVGFnYmFud2EgVGFnYiBUYWlfTGUgVGFsZSBUYWlfVGhhbSBMYW5hIFRhaV9WaWV0IFRhdnQgVGFrcmkgVGFrciBUYW1pbCBUYW1sIFRhbmd1dCBUYW5nIFRlbHVndSBUZWx1IFRoYWFuYSBUaGFhIFRoYWkgVGhhaSBUaWJldGFuIFRpYnQgVGlmaW5hZ2ggVGZuZyBUaXJodXRhIFRpcmggVWdhcml0aWMgVWdhciBWYWkgVmFpaSBXYXJhbmdfQ2l0aSBXYXJhIFlpIFlpaWkgWmFuYWJhemFyX1NxdWFyZSBaYW5iXCI7XG52YXIgZWNtYTEwU2NyaXB0VmFsdWVzID0gZWNtYTlTY3JpcHRWYWx1ZXMgKyBcIiBEb2dyYSBEb2dyIEd1bmphbGFfR29uZGkgR29uZyBIYW5pZmlfUm9oaW5neWEgUm9oZyBNYWthc2FyIE1ha2EgTWVkZWZhaWRyaW4gTWVkZiBPbGRfU29nZGlhbiBTb2dvIFNvZ2RpYW4gU29nZFwiO1xudmFyIGVjbWExMVNjcmlwdFZhbHVlcyA9IGVjbWExMFNjcmlwdFZhbHVlcyArIFwiIEVseW1haWMgRWx5bSBOYW5kaW5hZ2FyaSBOYW5kIE55aWFrZW5nX1B1YWNodWVfSG1vbmcgSG1ucCBXYW5jaG8gV2Nob1wiO1xudmFyIGVjbWExMlNjcmlwdFZhbHVlcyA9IGVjbWExMVNjcmlwdFZhbHVlcyArIFwiIENob3Jhc21pYW4gQ2hycyBEaWFrIERpdmVzX0FrdXJ1IEtoaXRhbl9TbWFsbF9TY3JpcHQgS2l0cyBZZXppIFllemlkaVwiO1xudmFyIGVjbWExM1NjcmlwdFZhbHVlcyA9IGVjbWExMlNjcmlwdFZhbHVlcyArIFwiIEN5cHJvX01pbm9hbiBDcG1uIE9sZF9VeWdodXIgT3VnciBUYW5nc2EgVG5zYSBUb3RvIFZpdGhrdXFpIFZpdGhcIjtcbnZhciBlY21hMTRTY3JpcHRWYWx1ZXMgPSBlY21hMTNTY3JpcHRWYWx1ZXMgKyBcIiBcIiArIHNjcmlwdFZhbHVlc0FkZGVkSW5Vbmljb2RlO1xuXG52YXIgdW5pY29kZVNjcmlwdFZhbHVlcyA9IHtcbiAgOTogZWNtYTlTY3JpcHRWYWx1ZXMsXG4gIDEwOiBlY21hMTBTY3JpcHRWYWx1ZXMsXG4gIDExOiBlY21hMTFTY3JpcHRWYWx1ZXMsXG4gIDEyOiBlY21hMTJTY3JpcHRWYWx1ZXMsXG4gIDEzOiBlY21hMTNTY3JpcHRWYWx1ZXMsXG4gIDE0OiBlY21hMTRTY3JpcHRWYWx1ZXNcbn07XG5cbnZhciBkYXRhID0ge307XG5mdW5jdGlvbiBidWlsZFVuaWNvZGVEYXRhKGVjbWFWZXJzaW9uKSB7XG4gIHZhciBkID0gZGF0YVtlY21hVmVyc2lvbl0gPSB7XG4gICAgYmluYXJ5OiB3b3Jkc1JlZ2V4cCh1bmljb2RlQmluYXJ5UHJvcGVydGllc1tlY21hVmVyc2lvbl0gKyBcIiBcIiArIHVuaWNvZGVHZW5lcmFsQ2F0ZWdvcnlWYWx1ZXMpLFxuICAgIGJpbmFyeU9mU3RyaW5nczogd29yZHNSZWdleHAodW5pY29kZUJpbmFyeVByb3BlcnRpZXNPZlN0cmluZ3NbZWNtYVZlcnNpb25dKSxcbiAgICBub25CaW5hcnk6IHtcbiAgICAgIEdlbmVyYWxfQ2F0ZWdvcnk6IHdvcmRzUmVnZXhwKHVuaWNvZGVHZW5lcmFsQ2F0ZWdvcnlWYWx1ZXMpLFxuICAgICAgU2NyaXB0OiB3b3Jkc1JlZ2V4cCh1bmljb2RlU2NyaXB0VmFsdWVzW2VjbWFWZXJzaW9uXSlcbiAgICB9XG4gIH07XG4gIGQubm9uQmluYXJ5LlNjcmlwdF9FeHRlbnNpb25zID0gZC5ub25CaW5hcnkuU2NyaXB0O1xuXG4gIGQubm9uQmluYXJ5LmdjID0gZC5ub25CaW5hcnkuR2VuZXJhbF9DYXRlZ29yeTtcbiAgZC5ub25CaW5hcnkuc2MgPSBkLm5vbkJpbmFyeS5TY3JpcHQ7XG4gIGQubm9uQmluYXJ5LnNjeCA9IGQubm9uQmluYXJ5LlNjcmlwdF9FeHRlbnNpb25zO1xufVxuXG5mb3IgKHZhciBpID0gMCwgbGlzdCA9IFs5LCAxMCwgMTEsIDEyLCAxMywgMTRdOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICB2YXIgZWNtYVZlcnNpb24gPSBsaXN0W2ldO1xuXG4gIGJ1aWxkVW5pY29kZURhdGEoZWNtYVZlcnNpb24pO1xufVxuXG52YXIgcHAkMSA9IFBhcnNlci5wcm90b3R5cGU7XG5cbi8vIFRyYWNrIGRpc2p1bmN0aW9uIHN0cnVjdHVyZSB0byBkZXRlcm1pbmUgd2hldGhlciBhIGR1cGxpY2F0ZVxuLy8gY2FwdHVyZSBncm91cCBuYW1lIGlzIGFsbG93ZWQgYmVjYXVzZSBpdCBpcyBpbiBhIHNlcGFyYXRlIGJyYW5jaC5cbnZhciBCcmFuY2hJRCA9IGZ1bmN0aW9uIEJyYW5jaElEKHBhcmVudCwgYmFzZSkge1xuICAvLyBQYXJlbnQgZGlzanVuY3Rpb24gYnJhbmNoXG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAvLyBJZGVudGlmaWVzIHRoaXMgc2V0IG9mIHNpYmxpbmcgYnJhbmNoZXNcbiAgdGhpcy5iYXNlID0gYmFzZSB8fCB0aGlzO1xufTtcblxuQnJhbmNoSUQucHJvdG90eXBlLnNlcGFyYXRlZEZyb20gPSBmdW5jdGlvbiBzZXBhcmF0ZWRGcm9tIChhbHQpIHtcbiAgLy8gQSBicmFuY2ggaXMgc2VwYXJhdGUgZnJvbSBhbm90aGVyIGJyYW5jaCBpZiB0aGV5IG9yIGFueSBvZlxuICAvLyB0aGVpciBwYXJlbnRzIGFyZSBzaWJsaW5ncyBpbiBhIGdpdmVuIGRpc2p1bmN0aW9uXG4gIGZvciAodmFyIHNlbGYgPSB0aGlzOyBzZWxmOyBzZWxmID0gc2VsZi5wYXJlbnQpIHtcbiAgICBmb3IgKHZhciBvdGhlciA9IGFsdDsgb3RoZXI7IG90aGVyID0gb3RoZXIucGFyZW50KSB7XG4gICAgICBpZiAoc2VsZi5iYXNlID09PSBvdGhlci5iYXNlICYmIHNlbGYgIT09IG90aGVyKSB7IHJldHVybiB0cnVlIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG5CcmFuY2hJRC5wcm90b3R5cGUuc2libGluZyA9IGZ1bmN0aW9uIHNpYmxpbmcgKCkge1xuICByZXR1cm4gbmV3IEJyYW5jaElEKHRoaXMucGFyZW50LCB0aGlzLmJhc2UpXG59O1xuXG52YXIgUmVnRXhwVmFsaWRhdGlvblN0YXRlID0gZnVuY3Rpb24gUmVnRXhwVmFsaWRhdGlvblN0YXRlKHBhcnNlcikge1xuICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgdGhpcy52YWxpZEZsYWdzID0gXCJnaW1cIiArIChwYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ID8gXCJ1eVwiIDogXCJcIikgKyAocGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSA/IFwic1wiIDogXCJcIikgKyAocGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTMgPyBcImRcIiA6IFwiXCIpICsgKHBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDE1ID8gXCJ2XCIgOiBcIlwiKTtcbiAgdGhpcy51bmljb2RlUHJvcGVydGllcyA9IGRhdGFbcGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTQgPyAxNCA6IHBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uXTtcbiAgdGhpcy5zb3VyY2UgPSBcIlwiO1xuICB0aGlzLmZsYWdzID0gXCJcIjtcbiAgdGhpcy5zdGFydCA9IDA7XG4gIHRoaXMuc3dpdGNoVSA9IGZhbHNlO1xuICB0aGlzLnN3aXRjaFYgPSBmYWxzZTtcbiAgdGhpcy5zd2l0Y2hOID0gZmFsc2U7XG4gIHRoaXMucG9zID0gMDtcbiAgdGhpcy5sYXN0SW50VmFsdWUgPSAwO1xuICB0aGlzLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gIHRoaXMubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlID0gZmFsc2U7XG4gIHRoaXMubnVtQ2FwdHVyaW5nUGFyZW5zID0gMDtcbiAgdGhpcy5tYXhCYWNrUmVmZXJlbmNlID0gMDtcbiAgdGhpcy5ncm91cE5hbWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5iYWNrUmVmZXJlbmNlTmFtZXMgPSBbXTtcbiAgdGhpcy5icmFuY2hJRCA9IG51bGw7XG59O1xuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQgKHN0YXJ0LCBwYXR0ZXJuLCBmbGFncykge1xuICB2YXIgdW5pY29kZVNldHMgPSBmbGFncy5pbmRleE9mKFwidlwiKSAhPT0gLTE7XG4gIHZhciB1bmljb2RlID0gZmxhZ3MuaW5kZXhPZihcInVcIikgIT09IC0xO1xuICB0aGlzLnN0YXJ0ID0gc3RhcnQgfCAwO1xuICB0aGlzLnNvdXJjZSA9IHBhdHRlcm4gKyBcIlwiO1xuICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gIGlmICh1bmljb2RlU2V0cyAmJiB0aGlzLnBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDE1KSB7XG4gICAgdGhpcy5zd2l0Y2hVID0gdHJ1ZTtcbiAgICB0aGlzLnN3aXRjaFYgPSB0cnVlO1xuICAgIHRoaXMuc3dpdGNoTiA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zd2l0Y2hVID0gdW5pY29kZSAmJiB0aGlzLnBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDY7XG4gICAgdGhpcy5zd2l0Y2hWID0gZmFsc2U7XG4gICAgdGhpcy5zd2l0Y2hOID0gdW5pY29kZSAmJiB0aGlzLnBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDk7XG4gIH1cbn07XG5cblJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUucmFpc2UgPSBmdW5jdGlvbiByYWlzZSAobWVzc2FnZSkge1xuICB0aGlzLnBhcnNlci5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIChcIkludmFsaWQgcmVndWxhciBleHByZXNzaW9uOiAvXCIgKyAodGhpcy5zb3VyY2UpICsgXCIvOiBcIiArIG1lc3NhZ2UpKTtcbn07XG5cbi8vIElmIHUgZmxhZyBpcyBnaXZlbiwgdGhpcyByZXR1cm5zIHRoZSBjb2RlIHBvaW50IGF0IHRoZSBpbmRleCAoaXQgY29tYmluZXMgYSBzdXJyb2dhdGUgcGFpcikuXG4vLyBPdGhlcndpc2UsIHRoaXMgcmV0dXJucyB0aGUgY29kZSB1bml0IG9mIHRoZSBpbmRleCAoY2FuIGJlIGEgcGFydCBvZiBhIHN1cnJvZ2F0ZSBwYWlyKS5cblJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiBhdCAoaSwgZm9yY2VVKSB7XG4gICAgaWYgKCBmb3JjZVUgPT09IHZvaWQgMCApIGZvcmNlVSA9IGZhbHNlO1xuXG4gIHZhciBzID0gdGhpcy5zb3VyY2U7XG4gIHZhciBsID0gcy5sZW5ndGg7XG4gIGlmIChpID49IGwpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICB2YXIgYyA9IHMuY2hhckNvZGVBdChpKTtcbiAgaWYgKCEoZm9yY2VVIHx8IHRoaXMuc3dpdGNoVSkgfHwgYyA8PSAweEQ3RkYgfHwgYyA+PSAweEUwMDAgfHwgaSArIDEgPj0gbCkge1xuICAgIHJldHVybiBjXG4gIH1cbiAgdmFyIG5leHQgPSBzLmNoYXJDb2RlQXQoaSArIDEpO1xuICByZXR1cm4gbmV4dCA+PSAweERDMDAgJiYgbmV4dCA8PSAweERGRkYgPyAoYyA8PCAxMCkgKyBuZXh0IC0gMHgzNUZEQzAwIDogY1xufTtcblxuUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5uZXh0SW5kZXggPSBmdW5jdGlvbiBuZXh0SW5kZXggKGksIGZvcmNlVSkge1xuICAgIGlmICggZm9yY2VVID09PSB2b2lkIDAgKSBmb3JjZVUgPSBmYWxzZTtcblxuICB2YXIgcyA9IHRoaXMuc291cmNlO1xuICB2YXIgbCA9IHMubGVuZ3RoO1xuICBpZiAoaSA+PSBsKSB7XG4gICAgcmV0dXJuIGxcbiAgfVxuICB2YXIgYyA9IHMuY2hhckNvZGVBdChpKSwgbmV4dDtcbiAgaWYgKCEoZm9yY2VVIHx8IHRoaXMuc3dpdGNoVSkgfHwgYyA8PSAweEQ3RkYgfHwgYyA+PSAweEUwMDAgfHwgaSArIDEgPj0gbCB8fFxuICAgICAgKG5leHQgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4REMwMCB8fCBuZXh0ID4gMHhERkZGKSB7XG4gICAgcmV0dXJuIGkgKyAxXG4gIH1cbiAgcmV0dXJuIGkgKyAyXG59O1xuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmN1cnJlbnQgPSBmdW5jdGlvbiBjdXJyZW50IChmb3JjZVUpIHtcbiAgICBpZiAoIGZvcmNlVSA9PT0gdm9pZCAwICkgZm9yY2VVID0gZmFsc2U7XG5cbiAgcmV0dXJuIHRoaXMuYXQodGhpcy5wb3MsIGZvcmNlVSlcbn07XG5cblJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUubG9va2FoZWFkID0gZnVuY3Rpb24gbG9va2FoZWFkIChmb3JjZVUpIHtcbiAgICBpZiAoIGZvcmNlVSA9PT0gdm9pZCAwICkgZm9yY2VVID0gZmFsc2U7XG5cbiAgcmV0dXJuIHRoaXMuYXQodGhpcy5uZXh0SW5kZXgodGhpcy5wb3MsIGZvcmNlVSksIGZvcmNlVSlcbn07XG5cblJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuYWR2YW5jZSA9IGZ1bmN0aW9uIGFkdmFuY2UgKGZvcmNlVSkge1xuICAgIGlmICggZm9yY2VVID09PSB2b2lkIDAgKSBmb3JjZVUgPSBmYWxzZTtcblxuICB0aGlzLnBvcyA9IHRoaXMubmV4dEluZGV4KHRoaXMucG9zLCBmb3JjZVUpO1xufTtcblxuUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5lYXQgPSBmdW5jdGlvbiBlYXQgKGNoLCBmb3JjZVUpIHtcbiAgICBpZiAoIGZvcmNlVSA9PT0gdm9pZCAwICkgZm9yY2VVID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMuY3VycmVudChmb3JjZVUpID09PSBjaCkge1xuICAgIHRoaXMuYWR2YW5jZShmb3JjZVUpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmVhdENoYXJzID0gZnVuY3Rpb24gZWF0Q2hhcnMgKGNocywgZm9yY2VVKSB7XG4gICAgaWYgKCBmb3JjZVUgPT09IHZvaWQgMCApIGZvcmNlVSA9IGZhbHNlO1xuXG4gIHZhciBwb3MgPSB0aGlzLnBvcztcbiAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBjaHM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgdmFyIGNoID0gbGlzdFtpXTtcblxuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmF0KHBvcywgZm9yY2VVKTtcbiAgICBpZiAoY3VycmVudCA9PT0gLTEgfHwgY3VycmVudCAhPT0gY2gpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBwb3MgPSB0aGlzLm5leHRJbmRleChwb3MsIGZvcmNlVSk7XG4gIH1cbiAgdGhpcy5wb3MgPSBwb3M7XG4gIHJldHVybiB0cnVlXG59O1xuXG4vKipcbiAqIFZhbGlkYXRlIHRoZSBmbGFncyBwYXJ0IG9mIGEgZ2l2ZW4gUmVnRXhwTGl0ZXJhbC5cbiAqXG4gKiBAcGFyYW0ge1JlZ0V4cFZhbGlkYXRpb25TdGF0ZX0gc3RhdGUgVGhlIHN0YXRlIHRvIHZhbGlkYXRlIFJlZ0V4cC5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5wcCQxLnZhbGlkYXRlUmVnRXhwRmxhZ3MgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgdmFsaWRGbGFncyA9IHN0YXRlLnZhbGlkRmxhZ3M7XG4gIHZhciBmbGFncyA9IHN0YXRlLmZsYWdzO1xuXG4gIHZhciB1ID0gZmFsc2U7XG4gIHZhciB2ID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbGFncy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBmbGFnID0gZmxhZ3MuY2hhckF0KGkpO1xuICAgIGlmICh2YWxpZEZsYWdzLmluZGV4T2YoZmxhZykgPT09IC0xKSB7XG4gICAgICB0aGlzLnJhaXNlKHN0YXRlLnN0YXJ0LCBcIkludmFsaWQgcmVndWxhciBleHByZXNzaW9uIGZsYWdcIik7XG4gICAgfVxuICAgIGlmIChmbGFncy5pbmRleE9mKGZsYWcsIGkgKyAxKSA+IC0xKSB7XG4gICAgICB0aGlzLnJhaXNlKHN0YXRlLnN0YXJ0LCBcIkR1cGxpY2F0ZSByZWd1bGFyIGV4cHJlc3Npb24gZmxhZ1wiKTtcbiAgICB9XG4gICAgaWYgKGZsYWcgPT09IFwidVwiKSB7IHUgPSB0cnVlOyB9XG4gICAgaWYgKGZsYWcgPT09IFwidlwiKSB7IHYgPSB0cnVlOyB9XG4gIH1cbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxNSAmJiB1ICYmIHYpIHtcbiAgICB0aGlzLnJhaXNlKHN0YXRlLnN0YXJ0LCBcIkludmFsaWQgcmVndWxhciBleHByZXNzaW9uIGZsYWdcIik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGhhc1Byb3Aob2JqKSB7XG4gIGZvciAodmFyIF8gaW4gb2JqKSB7IHJldHVybiB0cnVlIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuICogVmFsaWRhdGUgdGhlIHBhdHRlcm4gcGFydCBvZiBhIGdpdmVuIFJlZ0V4cExpdGVyYWwuXG4gKlxuICogQHBhcmFtIHtSZWdFeHBWYWxpZGF0aW9uU3RhdGV9IHN0YXRlIFRoZSBzdGF0ZSB0byB2YWxpZGF0ZSBSZWdFeHAuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xucHAkMS52YWxpZGF0ZVJlZ0V4cFBhdHRlcm4gPSBmdW5jdGlvbihzdGF0ZSkge1xuICB0aGlzLnJlZ2V4cF9wYXR0ZXJuKHN0YXRlKTtcblxuICAvLyBUaGUgZ29hbCBzeW1ib2wgZm9yIHRoZSBwYXJzZSBpcyB8UGF0dGVyblt+VSwgfk5dfC4gSWYgdGhlIHJlc3VsdCBvZlxuICAvLyBwYXJzaW5nIGNvbnRhaW5zIGEgfEdyb3VwTmFtZXwsIHJlcGFyc2Ugd2l0aCB0aGUgZ29hbCBzeW1ib2xcbiAgLy8gfFBhdHRlcm5bflUsICtOXXwgYW5kIHVzZSB0aGlzIHJlc3VsdCBpbnN0ZWFkLiBUaHJvdyBhICpTeW50YXhFcnJvcipcbiAgLy8gZXhjZXB0aW9uIGlmIF9QXyBkaWQgbm90IGNvbmZvcm0gdG8gdGhlIGdyYW1tYXIsIGlmIGFueSBlbGVtZW50cyBvZiBfUF9cbiAgLy8gd2VyZSBub3QgbWF0Y2hlZCBieSB0aGUgcGFyc2UsIG9yIGlmIGFueSBFYXJseSBFcnJvciBjb25kaXRpb25zIGV4aXN0LlxuICBpZiAoIXN0YXRlLnN3aXRjaE4gJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgaGFzUHJvcChzdGF0ZS5ncm91cE5hbWVzKSkge1xuICAgIHN0YXRlLnN3aXRjaE4gPSB0cnVlO1xuICAgIHRoaXMucmVnZXhwX3BhdHRlcm4oc3RhdGUpO1xuICB9XG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1QYXR0ZXJuXG5wcCQxLnJlZ2V4cF9wYXR0ZXJuID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgc3RhdGUucG9zID0gMDtcbiAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlID0gZmFsc2U7XG4gIHN0YXRlLm51bUNhcHR1cmluZ1BhcmVucyA9IDA7XG4gIHN0YXRlLm1heEJhY2tSZWZlcmVuY2UgPSAwO1xuICBzdGF0ZS5ncm91cE5hbWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgc3RhdGUuYmFja1JlZmVyZW5jZU5hbWVzLmxlbmd0aCA9IDA7XG4gIHN0YXRlLmJyYW5jaElEID0gbnVsbDtcblxuICB0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihzdGF0ZSk7XG5cbiAgaWYgKHN0YXRlLnBvcyAhPT0gc3RhdGUuc291cmNlLmxlbmd0aCkge1xuICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZXMgYXMgVjguXG4gICAgaWYgKHN0YXRlLmVhdCgweDI5IC8qICkgKi8pKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIlVubWF0Y2hlZCAnKSdcIik7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5lYXQoMHg1RCAvKiBdICovKSB8fCBzdGF0ZS5lYXQoMHg3RCAvKiB9ICovKSkge1xuICAgICAgc3RhdGUucmFpc2UoXCJMb25lIHF1YW50aWZpZXIgYnJhY2tldHNcIik7XG4gICAgfVxuICB9XG4gIGlmIChzdGF0ZS5tYXhCYWNrUmVmZXJlbmNlID4gc3RhdGUubnVtQ2FwdHVyaW5nUGFyZW5zKSB7XG4gICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGVzY2FwZVwiKTtcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHN0YXRlLmJhY2tSZWZlcmVuY2VOYW1lczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICB2YXIgbmFtZSA9IGxpc3RbaV07XG5cbiAgICBpZiAoIXN0YXRlLmdyb3VwTmFtZXNbbmFtZV0pIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBuYW1lZCBjYXB0dXJlIHJlZmVyZW5jZWRcIik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1EaXNqdW5jdGlvblxucHAkMS5yZWdleHBfZGlzanVuY3Rpb24gPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgdHJhY2tEaXNqdW5jdGlvbiA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxNjtcbiAgaWYgKHRyYWNrRGlzanVuY3Rpb24pIHsgc3RhdGUuYnJhbmNoSUQgPSBuZXcgQnJhbmNoSUQoc3RhdGUuYnJhbmNoSUQsIG51bGwpOyB9XG4gIHRoaXMucmVnZXhwX2FsdGVybmF0aXZlKHN0YXRlKTtcbiAgd2hpbGUgKHN0YXRlLmVhdCgweDdDIC8qIHwgKi8pKSB7XG4gICAgaWYgKHRyYWNrRGlzanVuY3Rpb24pIHsgc3RhdGUuYnJhbmNoSUQgPSBzdGF0ZS5icmFuY2hJRC5zaWJsaW5nKCk7IH1cbiAgICB0aGlzLnJlZ2V4cF9hbHRlcm5hdGl2ZShzdGF0ZSk7XG4gIH1cbiAgaWYgKHRyYWNrRGlzanVuY3Rpb24pIHsgc3RhdGUuYnJhbmNoSUQgPSBzdGF0ZS5icmFuY2hJRC5wYXJlbnQ7IH1cblxuICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2UgYXMgVjguXG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRRdWFudGlmaWVyKHN0YXRlLCB0cnVlKSkge1xuICAgIHN0YXRlLnJhaXNlKFwiTm90aGluZyB0byByZXBlYXRcIik7XG4gIH1cbiAgaWYgKHN0YXRlLmVhdCgweDdCIC8qIHsgKi8pKSB7XG4gICAgc3RhdGUucmFpc2UoXCJMb25lIHF1YW50aWZpZXIgYnJhY2tldHNcIik7XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUFsdGVybmF0aXZlXG5wcCQxLnJlZ2V4cF9hbHRlcm5hdGl2ZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHdoaWxlIChzdGF0ZS5wb3MgPCBzdGF0ZS5zb3VyY2UubGVuZ3RoICYmIHRoaXMucmVnZXhwX2VhdFRlcm0oc3RhdGUpKSB7fVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLVRlcm1cbnBwJDEucmVnZXhwX2VhdFRlcm0gPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAodGhpcy5yZWdleHBfZWF0QXNzZXJ0aW9uKHN0YXRlKSkge1xuICAgIC8vIEhhbmRsZSBgUXVhbnRpZmlhYmxlQXNzZXJ0aW9uIFF1YW50aWZpZXJgIGFsdGVybmF0aXZlLlxuICAgIC8vIGBzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGVgIGlzIHRydWUgaWYgdGhlIGxhc3QgZWF0ZW4gQXNzZXJ0aW9uXG4gICAgLy8gaXMgYSBRdWFudGlmaWFibGVBc3NlcnRpb24uXG4gICAgaWYgKHN0YXRlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSAmJiB0aGlzLnJlZ2V4cF9lYXRRdWFudGlmaWVyKHN0YXRlKSkge1xuICAgICAgLy8gTWFrZSB0aGUgc2FtZSBtZXNzYWdlIGFzIFY4LlxuICAgICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHF1YW50aWZpZXJcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoc3RhdGUuc3dpdGNoVSA/IHRoaXMucmVnZXhwX2VhdEF0b20oc3RhdGUpIDogdGhpcy5yZWdleHBfZWF0RXh0ZW5kZWRBdG9tKHN0YXRlKSkge1xuICAgIHRoaXMucmVnZXhwX2VhdFF1YW50aWZpZXIoc3RhdGUpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1Bc3NlcnRpb25cbnBwJDEucmVnZXhwX2VhdEFzc2VydGlvbiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlID0gZmFsc2U7XG5cbiAgLy8gXiwgJFxuICBpZiAoc3RhdGUuZWF0KDB4NUUgLyogXiAqLykgfHwgc3RhdGUuZWF0KDB4MjQgLyogJCAqLykpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gXFxiIFxcQlxuICBpZiAoc3RhdGUuZWF0KDB4NUMgLyogXFwgKi8pKSB7XG4gICAgaWYgKHN0YXRlLmVhdCgweDQyIC8qIEIgKi8pIHx8IHN0YXRlLmVhdCgweDYyIC8qIGIgKi8pKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuXG4gIC8vIExvb2thaGVhZCAvIExvb2tiZWhpbmRcbiAgaWYgKHN0YXRlLmVhdCgweDI4IC8qICggKi8pICYmIHN0YXRlLmVhdCgweDNGIC8qID8gKi8pKSB7XG4gICAgdmFyIGxvb2tiZWhpbmQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgIGxvb2tiZWhpbmQgPSBzdGF0ZS5lYXQoMHgzQyAvKiA8ICovKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmVhdCgweDNEIC8qID0gKi8pIHx8IHN0YXRlLmVhdCgweDIxIC8qICEgKi8pKSB7XG4gICAgICB0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihzdGF0ZSk7XG4gICAgICBpZiAoIXN0YXRlLmVhdCgweDI5IC8qICkgKi8pKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiVW50ZXJtaW5hdGVkIGdyb3VwXCIpO1xuICAgICAgfVxuICAgICAgc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlID0gIWxvb2tiZWhpbmQ7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVF1YW50aWZpZXJcbnBwJDEucmVnZXhwX2VhdFF1YW50aWZpZXIgPSBmdW5jdGlvbihzdGF0ZSwgbm9FcnJvcikge1xuICBpZiAoIG5vRXJyb3IgPT09IHZvaWQgMCApIG5vRXJyb3IgPSBmYWxzZTtcblxuICBpZiAodGhpcy5yZWdleHBfZWF0UXVhbnRpZmllclByZWZpeChzdGF0ZSwgbm9FcnJvcikpIHtcbiAgICBzdGF0ZS5lYXQoMHgzRiAvKiA/ICovKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUXVhbnRpZmllclByZWZpeFxucHAkMS5yZWdleHBfZWF0UXVhbnRpZmllclByZWZpeCA9IGZ1bmN0aW9uKHN0YXRlLCBub0Vycm9yKSB7XG4gIHJldHVybiAoXG4gICAgc3RhdGUuZWF0KDB4MkEgLyogKiAqLykgfHxcbiAgICBzdGF0ZS5lYXQoMHgyQiAvKiArICovKSB8fFxuICAgIHN0YXRlLmVhdCgweDNGIC8qID8gKi8pIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0QnJhY2VkUXVhbnRpZmllcihzdGF0ZSwgbm9FcnJvcilcbiAgKVxufTtcbnBwJDEucmVnZXhwX2VhdEJyYWNlZFF1YW50aWZpZXIgPSBmdW5jdGlvbihzdGF0ZSwgbm9FcnJvcikge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIGlmIChzdGF0ZS5lYXQoMHg3QiAvKiB7ICovKSkge1xuICAgIHZhciBtaW4gPSAwLCBtYXggPSAtMTtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0RGVjaW1hbERpZ2l0cyhzdGF0ZSkpIHtcbiAgICAgIG1pbiA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIGlmIChzdGF0ZS5lYXQoMHgyQyAvKiAsICovKSAmJiB0aGlzLnJlZ2V4cF9lYXREZWNpbWFsRGlnaXRzKHN0YXRlKSkge1xuICAgICAgICBtYXggPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4N0QgLyogfSAqLykpIHtcbiAgICAgICAgLy8gU3ludGF4RXJyb3IgaW4gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3NlYy10ZXJtXG4gICAgICAgIGlmIChtYXggIT09IC0xICYmIG1heCA8IG1pbiAmJiAhbm9FcnJvcikge1xuICAgICAgICAgIHN0YXRlLnJhaXNlKFwibnVtYmVycyBvdXQgb2Ygb3JkZXIgaW4ge30gcXVhbnRpZmllclwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhdGUuc3dpdGNoVSAmJiAhbm9FcnJvcikge1xuICAgICAgc3RhdGUucmFpc2UoXCJJbmNvbXBsZXRlIHF1YW50aWZpZXJcIik7XG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQXRvbVxucHAkMS5yZWdleHBfZWF0QXRvbSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHJldHVybiAoXG4gICAgdGhpcy5yZWdleHBfZWF0UGF0dGVybkNoYXJhY3RlcnMoc3RhdGUpIHx8XG4gICAgc3RhdGUuZWF0KDB4MkUgLyogLiAqLykgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRSZXZlcnNlU29saWR1c0F0b21Fc2NhcGUoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3Moc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0VW5jYXB0dXJpbmdHcm91cChzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRDYXB0dXJpbmdHcm91cChzdGF0ZSlcbiAgKVxufTtcbnBwJDEucmVnZXhwX2VhdFJldmVyc2VTb2xpZHVzQXRvbUVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgaWYgKHN0YXRlLmVhdCgweDVDIC8qIFxcICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRBdG9tRXNjYXBlKHN0YXRlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xucHAkMS5yZWdleHBfZWF0VW5jYXB0dXJpbmdHcm91cCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgaWYgKHN0YXRlLmVhdCgweDI4IC8qICggKi8pKSB7XG4gICAgaWYgKHN0YXRlLmVhdCgweDNGIC8qID8gKi8pKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDE2KSB7XG4gICAgICAgIHZhciBhZGRNb2RpZmllcnMgPSB0aGlzLnJlZ2V4cF9lYXRNb2RpZmllcnMoc3RhdGUpO1xuICAgICAgICB2YXIgaGFzSHlwaGVuID0gc3RhdGUuZWF0KDB4MkQgLyogLSAqLyk7XG4gICAgICAgIGlmIChhZGRNb2RpZmllcnMgfHwgaGFzSHlwaGVuKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhZGRNb2RpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtb2RpZmllciA9IGFkZE1vZGlmaWVycy5jaGFyQXQoaSk7XG4gICAgICAgICAgICBpZiAoYWRkTW9kaWZpZXJzLmluZGV4T2YobW9kaWZpZXIsIGkgKyAxKSA+IC0xKSB7XG4gICAgICAgICAgICAgIHN0YXRlLnJhaXNlKFwiRHVwbGljYXRlIHJlZ3VsYXIgZXhwcmVzc2lvbiBtb2RpZmllcnNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYXNIeXBoZW4pIHtcbiAgICAgICAgICAgIHZhciByZW1vdmVNb2RpZmllcnMgPSB0aGlzLnJlZ2V4cF9lYXRNb2RpZmllcnMoc3RhdGUpO1xuICAgICAgICAgICAgaWYgKCFhZGRNb2RpZmllcnMgJiYgIXJlbW92ZU1vZGlmaWVycyAmJiBzdGF0ZS5jdXJyZW50KCkgPT09IDB4M0EgLyogOiAqLykge1xuICAgICAgICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgcmVndWxhciBleHByZXNzaW9uIG1vZGlmaWVyc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHJlbW92ZU1vZGlmaWVycy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICAgIHZhciBtb2RpZmllciQxID0gcmVtb3ZlTW9kaWZpZXJzLmNoYXJBdChpJDEpO1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgcmVtb3ZlTW9kaWZpZXJzLmluZGV4T2YobW9kaWZpZXIkMSwgaSQxICsgMSkgPiAtMSB8fFxuICAgICAgICAgICAgICAgIGFkZE1vZGlmaWVycy5pbmRleE9mKG1vZGlmaWVyJDEpID4gLTFcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUucmFpc2UoXCJEdXBsaWNhdGUgcmVndWxhciBleHByZXNzaW9uIG1vZGlmaWVyc1wiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmVhdCgweDNBIC8qIDogKi8pKSB7XG4gICAgICAgIHRoaXMucmVnZXhwX2Rpc2p1bmN0aW9uKHN0YXRlKTtcbiAgICAgICAgaWYgKHN0YXRlLmVhdCgweDI5IC8qICkgKi8pKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5yYWlzZShcIlVudGVybWluYXRlZCBncm91cFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xucHAkMS5yZWdleHBfZWF0Q2FwdHVyaW5nR3JvdXAgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoc3RhdGUuZWF0KDB4MjggLyogKCAqLykpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgIHRoaXMucmVnZXhwX2dyb3VwU3BlY2lmaWVyKHN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmN1cnJlbnQoKSA9PT0gMHgzRiAvKiA/ICovKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZ3JvdXBcIik7XG4gICAgfVxuICAgIHRoaXMucmVnZXhwX2Rpc2p1bmN0aW9uKHN0YXRlKTtcbiAgICBpZiAoc3RhdGUuZWF0KDB4MjkgLyogKSAqLykpIHtcbiAgICAgIHN0YXRlLm51bUNhcHR1cmluZ1BhcmVucyArPSAxO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucmFpc2UoXCJVbnRlcm1pbmF0ZWQgZ3JvdXBcIik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuLy8gUmVndWxhckV4cHJlc3Npb25Nb2RpZmllcnMgOjpcbi8vICAgW2VtcHR5XVxuLy8gICBSZWd1bGFyRXhwcmVzc2lvbk1vZGlmaWVycyBSZWd1bGFyRXhwcmVzc2lvbk1vZGlmaWVyXG5wcCQxLnJlZ2V4cF9lYXRNb2RpZmllcnMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgbW9kaWZpZXJzID0gXCJcIjtcbiAgdmFyIGNoID0gMDtcbiAgd2hpbGUgKChjaCA9IHN0YXRlLmN1cnJlbnQoKSkgIT09IC0xICYmIGlzUmVndWxhckV4cHJlc3Npb25Nb2RpZmllcihjaCkpIHtcbiAgICBtb2RpZmllcnMgKz0gY29kZVBvaW50VG9TdHJpbmcoY2gpO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgfVxuICByZXR1cm4gbW9kaWZpZXJzXG59O1xuLy8gUmVndWxhckV4cHJlc3Npb25Nb2RpZmllciA6OiBvbmUgb2Zcbi8vICAgYGlgIGBtYCBgc2BcbmZ1bmN0aW9uIGlzUmVndWxhckV4cHJlc3Npb25Nb2RpZmllcihjaCkge1xuICByZXR1cm4gY2ggPT09IDB4NjkgLyogaSAqLyB8fCBjaCA9PT0gMHg2ZCAvKiBtICovIHx8IGNoID09PSAweDczIC8qIHMgKi9cbn1cblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUV4dGVuZGVkQXRvbVxucHAkMS5yZWdleHBfZWF0RXh0ZW5kZWRBdG9tID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgcmV0dXJuIChcbiAgICBzdGF0ZS5lYXQoMHgyRSAvKiAuICovKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdFJldmVyc2VTb2xpZHVzQXRvbUVzY2FwZShzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzcyhzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENhcHR1cmluZ0dyb3VwKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdEludmFsaWRCcmFjZWRRdWFudGlmaWVyKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdEV4dGVuZGVkUGF0dGVybkNoYXJhY3RlcihzdGF0ZSlcbiAgKVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUludmFsaWRCcmFjZWRRdWFudGlmaWVyXG5wcCQxLnJlZ2V4cF9lYXRJbnZhbGlkQnJhY2VkUXVhbnRpZmllciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRCcmFjZWRRdWFudGlmaWVyKHN0YXRlLCB0cnVlKSkge1xuICAgIHN0YXRlLnJhaXNlKFwiTm90aGluZyB0byByZXBlYXRcIik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1TeW50YXhDaGFyYWN0ZXJcbnBwJDEucmVnZXhwX2VhdFN5bnRheENoYXJhY3RlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGlzU3ludGF4Q2hhcmFjdGVyKGNoKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbmZ1bmN0aW9uIGlzU3ludGF4Q2hhcmFjdGVyKGNoKSB7XG4gIHJldHVybiAoXG4gICAgY2ggPT09IDB4MjQgLyogJCAqLyB8fFxuICAgIGNoID49IDB4MjggLyogKCAqLyAmJiBjaCA8PSAweDJCIC8qICsgKi8gfHxcbiAgICBjaCA9PT0gMHgyRSAvKiAuICovIHx8XG4gICAgY2ggPT09IDB4M0YgLyogPyAqLyB8fFxuICAgIGNoID49IDB4NUIgLyogWyAqLyAmJiBjaCA8PSAweDVFIC8qIF4gKi8gfHxcbiAgICBjaCA+PSAweDdCIC8qIHsgKi8gJiYgY2ggPD0gMHg3RCAvKiB9ICovXG4gIClcbn1cblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUGF0dGVybkNoYXJhY3RlclxuLy8gQnV0IGVhdCBlYWdlci5cbnBwJDEucmVnZXhwX2VhdFBhdHRlcm5DaGFyYWN0ZXJzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICB2YXIgY2ggPSAwO1xuICB3aGlsZSAoKGNoID0gc3RhdGUuY3VycmVudCgpKSAhPT0gLTEgJiYgIWlzU3ludGF4Q2hhcmFjdGVyKGNoKSkge1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgfVxuICByZXR1cm4gc3RhdGUucG9zICE9PSBzdGFydFxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUV4dGVuZGVkUGF0dGVybkNoYXJhY3RlclxucHAkMS5yZWdleHBfZWF0RXh0ZW5kZWRQYXR0ZXJuQ2hhcmFjdGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoXG4gICAgY2ggIT09IC0xICYmXG4gICAgY2ggIT09IDB4MjQgLyogJCAqLyAmJlxuICAgICEoY2ggPj0gMHgyOCAvKiAoICovICYmIGNoIDw9IDB4MkIgLyogKyAqLykgJiZcbiAgICBjaCAhPT0gMHgyRSAvKiAuICovICYmXG4gICAgY2ggIT09IDB4M0YgLyogPyAqLyAmJlxuICAgIGNoICE9PSAweDVCIC8qIFsgKi8gJiZcbiAgICBjaCAhPT0gMHg1RSAvKiBeICovICYmXG4gICAgY2ggIT09IDB4N0MgLyogfCAqL1xuICApIHtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIEdyb3VwU3BlY2lmaWVyIDo6XG4vLyAgIFtlbXB0eV1cbi8vICAgYD9gIEdyb3VwTmFtZVxucHAkMS5yZWdleHBfZ3JvdXBTcGVjaWZpZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoc3RhdGUuZWF0KDB4M0YgLyogPyAqLykpIHtcbiAgICBpZiAoIXRoaXMucmVnZXhwX2VhdEdyb3VwTmFtZShzdGF0ZSkpIHsgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGdyb3VwXCIpOyB9XG4gICAgdmFyIHRyYWNrRGlzanVuY3Rpb24gPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTY7XG4gICAgdmFyIGtub3duID0gc3RhdGUuZ3JvdXBOYW1lc1tzdGF0ZS5sYXN0U3RyaW5nVmFsdWVdO1xuICAgIGlmIChrbm93bikge1xuICAgICAgaWYgKHRyYWNrRGlzanVuY3Rpb24pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBrbm93bjsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICB2YXIgYWx0SUQgPSBsaXN0W2ldO1xuXG4gICAgICAgICAgaWYgKCFhbHRJRC5zZXBhcmF0ZWRGcm9tKHN0YXRlLmJyYW5jaElEKSlcbiAgICAgICAgICAgIHsgc3RhdGUucmFpc2UoXCJEdXBsaWNhdGUgY2FwdHVyZSBncm91cCBuYW1lXCIpOyB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiRHVwbGljYXRlIGNhcHR1cmUgZ3JvdXAgbmFtZVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRyYWNrRGlzanVuY3Rpb24pIHtcbiAgICAgIChrbm93biB8fCAoc3RhdGUuZ3JvdXBOYW1lc1tzdGF0ZS5sYXN0U3RyaW5nVmFsdWVdID0gW10pKS5wdXNoKHN0YXRlLmJyYW5jaElEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuZ3JvdXBOYW1lc1tzdGF0ZS5sYXN0U3RyaW5nVmFsdWVdID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIEdyb3VwTmFtZSA6OlxuLy8gICBgPGAgUmVnRXhwSWRlbnRpZmllck5hbWUgYD5gXG4vLyBOb3RlOiB0aGlzIHVwZGF0ZXMgYHN0YXRlLmxhc3RTdHJpbmdWYWx1ZWAgcHJvcGVydHkgd2l0aCB0aGUgZWF0ZW4gbmFtZS5cbnBwJDEucmVnZXhwX2VhdEdyb3VwTmFtZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gIGlmIChzdGF0ZS5lYXQoMHgzQyAvKiA8ICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyTmFtZShzdGF0ZSkgJiYgc3RhdGUuZWF0KDB4M0UgLyogPiAqLykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBjYXB0dXJlIGdyb3VwIG5hbWVcIik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBSZWdFeHBJZGVudGlmaWVyTmFtZSA6OlxuLy8gICBSZWdFeHBJZGVudGlmaWVyU3RhcnRcbi8vICAgUmVnRXhwSWRlbnRpZmllck5hbWUgUmVnRXhwSWRlbnRpZmllclBhcnRcbi8vIE5vdGU6IHRoaXMgdXBkYXRlcyBgc3RhdGUubGFzdFN0cmluZ1ZhbHVlYCBwcm9wZXJ0eSB3aXRoIHRoZSBlYXRlbiBuYW1lLlxucHAkMS5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllck5hbWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICBpZiAodGhpcy5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclN0YXJ0KHN0YXRlKSkge1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyhzdGF0ZS5sYXN0SW50VmFsdWUpO1xuICAgIHdoaWxlICh0aGlzLnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyUGFydChzdGF0ZSkpIHtcbiAgICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyhzdGF0ZS5sYXN0SW50VmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gUmVnRXhwSWRlbnRpZmllclN0YXJ0IDo6XG4vLyAgIFVuaWNvZGVJRFN0YXJ0XG4vLyAgIGAkYFxuLy8gICBgX2Bcbi8vICAgYFxcYCBSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2VbK1VdXG5wcCQxLnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyU3RhcnQgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIHZhciBmb3JjZVUgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTE7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoZm9yY2VVKTtcbiAgc3RhdGUuYWR2YW5jZShmb3JjZVUpO1xuXG4gIGlmIChjaCA9PT0gMHg1QyAvKiBcXCAqLyAmJiB0aGlzLnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2Uoc3RhdGUsIGZvcmNlVSkpIHtcbiAgICBjaCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgfVxuICBpZiAoaXNSZWdFeHBJZGVudGlmaWVyU3RhcnQoY2gpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICByZXR1cm4gZmFsc2Vcbn07XG5mdW5jdGlvbiBpc1JlZ0V4cElkZW50aWZpZXJTdGFydChjaCkge1xuICByZXR1cm4gaXNJZGVudGlmaWVyU3RhcnQoY2gsIHRydWUpIHx8IGNoID09PSAweDI0IC8qICQgKi8gfHwgY2ggPT09IDB4NUYgLyogXyAqL1xufVxuXG4vLyBSZWdFeHBJZGVudGlmaWVyUGFydCA6OlxuLy8gICBVbmljb2RlSURDb250aW51ZVxuLy8gICBgJGBcbi8vICAgYF9gXG4vLyAgIGBcXGAgUmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlWytVXVxuLy8gICA8WldOSj5cbi8vICAgPFpXSj5cbnBwJDEucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJQYXJ0ID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICB2YXIgZm9yY2VVID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExO1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KGZvcmNlVSk7XG4gIHN0YXRlLmFkdmFuY2UoZm9yY2VVKTtcblxuICBpZiAoY2ggPT09IDB4NUMgLyogXFwgKi8gJiYgdGhpcy5yZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlKHN0YXRlLCBmb3JjZVUpKSB7XG4gICAgY2ggPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gIH1cbiAgaWYgKGlzUmVnRXhwSWRlbnRpZmllclBhcnQoY2gpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICByZXR1cm4gZmFsc2Vcbn07XG5mdW5jdGlvbiBpc1JlZ0V4cElkZW50aWZpZXJQYXJ0KGNoKSB7XG4gIHJldHVybiBpc0lkZW50aWZpZXJDaGFyKGNoLCB0cnVlKSB8fCBjaCA9PT0gMHgyNCAvKiAkICovIHx8IGNoID09PSAweDVGIC8qIF8gKi8gfHwgY2ggPT09IDB4MjAwQyAvKiA8WldOSj4gKi8gfHwgY2ggPT09IDB4MjAwRCAvKiA8WldKPiAqL1xufVxuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItQXRvbUVzY2FwZVxucHAkMS5yZWdleHBfZWF0QXRvbUVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmIChcbiAgICB0aGlzLnJlZ2V4cF9lYXRCYWNrUmVmZXJlbmNlKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckVzY2FwZShzdGF0ZSkgfHxcbiAgICAoc3RhdGUuc3dpdGNoTiAmJiB0aGlzLnJlZ2V4cF9lYXRLR3JvdXBOYW1lKHN0YXRlKSlcbiAgKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZSBhcyBWOC5cbiAgICBpZiAoc3RhdGUuY3VycmVudCgpID09PSAweDYzIC8qIGMgKi8pIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCB1bmljb2RlIGVzY2FwZVwiKTtcbiAgICB9XG4gICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGVzY2FwZVwiKTtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5wcCQxLnJlZ2V4cF9lYXRCYWNrUmVmZXJlbmNlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBpZiAodGhpcy5yZWdleHBfZWF0RGVjaW1hbEVzY2FwZShzdGF0ZSkpIHtcbiAgICB2YXIgbiA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgLy8gRm9yIFN5bnRheEVycm9yIGluIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNzZWMtYXRvbWVzY2FwZVxuICAgICAgaWYgKG4gPiBzdGF0ZS5tYXhCYWNrUmVmZXJlbmNlKSB7XG4gICAgICAgIHN0YXRlLm1heEJhY2tSZWZlcmVuY2UgPSBuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKG4gPD0gc3RhdGUubnVtQ2FwdHVyaW5nUGFyZW5zKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5wcCQxLnJlZ2V4cF9lYXRLR3JvdXBOYW1lID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVhdCgweDZCIC8qIGsgKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdEdyb3VwTmFtZShzdGF0ZSkpIHtcbiAgICAgIHN0YXRlLmJhY2tSZWZlcmVuY2VOYW1lcy5wdXNoKHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgbmFtZWQgcmVmZXJlbmNlXCIpO1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUNoYXJhY3RlckVzY2FwZVxucHAkMS5yZWdleHBfZWF0Q2hhcmFjdGVyRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgcmV0dXJuIChcbiAgICB0aGlzLnJlZ2V4cF9lYXRDb250cm9sRXNjYXBlKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENDb250cm9sTGV0dGVyKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdFplcm8oc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0SGV4RXNjYXBlU2VxdWVuY2Uoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlKHN0YXRlLCBmYWxzZSkgfHxcbiAgICAoIXN0YXRlLnN3aXRjaFUgJiYgdGhpcy5yZWdleHBfZWF0TGVnYWN5T2N0YWxFc2NhcGVTZXF1ZW5jZShzdGF0ZSkpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0SWRlbnRpdHlFc2NhcGUoc3RhdGUpXG4gIClcbn07XG5wcCQxLnJlZ2V4cF9lYXRDQ29udHJvbExldHRlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgaWYgKHN0YXRlLmVhdCgweDYzIC8qIGMgKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdENvbnRyb2xMZXR0ZXIoc3RhdGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5wcCQxLnJlZ2V4cF9lYXRaZXJvID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmN1cnJlbnQoKSA9PT0gMHgzMCAvKiAwICovICYmICFpc0RlY2ltYWxEaWdpdChzdGF0ZS5sb29rYWhlYWQoKSkpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ29udHJvbEVzY2FwZVxucHAkMS5yZWdleHBfZWF0Q29udHJvbEVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGNoID09PSAweDc0IC8qIHQgKi8pIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDA5OyAvKiBcXHQgKi9cbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoY2ggPT09IDB4NkUgLyogbiAqLykge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MEE7IC8qIFxcbiAqL1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChjaCA9PT0gMHg3NiAvKiB2ICovKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwQjsgLyogXFx2ICovXG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGNoID09PSAweDY2IC8qIGYgKi8pIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDBDOyAvKiBcXGYgKi9cbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoY2ggPT09IDB4NzIgLyogciAqLykge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MEQ7IC8qIFxcciAqL1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ29udHJvbExldHRlclxucHAkMS5yZWdleHBfZWF0Q29udHJvbExldHRlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGlzQ29udHJvbExldHRlcihjaCkpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaCAlIDB4MjA7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuZnVuY3Rpb24gaXNDb250cm9sTGV0dGVyKGNoKSB7XG4gIHJldHVybiAoXG4gICAgKGNoID49IDB4NDEgLyogQSAqLyAmJiBjaCA8PSAweDVBIC8qIFogKi8pIHx8XG4gICAgKGNoID49IDB4NjEgLyogYSAqLyAmJiBjaCA8PSAweDdBIC8qIHogKi8pXG4gIClcbn1cblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlXG5wcCQxLnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2UgPSBmdW5jdGlvbihzdGF0ZSwgZm9yY2VVKSB7XG4gIGlmICggZm9yY2VVID09PSB2b2lkIDAgKSBmb3JjZVUgPSBmYWxzZTtcblxuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIHZhciBzd2l0Y2hVID0gZm9yY2VVIHx8IHN0YXRlLnN3aXRjaFU7XG5cbiAgaWYgKHN0YXRlLmVhdCgweDc1IC8qIHUgKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzKHN0YXRlLCA0KSkge1xuICAgICAgdmFyIGxlYWQgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICBpZiAoc3dpdGNoVSAmJiBsZWFkID49IDB4RDgwMCAmJiBsZWFkIDw9IDB4REJGRikge1xuICAgICAgICB2YXIgbGVhZFN1cnJvZ2F0ZUVuZCA9IHN0YXRlLnBvcztcbiAgICAgICAgaWYgKHN0YXRlLmVhdCgweDVDIC8qIFxcICovKSAmJiBzdGF0ZS5lYXQoMHg3NSAvKiB1ICovKSAmJiB0aGlzLnJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cyhzdGF0ZSwgNCkpIHtcbiAgICAgICAgICB2YXIgdHJhaWwgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICAgICAgaWYgKHRyYWlsID49IDB4REMwMCAmJiB0cmFpbCA8PSAweERGRkYpIHtcbiAgICAgICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IChsZWFkIC0gMHhEODAwKSAqIDB4NDAwICsgKHRyYWlsIC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5wb3MgPSBsZWFkU3Vycm9nYXRlRW5kO1xuICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBsZWFkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKFxuICAgICAgc3dpdGNoVSAmJlxuICAgICAgc3RhdGUuZWF0KDB4N0IgLyogeyAqLykgJiZcbiAgICAgIHRoaXMucmVnZXhwX2VhdEhleERpZ2l0cyhzdGF0ZSkgJiZcbiAgICAgIHN0YXRlLmVhdCgweDdEIC8qIH0gKi8pICYmXG4gICAgICBpc1ZhbGlkVW5pY29kZShzdGF0ZS5sYXN0SW50VmFsdWUpXG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoc3dpdGNoVSkge1xuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHVuaWNvZGUgZXNjYXBlXCIpO1xuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufTtcbmZ1bmN0aW9uIGlzVmFsaWRVbmljb2RlKGNoKSB7XG4gIHJldHVybiBjaCA+PSAwICYmIGNoIDw9IDB4MTBGRkZGXG59XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1JZGVudGl0eUVzY2FwZVxucHAkMS5yZWdleHBfZWF0SWRlbnRpdHlFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRTeW50YXhDaGFyYWN0ZXIoc3RhdGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoc3RhdGUuZWF0KDB4MkYgLyogLyAqLykpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MkY7IC8qIC8gKi9cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoY2ggIT09IDB4NjMgLyogYyAqLyAmJiAoIXN0YXRlLnN3aXRjaE4gfHwgY2ggIT09IDB4NkIgLyogayAqLykpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtRGVjaW1hbEVzY2FwZVxucHAkMS5yZWdleHBfZWF0RGVjaW1hbEVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGNoID49IDB4MzEgLyogMSAqLyAmJiBjaCA8PSAweDM5IC8qIDkgKi8pIHtcbiAgICBkbyB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAxMCAqIHN0YXRlLmxhc3RJbnRWYWx1ZSArIChjaCAtIDB4MzAgLyogMCAqLyk7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgfSB3aGlsZSAoKGNoID0gc3RhdGUuY3VycmVudCgpKSA+PSAweDMwIC8qIDAgKi8gJiYgY2ggPD0gMHgzOSAvKiA5ICovKVxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBSZXR1cm4gdmFsdWVzIHVzZWQgYnkgY2hhcmFjdGVyIHNldCBwYXJzaW5nIG1ldGhvZHMsIG5lZWRlZCB0b1xuLy8gZm9yYmlkIG5lZ2F0aW9uIG9mIHNldHMgdGhhdCBjYW4gbWF0Y2ggc3RyaW5ncy5cbnZhciBDaGFyU2V0Tm9uZSA9IDA7IC8vIE5vdGhpbmcgcGFyc2VkXG52YXIgQ2hhclNldE9rID0gMTsgLy8gQ29uc3RydWN0IHBhcnNlZCwgY2Fubm90IGNvbnRhaW4gc3RyaW5nc1xudmFyIENoYXJTZXRTdHJpbmcgPSAyOyAvLyBDb25zdHJ1Y3QgcGFyc2VkLCBjYW4gY29udGFpbiBzdHJpbmdzXG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNoYXJhY3RlckNsYXNzRXNjYXBlXG5wcCQxLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzc0VzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcblxuICBpZiAoaXNDaGFyYWN0ZXJDbGFzc0VzY2FwZShjaCkpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAtMTtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIENoYXJTZXRPa1xuICB9XG5cbiAgdmFyIG5lZ2F0ZSA9IGZhbHNlO1xuICBpZiAoXG4gICAgc3RhdGUuc3dpdGNoVSAmJlxuICAgIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmXG4gICAgKChuZWdhdGUgPSBjaCA9PT0gMHg1MCAvKiBQICovKSB8fCBjaCA9PT0gMHg3MCAvKiBwICovKVxuICApIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAtMTtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBpZiAoXG4gICAgICBzdGF0ZS5lYXQoMHg3QiAvKiB7ICovKSAmJlxuICAgICAgKHJlc3VsdCA9IHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlRXhwcmVzc2lvbihzdGF0ZSkpICYmXG4gICAgICBzdGF0ZS5lYXQoMHg3RCAvKiB9ICovKVxuICAgICkge1xuICAgICAgaWYgKG5lZ2F0ZSAmJiByZXN1bHQgPT09IENoYXJTZXRTdHJpbmcpIHsgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IG5hbWVcIik7IH1cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG4gICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IG5hbWVcIik7XG4gIH1cblxuICByZXR1cm4gQ2hhclNldE5vbmVcbn07XG5cbmZ1bmN0aW9uIGlzQ2hhcmFjdGVyQ2xhc3NFc2NhcGUoY2gpIHtcbiAgcmV0dXJuIChcbiAgICBjaCA9PT0gMHg2NCAvKiBkICovIHx8XG4gICAgY2ggPT09IDB4NDQgLyogRCAqLyB8fFxuICAgIGNoID09PSAweDczIC8qIHMgKi8gfHxcbiAgICBjaCA9PT0gMHg1MyAvKiBTICovIHx8XG4gICAgY2ggPT09IDB4NzcgLyogdyAqLyB8fFxuICAgIGNoID09PSAweDU3IC8qIFcgKi9cbiAgKVxufVxuXG4vLyBVbmljb2RlUHJvcGVydHlWYWx1ZUV4cHJlc3Npb24gOjpcbi8vICAgVW5pY29kZVByb3BlcnR5TmFtZSBgPWAgVW5pY29kZVByb3BlcnR5VmFsdWVcbi8vICAgTG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlXG5wcCQxLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZUV4cHJlc3Npb24gPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG5cbiAgLy8gVW5pY29kZVByb3BlcnR5TmFtZSBgPWAgVW5pY29kZVByb3BlcnR5VmFsdWVcbiAgaWYgKHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eU5hbWUoc3RhdGUpICYmIHN0YXRlLmVhdCgweDNEIC8qID0gKi8pKSB7XG4gICAgdmFyIG5hbWUgPSBzdGF0ZS5sYXN0U3RyaW5nVmFsdWU7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlKHN0YXRlKSkge1xuICAgICAgdmFyIHZhbHVlID0gc3RhdGUubGFzdFN0cmluZ1ZhbHVlO1xuICAgICAgdGhpcy5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lQW5kVmFsdWUoc3RhdGUsIG5hbWUsIHZhbHVlKTtcbiAgICAgIHJldHVybiBDaGFyU2V0T2tcbiAgICB9XG4gIH1cbiAgc3RhdGUucG9zID0gc3RhcnQ7XG5cbiAgLy8gTG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlXG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUoc3RhdGUpKSB7XG4gICAgdmFyIG5hbWVPclZhbHVlID0gc3RhdGUubGFzdFN0cmluZ1ZhbHVlO1xuICAgIHJldHVybiB0aGlzLnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlKHN0YXRlLCBuYW1lT3JWYWx1ZSlcbiAgfVxuICByZXR1cm4gQ2hhclNldE5vbmVcbn07XG5cbnBwJDEucmVnZXhwX3ZhbGlkYXRlVW5pY29kZVByb3BlcnR5TmFtZUFuZFZhbHVlID0gZnVuY3Rpb24oc3RhdGUsIG5hbWUsIHZhbHVlKSB7XG4gIGlmICghaGFzT3duKHN0YXRlLnVuaWNvZGVQcm9wZXJ0aWVzLm5vbkJpbmFyeSwgbmFtZSkpXG4gICAgeyBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgbmFtZVwiKTsgfVxuICBpZiAoIXN0YXRlLnVuaWNvZGVQcm9wZXJ0aWVzLm5vbkJpbmFyeVtuYW1lXS50ZXN0KHZhbHVlKSlcbiAgICB7IHN0YXRlLnJhaXNlKFwiSW52YWxpZCBwcm9wZXJ0eSB2YWx1ZVwiKTsgfVxufTtcblxucHAkMS5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZSA9IGZ1bmN0aW9uKHN0YXRlLCBuYW1lT3JWYWx1ZSkge1xuICBpZiAoc3RhdGUudW5pY29kZVByb3BlcnRpZXMuYmluYXJ5LnRlc3QobmFtZU9yVmFsdWUpKSB7IHJldHVybiBDaGFyU2V0T2sgfVxuICBpZiAoc3RhdGUuc3dpdGNoViAmJiBzdGF0ZS51bmljb2RlUHJvcGVydGllcy5iaW5hcnlPZlN0cmluZ3MudGVzdChuYW1lT3JWYWx1ZSkpIHsgcmV0dXJuIENoYXJTZXRTdHJpbmcgfVxuICBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgbmFtZVwiKTtcbn07XG5cbi8vIFVuaWNvZGVQcm9wZXJ0eU5hbWUgOjpcbi8vICAgVW5pY29kZVByb3BlcnR5TmFtZUNoYXJhY3RlcnNcbnBwJDEucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgY2ggPSAwO1xuICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICB3aGlsZSAoaXNVbmljb2RlUHJvcGVydHlOYW1lQ2hhcmFjdGVyKGNoID0gc3RhdGUuY3VycmVudCgpKSkge1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyhjaCk7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgIT09IFwiXCJcbn07XG5cbmZ1bmN0aW9uIGlzVW5pY29kZVByb3BlcnR5TmFtZUNoYXJhY3RlcihjaCkge1xuICByZXR1cm4gaXNDb250cm9sTGV0dGVyKGNoKSB8fCBjaCA9PT0gMHg1RiAvKiBfICovXG59XG5cbi8vIFVuaWNvZGVQcm9wZXJ0eVZhbHVlIDo6XG4vLyAgIFVuaWNvZGVQcm9wZXJ0eVZhbHVlQ2hhcmFjdGVyc1xucHAkMS5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgY2ggPSAwO1xuICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICB3aGlsZSAoaXNVbmljb2RlUHJvcGVydHlWYWx1ZUNoYXJhY3RlcihjaCA9IHN0YXRlLmN1cnJlbnQoKSkpIHtcbiAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgKz0gY29kZVBvaW50VG9TdHJpbmcoY2gpO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgfVxuICByZXR1cm4gc3RhdGUubGFzdFN0cmluZ1ZhbHVlICE9PSBcIlwiXG59O1xuZnVuY3Rpb24gaXNVbmljb2RlUHJvcGVydHlWYWx1ZUNoYXJhY3RlcihjaCkge1xuICByZXR1cm4gaXNVbmljb2RlUHJvcGVydHlOYW1lQ2hhcmFjdGVyKGNoKSB8fCBpc0RlY2ltYWxEaWdpdChjaClcbn1cblxuLy8gTG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlIDo6XG4vLyAgIFVuaWNvZGVQcm9wZXJ0eVZhbHVlQ2hhcmFjdGVyc1xucHAkMS5yZWdleHBfZWF0TG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgcmV0dXJuIHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlKHN0YXRlKVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ2hhcmFjdGVyQ2xhc3NcbnBwJDEucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVhdCgweDVCIC8qIFsgKi8pKSB7XG4gICAgdmFyIG5lZ2F0ZSA9IHN0YXRlLmVhdCgweDVFIC8qIF4gKi8pO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLnJlZ2V4cF9jbGFzc0NvbnRlbnRzKHN0YXRlKTtcbiAgICBpZiAoIXN0YXRlLmVhdCgweDVEIC8qIF0gKi8pKVxuICAgICAgeyBzdGF0ZS5yYWlzZShcIlVudGVybWluYXRlZCBjaGFyYWN0ZXIgY2xhc3NcIik7IH1cbiAgICBpZiAobmVnYXRlICYmIHJlc3VsdCA9PT0gQ2hhclNldFN0cmluZylcbiAgICAgIHsgc3RhdGUucmFpc2UoXCJOZWdhdGVkIGNoYXJhY3RlciBjbGFzcyBtYXkgY29udGFpbiBzdHJpbmdzXCIpOyB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzQ29udGVudHNcbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNsYXNzUmFuZ2VzXG5wcCQxLnJlZ2V4cF9jbGFzc0NvbnRlbnRzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmN1cnJlbnQoKSA9PT0gMHg1RCAvKiBdICovKSB7IHJldHVybiBDaGFyU2V0T2sgfVxuICBpZiAoc3RhdGUuc3dpdGNoVikgeyByZXR1cm4gdGhpcy5yZWdleHBfY2xhc3NTZXRFeHByZXNzaW9uKHN0YXRlKSB9XG4gIHRoaXMucmVnZXhwX25vbkVtcHR5Q2xhc3NSYW5nZXMoc3RhdGUpO1xuICByZXR1cm4gQ2hhclNldE9rXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1Ob25lbXB0eUNsYXNzUmFuZ2VzXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1Ob25lbXB0eUNsYXNzUmFuZ2VzTm9EYXNoXG5wcCQxLnJlZ2V4cF9ub25FbXB0eUNsYXNzUmFuZ2VzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgd2hpbGUgKHRoaXMucmVnZXhwX2VhdENsYXNzQXRvbShzdGF0ZSkpIHtcbiAgICB2YXIgbGVmdCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICBpZiAoc3RhdGUuZWF0KDB4MkQgLyogLSAqLykgJiYgdGhpcy5yZWdleHBfZWF0Q2xhc3NBdG9tKHN0YXRlKSkge1xuICAgICAgdmFyIHJpZ2h0ID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgaWYgKHN0YXRlLnN3aXRjaFUgJiYgKGxlZnQgPT09IC0xIHx8IHJpZ2h0ID09PSAtMSkpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGNoYXJhY3RlciBjbGFzc1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChsZWZ0ICE9PSAtMSAmJiByaWdodCAhPT0gLTEgJiYgbGVmdCA+IHJpZ2h0KSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiUmFuZ2Ugb3V0IG9mIG9yZGVyIGluIGNoYXJhY3RlciBjbGFzc1wiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNsYXNzQXRvbVxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ2xhc3NBdG9tTm9EYXNoXG5wcCQxLnJlZ2V4cF9lYXRDbGFzc0F0b20gPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG5cbiAgaWYgKHN0YXRlLmVhdCgweDVDIC8qIFxcICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRDbGFzc0VzY2FwZShzdGF0ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2UgYXMgVjguXG4gICAgICB2YXIgY2gkMSA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICAgIGlmIChjaCQxID09PSAweDYzIC8qIGMgKi8gfHwgaXNPY3RhbERpZ2l0KGNoJDEpKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBjbGFzcyBlc2NhcGVcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZXNjYXBlXCIpO1xuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuXG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGNoICE9PSAweDVEIC8qIF0gKi8pIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUNsYXNzRXNjYXBlXG5wcCQxLnJlZ2V4cF9lYXRDbGFzc0VzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcblxuICBpZiAoc3RhdGUuZWF0KDB4NjIgLyogYiAqLykpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDA4OyAvKiA8QlM+ICovXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmIChzdGF0ZS5zd2l0Y2hVICYmIHN0YXRlLmVhdCgweDJEIC8qIC0gKi8pKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgyRDsgLyogLSAqL1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoIXN0YXRlLnN3aXRjaFUgJiYgc3RhdGUuZWF0KDB4NjMgLyogYyAqLykpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0Q2xhc3NDb250cm9sTGV0dGVyKHN0YXRlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckVzY2FwZShzdGF0ZSlcbiAgKVxufTtcblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NTZXRFeHByZXNzaW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1VuaW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc0ludGVyc2VjdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NTdWJ0cmFjdGlvblxucHAkMS5yZWdleHBfY2xhc3NTZXRFeHByZXNzaW9uID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHJlc3VsdCA9IENoYXJTZXRPaywgc3ViUmVzdWx0O1xuICBpZiAodGhpcy5yZWdleHBfZWF0Q2xhc3NTZXRSYW5nZShzdGF0ZSkpIDsgZWxzZSBpZiAoc3ViUmVzdWx0ID0gdGhpcy5yZWdleHBfZWF0Q2xhc3NTZXRPcGVyYW5kKHN0YXRlKSkge1xuICAgIGlmIChzdWJSZXN1bHQgPT09IENoYXJTZXRTdHJpbmcpIHsgcmVzdWx0ID0gQ2hhclNldFN0cmluZzsgfVxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzSW50ZXJzZWN0aW9uXG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHdoaWxlIChzdGF0ZS5lYXRDaGFycyhbMHgyNiwgMHgyNl0gLyogJiYgKi8pKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHN0YXRlLmN1cnJlbnQoKSAhPT0gMHgyNiAvKiAmICovICYmXG4gICAgICAgIChzdWJSZXN1bHQgPSB0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldE9wZXJhbmQoc3RhdGUpKVxuICAgICAgKSB7XG4gICAgICAgIGlmIChzdWJSZXN1bHQgIT09IENoYXJTZXRTdHJpbmcpIHsgcmVzdWx0ID0gQ2hhclNldE9rOyB9XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgY2hhcmFjdGVyIGluIGNoYXJhY3RlciBjbGFzc1wiKTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0ICE9PSBzdGF0ZS5wb3MpIHsgcmV0dXJuIHJlc3VsdCB9XG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NTdWJ0cmFjdGlvblxuICAgIHdoaWxlIChzdGF0ZS5lYXRDaGFycyhbMHgyRCwgMHgyRF0gLyogLS0gKi8pKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0Q2xhc3NTZXRPcGVyYW5kKHN0YXRlKSkgeyBjb250aW51ZSB9XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgY2hhcmFjdGVyIGluIGNoYXJhY3RlciBjbGFzc1wiKTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0ICE9PSBzdGF0ZS5wb3MpIHsgcmV0dXJuIHJlc3VsdCB9XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGNoYXJhY3RlciBpbiBjaGFyYWN0ZXIgY2xhc3NcIik7XG4gIH1cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NVbmlvblxuICBmb3IgKDs7KSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdENsYXNzU2V0UmFuZ2Uoc3RhdGUpKSB7IGNvbnRpbnVlIH1cbiAgICBzdWJSZXN1bHQgPSB0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldE9wZXJhbmQoc3RhdGUpO1xuICAgIGlmICghc3ViUmVzdWx0KSB7IHJldHVybiByZXN1bHQgfVxuICAgIGlmIChzdWJSZXN1bHQgPT09IENoYXJTZXRTdHJpbmcpIHsgcmVzdWx0ID0gQ2hhclNldFN0cmluZzsgfVxuICB9XG59O1xuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1NldFJhbmdlXG5wcCQxLnJlZ2V4cF9lYXRDbGFzc1NldFJhbmdlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBpZiAodGhpcy5yZWdleHBfZWF0Q2xhc3NTZXRDaGFyYWN0ZXIoc3RhdGUpKSB7XG4gICAgdmFyIGxlZnQgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgaWYgKHN0YXRlLmVhdCgweDJEIC8qIC0gKi8pICYmIHRoaXMucmVnZXhwX2VhdENsYXNzU2V0Q2hhcmFjdGVyKHN0YXRlKSkge1xuICAgICAgdmFyIHJpZ2h0ID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgaWYgKGxlZnQgIT09IC0xICYmIHJpZ2h0ICE9PSAtMSAmJiBsZWZ0ID4gcmlnaHQpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJSYW5nZSBvdXQgb2Ygb3JkZXIgaW4gY2hhcmFjdGVyIGNsYXNzXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1NldE9wZXJhbmRcbnBwJDEucmVnZXhwX2VhdENsYXNzU2V0T3BlcmFuZCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldENoYXJhY3RlcihzdGF0ZSkpIHsgcmV0dXJuIENoYXJTZXRPayB9XG4gIHJldHVybiB0aGlzLnJlZ2V4cF9lYXRDbGFzc1N0cmluZ0Rpc2p1bmN0aW9uKHN0YXRlKSB8fCB0aGlzLnJlZ2V4cF9lYXROZXN0ZWRDbGFzcyhzdGF0ZSlcbn07XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLU5lc3RlZENsYXNzXG5wcCQxLnJlZ2V4cF9lYXROZXN0ZWRDbGFzcyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgaWYgKHN0YXRlLmVhdCgweDVCIC8qIFsgKi8pKSB7XG4gICAgdmFyIG5lZ2F0ZSA9IHN0YXRlLmVhdCgweDVFIC8qIF4gKi8pO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLnJlZ2V4cF9jbGFzc0NvbnRlbnRzKHN0YXRlKTtcbiAgICBpZiAoc3RhdGUuZWF0KDB4NUQgLyogXSAqLykpIHtcbiAgICAgIGlmIChuZWdhdGUgJiYgcmVzdWx0ID09PSBDaGFyU2V0U3RyaW5nKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiTmVnYXRlZCBjaGFyYWN0ZXIgY2xhc3MgbWF5IGNvbnRhaW4gc3RyaW5nc1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cbiAgaWYgKHN0YXRlLmVhdCgweDVDIC8qIFxcICovKSkge1xuICAgIHZhciByZXN1bHQkMSA9IHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlKHN0YXRlKTtcbiAgICBpZiAocmVzdWx0JDEpIHtcbiAgICAgIHJldHVybiByZXN1bHQkMVxuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuICByZXR1cm4gbnVsbFxufTtcblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NTdHJpbmdEaXNqdW5jdGlvblxucHAkMS5yZWdleHBfZWF0Q2xhc3NTdHJpbmdEaXNqdW5jdGlvbiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgaWYgKHN0YXRlLmVhdENoYXJzKFsweDVDLCAweDcxXSAvKiBcXHEgKi8pKSB7XG4gICAgaWYgKHN0YXRlLmVhdCgweDdCIC8qIHsgKi8pKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZWdleHBfY2xhc3NTdHJpbmdEaXNqdW5jdGlvbkNvbnRlbnRzKHN0YXRlKTtcbiAgICAgIGlmIChzdGF0ZS5lYXQoMHg3RCAvKiB9ICovKSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZSBhcyBWOC5cbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG4gIHJldHVybiBudWxsXG59O1xuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1N0cmluZ0Rpc2p1bmN0aW9uQ29udGVudHNcbnBwJDEucmVnZXhwX2NsYXNzU3RyaW5nRGlzanVuY3Rpb25Db250ZW50cyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLnJlZ2V4cF9jbGFzc1N0cmluZyhzdGF0ZSk7XG4gIHdoaWxlIChzdGF0ZS5lYXQoMHg3QyAvKiB8ICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9jbGFzc1N0cmluZyhzdGF0ZSkgPT09IENoYXJTZXRTdHJpbmcpIHsgcmVzdWx0ID0gQ2hhclNldFN0cmluZzsgfVxuICB9XG4gIHJldHVybiByZXN1bHRcbn07XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzU3RyaW5nXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1Ob25FbXB0eUNsYXNzU3RyaW5nXG5wcCQxLnJlZ2V4cF9jbGFzc1N0cmluZyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjb3VudCA9IDA7XG4gIHdoaWxlICh0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldENoYXJhY3RlcihzdGF0ZSkpIHsgY291bnQrKzsgfVxuICByZXR1cm4gY291bnQgPT09IDEgPyBDaGFyU2V0T2sgOiBDaGFyU2V0U3RyaW5nXG59O1xuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1NldENoYXJhY3RlclxucHAkMS5yZWdleHBfZWF0Q2xhc3NTZXRDaGFyYWN0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIGlmIChzdGF0ZS5lYXQoMHg1QyAvKiBcXCAqLykpIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJFc2NhcGUoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldFJlc2VydmVkUHVuY3R1YXRvcihzdGF0ZSlcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChzdGF0ZS5lYXQoMHg2MiAvKiBiICovKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwODsgLyogPEJTPiAqL1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoY2ggPCAwIHx8IGNoID09PSBzdGF0ZS5sb29rYWhlYWQoKSAmJiBpc0NsYXNzU2V0UmVzZXJ2ZWREb3VibGVQdW5jdHVhdG9yQ2hhcmFjdGVyKGNoKSkgeyByZXR1cm4gZmFsc2UgfVxuICBpZiAoaXNDbGFzc1NldFN5bnRheENoYXJhY3RlcihjaCkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgc3RhdGUuYWR2YW5jZSgpO1xuICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgcmV0dXJuIHRydWVcbn07XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzU2V0UmVzZXJ2ZWREb3VibGVQdW5jdHVhdG9yXG5mdW5jdGlvbiBpc0NsYXNzU2V0UmVzZXJ2ZWREb3VibGVQdW5jdHVhdG9yQ2hhcmFjdGVyKGNoKSB7XG4gIHJldHVybiAoXG4gICAgY2ggPT09IDB4MjEgLyogISAqLyB8fFxuICAgIGNoID49IDB4MjMgLyogIyAqLyAmJiBjaCA8PSAweDI2IC8qICYgKi8gfHxcbiAgICBjaCA+PSAweDJBIC8qICogKi8gJiYgY2ggPD0gMHgyQyAvKiAsICovIHx8XG4gICAgY2ggPT09IDB4MkUgLyogLiAqLyB8fFxuICAgIGNoID49IDB4M0EgLyogOiAqLyAmJiBjaCA8PSAweDQwIC8qIEAgKi8gfHxcbiAgICBjaCA9PT0gMHg1RSAvKiBeICovIHx8XG4gICAgY2ggPT09IDB4NjAgLyogYCAqLyB8fFxuICAgIGNoID09PSAweDdFIC8qIH4gKi9cbiAgKVxufVxuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1NldFN5bnRheENoYXJhY3RlclxuZnVuY3Rpb24gaXNDbGFzc1NldFN5bnRheENoYXJhY3RlcihjaCkge1xuICByZXR1cm4gKFxuICAgIGNoID09PSAweDI4IC8qICggKi8gfHxcbiAgICBjaCA9PT0gMHgyOSAvKiApICovIHx8XG4gICAgY2ggPT09IDB4MkQgLyogLSAqLyB8fFxuICAgIGNoID09PSAweDJGIC8qIC8gKi8gfHxcbiAgICBjaCA+PSAweDVCIC8qIFsgKi8gJiYgY2ggPD0gMHg1RCAvKiBdICovIHx8XG4gICAgY2ggPj0gMHg3QiAvKiB7ICovICYmIGNoIDw9IDB4N0QgLyogfSAqL1xuICApXG59XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzU2V0UmVzZXJ2ZWRQdW5jdHVhdG9yXG5wcCQxLnJlZ2V4cF9lYXRDbGFzc1NldFJlc2VydmVkUHVuY3R1YXRvciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGlzQ2xhc3NTZXRSZXNlcnZlZFB1bmN0dWF0b3IoY2gpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1NldFJlc2VydmVkUHVuY3R1YXRvclxuZnVuY3Rpb24gaXNDbGFzc1NldFJlc2VydmVkUHVuY3R1YXRvcihjaCkge1xuICByZXR1cm4gKFxuICAgIGNoID09PSAweDIxIC8qICEgKi8gfHxcbiAgICBjaCA9PT0gMHgyMyAvKiAjICovIHx8XG4gICAgY2ggPT09IDB4MjUgLyogJSAqLyB8fFxuICAgIGNoID09PSAweDI2IC8qICYgKi8gfHxcbiAgICBjaCA9PT0gMHgyQyAvKiAsICovIHx8XG4gICAgY2ggPT09IDB4MkQgLyogLSAqLyB8fFxuICAgIGNoID49IDB4M0EgLyogOiAqLyAmJiBjaCA8PSAweDNFIC8qID4gKi8gfHxcbiAgICBjaCA9PT0gMHg0MCAvKiBAICovIHx8XG4gICAgY2ggPT09IDB4NjAgLyogYCAqLyB8fFxuICAgIGNoID09PSAweDdFIC8qIH4gKi9cbiAgKVxufVxuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItQ2xhc3NDb250cm9sTGV0dGVyXG5wcCQxLnJlZ2V4cF9lYXRDbGFzc0NvbnRyb2xMZXR0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIGlmIChpc0RlY2ltYWxEaWdpdChjaCkgfHwgY2ggPT09IDB4NUYgLyogXyAqLykge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoICUgMHgyMDtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleEVzY2FwZVNlcXVlbmNlXG5wcCQxLnJlZ2V4cF9lYXRIZXhFc2NhcGVTZXF1ZW5jZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgaWYgKHN0YXRlLmVhdCgweDc4IC8qIHggKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzKHN0YXRlLCAyKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtRGVjaW1hbERpZ2l0c1xucHAkMS5yZWdleHBfZWF0RGVjaW1hbERpZ2l0cyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgdmFyIGNoID0gMDtcbiAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KGNoID0gc3RhdGUuY3VycmVudCgpKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDEwICogc3RhdGUubGFzdEludFZhbHVlICsgKGNoIC0gMHgzMCAvKiAwICovKTtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLnBvcyAhPT0gc3RhcnRcbn07XG5mdW5jdGlvbiBpc0RlY2ltYWxEaWdpdChjaCkge1xuICByZXR1cm4gY2ggPj0gMHgzMCAvKiAwICovICYmIGNoIDw9IDB4MzkgLyogOSAqL1xufVxuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXhEaWdpdHNcbnBwJDEucmVnZXhwX2VhdEhleERpZ2l0cyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgdmFyIGNoID0gMDtcbiAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgd2hpbGUgKGlzSGV4RGlnaXQoY2ggPSBzdGF0ZS5jdXJyZW50KCkpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMTYgKiBzdGF0ZS5sYXN0SW50VmFsdWUgKyBoZXhUb0ludChjaCk7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICB9XG4gIHJldHVybiBzdGF0ZS5wb3MgIT09IHN0YXJ0XG59O1xuZnVuY3Rpb24gaXNIZXhEaWdpdChjaCkge1xuICByZXR1cm4gKFxuICAgIChjaCA+PSAweDMwIC8qIDAgKi8gJiYgY2ggPD0gMHgzOSAvKiA5ICovKSB8fFxuICAgIChjaCA+PSAweDQxIC8qIEEgKi8gJiYgY2ggPD0gMHg0NiAvKiBGICovKSB8fFxuICAgIChjaCA+PSAweDYxIC8qIGEgKi8gJiYgY2ggPD0gMHg2NiAvKiBmICovKVxuICApXG59XG5mdW5jdGlvbiBoZXhUb0ludChjaCkge1xuICBpZiAoY2ggPj0gMHg0MSAvKiBBICovICYmIGNoIDw9IDB4NDYgLyogRiAqLykge1xuICAgIHJldHVybiAxMCArIChjaCAtIDB4NDEgLyogQSAqLylcbiAgfVxuICBpZiAoY2ggPj0gMHg2MSAvKiBhICovICYmIGNoIDw9IDB4NjYgLyogZiAqLykge1xuICAgIHJldHVybiAxMCArIChjaCAtIDB4NjEgLyogYSAqLylcbiAgfVxuICByZXR1cm4gY2ggLSAweDMwIC8qIDAgKi9cbn1cblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUxlZ2FjeU9jdGFsRXNjYXBlU2VxdWVuY2Vcbi8vIEFsbG93cyBvbmx5IDAtMzc3KG9jdGFsKSBpLmUuIDAtMjU1KGRlY2ltYWwpLlxucHAkMS5yZWdleHBfZWF0TGVnYWN5T2N0YWxFc2NhcGVTZXF1ZW5jZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRPY3RhbERpZ2l0KHN0YXRlKSkge1xuICAgIHZhciBuMSA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0T2N0YWxEaWdpdChzdGF0ZSkpIHtcbiAgICAgIHZhciBuMiA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIGlmIChuMSA8PSAzICYmIHRoaXMucmVnZXhwX2VhdE9jdGFsRGlnaXQoc3RhdGUpKSB7XG4gICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IG4xICogNjQgKyBuMiAqIDggKyBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBuMSAqIDggKyBuMjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gbjE7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1PY3RhbERpZ2l0XG5wcCQxLnJlZ2V4cF9lYXRPY3RhbERpZ2l0ID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoaXNPY3RhbERpZ2l0KGNoKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoIC0gMHgzMDsgLyogMCAqL1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gIHJldHVybiBmYWxzZVxufTtcbmZ1bmN0aW9uIGlzT2N0YWxEaWdpdChjaCkge1xuICByZXR1cm4gY2ggPj0gMHgzMCAvKiAwICovICYmIGNoIDw9IDB4MzcgLyogNyAqL1xufVxuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXg0RGlnaXRzXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXhEaWdpdFxuLy8gQW5kIEhleERpZ2l0IEhleERpZ2l0IGluIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleEVzY2FwZVNlcXVlbmNlXG5wcCQxLnJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cyA9IGZ1bmN0aW9uKHN0YXRlLCBsZW5ndGgpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmICghaXNIZXhEaWdpdChjaCkpIHtcbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDE2ICogc3RhdGUubGFzdEludFZhbHVlICsgaGV4VG9JbnQoY2gpO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgfVxuICByZXR1cm4gdHJ1ZVxufTtcblxuLy8gT2JqZWN0IHR5cGUgdXNlZCB0byByZXByZXNlbnQgdG9rZW5zLiBOb3RlIHRoYXQgbm9ybWFsbHksIHRva2Vuc1xuLy8gc2ltcGx5IGV4aXN0IGFzIHByb3BlcnRpZXMgb24gdGhlIHBhcnNlciBvYmplY3QuIFRoaXMgaXMgb25seVxuLy8gdXNlZCBmb3IgdGhlIG9uVG9rZW4gY2FsbGJhY2sgYW5kIHRoZSBleHRlcm5hbCB0b2tlbml6ZXIuXG5cbnZhciBUb2tlbiA9IGZ1bmN0aW9uIFRva2VuKHApIHtcbiAgdGhpcy50eXBlID0gcC50eXBlO1xuICB0aGlzLnZhbHVlID0gcC52YWx1ZTtcbiAgdGhpcy5zdGFydCA9IHAuc3RhcnQ7XG4gIHRoaXMuZW5kID0gcC5lbmQ7XG4gIGlmIChwLm9wdGlvbnMubG9jYXRpb25zKVxuICAgIHsgdGhpcy5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24ocCwgcC5zdGFydExvYywgcC5lbmRMb2MpOyB9XG4gIGlmIChwLm9wdGlvbnMucmFuZ2VzKVxuICAgIHsgdGhpcy5yYW5nZSA9IFtwLnN0YXJ0LCBwLmVuZF07IH1cbn07XG5cbi8vICMjIFRva2VuaXplclxuXG52YXIgcHAgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4vLyBNb3ZlIHRvIHRoZSBuZXh0IHRva2VuXG5cbnBwLm5leHQgPSBmdW5jdGlvbihpZ25vcmVFc2NhcGVTZXF1ZW5jZUluS2V5d29yZCkge1xuICBpZiAoIWlnbm9yZUVzY2FwZVNlcXVlbmNlSW5LZXl3b3JkICYmIHRoaXMudHlwZS5rZXl3b3JkICYmIHRoaXMuY29udGFpbnNFc2MpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJFc2NhcGUgc2VxdWVuY2UgaW4ga2V5d29yZCBcIiArIHRoaXMudHlwZS5rZXl3b3JkKTsgfVxuICBpZiAodGhpcy5vcHRpb25zLm9uVG9rZW4pXG4gICAgeyB0aGlzLm9wdGlvbnMub25Ub2tlbihuZXcgVG9rZW4odGhpcykpOyB9XG5cbiAgdGhpcy5sYXN0VG9rRW5kID0gdGhpcy5lbmQ7XG4gIHRoaXMubGFzdFRva1N0YXJ0ID0gdGhpcy5zdGFydDtcbiAgdGhpcy5sYXN0VG9rRW5kTG9jID0gdGhpcy5lbmRMb2M7XG4gIHRoaXMubGFzdFRva1N0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgdGhpcy5uZXh0VG9rZW4oKTtcbn07XG5cbnBwLmdldFRva2VuID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gbmV3IFRva2VuKHRoaXMpXG59O1xuXG4vLyBJZiB3ZSdyZSBpbiBhbiBFUzYgZW52aXJvbm1lbnQsIG1ha2UgcGFyc2VycyBpdGVyYWJsZVxuaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIpXG4gIHsgcHBbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGlzJDEkMSA9IHRoaXM7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdG9rZW4gPSB0aGlzJDEkMS5nZXRUb2tlbigpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IHRva2VuLnR5cGUgPT09IHR5cGVzJDEuZW9mLFxuICAgICAgICAgIHZhbHVlOiB0b2tlblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9OyB9XG5cbi8vIFRvZ2dsZSBzdHJpY3QgbW9kZS4gUmUtcmVhZHMgdGhlIG5leHQgbnVtYmVyIG9yIHN0cmluZyB0byBwbGVhc2Vcbi8vIHBlZGFudGljIHRlc3RzIChgXCJ1c2Ugc3RyaWN0XCI7IDAxMDtgIHNob3VsZCBmYWlsKS5cblxuLy8gUmVhZCBhIHNpbmdsZSB0b2tlbiwgdXBkYXRpbmcgdGhlIHBhcnNlciBvYmplY3QncyB0b2tlbi1yZWxhdGVkXG4vLyBwcm9wZXJ0aWVzLlxuXG5wcC5uZXh0VG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGN1ckNvbnRleHQgPSB0aGlzLmN1ckNvbnRleHQoKTtcbiAgaWYgKCFjdXJDb250ZXh0IHx8ICFjdXJDb250ZXh0LnByZXNlcnZlU3BhY2UpIHsgdGhpcy5za2lwU3BhY2UoKTsgfVxuXG4gIHRoaXMuc3RhcnQgPSB0aGlzLnBvcztcbiAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHsgdGhpcy5zdGFydExvYyA9IHRoaXMuY3VyUG9zaXRpb24oKTsgfVxuICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5lb2YpIH1cblxuICBpZiAoY3VyQ29udGV4dC5vdmVycmlkZSkgeyByZXR1cm4gY3VyQ29udGV4dC5vdmVycmlkZSh0aGlzKSB9XG4gIGVsc2UgeyB0aGlzLnJlYWRUb2tlbih0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpOyB9XG59O1xuXG5wcC5yZWFkVG9rZW4gPSBmdW5jdGlvbihjb2RlKSB7XG4gIC8vIElkZW50aWZpZXIgb3Iga2V5d29yZC4gJ1xcdVhYWFgnIHNlcXVlbmNlcyBhcmUgYWxsb3dlZCBpblxuICAvLyBpZGVudGlmaWVycywgc28gJ1xcJyBhbHNvIGRpc3BhdGNoZXMgdG8gdGhhdC5cbiAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGNvZGUsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB8fCBjb2RlID09PSA5MiAvKiAnXFwnICovKVxuICAgIHsgcmV0dXJuIHRoaXMucmVhZFdvcmQoKSB9XG5cbiAgcmV0dXJuIHRoaXMuZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKVxufTtcblxucHAuZnVsbENoYXJDb2RlQXRQb3MgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvZGUgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICBpZiAoY29kZSA8PSAweGQ3ZmYgfHwgY29kZSA+PSAweGRjMDApIHsgcmV0dXJuIGNvZGUgfVxuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICByZXR1cm4gbmV4dCA8PSAweGRiZmYgfHwgbmV4dCA+PSAweGUwMDAgPyBjb2RlIDogKGNvZGUgPDwgMTApICsgbmV4dCAtIDB4MzVmZGMwMFxufTtcblxucHAuc2tpcEJsb2NrQ29tbWVudCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhcnRMb2MgPSB0aGlzLm9wdGlvbnMub25Db21tZW50ICYmIHRoaXMuY3VyUG9zaXRpb24oKTtcbiAgdmFyIHN0YXJ0ID0gdGhpcy5wb3MsIGVuZCA9IHRoaXMuaW5wdXQuaW5kZXhPZihcIiovXCIsIHRoaXMucG9zICs9IDIpO1xuICBpZiAoZW5kID09PSAtMSkgeyB0aGlzLnJhaXNlKHRoaXMucG9zIC0gMiwgXCJVbnRlcm1pbmF0ZWQgY29tbWVudFwiKTsgfVxuICB0aGlzLnBvcyA9IGVuZCArIDI7XG4gIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgZm9yICh2YXIgbmV4dEJyZWFrID0gKHZvaWQgMCksIHBvcyA9IHN0YXJ0OyAobmV4dEJyZWFrID0gbmV4dExpbmVCcmVhayh0aGlzLmlucHV0LCBwb3MsIHRoaXMucG9zKSkgPiAtMTspIHtcbiAgICAgICsrdGhpcy5jdXJMaW5lO1xuICAgICAgcG9zID0gdGhpcy5saW5lU3RhcnQgPSBuZXh0QnJlYWs7XG4gICAgfVxuICB9XG4gIGlmICh0aGlzLm9wdGlvbnMub25Db21tZW50KVxuICAgIHsgdGhpcy5vcHRpb25zLm9uQ29tbWVudCh0cnVlLCB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0ICsgMiwgZW5kKSwgc3RhcnQsIHRoaXMucG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRMb2MsIHRoaXMuY3VyUG9zaXRpb24oKSk7IH1cbn07XG5cbnBwLnNraXBMaW5lQ29tbWVudCA9IGZ1bmN0aW9uKHN0YXJ0U2tpcCkge1xuICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcbiAgdmFyIHN0YXJ0TG9jID0gdGhpcy5vcHRpb25zLm9uQ29tbWVudCAmJiB0aGlzLmN1clBvc2l0aW9uKCk7XG4gIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArPSBzdGFydFNraXApO1xuICB3aGlsZSAodGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCAmJiAhaXNOZXdMaW5lKGNoKSkge1xuICAgIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpO1xuICB9XG4gIGlmICh0aGlzLm9wdGlvbnMub25Db21tZW50KVxuICAgIHsgdGhpcy5vcHRpb25zLm9uQ29tbWVudChmYWxzZSwgdGhpcy5pbnB1dC5zbGljZShzdGFydCArIHN0YXJ0U2tpcCwgdGhpcy5wb3MpLCBzdGFydCwgdGhpcy5wb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydExvYywgdGhpcy5jdXJQb3NpdGlvbigpKTsgfVxufTtcblxuLy8gQ2FsbGVkIGF0IHRoZSBzdGFydCBvZiB0aGUgcGFyc2UgYW5kIGFmdGVyIGV2ZXJ5IHRva2VuLiBTa2lwc1xuLy8gd2hpdGVzcGFjZSBhbmQgY29tbWVudHMsIGFuZC5cblxucHAuc2tpcFNwYWNlID0gZnVuY3Rpb24oKSB7XG4gIGxvb3A6IHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICBzd2l0Y2ggKGNoKSB7XG4gICAgY2FzZSAzMjogY2FzZSAxNjA6IC8vICcgJ1xuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAxMzpcbiAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKSA9PT0gMTApIHtcbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgIH1cbiAgICBjYXNlIDEwOiBjYXNlIDgyMzI6IGNhc2UgODIzMzpcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICArK3RoaXMuY3VyTGluZTtcbiAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSA0NzogLy8gJy8nXG4gICAgICBzd2l0Y2ggKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpKSB7XG4gICAgICBjYXNlIDQyOiAvLyAnKidcbiAgICAgICAgdGhpcy5za2lwQmxvY2tDb21tZW50KCk7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDQ3OlxuICAgICAgICB0aGlzLnNraXBMaW5lQ29tbWVudCgyKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrIGxvb3BcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChjaCA+IDggJiYgY2ggPCAxNCB8fCBjaCA+PSA1NzYwICYmIG5vbkFTQ0lJd2hpdGVzcGFjZS50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKSkge1xuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWsgbG9vcFxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gQ2FsbGVkIGF0IHRoZSBlbmQgb2YgZXZlcnkgdG9rZW4uIFNldHMgYGVuZGAsIGB2YWxgLCBhbmRcbi8vIG1haW50YWlucyBgY29udGV4dGAgYW5kIGBleHByQWxsb3dlZGAsIGFuZCBza2lwcyB0aGUgc3BhY2UgYWZ0ZXJcbi8vIHRoZSB0b2tlbiwgc28gdGhhdCB0aGUgbmV4dCBvbmUncyBgc3RhcnRgIHdpbGwgcG9pbnQgYXQgdGhlXG4vLyByaWdodCBwb3NpdGlvbi5cblxucHAuZmluaXNoVG9rZW4gPSBmdW5jdGlvbih0eXBlLCB2YWwpIHtcbiAgdGhpcy5lbmQgPSB0aGlzLnBvcztcbiAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHsgdGhpcy5lbmRMb2MgPSB0aGlzLmN1clBvc2l0aW9uKCk7IH1cbiAgdmFyIHByZXZUeXBlID0gdGhpcy50eXBlO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnZhbHVlID0gdmFsO1xuXG4gIHRoaXMudXBkYXRlQ29udGV4dChwcmV2VHlwZSk7XG59O1xuXG4vLyAjIyMgVG9rZW4gcmVhZGluZ1xuXG4vLyBUaGlzIGlzIHRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB0byBmZXRjaCB0aGUgbmV4dCB0b2tlbi4gSXRcbi8vIGlzIHNvbWV3aGF0IG9ic2N1cmUsIGJlY2F1c2UgaXQgd29ya3MgaW4gY2hhcmFjdGVyIGNvZGVzIHJhdGhlclxuLy8gdGhhbiBjaGFyYWN0ZXJzLCBhbmQgYmVjYXVzZSBvcGVyYXRvciBwYXJzaW5nIGhhcyBiZWVuIGlubGluZWRcbi8vIGludG8gaXQuXG4vL1xuLy8gQWxsIGluIHRoZSBuYW1lIG9mIHNwZWVkLlxuLy9cbnBwLnJlYWRUb2tlbl9kb3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgaWYgKG5leHQgPj0gNDggJiYgbmV4dCA8PSA1NykgeyByZXR1cm4gdGhpcy5yZWFkTnVtYmVyKHRydWUpIH1cbiAgdmFyIG5leHQyID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiBuZXh0ID09PSA0NiAmJiBuZXh0MiA9PT0gNDYpIHsgLy8gNDYgPSBkb3QgJy4nXG4gICAgdGhpcy5wb3MgKz0gMztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLmVsbGlwc2lzKVxuICB9IGVsc2Uge1xuICAgICsrdGhpcy5wb3M7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5kb3QpXG4gIH1cbn07XG5cbnBwLnJlYWRUb2tlbl9zbGFzaCA9IGZ1bmN0aW9uKCkgeyAvLyAnLydcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgaWYgKHRoaXMuZXhwckFsbG93ZWQpIHsgKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMucmVhZFJlZ2V4cCgpIH1cbiAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEuYXNzaWduLCAyKSB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEuc2xhc2gsIDEpXG59O1xuXG5wcC5yZWFkVG9rZW5fbXVsdF9tb2R1bG9fZXhwID0gZnVuY3Rpb24oY29kZSkgeyAvLyAnJSonXG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIHZhciBzaXplID0gMTtcbiAgdmFyIHRva2VudHlwZSA9IGNvZGUgPT09IDQyID8gdHlwZXMkMS5zdGFyIDogdHlwZXMkMS5tb2R1bG87XG5cbiAgLy8gZXhwb25lbnRpYXRpb24gb3BlcmF0b3IgKiogYW5kICoqPVxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDcgJiYgY29kZSA9PT0gNDIgJiYgbmV4dCA9PT0gNDIpIHtcbiAgICArK3NpemU7XG4gICAgdG9rZW50eXBlID0gdHlwZXMkMS5zdGFyc3RhcjtcbiAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gIH1cblxuICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5hc3NpZ24sIHNpemUgKyAxKSB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE9wKHRva2VudHlwZSwgc2l6ZSlcbn07XG5cbnBwLnJlYWRUb2tlbl9waXBlX2FtcCA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJ3wmJ1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTIpIHtcbiAgICAgIHZhciBuZXh0MiA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpO1xuICAgICAgaWYgKG5leHQyID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLmFzc2lnbiwgMykgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcChjb2RlID09PSAxMjQgPyB0eXBlcyQxLmxvZ2ljYWxPUiA6IHR5cGVzJDEubG9naWNhbEFORCwgMilcbiAgfVxuICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5hc3NpZ24sIDIpIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gMTI0ID8gdHlwZXMkMS5iaXR3aXNlT1IgOiB0eXBlcyQxLmJpdHdpc2VBTkQsIDEpXG59O1xuXG5wcC5yZWFkVG9rZW5fY2FyZXQgPSBmdW5jdGlvbigpIHsgLy8gJ14nXG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLmFzc2lnbiwgMikgfVxuICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLmJpdHdpc2VYT1IsIDEpXG59O1xuXG5wcC5yZWFkVG9rZW5fcGx1c19taW4gPSBmdW5jdGlvbihjb2RlKSB7IC8vICcrLSdcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgaWYgKG5leHQgPT09IGNvZGUpIHtcbiAgICBpZiAobmV4dCA9PT0gNDUgJiYgIXRoaXMuaW5Nb2R1bGUgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDYyICYmXG4gICAgICAgICh0aGlzLmxhc3RUb2tFbmQgPT09IDAgfHwgbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMucG9zKSkpKSB7XG4gICAgICAvLyBBIGAtLT5gIGxpbmUgY29tbWVudFxuICAgICAgdGhpcy5za2lwTGluZUNvbW1lbnQoMyk7XG4gICAgICB0aGlzLnNraXBTcGFjZSgpO1xuICAgICAgcmV0dXJuIHRoaXMubmV4dFRva2VuKClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5pbmNEZWMsIDIpXG4gIH1cbiAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEuYXNzaWduLCAyKSB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEucGx1c01pbiwgMSlcbn07XG5cbnBwLnJlYWRUb2tlbl9sdF9ndCA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJzw+J1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICB2YXIgc2l6ZSA9IDE7XG4gIGlmIChuZXh0ID09PSBjb2RlKSB7XG4gICAgc2l6ZSA9IGNvZGUgPT09IDYyICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09PSA2MiA/IDMgOiAyO1xuICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyBzaXplKSA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5hc3NpZ24sIHNpemUgKyAxKSB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5iaXRTaGlmdCwgc2l6ZSlcbiAgfVxuICBpZiAobmV4dCA9PT0gMzMgJiYgY29kZSA9PT0gNjAgJiYgIXRoaXMuaW5Nb2R1bGUgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDQ1ICYmXG4gICAgICB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAzKSA9PT0gNDUpIHtcbiAgICAvLyBgPCEtLWAsIGFuIFhNTC1zdHlsZSBjb21tZW50IHRoYXQgc2hvdWxkIGJlIGludGVycHJldGVkIGFzIGEgbGluZSBjb21tZW50XG4gICAgdGhpcy5za2lwTGluZUNvbW1lbnQoNCk7XG4gICAgdGhpcy5za2lwU3BhY2UoKTtcbiAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW4oKVxuICB9XG4gIGlmIChuZXh0ID09PSA2MSkgeyBzaXplID0gMjsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLnJlbGF0aW9uYWwsIHNpemUpXG59O1xuXG5wcC5yZWFkVG9rZW5fZXFfZXhjbCA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJz0hJ1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5lcXVhbGl0eSwgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDYxID8gMyA6IDIpIH1cbiAgaWYgKGNvZGUgPT09IDYxICYmIG5leHQgPT09IDYyICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7IC8vICc9PidcbiAgICB0aGlzLnBvcyArPSAyO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuYXJyb3cpXG4gIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gNjEgPyB0eXBlcyQxLmVxIDogdHlwZXMkMS5wcmVmaXgsIDEpXG59O1xuXG5wcC5yZWFkVG9rZW5fcXVlc3Rpb24gPSBmdW5jdGlvbigpIHsgLy8gJz8nXG4gIHZhciBlY21hVmVyc2lvbiA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbjtcbiAgaWYgKGVjbWFWZXJzaW9uID49IDExKSB7XG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gNDYpIHtcbiAgICAgIHZhciBuZXh0MiA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpO1xuICAgICAgaWYgKG5leHQyIDwgNDggfHwgbmV4dDIgPiA1NykgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLnF1ZXN0aW9uRG90LCAyKSB9XG4gICAgfVxuICAgIGlmIChuZXh0ID09PSA2Mykge1xuICAgICAgaWYgKGVjbWFWZXJzaW9uID49IDEyKSB7XG4gICAgICAgIHZhciBuZXh0MiQxID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gICAgICAgIGlmIChuZXh0MiQxID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLmFzc2lnbiwgMykgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5jb2FsZXNjZSwgMilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5xdWVzdGlvbiwgMSlcbn07XG5cbnBwLnJlYWRUb2tlbl9udW1iZXJTaWduID0gZnVuY3Rpb24oKSB7IC8vICcjJ1xuICB2YXIgZWNtYVZlcnNpb24gPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb247XG4gIHZhciBjb2RlID0gMzU7IC8vICcjJ1xuICBpZiAoZWNtYVZlcnNpb24gPj0gMTMpIHtcbiAgICArK3RoaXMucG9zO1xuICAgIGNvZGUgPSB0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCk7XG4gICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGNvZGUsIHRydWUpIHx8IGNvZGUgPT09IDkyIC8qICdcXCcgKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEucHJpdmF0ZUlkLCB0aGlzLnJlYWRXb3JkMSgpKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMucmFpc2UodGhpcy5wb3MsIFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgJ1wiICsgY29kZVBvaW50VG9TdHJpbmcoY29kZSkgKyBcIidcIik7XG59O1xuXG5wcC5nZXRUb2tlbkZyb21Db2RlID0gZnVuY3Rpb24oY29kZSkge1xuICBzd2l0Y2ggKGNvZGUpIHtcbiAgLy8gVGhlIGludGVycHJldGF0aW9uIG9mIGEgZG90IGRlcGVuZHMgb24gd2hldGhlciBpdCBpcyBmb2xsb3dlZFxuICAvLyBieSBhIGRpZ2l0IG9yIGFub3RoZXIgdHdvIGRvdHMuXG4gIGNhc2UgNDY6IC8vICcuJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9kb3QoKVxuXG4gIC8vIFB1bmN0dWF0aW9uIHRva2Vucy5cbiAgY2FzZSA0MDogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5wYXJlbkwpXG4gIGNhc2UgNDE6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEucGFyZW5SKVxuICBjYXNlIDU5OiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLnNlbWkpXG4gIGNhc2UgNDQ6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuY29tbWEpXG4gIGNhc2UgOTE6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuYnJhY2tldEwpXG4gIGNhc2UgOTM6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuYnJhY2tldFIpXG4gIGNhc2UgMTIzOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLmJyYWNlTClcbiAgY2FzZSAxMjU6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuYnJhY2VSKVxuICBjYXNlIDU4OiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLmNvbG9uKVxuXG4gIGNhc2UgOTY6IC8vICdgJ1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2KSB7IGJyZWFrIH1cbiAgICArK3RoaXMucG9zO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuYmFja1F1b3RlKVxuXG4gIGNhc2UgNDg6IC8vICcwJ1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IDEyMCB8fCBuZXh0ID09PSA4OCkgeyByZXR1cm4gdGhpcy5yZWFkUmFkaXhOdW1iZXIoMTYpIH0gLy8gJzB4JywgJzBYJyAtIGhleCBudW1iZXJcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgIGlmIChuZXh0ID09PSAxMTEgfHwgbmV4dCA9PT0gNzkpIHsgcmV0dXJuIHRoaXMucmVhZFJhZGl4TnVtYmVyKDgpIH0gLy8gJzBvJywgJzBPJyAtIG9jdGFsIG51bWJlclxuICAgICAgaWYgKG5leHQgPT09IDk4IHx8IG5leHQgPT09IDY2KSB7IHJldHVybiB0aGlzLnJlYWRSYWRpeE51bWJlcigyKSB9IC8vICcwYicsICcwQicgLSBiaW5hcnkgbnVtYmVyXG4gICAgfVxuXG4gIC8vIEFueXRoaW5nIGVsc2UgYmVnaW5uaW5nIHdpdGggYSBkaWdpdCBpcyBhbiBpbnRlZ2VyLCBvY3RhbFxuICAvLyBudW1iZXIsIG9yIGZsb2F0LlxuICBjYXNlIDQ5OiBjYXNlIDUwOiBjYXNlIDUxOiBjYXNlIDUyOiBjYXNlIDUzOiBjYXNlIDU0OiBjYXNlIDU1OiBjYXNlIDU2OiBjYXNlIDU3OiAvLyAxLTlcbiAgICByZXR1cm4gdGhpcy5yZWFkTnVtYmVyKGZhbHNlKVxuXG4gIC8vIFF1b3RlcyBwcm9kdWNlIHN0cmluZ3MuXG4gIGNhc2UgMzQ6IGNhc2UgMzk6IC8vICdcIicsIFwiJ1wiXG4gICAgcmV0dXJuIHRoaXMucmVhZFN0cmluZyhjb2RlKVxuXG4gIC8vIE9wZXJhdG9ycyBhcmUgcGFyc2VkIGlubGluZSBpbiB0aW55IHN0YXRlIG1hY2hpbmVzLiAnPScgKDYxKSBpc1xuICAvLyBvZnRlbiByZWZlcnJlZCB0by4gYGZpbmlzaE9wYCBzaW1wbHkgc2tpcHMgdGhlIGFtb3VudCBvZlxuICAvLyBjaGFyYWN0ZXJzIGl0IGlzIGdpdmVuIGFzIHNlY29uZCBhcmd1bWVudCwgYW5kIHJldHVybnMgYSB0b2tlblxuICAvLyBvZiB0aGUgdHlwZSBnaXZlbiBieSBpdHMgZmlyc3QgYXJndW1lbnQuXG4gIGNhc2UgNDc6IC8vICcvJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9zbGFzaCgpXG5cbiAgY2FzZSAzNzogY2FzZSA0MjogLy8gJyUqJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9tdWx0X21vZHVsb19leHAoY29kZSlcblxuICBjYXNlIDEyNDogY2FzZSAzODogLy8gJ3wmJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9waXBlX2FtcChjb2RlKVxuXG4gIGNhc2UgOTQ6IC8vICdeJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9jYXJldCgpXG5cbiAgY2FzZSA0MzogY2FzZSA0NTogLy8gJystJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9wbHVzX21pbihjb2RlKVxuXG4gIGNhc2UgNjA6IGNhc2UgNjI6IC8vICc8PidcbiAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fbHRfZ3QoY29kZSlcblxuICBjYXNlIDYxOiBjYXNlIDMzOiAvLyAnPSEnXG4gICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2VxX2V4Y2woY29kZSlcblxuICBjYXNlIDYzOiAvLyAnPydcbiAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fcXVlc3Rpb24oKVxuXG4gIGNhc2UgMTI2OiAvLyAnfidcbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLnByZWZpeCwgMSlcblxuICBjYXNlIDM1OiAvLyAnIydcbiAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fbnVtYmVyU2lnbigpXG4gIH1cblxuICB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyICdcIiArIGNvZGVQb2ludFRvU3RyaW5nKGNvZGUpICsgXCInXCIpO1xufTtcblxucHAuZmluaXNoT3AgPSBmdW5jdGlvbih0eXBlLCBzaXplKSB7XG4gIHZhciBzdHIgPSB0aGlzLmlucHV0LnNsaWNlKHRoaXMucG9zLCB0aGlzLnBvcyArIHNpemUpO1xuICB0aGlzLnBvcyArPSBzaXplO1xuICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlLCBzdHIpXG59O1xuXG5wcC5yZWFkUmVnZXhwID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlc2NhcGVkLCBpbkNsYXNzLCBzdGFydCA9IHRoaXMucG9zO1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKTsgfVxuICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckF0KHRoaXMucG9zKTtcbiAgICBpZiAobGluZUJyZWFrLnRlc3QoY2gpKSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKTsgfVxuICAgIGlmICghZXNjYXBlZCkge1xuICAgICAgaWYgKGNoID09PSBcIltcIikgeyBpbkNsYXNzID0gdHJ1ZTsgfVxuICAgICAgZWxzZSBpZiAoY2ggPT09IFwiXVwiICYmIGluQ2xhc3MpIHsgaW5DbGFzcyA9IGZhbHNlOyB9XG4gICAgICBlbHNlIGlmIChjaCA9PT0gXCIvXCIgJiYgIWluQ2xhc3MpIHsgYnJlYWsgfVxuICAgICAgZXNjYXBlZCA9IGNoID09PSBcIlxcXFxcIjtcbiAgICB9IGVsc2UgeyBlc2NhcGVkID0gZmFsc2U7IH1cbiAgICArK3RoaXMucG9zO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gdGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpO1xuICArK3RoaXMucG9zO1xuICB2YXIgZmxhZ3NTdGFydCA9IHRoaXMucG9zO1xuICB2YXIgZmxhZ3MgPSB0aGlzLnJlYWRXb3JkMSgpO1xuICBpZiAodGhpcy5jb250YWluc0VzYykgeyB0aGlzLnVuZXhwZWN0ZWQoZmxhZ3NTdGFydCk7IH1cblxuICAvLyBWYWxpZGF0ZSBwYXR0ZXJuXG4gIHZhciBzdGF0ZSA9IHRoaXMucmVnZXhwU3RhdGUgfHwgKHRoaXMucmVnZXhwU3RhdGUgPSBuZXcgUmVnRXhwVmFsaWRhdGlvblN0YXRlKHRoaXMpKTtcbiAgc3RhdGUucmVzZXQoc3RhcnQsIHBhdHRlcm4sIGZsYWdzKTtcbiAgdGhpcy52YWxpZGF0ZVJlZ0V4cEZsYWdzKHN0YXRlKTtcbiAgdGhpcy52YWxpZGF0ZVJlZ0V4cFBhdHRlcm4oc3RhdGUpO1xuXG4gIC8vIENyZWF0ZSBMaXRlcmFsI3ZhbHVlIHByb3BlcnR5IHZhbHVlLlxuICB2YXIgdmFsdWUgPSBudWxsO1xuICB0cnkge1xuICAgIHZhbHVlID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBFU1RyZWUgcmVxdWlyZXMgbnVsbCBpZiBpdCBmYWlsZWQgdG8gaW5zdGFudGlhdGUgUmVnRXhwIG9iamVjdC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZXN0cmVlL2VzdHJlZS9ibG9iL2EyNzAwM2FkZjRmZDdiZmFkNDRkZTljZWYzNzJhMmVhY2Q1MjdiMWMvZXM1Lm1kI3JlZ2V4cGxpdGVyYWxcbiAgfVxuXG4gIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEucmVnZXhwLCB7cGF0dGVybjogcGF0dGVybiwgZmxhZ3M6IGZsYWdzLCB2YWx1ZTogdmFsdWV9KVxufTtcblxuLy8gUmVhZCBhbiBpbnRlZ2VyIGluIHRoZSBnaXZlbiByYWRpeC4gUmV0dXJuIG51bGwgaWYgemVybyBkaWdpdHNcbi8vIHdlcmUgcmVhZCwgdGhlIGludGVnZXIgdmFsdWUgb3RoZXJ3aXNlLiBXaGVuIGBsZW5gIGlzIGdpdmVuLCB0aGlzXG4vLyB3aWxsIHJldHVybiBgbnVsbGAgdW5sZXNzIHRoZSBpbnRlZ2VyIGhhcyBleGFjdGx5IGBsZW5gIGRpZ2l0cy5cblxucHAucmVhZEludCA9IGZ1bmN0aW9uKHJhZGl4LCBsZW4sIG1heWJlTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbCkge1xuICAvLyBgbGVuYCBpcyB1c2VkIGZvciBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlcy4gSW4gdGhhdCBjYXNlLCBkaXNhbGxvdyBzZXBhcmF0b3JzLlxuICB2YXIgYWxsb3dTZXBhcmF0b3JzID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDEyICYmIGxlbiA9PT0gdW5kZWZpbmVkO1xuXG4gIC8vIGBtYXliZUxlZ2FjeU9jdGFsTnVtZXJpY0xpdGVyYWxgIGlzIHRydWUgaWYgaXQgZG9lc24ndCBoYXZlIHByZWZpeCAoMHgsMG8sMGIpXG4gIC8vIGFuZCBpc24ndCBmcmFjdGlvbiBwYXJ0IG5vciBleHBvbmVudCBwYXJ0LiBJbiB0aGF0IGNhc2UsIGlmIHRoZSBmaXJzdCBkaWdpdFxuICAvLyBpcyB6ZXJvIHRoZW4gZGlzYWxsb3cgc2VwYXJhdG9ycy5cbiAgdmFyIGlzTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbCA9IG1heWJlTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbCAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpID09PSA0ODtcblxuICB2YXIgc3RhcnQgPSB0aGlzLnBvcywgdG90YWwgPSAwLCBsYXN0Q29kZSA9IDA7XG4gIGZvciAodmFyIGkgPSAwLCBlID0gbGVuID09IG51bGwgPyBJbmZpbml0eSA6IGxlbjsgaSA8IGU7ICsraSwgKyt0aGlzLnBvcykge1xuICAgIHZhciBjb2RlID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSwgdmFsID0gKHZvaWQgMCk7XG5cbiAgICBpZiAoYWxsb3dTZXBhcmF0b3JzICYmIGNvZGUgPT09IDk1KSB7XG4gICAgICBpZiAoaXNMZWdhY3lPY3RhbE51bWVyaWNMaXRlcmFsKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnBvcywgXCJOdW1lcmljIHNlcGFyYXRvciBpcyBub3QgYWxsb3dlZCBpbiBsZWdhY3kgb2N0YWwgbnVtZXJpYyBsaXRlcmFsc1wiKTsgfVxuICAgICAgaWYgKGxhc3RDb2RlID09PSA5NSkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5wb3MsIFwiTnVtZXJpYyBzZXBhcmF0b3IgbXVzdCBiZSBleGFjdGx5IG9uZSB1bmRlcnNjb3JlXCIpOyB9XG4gICAgICBpZiAoaSA9PT0gMCkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5wb3MsIFwiTnVtZXJpYyBzZXBhcmF0b3IgaXMgbm90IGFsbG93ZWQgYXQgdGhlIGZpcnN0IG9mIGRpZ2l0c1wiKTsgfVxuICAgICAgbGFzdENvZGUgPSBjb2RlO1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAoY29kZSA+PSA5NykgeyB2YWwgPSBjb2RlIC0gOTcgKyAxMDsgfSAvLyBhXG4gICAgZWxzZSBpZiAoY29kZSA+PSA2NSkgeyB2YWwgPSBjb2RlIC0gNjUgKyAxMDsgfSAvLyBBXG4gICAgZWxzZSBpZiAoY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KSB7IHZhbCA9IGNvZGUgLSA0ODsgfSAvLyAwLTlcbiAgICBlbHNlIHsgdmFsID0gSW5maW5pdHk7IH1cbiAgICBpZiAodmFsID49IHJhZGl4KSB7IGJyZWFrIH1cbiAgICBsYXN0Q29kZSA9IGNvZGU7XG4gICAgdG90YWwgPSB0b3RhbCAqIHJhZGl4ICsgdmFsO1xuICB9XG5cbiAgaWYgKGFsbG93U2VwYXJhdG9ycyAmJiBsYXN0Q29kZSA9PT0gOTUpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMucG9zIC0gMSwgXCJOdW1lcmljIHNlcGFyYXRvciBpcyBub3QgYWxsb3dlZCBhdCB0aGUgbGFzdCBvZiBkaWdpdHNcIik7IH1cbiAgaWYgKHRoaXMucG9zID09PSBzdGFydCB8fCBsZW4gIT0gbnVsbCAmJiB0aGlzLnBvcyAtIHN0YXJ0ICE9PSBsZW4pIHsgcmV0dXJuIG51bGwgfVxuXG4gIHJldHVybiB0b3RhbFxufTtcblxuZnVuY3Rpb24gc3RyaW5nVG9OdW1iZXIoc3RyLCBpc0xlZ2FjeU9jdGFsTnVtZXJpY0xpdGVyYWwpIHtcbiAgaWYgKGlzTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbCkge1xuICAgIHJldHVybiBwYXJzZUludChzdHIsIDgpXG4gIH1cblxuICAvLyBgcGFyc2VGbG9hdCh2YWx1ZSlgIHN0b3BzIHBhcnNpbmcgYXQgdGhlIGZpcnN0IG51bWVyaWMgc2VwYXJhdG9yIHRoZW4gcmV0dXJucyBhIHdyb25nIHZhbHVlLlxuICByZXR1cm4gcGFyc2VGbG9hdChzdHIucmVwbGFjZSgvXy9nLCBcIlwiKSlcbn1cblxuZnVuY3Rpb24gc3RyaW5nVG9CaWdJbnQoc3RyKSB7XG4gIGlmICh0eXBlb2YgQmlnSW50ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gYEJpZ0ludCh2YWx1ZSlgIHRocm93cyBzeW50YXggZXJyb3IgaWYgdGhlIHN0cmluZyBjb250YWlucyBudW1lcmljIHNlcGFyYXRvcnMuXG4gIHJldHVybiBCaWdJbnQoc3RyLnJlcGxhY2UoL18vZywgXCJcIikpXG59XG5cbnBwLnJlYWRSYWRpeE51bWJlciA9IGZ1bmN0aW9uKHJhZGl4KSB7XG4gIHZhciBzdGFydCA9IHRoaXMucG9zO1xuICB0aGlzLnBvcyArPSAyOyAvLyAweFxuICB2YXIgdmFsID0gdGhpcy5yZWFkSW50KHJhZGl4KTtcbiAgaWYgKHZhbCA9PSBudWxsKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCArIDIsIFwiRXhwZWN0ZWQgbnVtYmVyIGluIHJhZGl4IFwiICsgcmFkaXgpOyB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTEgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSA9PT0gMTEwKSB7XG4gICAgdmFsID0gc3RyaW5nVG9CaWdJbnQodGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpKTtcbiAgICArK3RoaXMucG9zO1xuICB9IGVsc2UgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSkpIHsgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKTsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLm51bSwgdmFsKVxufTtcblxuLy8gUmVhZCBhbiBpbnRlZ2VyLCBvY3RhbCBpbnRlZ2VyLCBvciBmbG9hdGluZy1wb2ludCBudW1iZXIuXG5cbnBwLnJlYWROdW1iZXIgPSBmdW5jdGlvbihzdGFydHNXaXRoRG90KSB7XG4gIHZhciBzdGFydCA9IHRoaXMucG9zO1xuICBpZiAoIXN0YXJ0c1dpdGhEb3QgJiYgdGhpcy5yZWFkSW50KDEwLCB1bmRlZmluZWQsIHRydWUpID09PSBudWxsKSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7IH1cbiAgdmFyIG9jdGFsID0gdGhpcy5wb3MgLSBzdGFydCA+PSAyICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdChzdGFydCkgPT09IDQ4O1xuICBpZiAob2N0YWwgJiYgdGhpcy5zdHJpY3QpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTsgfVxuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gIGlmICghb2N0YWwgJiYgIXN0YXJ0c1dpdGhEb3QgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExICYmIG5leHQgPT09IDExMCkge1xuICAgIHZhciB2YWwkMSA9IHN0cmluZ1RvQmlnSW50KHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMucG9zKSk7XG4gICAgKyt0aGlzLnBvcztcbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQodGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKSkgeyB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyXCIpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5udW0sIHZhbCQxKVxuICB9XG4gIGlmIChvY3RhbCAmJiAvWzg5XS8udGVzdCh0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcykpKSB7IG9jdGFsID0gZmFsc2U7IH1cbiAgaWYgKG5leHQgPT09IDQ2ICYmICFvY3RhbCkgeyAvLyAnLidcbiAgICArK3RoaXMucG9zO1xuICAgIHRoaXMucmVhZEludCgxMCk7XG4gICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gIH1cbiAgaWYgKChuZXh0ID09PSA2OSB8fCBuZXh0ID09PSAxMDEpICYmICFvY3RhbCkgeyAvLyAnZUUnXG4gICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMucG9zKTtcbiAgICBpZiAobmV4dCA9PT0gNDMgfHwgbmV4dCA9PT0gNDUpIHsgKyt0aGlzLnBvczsgfSAvLyAnKy0nXG4gICAgaWYgKHRoaXMucmVhZEludCgxMCkgPT09IG51bGwpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTsgfVxuICB9XG4gIGlmIChpc0lkZW50aWZpZXJTdGFydCh0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7IH1cblxuICB2YXIgdmFsID0gc3RyaW5nVG9OdW1iZXIodGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpLCBvY3RhbCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEubnVtLCB2YWwpXG59O1xuXG4vLyBSZWFkIGEgc3RyaW5nIHZhbHVlLCBpbnRlcnByZXRpbmcgYmFja3NsYXNoLWVzY2FwZXMuXG5cbnBwLnJlYWRDb2RlUG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSwgY29kZTtcblxuICBpZiAoY2ggPT09IDEyMykgeyAvLyAneydcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIHZhciBjb2RlUG9zID0gKyt0aGlzLnBvcztcbiAgICBjb2RlID0gdGhpcy5yZWFkSGV4Q2hhcih0aGlzLmlucHV0LmluZGV4T2YoXCJ9XCIsIHRoaXMucG9zKSAtIHRoaXMucG9zKTtcbiAgICArK3RoaXMucG9zO1xuICAgIGlmIChjb2RlID4gMHgxMEZGRkYpIHsgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oY29kZVBvcywgXCJDb2RlIHBvaW50IG91dCBvZiBib3VuZHNcIik7IH1cbiAgfSBlbHNlIHtcbiAgICBjb2RlID0gdGhpcy5yZWFkSGV4Q2hhcig0KTtcbiAgfVxuICByZXR1cm4gY29kZVxufTtcblxucHAucmVhZFN0cmluZyA9IGZ1bmN0aW9uKHF1b3RlKSB7XG4gIHZhciBvdXQgPSBcIlwiLCBjaHVua1N0YXJ0ID0gKyt0aGlzLnBvcztcbiAgZm9yICg7Oykge1xuICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudFwiKTsgfVxuICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgaWYgKGNoID09PSBxdW90ZSkgeyBicmVhayB9XG4gICAgaWYgKGNoID09PSA5MikgeyAvLyAnXFwnXG4gICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICBvdXQgKz0gdGhpcy5yZWFkRXNjYXBlZENoYXIoZmFsc2UpO1xuICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4MjAyOCB8fCBjaCA9PT0gMHgyMDI5KSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgMTApIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIik7IH1cbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICB0aGlzLmN1ckxpbmUrKztcbiAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzTmV3TGluZShjaCkpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIik7IH1cbiAgICAgICsrdGhpcy5wb3M7XG4gICAgfVxuICB9XG4gIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKyspO1xuICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLnN0cmluZywgb3V0KVxufTtcblxuLy8gUmVhZHMgdGVtcGxhdGUgc3RyaW5nIHRva2Vucy5cblxudmFyIElOVkFMSURfVEVNUExBVEVfRVNDQVBFX0VSUk9SID0ge307XG5cbnBwLnRyeVJlYWRUZW1wbGF0ZVRva2VuID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaW5UZW1wbGF0ZUVsZW1lbnQgPSB0cnVlO1xuICB0cnkge1xuICAgIHRoaXMucmVhZFRtcGxUb2tlbigpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyID09PSBJTlZBTElEX1RFTVBMQVRFX0VTQ0FQRV9FUlJPUikge1xuICAgICAgdGhpcy5yZWFkSW52YWxpZFRlbXBsYXRlVG9rZW4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgdGhpcy5pblRlbXBsYXRlRWxlbWVudCA9IGZhbHNlO1xufTtcblxucHAuaW52YWxpZFN0cmluZ1Rva2VuID0gZnVuY3Rpb24ocG9zaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKHRoaXMuaW5UZW1wbGF0ZUVsZW1lbnQgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICB0aHJvdyBJTlZBTElEX1RFTVBMQVRFX0VTQ0FQRV9FUlJPUlxuICB9IGVsc2Uge1xuICAgIHRoaXMucmFpc2UocG9zaXRpb24sIG1lc3NhZ2UpO1xuICB9XG59O1xuXG5wcC5yZWFkVG1wbFRva2VuID0gZnVuY3Rpb24oKSB7XG4gIHZhciBvdXQgPSBcIlwiLCBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gIGZvciAoOzspIHtcbiAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIlVudGVybWluYXRlZCB0ZW1wbGF0ZVwiKTsgfVxuICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgaWYgKGNoID09PSA5NiB8fCBjaCA9PT0gMzYgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSkgPT09IDEyMykgeyAvLyAnYCcsICckeydcbiAgICAgIGlmICh0aGlzLnBvcyA9PT0gdGhpcy5zdGFydCAmJiAodGhpcy50eXBlID09PSB0eXBlcyQxLnRlbXBsYXRlIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5pbnZhbGlkVGVtcGxhdGUpKSB7XG4gICAgICAgIGlmIChjaCA9PT0gMzYpIHtcbiAgICAgICAgICB0aGlzLnBvcyArPSAyO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuZG9sbGFyQnJhY2VMKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5iYWNrUXVvdGUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEudGVtcGxhdGUsIG91dClcbiAgICB9XG4gICAgaWYgKGNoID09PSA5MikgeyAvLyAnXFwnXG4gICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICBvdXQgKz0gdGhpcy5yZWFkRXNjYXBlZENoYXIodHJ1ZSk7XG4gICAgICBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgfSBlbHNlIGlmIChpc05ld0xpbmUoY2gpKSB7XG4gICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICArK3RoaXMucG9zO1xuICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgY2FzZSAxMzpcbiAgICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcykgPT09IDEwKSB7ICsrdGhpcy5wb3M7IH1cbiAgICAgIGNhc2UgMTA6XG4gICAgICAgIG91dCArPSBcIlxcblwiO1xuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgICAgKyt0aGlzLmN1ckxpbmU7XG4gICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICB9XG4gICAgICBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgfSBlbHNlIHtcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgfVxuICB9XG59O1xuXG4vLyBSZWFkcyBhIHRlbXBsYXRlIHRva2VuIHRvIHNlYXJjaCBmb3IgdGhlIGVuZCwgd2l0aG91dCB2YWxpZGF0aW5nIGFueSBlc2NhcGUgc2VxdWVuY2VzXG5wcC5yZWFkSW52YWxpZFRlbXBsYXRlVG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgZm9yICg7IHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGg7IHRoaXMucG9zKyspIHtcbiAgICBzd2l0Y2ggKHRoaXMuaW5wdXRbdGhpcy5wb3NdKSB7XG4gICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIiRcIjpcbiAgICAgIGlmICh0aGlzLmlucHV0W3RoaXMucG9zICsgMV0gIT09IFwie1wiKSB7IGJyZWFrIH1cbiAgICAgIC8vIGZhbGwgdGhyb3VnaFxuICAgIGNhc2UgXCJgXCI6XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLmludmFsaWRUZW1wbGF0ZSwgdGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLnBvcykpXG5cbiAgICBjYXNlIFwiXFxyXCI6XG4gICAgICBpZiAodGhpcy5pbnB1dFt0aGlzLnBvcyArIDFdID09PSBcIlxcblwiKSB7ICsrdGhpcy5wb3M7IH1cbiAgICAgIC8vIGZhbGwgdGhyb3VnaFxuICAgIGNhc2UgXCJcXG5cIjogY2FzZSBcIlxcdTIwMjhcIjogY2FzZSBcIlxcdTIwMjlcIjpcbiAgICAgICsrdGhpcy5jdXJMaW5lO1xuICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLnBvcyArIDE7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlXCIpO1xufTtcblxuLy8gVXNlZCB0byByZWFkIGVzY2FwZWQgY2hhcmFjdGVyc1xuXG5wcC5yZWFkRXNjYXBlZENoYXIgPSBmdW5jdGlvbihpblRlbXBsYXRlKSB7XG4gIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMucG9zKTtcbiAgKyt0aGlzLnBvcztcbiAgc3dpdGNoIChjaCkge1xuICBjYXNlIDExMDogcmV0dXJuIFwiXFxuXCIgLy8gJ24nIC0+ICdcXG4nXG4gIGNhc2UgMTE0OiByZXR1cm4gXCJcXHJcIiAvLyAncicgLT4gJ1xccidcbiAgY2FzZSAxMjA6IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMucmVhZEhleENoYXIoMikpIC8vICd4J1xuICBjYXNlIDExNzogcmV0dXJuIGNvZGVQb2ludFRvU3RyaW5nKHRoaXMucmVhZENvZGVQb2ludCgpKSAvLyAndSdcbiAgY2FzZSAxMTY6IHJldHVybiBcIlxcdFwiIC8vICd0JyAtPiAnXFx0J1xuICBjYXNlIDk4OiByZXR1cm4gXCJcXGJcIiAvLyAnYicgLT4gJ1xcYidcbiAgY2FzZSAxMTg6IHJldHVybiBcIlxcdTAwMGJcIiAvLyAndicgLT4gJ1xcdTAwMGInXG4gIGNhc2UgMTAyOiByZXR1cm4gXCJcXGZcIiAvLyAnZicgLT4gJ1xcZidcbiAgY2FzZSAxMzogaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcykgPT09IDEwKSB7ICsrdGhpcy5wb3M7IH0gLy8gJ1xcclxcbidcbiAgY2FzZSAxMDogLy8gJyBcXG4nXG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHsgdGhpcy5saW5lU3RhcnQgPSB0aGlzLnBvczsgKyt0aGlzLmN1ckxpbmU7IH1cbiAgICByZXR1cm4gXCJcIlxuICBjYXNlIDU2OlxuICBjYXNlIDU3OlxuICAgIGlmICh0aGlzLnN0cmljdCkge1xuICAgICAgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oXG4gICAgICAgIHRoaXMucG9zIC0gMSxcbiAgICAgICAgXCJJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZVwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoaW5UZW1wbGF0ZSkge1xuICAgICAgdmFyIGNvZGVQb3MgPSB0aGlzLnBvcyAtIDE7XG5cbiAgICAgIHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKFxuICAgICAgICBjb2RlUG9zLFxuICAgICAgICBcIkludmFsaWQgZXNjYXBlIHNlcXVlbmNlIGluIHRlbXBsYXRlIHN0cmluZ1wiXG4gICAgICApO1xuICAgIH1cbiAgZGVmYXVsdDpcbiAgICBpZiAoY2ggPj0gNDggJiYgY2ggPD0gNTUpIHtcbiAgICAgIHZhciBvY3RhbFN0ciA9IHRoaXMuaW5wdXQuc3Vic3RyKHRoaXMucG9zIC0gMSwgMykubWF0Y2goL15bMC03XSsvKVswXTtcbiAgICAgIHZhciBvY3RhbCA9IHBhcnNlSW50KG9jdGFsU3RyLCA4KTtcbiAgICAgIGlmIChvY3RhbCA+IDI1NSkge1xuICAgICAgICBvY3RhbFN0ciA9IG9jdGFsU3RyLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgb2N0YWwgPSBwYXJzZUludChvY3RhbFN0ciwgOCk7XG4gICAgICB9XG4gICAgICB0aGlzLnBvcyArPSBvY3RhbFN0ci5sZW5ndGggLSAxO1xuICAgICAgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgICAgaWYgKChvY3RhbFN0ciAhPT0gXCIwXCIgfHwgY2ggPT09IDU2IHx8IGNoID09PSA1NykgJiYgKHRoaXMuc3RyaWN0IHx8IGluVGVtcGxhdGUpKSB7XG4gICAgICAgIHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKFxuICAgICAgICAgIHRoaXMucG9zIC0gMSAtIG9jdGFsU3RyLmxlbmd0aCxcbiAgICAgICAgICBpblRlbXBsYXRlXG4gICAgICAgICAgICA/IFwiT2N0YWwgbGl0ZXJhbCBpbiB0ZW1wbGF0ZSBzdHJpbmdcIlxuICAgICAgICAgICAgOiBcIk9jdGFsIGxpdGVyYWwgaW4gc3RyaWN0IG1vZGVcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUob2N0YWwpXG4gICAgfVxuICAgIGlmIChpc05ld0xpbmUoY2gpKSB7XG4gICAgICAvLyBVbmljb2RlIG5ldyBsaW5lIGNoYXJhY3RlcnMgYWZ0ZXIgXFwgZ2V0IHJlbW92ZWQgZnJvbSBvdXRwdXQgaW4gYm90aFxuICAgICAgLy8gdGVtcGxhdGUgbGl0ZXJhbHMgYW5kIHN0cmluZ3NcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7IHRoaXMubGluZVN0YXJ0ID0gdGhpcy5wb3M7ICsrdGhpcy5jdXJMaW5lOyB9XG4gICAgICByZXR1cm4gXCJcIlxuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaClcbiAgfVxufTtcblxuLy8gVXNlZCB0byByZWFkIGNoYXJhY3RlciBlc2NhcGUgc2VxdWVuY2VzICgnXFx4JywgJ1xcdScsICdcXFUnKS5cblxucHAucmVhZEhleENoYXIgPSBmdW5jdGlvbihsZW4pIHtcbiAgdmFyIGNvZGVQb3MgPSB0aGlzLnBvcztcbiAgdmFyIG4gPSB0aGlzLnJlYWRJbnQoMTYsIGxlbik7XG4gIGlmIChuID09PSBudWxsKSB7IHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKGNvZGVQb3MsIFwiQmFkIGNoYXJhY3RlciBlc2NhcGUgc2VxdWVuY2VcIik7IH1cbiAgcmV0dXJuIG5cbn07XG5cbi8vIFJlYWQgYW4gaWRlbnRpZmllciwgYW5kIHJldHVybiBpdCBhcyBhIHN0cmluZy4gU2V0cyBgdGhpcy5jb250YWluc0VzY2Bcbi8vIHRvIHdoZXRoZXIgdGhlIHdvcmQgY29udGFpbmVkIGEgJ1xcdScgZXNjYXBlLlxuLy9cbi8vIEluY3JlbWVudGFsbHkgYWRkcyBvbmx5IGVzY2FwZWQgY2hhcnMsIGFkZGluZyBvdGhlciBjaHVua3MgYXMtaXNcbi8vIGFzIGEgbWljcm8tb3B0aW1pemF0aW9uLlxuXG5wcC5yZWFkV29yZDEgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jb250YWluc0VzYyA9IGZhbHNlO1xuICB2YXIgd29yZCA9IFwiXCIsIGZpcnN0ID0gdHJ1ZSwgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICB2YXIgYXN0cmFsID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDY7XG4gIHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgdmFyIGNoID0gdGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpO1xuICAgIGlmIChpc0lkZW50aWZpZXJDaGFyKGNoLCBhc3RyYWwpKSB7XG4gICAgICB0aGlzLnBvcyArPSBjaCA8PSAweGZmZmYgPyAxIDogMjtcbiAgICB9IGVsc2UgaWYgKGNoID09PSA5MikgeyAvLyBcIlxcXCJcbiAgICAgIHRoaXMuY29udGFpbnNFc2MgPSB0cnVlO1xuICAgICAgd29yZCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgIHZhciBlc2NTdGFydCA9IHRoaXMucG9zO1xuICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMucG9zKSAhPT0gMTE3KSAvLyBcInVcIlxuICAgICAgICB7IHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKHRoaXMucG9zLCBcIkV4cGVjdGluZyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZSBcXFxcdVhYWFhcIik7IH1cbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICB2YXIgZXNjID0gdGhpcy5yZWFkQ29kZVBvaW50KCk7XG4gICAgICBpZiAoIShmaXJzdCA/IGlzSWRlbnRpZmllclN0YXJ0IDogaXNJZGVudGlmaWVyQ2hhcikoZXNjLCBhc3RyYWwpKVxuICAgICAgICB7IHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKGVzY1N0YXJ0LCBcIkludmFsaWQgVW5pY29kZSBlc2NhcGVcIik7IH1cbiAgICAgIHdvcmQgKz0gY29kZVBvaW50VG9TdHJpbmcoZXNjKTtcbiAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgZmlyc3QgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gd29yZCArIHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpXG59O1xuXG4vLyBSZWFkIGFuIGlkZW50aWZpZXIgb3Iga2V5d29yZCB0b2tlbi4gV2lsbCBjaGVjayBmb3IgcmVzZXJ2ZWRcbi8vIHdvcmRzIHdoZW4gbmVjZXNzYXJ5LlxuXG5wcC5yZWFkV29yZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgd29yZCA9IHRoaXMucmVhZFdvcmQxKCk7XG4gIHZhciB0eXBlID0gdHlwZXMkMS5uYW1lO1xuICBpZiAodGhpcy5rZXl3b3Jkcy50ZXN0KHdvcmQpKSB7XG4gICAgdHlwZSA9IGtleXdvcmRzW3dvcmRdO1xuICB9XG4gIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGUsIHdvcmQpXG59O1xuXG4vLyBBY29ybiBpcyBhIHRpbnksIGZhc3QgSmF2YVNjcmlwdCBwYXJzZXIgd3JpdHRlbiBpbiBKYXZhU2NyaXB0LlxuLy9cbi8vIEFjb3JuIHdhcyB3cml0dGVuIGJ5IE1hcmlqbiBIYXZlcmJla2UsIEluZ3ZhciBTdGVwYW55YW4sIGFuZFxuLy8gdmFyaW91cyBjb250cmlidXRvcnMgYW5kIHJlbGVhc2VkIHVuZGVyIGFuIE1JVCBsaWNlbnNlLlxuLy9cbi8vIEdpdCByZXBvc2l0b3JpZXMgZm9yIEFjb3JuIGFyZSBhdmFpbGFibGUgYXRcbi8vXG4vLyAgICAgaHR0cDovL21hcmlqbmhhdmVyYmVrZS5ubC9naXQvYWNvcm5cbi8vICAgICBodHRwczovL2dpdGh1Yi5jb20vYWNvcm5qcy9hY29ybi5naXRcbi8vXG4vLyBQbGVhc2UgdXNlIHRoZSBbZ2l0aHViIGJ1ZyB0cmFja2VyXVtnaGJ0XSB0byByZXBvcnQgaXNzdWVzLlxuLy9cbi8vIFtnaGJ0XTogaHR0cHM6Ly9naXRodWIuY29tL2Fjb3JuanMvYWNvcm4vaXNzdWVzXG4vL1xuLy8gW3dhbGtdOiB1dGlsL3dhbGsuanNcblxuXG52YXIgdmVyc2lvbiA9IFwiOC4xNC4xXCI7XG5cblBhcnNlci5hY29ybiA9IHtcbiAgUGFyc2VyOiBQYXJzZXIsXG4gIHZlcnNpb246IHZlcnNpb24sXG4gIGRlZmF1bHRPcHRpb25zOiBkZWZhdWx0T3B0aW9ucyxcbiAgUG9zaXRpb246IFBvc2l0aW9uLFxuICBTb3VyY2VMb2NhdGlvbjogU291cmNlTG9jYXRpb24sXG4gIGdldExpbmVJbmZvOiBnZXRMaW5lSW5mbyxcbiAgTm9kZTogTm9kZSxcbiAgVG9rZW5UeXBlOiBUb2tlblR5cGUsXG4gIHRva1R5cGVzOiB0eXBlcyQxLFxuICBrZXl3b3JkVHlwZXM6IGtleXdvcmRzLFxuICBUb2tDb250ZXh0OiBUb2tDb250ZXh0LFxuICB0b2tDb250ZXh0czogdHlwZXMsXG4gIGlzSWRlbnRpZmllckNoYXI6IGlzSWRlbnRpZmllckNoYXIsXG4gIGlzSWRlbnRpZmllclN0YXJ0OiBpc0lkZW50aWZpZXJTdGFydCxcbiAgVG9rZW46IFRva2VuLFxuICBpc05ld0xpbmU6IGlzTmV3TGluZSxcbiAgbGluZUJyZWFrOiBsaW5lQnJlYWssXG4gIGxpbmVCcmVha0c6IGxpbmVCcmVha0csXG4gIG5vbkFTQ0lJd2hpdGVzcGFjZTogbm9uQVNDSUl3aGl0ZXNwYWNlXG59O1xuXG4vLyBUaGUgbWFpbiBleHBvcnRlZCBpbnRlcmZhY2UgKHVuZGVyIGBzZWxmLmFjb3JuYCB3aGVuIGluIHRoZVxuLy8gYnJvd3NlcikgaXMgYSBgcGFyc2VgIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBjb2RlIHN0cmluZyBhbmQgcmV0dXJuc1xuLy8gYW4gYWJzdHJhY3Qgc3ludGF4IHRyZWUgYXMgc3BlY2lmaWVkIGJ5IHRoZSBbRVNUcmVlIHNwZWNdW2VzdHJlZV0uXG4vL1xuLy8gW2VzdHJlZV06IGh0dHBzOi8vZ2l0aHViLmNvbS9lc3RyZWUvZXN0cmVlXG5cbmZ1bmN0aW9uIHBhcnNlKGlucHV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBQYXJzZXIucGFyc2UoaW5wdXQsIG9wdGlvbnMpXG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gdHJpZXMgdG8gcGFyc2UgYSBzaW5nbGUgZXhwcmVzc2lvbiBhdCBhIGdpdmVuXG4vLyBvZmZzZXQgaW4gYSBzdHJpbmcuIFVzZWZ1bCBmb3IgcGFyc2luZyBtaXhlZC1sYW5ndWFnZSBmb3JtYXRzXG4vLyB0aGF0IGVtYmVkIEphdmFTY3JpcHQgZXhwcmVzc2lvbnMuXG5cbmZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbkF0KGlucHV0LCBwb3MsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIFBhcnNlci5wYXJzZUV4cHJlc3Npb25BdChpbnB1dCwgcG9zLCBvcHRpb25zKVxufVxuXG4vLyBBY29ybiBpcyBvcmdhbml6ZWQgYXMgYSB0b2tlbml6ZXIgYW5kIGEgcmVjdXJzaXZlLWRlc2NlbnQgcGFyc2VyLlxuLy8gVGhlIGB0b2tlbml6ZXJgIGV4cG9ydCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgdG8gdGhlIHRva2VuaXplci5cblxuZnVuY3Rpb24gdG9rZW5pemVyKGlucHV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBQYXJzZXIudG9rZW5pemVyKGlucHV0LCBvcHRpb25zKVxufVxuXG5leHBvcnQgeyBOb2RlLCBQYXJzZXIsIFBvc2l0aW9uLCBTb3VyY2VMb2NhdGlvbiwgVG9rQ29udGV4dCwgVG9rZW4sIFRva2VuVHlwZSwgZGVmYXVsdE9wdGlvbnMsIGdldExpbmVJbmZvLCBpc0lkZW50aWZpZXJDaGFyLCBpc0lkZW50aWZpZXJTdGFydCwgaXNOZXdMaW5lLCBrZXl3b3JkcyBhcyBrZXl3b3JkVHlwZXMsIGxpbmVCcmVhaywgbGluZUJyZWFrRywgbm9uQVNDSUl3aGl0ZXNwYWNlLCBwYXJzZSwgcGFyc2VFeHByZXNzaW9uQXQsIHR5cGVzIGFzIHRva0NvbnRleHRzLCB0eXBlcyQxIGFzIHRva1R5cGVzLCB0b2tlbml6ZXIsIHZlcnNpb24gfTtcbiJdLCJuYW1lcyI6WyJhc3RyYWxJZGVudGlmaWVyQ29kZXMiLCJhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcyIsIm5vbkFTQ0lJaWRlbnRpZmllckNoYXJzIiwibm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyIsInJlc2VydmVkV29yZHMiLCJzdHJpY3QiLCJzdHJpY3RCaW5kIiwiZWNtYTVBbmRMZXNzS2V5d29yZHMiLCJrZXl3b3JkcyQxIiwia2V5d29yZFJlbGF0aW9uYWxPcGVyYXRvciIsIm5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0IiwiUmVnRXhwIiwibm9uQVNDSUlpZGVudGlmaWVyIiwiaXNJbkFzdHJhbFNldCIsImNvZGUiLCJzZXQiLCJwb3MiLCJpIiwibGVuZ3RoIiwiaXNJZGVudGlmaWVyU3RhcnQiLCJhc3RyYWwiLCJ0ZXN0IiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiaXNJZGVudGlmaWVyQ2hhciIsIlRva2VuVHlwZSIsImxhYmVsIiwiY29uZiIsImtleXdvcmQiLCJiZWZvcmVFeHByIiwic3RhcnRzRXhwciIsImlzTG9vcCIsImlzQXNzaWduIiwicHJlZml4IiwicG9zdGZpeCIsImJpbm9wIiwidXBkYXRlQ29udGV4dCIsIm5hbWUiLCJwcmVjIiwia2V5d29yZHMiLCJrdyIsIm9wdGlvbnMiLCJ0eXBlcyQxIiwibnVtIiwicmVnZXhwIiwic3RyaW5nIiwicHJpdmF0ZUlkIiwiZW9mIiwiYnJhY2tldEwiLCJicmFja2V0UiIsImJyYWNlTCIsImJyYWNlUiIsInBhcmVuTCIsInBhcmVuUiIsImNvbW1hIiwic2VtaSIsImNvbG9uIiwiZG90IiwicXVlc3Rpb24iLCJxdWVzdGlvbkRvdCIsImFycm93IiwidGVtcGxhdGUiLCJpbnZhbGlkVGVtcGxhdGUiLCJlbGxpcHNpcyIsImJhY2tRdW90ZSIsImRvbGxhckJyYWNlTCIsImVxIiwiYXNzaWduIiwiaW5jRGVjIiwibG9naWNhbE9SIiwibG9naWNhbEFORCIsImJpdHdpc2VPUiIsImJpdHdpc2VYT1IiLCJiaXR3aXNlQU5EIiwiZXF1YWxpdHkiLCJyZWxhdGlvbmFsIiwiYml0U2hpZnQiLCJwbHVzTWluIiwibW9kdWxvIiwic3RhciIsInNsYXNoIiwic3RhcnN0YXIiLCJjb2FsZXNjZSIsIl9icmVhayIsIl9jYXNlIiwiX2NhdGNoIiwiX2NvbnRpbnVlIiwiX2RlYnVnZ2VyIiwiX2RlZmF1bHQiLCJfZG8iLCJfZWxzZSIsIl9maW5hbGx5IiwiX2ZvciIsIl9mdW5jdGlvbiIsIl9pZiIsIl9yZXR1cm4iLCJfc3dpdGNoIiwiX3Rocm93IiwiX3RyeSIsIl92YXIiLCJfY29uc3QiLCJfd2hpbGUiLCJfd2l0aCIsIl9uZXciLCJfdGhpcyIsIl9zdXBlciIsIl9jbGFzcyIsIl9leHRlbmRzIiwiX2V4cG9ydCIsIl9pbXBvcnQiLCJfbnVsbCIsIl90cnVlIiwiX2ZhbHNlIiwiX2luIiwiX2luc3RhbmNlb2YiLCJfdHlwZW9mIiwiX3ZvaWQiLCJfZGVsZXRlIiwibGluZUJyZWFrIiwibGluZUJyZWFrRyIsInNvdXJjZSIsImlzTmV3TGluZSIsIm5leHRMaW5lQnJlYWsiLCJmcm9tIiwiZW5kIiwibmV4dCIsImNoYXJDb2RlQXQiLCJub25BU0NJSXdoaXRlc3BhY2UiLCJza2lwV2hpdGVTcGFjZSIsInJlZiIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwidG9TdHJpbmciLCJoYXNPd24iLCJvYmoiLCJwcm9wTmFtZSIsImNhbGwiLCJpc0FycmF5IiwiQXJyYXkiLCJyZWdleHBDYWNoZSIsImNyZWF0ZSIsIndvcmRzUmVnZXhwIiwid29yZHMiLCJyZXBsYWNlIiwiY29kZVBvaW50VG9TdHJpbmciLCJsb25lU3Vycm9nYXRlIiwiUG9zaXRpb24iLCJsaW5lIiwiY29sIiwiY29sdW1uIiwib2Zmc2V0IiwibiIsIlNvdXJjZUxvY2F0aW9uIiwicCIsInN0YXJ0Iiwic291cmNlRmlsZSIsImdldExpbmVJbmZvIiwiaW5wdXQiLCJjdXIiLCJuZXh0QnJlYWsiLCJkZWZhdWx0T3B0aW9ucyIsImVjbWFWZXJzaW9uIiwic291cmNlVHlwZSIsIm9uSW5zZXJ0ZWRTZW1pY29sb24iLCJvblRyYWlsaW5nQ29tbWEiLCJhbGxvd1Jlc2VydmVkIiwiYWxsb3dSZXR1cm5PdXRzaWRlRnVuY3Rpb24iLCJhbGxvd0ltcG9ydEV4cG9ydEV2ZXJ5d2hlcmUiLCJhbGxvd0F3YWl0T3V0c2lkZUZ1bmN0aW9uIiwiYWxsb3dTdXBlck91dHNpZGVNZXRob2QiLCJhbGxvd0hhc2hCYW5nIiwiY2hlY2tQcml2YXRlRmllbGRzIiwibG9jYXRpb25zIiwib25Ub2tlbiIsIm9uQ29tbWVudCIsInJhbmdlcyIsInByb2dyYW0iLCJkaXJlY3RTb3VyY2VGaWxlIiwicHJlc2VydmVQYXJlbnMiLCJ3YXJuZWRBYm91dEVjbWFWZXJzaW9uIiwiZ2V0T3B0aW9ucyIsIm9wdHMiLCJvcHQiLCJjb25zb2xlIiwid2FybiIsInRva2VucyIsInRva2VuIiwicHVzaCIsInB1c2hDb21tZW50IiwiYXJyYXkiLCJibG9jayIsInRleHQiLCJzdGFydExvYyIsImVuZExvYyIsImNvbW1lbnQiLCJ0eXBlIiwidmFsdWUiLCJsb2MiLCJyYW5nZSIsIlNDT1BFX1RPUCIsIlNDT1BFX0ZVTkNUSU9OIiwiU0NPUEVfQVNZTkMiLCJTQ09QRV9HRU5FUkFUT1IiLCJTQ09QRV9BUlJPVyIsIlNDT1BFX1NJTVBMRV9DQVRDSCIsIlNDT1BFX1NVUEVSIiwiU0NPUEVfRElSRUNUX1NVUEVSIiwiU0NPUEVfQ0xBU1NfU1RBVElDX0JMT0NLIiwiU0NPUEVfQ0xBU1NfRklFTERfSU5JVCIsIlNDT1BFX1ZBUiIsImZ1bmN0aW9uRmxhZ3MiLCJhc3luYyIsImdlbmVyYXRvciIsIkJJTkRfTk9ORSIsIkJJTkRfVkFSIiwiQklORF9MRVhJQ0FMIiwiQklORF9GVU5DVElPTiIsIkJJTkRfU0lNUExFX0NBVENIIiwiQklORF9PVVRTSURFIiwiUGFyc2VyIiwic3RhcnRQb3MiLCJyZXNlcnZlZCIsInJlc2VydmVkU3RyaWN0IiwicmVzZXJ2ZWRXb3Jkc1N0cmljdCIsInJlc2VydmVkV29yZHNTdHJpY3RCaW5kIiwiY29udGFpbnNFc2MiLCJsaW5lU3RhcnQiLCJsYXN0SW5kZXhPZiIsImN1ckxpbmUiLCJzbGljZSIsInNwbGl0IiwiY3VyUG9zaXRpb24iLCJsYXN0VG9rRW5kTG9jIiwibGFzdFRva1N0YXJ0TG9jIiwibGFzdFRva1N0YXJ0IiwibGFzdFRva0VuZCIsImNvbnRleHQiLCJpbml0aWFsQ29udGV4dCIsImV4cHJBbGxvd2VkIiwiaW5Nb2R1bGUiLCJzdHJpY3REaXJlY3RpdmUiLCJwb3RlbnRpYWxBcnJvd0F0IiwicG90ZW50aWFsQXJyb3dJbkZvckF3YWl0IiwieWllbGRQb3MiLCJhd2FpdFBvcyIsImF3YWl0SWRlbnRQb3MiLCJsYWJlbHMiLCJ1bmRlZmluZWRFeHBvcnRzIiwic2tpcExpbmVDb21tZW50Iiwic2NvcGVTdGFjayIsImVudGVyU2NvcGUiLCJyZWdleHBTdGF0ZSIsInByaXZhdGVOYW1lU3RhY2siLCJwcm90b3R5cGVBY2Nlc3NvcnMiLCJpbkZ1bmN0aW9uIiwiY29uZmlndXJhYmxlIiwiaW5HZW5lcmF0b3IiLCJpbkFzeW5jIiwiY2FuQXdhaXQiLCJhbGxvd1N1cGVyIiwiYWxsb3dEaXJlY3RTdXBlciIsInRyZWF0RnVuY3Rpb25zQXNWYXIiLCJhbGxvd05ld0RvdFRhcmdldCIsImluQ2xhc3NTdGF0aWNCbG9jayIsInBhcnNlIiwibm9kZSIsInN0YXJ0Tm9kZSIsIm5leHRUb2tlbiIsInBhcnNlVG9wTGV2ZWwiLCJnZXQiLCJjdXJyZW50VmFyU2NvcGUiLCJmbGFncyIsImN1cnJlbnRUaGlzU2NvcGUiLCJ0cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZSIsImN1cnJlbnRTY29wZSIsImV4dGVuZCIsInBsdWdpbnMiLCJsZW4iLCJhcmd1bWVudHMiLCJjbHMiLCJwYXJzZUV4cHJlc3Npb25BdCIsInBhcnNlciIsInBhcnNlRXhwcmVzc2lvbiIsInRva2VuaXplciIsImRlZmluZVByb3BlcnRpZXMiLCJwcCQ5IiwibGl0ZXJhbCIsImxhc3RJbmRleCIsImV4ZWMiLCJtYXRjaCIsInNwYWNlQWZ0ZXIiLCJpbmRleCIsImNoYXJBdCIsImVhdCIsImlzQ29udGV4dHVhbCIsImVhdENvbnRleHR1YWwiLCJleHBlY3RDb250ZXh0dWFsIiwidW5leHBlY3RlZCIsImNhbkluc2VydFNlbWljb2xvbiIsImluc2VydFNlbWljb2xvbiIsInNlbWljb2xvbiIsImFmdGVyVHJhaWxpbmdDb21tYSIsInRva1R5cGUiLCJub3ROZXh0IiwiZXhwZWN0IiwicmFpc2UiLCJEZXN0cnVjdHVyaW5nRXJyb3JzIiwic2hvcnRoYW5kQXNzaWduIiwidHJhaWxpbmdDb21tYSIsInBhcmVudGhlc2l6ZWRBc3NpZ24iLCJwYXJlbnRoZXNpemVkQmluZCIsImRvdWJsZVByb3RvIiwiY2hlY2tQYXR0ZXJuRXJyb3JzIiwicmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyIsInJhaXNlUmVjb3ZlcmFibGUiLCJwYXJlbnMiLCJjaGVja0V4cHJlc3Npb25FcnJvcnMiLCJhbmRUaHJvdyIsImNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcyIsImlzU2ltcGxlQXNzaWduVGFyZ2V0IiwiZXhwciIsImV4cHJlc3Npb24iLCJwcCQ4IiwiZXhwb3J0cyIsImJvZHkiLCJzdG10IiwicGFyc2VTdGF0ZW1lbnQiLCJsaXN0Iiwia2V5cyIsImFkYXB0RGlyZWN0aXZlUHJvbG9ndWUiLCJmaW5pc2hOb2RlIiwibG9vcExhYmVsIiwia2luZCIsInN3aXRjaExhYmVsIiwiaXNMZXQiLCJza2lwIiwibmV4dENoIiwiaWRlbnQiLCJpc0FzeW5jRnVuY3Rpb24iLCJhZnRlciIsInRvcExldmVsIiwic3RhcnR0eXBlIiwicGFyc2VCcmVha0NvbnRpbnVlU3RhdGVtZW50IiwicGFyc2VEZWJ1Z2dlclN0YXRlbWVudCIsInBhcnNlRG9TdGF0ZW1lbnQiLCJwYXJzZUZvclN0YXRlbWVudCIsInBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQiLCJwYXJzZUNsYXNzIiwicGFyc2VJZlN0YXRlbWVudCIsInBhcnNlUmV0dXJuU3RhdGVtZW50IiwicGFyc2VTd2l0Y2hTdGF0ZW1lbnQiLCJwYXJzZVRocm93U3RhdGVtZW50IiwicGFyc2VUcnlTdGF0ZW1lbnQiLCJwYXJzZVZhclN0YXRlbWVudCIsInBhcnNlV2hpbGVTdGF0ZW1lbnQiLCJwYXJzZVdpdGhTdGF0ZW1lbnQiLCJwYXJzZUJsb2NrIiwicGFyc2VFbXB0eVN0YXRlbWVudCIsInBhcnNlRXhwcmVzc2lvblN0YXRlbWVudCIsInBhcnNlSW1wb3J0IiwicGFyc2VFeHBvcnQiLCJtYXliZU5hbWUiLCJwYXJzZUxhYmVsZWRTdGF0ZW1lbnQiLCJpc0JyZWFrIiwicGFyc2VJZGVudCIsImxhYiIsInBvcCIsInBhcnNlUGFyZW5FeHByZXNzaW9uIiwiYXdhaXRBdCIsInBhcnNlRm9yIiwiaW5pdCQxIiwicGFyc2VWYXIiLCJkZWNsYXJhdGlvbnMiLCJhd2FpdCIsInBhcnNlRm9ySW4iLCJzdGFydHNXaXRoTGV0IiwiaXNGb3JPZiIsImluaXRQb3MiLCJpbml0IiwicGFyc2VFeHByU3Vic2NyaXB0cyIsInRvQXNzaWduYWJsZSIsImNoZWNrTFZhbFBhdHRlcm4iLCJpc0FzeW5jIiwiZGVjbGFyYXRpb25Qb3NpdGlvbiIsInBhcnNlRnVuY3Rpb24iLCJGVU5DX1NUQVRFTUVOVCIsIkZVTkNfSEFOR0lOR19TVEFURU1FTlQiLCJjb25zZXF1ZW50IiwiYWx0ZXJuYXRlIiwiYXJndW1lbnQiLCJkaXNjcmltaW5hbnQiLCJjYXNlcyIsInNhd0RlZmF1bHQiLCJpc0Nhc2UiLCJleGl0U2NvcGUiLCJlbXB0eSQxIiwicGFyc2VDYXRjaENsYXVzZVBhcmFtIiwicGFyYW0iLCJwYXJzZUJpbmRpbmdBdG9tIiwic2ltcGxlIiwiaGFuZGxlciIsImNsYXVzZSIsImZpbmFsaXplciIsImFsbG93TWlzc2luZ0luaXRpYWxpemVyIiwib2JqZWN0IiwiaSQxIiwibGFiZWwkMSIsInN0YXRlbWVudFN0YXJ0IiwiaW5kZXhPZiIsImNyZWF0ZU5ld0xleGljYWxTY29wZSIsImV4aXRTdHJpY3QiLCJ1cGRhdGUiLCJpc0ZvckluIiwiaWQiLCJsZWZ0IiwicmlnaHQiLCJwYXJzZU1heWJlQXNzaWduIiwiaXNGb3IiLCJkZWNsIiwicGFyc2VWYXJJZCIsIkZVTkNfTlVMTEFCTEVfSUQiLCJzdGF0ZW1lbnQiLCJhbGxvd0V4cHJlc3Npb25Cb2R5IiwiZm9ySW5pdCIsImluaXRGdW5jdGlvbiIsImNoZWNrTFZhbFNpbXBsZSIsIm9sZFlpZWxkUG9zIiwib2xkQXdhaXRQb3MiLCJvbGRBd2FpdElkZW50UG9zIiwicGFyc2VGdW5jdGlvblBhcmFtcyIsInBhcnNlRnVuY3Rpb25Cb2R5IiwicGFyYW1zIiwicGFyc2VCaW5kaW5nTGlzdCIsImlzU3RhdGVtZW50Iiwib2xkU3RyaWN0IiwicGFyc2VDbGFzc0lkIiwicGFyc2VDbGFzc1N1cGVyIiwicHJpdmF0ZU5hbWVNYXAiLCJlbnRlckNsYXNzQm9keSIsImNsYXNzQm9keSIsImhhZENvbnN0cnVjdG9yIiwiZWxlbWVudCIsInBhcnNlQ2xhc3NFbGVtZW50Iiwic3VwZXJDbGFzcyIsImtleSIsImlzUHJpdmF0ZU5hbWVDb25mbGljdGVkIiwiZXhpdENsYXNzQm9keSIsImNvbnN0cnVjdG9yQWxsb3dzU3VwZXIiLCJrZXlOYW1lIiwiaXNHZW5lcmF0b3IiLCJpc1N0YXRpYyIsInBhcnNlQ2xhc3NTdGF0aWNCbG9jayIsImlzQ2xhc3NFbGVtZW50TmFtZVN0YXJ0Iiwic3RhdGljIiwibGFzdFZhbHVlIiwiY29tcHV0ZWQiLCJzdGFydE5vZGVBdCIsInBhcnNlQ2xhc3NFbGVtZW50TmFtZSIsImlzQ29uc3RydWN0b3IiLCJjaGVja0tleU5hbWUiLCJhbGxvd3NEaXJlY3RTdXBlciIsInBhcnNlQ2xhc3NNZXRob2QiLCJwYXJzZUNsYXNzRmllbGQiLCJwYXJzZVByaXZhdGVJZGVudCIsInBhcnNlUHJvcGVydHlOYW1lIiwibWV0aG9kIiwicGFyc2VNZXRob2QiLCJmaWVsZCIsIm9sZExhYmVscyIsImRlY2xhcmVkIiwidXNlZCIsInBhcmVudCIsImN1cnIiLCJwYXJzZUV4cG9ydEFsbERlY2xhcmF0aW9uIiwiZXhwb3J0ZWQiLCJwYXJzZU1vZHVsZUV4cG9ydE5hbWUiLCJjaGVja0V4cG9ydCIsInBhcnNlRXhwckF0b20iLCJhdHRyaWJ1dGVzIiwicGFyc2VXaXRoQ2xhdXNlIiwiZGVjbGFyYXRpb24iLCJwYXJzZUV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiIsInNob3VsZFBhcnNlRXhwb3J0U3RhdGVtZW50IiwicGFyc2VFeHBvcnREZWNsYXJhdGlvbiIsImNoZWNrVmFyaWFibGVFeHBvcnQiLCJzcGVjaWZpZXJzIiwicGFyc2VFeHBvcnRTcGVjaWZpZXJzIiwic3BlYyIsImNoZWNrVW5yZXNlcnZlZCIsImxvY2FsIiwiY2hlY2tMb2NhbEV4cG9ydCIsImZOb2RlIiwiY05vZGUiLCJjaGVja1BhdHRlcm5FeHBvcnQiLCJwYXQiLCJwcm9wZXJ0aWVzIiwicHJvcCIsImxpc3QkMSIsImVsZW1lbnRzIiwiZWx0IiwiZGVjbHMiLCJwYXJzZUV4cG9ydFNwZWNpZmllciIsIm5vZGVzIiwiZmlyc3QiLCJwYXJzZUltcG9ydFNwZWNpZmllcnMiLCJwYXJzZUltcG9ydFNwZWNpZmllciIsImltcG9ydGVkIiwicGFyc2VJbXBvcnREZWZhdWx0U3BlY2lmaWVyIiwicGFyc2VJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIiLCJhdHRyaWJ1dGVLZXlzIiwiYXR0ciIsInBhcnNlSW1wb3J0QXR0cmlidXRlIiwic3RyaW5nTGl0ZXJhbCIsInBhcnNlTGl0ZXJhbCIsInN0YXRlbWVudHMiLCJpc0RpcmVjdGl2ZUNhbmRpZGF0ZSIsImRpcmVjdGl2ZSIsInJhdyIsInBwJDciLCJpc0JpbmRpbmciLCJ0b0Fzc2lnbmFibGVMaXN0Iiwib3BlcmF0b3IiLCJleHByTGlzdCIsImxhc3QiLCJwYXJzZVNwcmVhZCIsInBhcnNlUmVzdEJpbmRpbmciLCJwYXJzZU9iaiIsImNsb3NlIiwiYWxsb3dFbXB0eSIsImFsbG93VHJhaWxpbmdDb21tYSIsImFsbG93TW9kaWZpZXJzIiwiZWx0cyIsInJlc3QiLCJwYXJzZUJpbmRpbmdMaXN0SXRlbSIsInBhcnNlQXNzaWduYWJsZUxpc3RJdGVtIiwiZWxlbSIsInBhcnNlTWF5YmVEZWZhdWx0IiwiYmluZGluZ1R5cGUiLCJjaGVja0NsYXNoZXMiLCJpc0JpbmQiLCJkZWNsYXJlTmFtZSIsImNoZWNrTFZhbElubmVyUGF0dGVybiIsIlRva0NvbnRleHQiLCJpc0V4cHIiLCJwcmVzZXJ2ZVNwYWNlIiwib3ZlcnJpZGUiLCJ0eXBlcyIsImJfc3RhdCIsImJfZXhwciIsImJfdG1wbCIsInBfc3RhdCIsInBfZXhwciIsInFfdG1wbCIsInRyeVJlYWRUZW1wbGF0ZVRva2VuIiwiZl9zdGF0IiwiZl9leHByIiwiZl9leHByX2dlbiIsImZfZ2VuIiwicHAkNiIsImN1ckNvbnRleHQiLCJicmFjZUlzQmxvY2siLCJwcmV2VHlwZSIsImluR2VuZXJhdG9yQ29udGV4dCIsIm92ZXJyaWRlQ29udGV4dCIsInRva2VuQ3R4Iiwib3V0Iiwic3RhdGVtZW50UGFyZW5zIiwiYWxsb3dlZCIsInBwJDUiLCJjaGVja1Byb3BDbGFzaCIsInByb3BIYXNoIiwic2hvcnRoYW5kIiwicHJvdG8iLCJvdGhlciIsInJlZGVmaW5pdGlvbiIsImV4cHJlc3Npb25zIiwiYWZ0ZXJMZWZ0UGFyc2UiLCJwYXJzZVlpZWxkIiwib3duRGVzdHJ1Y3R1cmluZ0Vycm9ycyIsIm9sZFBhcmVuQXNzaWduIiwib2xkVHJhaWxpbmdDb21tYSIsIm9sZERvdWJsZVByb3RvIiwicGFyc2VNYXliZUNvbmRpdGlvbmFsIiwicGFyc2VFeHByT3BzIiwicGFyc2VNYXliZVVuYXJ5IiwicGFyc2VFeHByT3AiLCJsZWZ0U3RhcnRQb3MiLCJsZWZ0U3RhcnRMb2MiLCJtaW5QcmVjIiwibG9naWNhbCIsIm9wIiwiYnVpbGRCaW5hcnkiLCJzYXdVbmFyeSIsInBhcnNlQXdhaXQiLCJpc0xvY2FsVmFyaWFibGVBY2Nlc3MiLCJpc1ByaXZhdGVGaWVsZEFjY2VzcyIsIm5vZGUkMSIsInByb3BlcnR5IiwicmVzdWx0IiwicGFyc2VTdWJzY3JpcHRzIiwiYmFzZSIsIm5vQ2FsbHMiLCJtYXliZUFzeW5jQXJyb3ciLCJvcHRpb25hbENoYWluZWQiLCJwYXJzZVN1YnNjcmlwdCIsIm9wdGlvbmFsIiwiY2hhaW5Ob2RlIiwic2hvdWxkUGFyc2VBc3luY0Fycm93IiwicGFyc2VTdWJzY3JpcHRBc3luY0Fycm93IiwicGFyc2VBcnJvd0V4cHJlc3Npb24iLCJvcHRpb25hbFN1cHBvcnRlZCIsInBhcnNlRXhwckxpc3QiLCJjYWxsZWUiLCJub2RlJDIiLCJ0YWciLCJxdWFzaSIsInBhcnNlVGVtcGxhdGUiLCJpc1RhZ2dlZCIsImZvck5ldyIsInJlYWRSZWdleHAiLCJjYW5CZUFycm93IiwicmVnZXgiLCJwYXR0ZXJuIiwicGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbiIsInBhcnNlTmV3IiwicGFyc2VFeHBySW1wb3J0IiwicGFyc2VFeHByQXRvbURlZmF1bHQiLCJwYXJzZUR5bmFtaWNJbXBvcnQiLCJtZXRhIiwicGFyc2VJbXBvcnRNZXRhIiwiZXJyb3JQb3MiLCJiaWdpbnQiLCJ2YWwiLCJzaG91bGRQYXJzZUFycm93IiwiaW5uZXJTdGFydFBvcyIsImlubmVyU3RhcnRMb2MiLCJsYXN0SXNDb21tYSIsInNwcmVhZFN0YXJ0IiwicGFyc2VQYXJlbkl0ZW0iLCJpbm5lckVuZFBvcyIsImlubmVyRW5kTG9jIiwicGFyc2VQYXJlbkFycm93TGlzdCIsImZpbmlzaE5vZGVBdCIsInBhciIsIml0ZW0iLCJlbXB0eSIsInBhcnNlVGVtcGxhdGVFbGVtZW50IiwiY29va2VkIiwidGFpbCIsImN1ckVsdCIsInF1YXNpcyIsImlzQXN5bmNQcm9wIiwiaXNQYXR0ZXJuIiwicGFyc2VQcm9wZXJ0eSIsInBhcnNlUHJvcGVydHlWYWx1ZSIsInBhcnNlR2V0dGVyU2V0dGVyIiwicGFyYW1Db3VudCIsImNvcHlOb2RlIiwiaXNBcnJvd0Z1bmN0aW9uIiwiaXNNZXRob2QiLCJpc0V4cHJlc3Npb24iLCJ1c2VTdHJpY3QiLCJjaGVja1BhcmFtcyIsIm5vblNpbXBsZSIsImlzU2ltcGxlUGFyYW1MaXN0IiwidW5kZWZpbmVkIiwiYWxsb3dEdXBsaWNhdGVzIiwibmFtZUhhc2giLCJyZSIsImxpYmVyYWwiLCJwYXJzZUlkZW50Tm9kZSIsImRlbGVnYXRlIiwicHAkNCIsIm1lc3NhZ2UiLCJlcnIiLCJTeW50YXhFcnJvciIsInJhaXNlZEF0IiwicHAkMyIsIlNjb3BlIiwidmFyIiwibGV4aWNhbCIsImZ1bmN0aW9ucyIsInNjb3BlIiwicmVkZWNsYXJlZCIsInNjb3BlJDEiLCJzY29wZSQyIiwic2NvcGUkMyIsIk5vZGUiLCJwcCQyIiwibmV3Tm9kZSIsInNjcmlwdFZhbHVlc0FkZGVkSW5Vbmljb2RlIiwiZWNtYTlCaW5hcnlQcm9wZXJ0aWVzIiwiZWNtYTEwQmluYXJ5UHJvcGVydGllcyIsImVjbWExMUJpbmFyeVByb3BlcnRpZXMiLCJlY21hMTJCaW5hcnlQcm9wZXJ0aWVzIiwiZWNtYTEzQmluYXJ5UHJvcGVydGllcyIsImVjbWExNEJpbmFyeVByb3BlcnRpZXMiLCJ1bmljb2RlQmluYXJ5UHJvcGVydGllcyIsImVjbWExNEJpbmFyeVByb3BlcnRpZXNPZlN0cmluZ3MiLCJ1bmljb2RlQmluYXJ5UHJvcGVydGllc09mU3RyaW5ncyIsInVuaWNvZGVHZW5lcmFsQ2F0ZWdvcnlWYWx1ZXMiLCJlY21hOVNjcmlwdFZhbHVlcyIsImVjbWExMFNjcmlwdFZhbHVlcyIsImVjbWExMVNjcmlwdFZhbHVlcyIsImVjbWExMlNjcmlwdFZhbHVlcyIsImVjbWExM1NjcmlwdFZhbHVlcyIsImVjbWExNFNjcmlwdFZhbHVlcyIsInVuaWNvZGVTY3JpcHRWYWx1ZXMiLCJkYXRhIiwiYnVpbGRVbmljb2RlRGF0YSIsImQiLCJiaW5hcnkiLCJiaW5hcnlPZlN0cmluZ3MiLCJub25CaW5hcnkiLCJHZW5lcmFsX0NhdGVnb3J5IiwiU2NyaXB0IiwiU2NyaXB0X0V4dGVuc2lvbnMiLCJnYyIsInNjIiwic2N4IiwicHAkMSIsIkJyYW5jaElEIiwic2VwYXJhdGVkRnJvbSIsImFsdCIsInNlbGYiLCJzaWJsaW5nIiwiUmVnRXhwVmFsaWRhdGlvblN0YXRlIiwidmFsaWRGbGFncyIsInVuaWNvZGVQcm9wZXJ0aWVzIiwic3dpdGNoVSIsInN3aXRjaFYiLCJzd2l0Y2hOIiwibGFzdEludFZhbHVlIiwibGFzdFN0cmluZ1ZhbHVlIiwibGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlIiwibnVtQ2FwdHVyaW5nUGFyZW5zIiwibWF4QmFja1JlZmVyZW5jZSIsImdyb3VwTmFtZXMiLCJiYWNrUmVmZXJlbmNlTmFtZXMiLCJicmFuY2hJRCIsInJlc2V0IiwidW5pY29kZVNldHMiLCJ1bmljb2RlIiwiYXQiLCJmb3JjZVUiLCJzIiwibCIsImMiLCJuZXh0SW5kZXgiLCJjdXJyZW50IiwibG9va2FoZWFkIiwiYWR2YW5jZSIsImNoIiwiZWF0Q2hhcnMiLCJjaHMiLCJ2YWxpZGF0ZVJlZ0V4cEZsYWdzIiwic3RhdGUiLCJ1IiwidiIsImZsYWciLCJoYXNQcm9wIiwiXyIsInZhbGlkYXRlUmVnRXhwUGF0dGVybiIsInJlZ2V4cF9wYXR0ZXJuIiwicmVnZXhwX2Rpc2p1bmN0aW9uIiwidHJhY2tEaXNqdW5jdGlvbiIsInJlZ2V4cF9hbHRlcm5hdGl2ZSIsInJlZ2V4cF9lYXRRdWFudGlmaWVyIiwicmVnZXhwX2VhdFRlcm0iLCJyZWdleHBfZWF0QXNzZXJ0aW9uIiwicmVnZXhwX2VhdEF0b20iLCJyZWdleHBfZWF0RXh0ZW5kZWRBdG9tIiwibG9va2JlaGluZCIsIm5vRXJyb3IiLCJyZWdleHBfZWF0UXVhbnRpZmllclByZWZpeCIsInJlZ2V4cF9lYXRCcmFjZWRRdWFudGlmaWVyIiwibWluIiwibWF4IiwicmVnZXhwX2VhdERlY2ltYWxEaWdpdHMiLCJyZWdleHBfZWF0UGF0dGVybkNoYXJhY3RlcnMiLCJyZWdleHBfZWF0UmV2ZXJzZVNvbGlkdXNBdG9tRXNjYXBlIiwicmVnZXhwX2VhdENoYXJhY3RlckNsYXNzIiwicmVnZXhwX2VhdFVuY2FwdHVyaW5nR3JvdXAiLCJyZWdleHBfZWF0Q2FwdHVyaW5nR3JvdXAiLCJyZWdleHBfZWF0QXRvbUVzY2FwZSIsImFkZE1vZGlmaWVycyIsInJlZ2V4cF9lYXRNb2RpZmllcnMiLCJoYXNIeXBoZW4iLCJtb2RpZmllciIsInJlbW92ZU1vZGlmaWVycyIsIm1vZGlmaWVyJDEiLCJyZWdleHBfZ3JvdXBTcGVjaWZpZXIiLCJtb2RpZmllcnMiLCJpc1JlZ3VsYXJFeHByZXNzaW9uTW9kaWZpZXIiLCJyZWdleHBfZWF0SW52YWxpZEJyYWNlZFF1YW50aWZpZXIiLCJyZWdleHBfZWF0RXh0ZW5kZWRQYXR0ZXJuQ2hhcmFjdGVyIiwicmVnZXhwX2VhdFN5bnRheENoYXJhY3RlciIsImlzU3ludGF4Q2hhcmFjdGVyIiwicmVnZXhwX2VhdEdyb3VwTmFtZSIsImtub3duIiwiYWx0SUQiLCJyZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllck5hbWUiLCJyZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclN0YXJ0IiwicmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJQYXJ0IiwicmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZSIsImlzUmVnRXhwSWRlbnRpZmllclN0YXJ0IiwiaXNSZWdFeHBJZGVudGlmaWVyUGFydCIsInJlZ2V4cF9lYXRCYWNrUmVmZXJlbmNlIiwicmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlIiwicmVnZXhwX2VhdENoYXJhY3RlckVzY2FwZSIsInJlZ2V4cF9lYXRLR3JvdXBOYW1lIiwicmVnZXhwX2VhdERlY2ltYWxFc2NhcGUiLCJyZWdleHBfZWF0Q29udHJvbEVzY2FwZSIsInJlZ2V4cF9lYXRDQ29udHJvbExldHRlciIsInJlZ2V4cF9lYXRaZXJvIiwicmVnZXhwX2VhdEhleEVzY2FwZVNlcXVlbmNlIiwicmVnZXhwX2VhdExlZ2FjeU9jdGFsRXNjYXBlU2VxdWVuY2UiLCJyZWdleHBfZWF0SWRlbnRpdHlFc2NhcGUiLCJyZWdleHBfZWF0Q29udHJvbExldHRlciIsImlzRGVjaW1hbERpZ2l0IiwiaXNDb250cm9sTGV0dGVyIiwicmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzIiwibGVhZCIsImxlYWRTdXJyb2dhdGVFbmQiLCJ0cmFpbCIsInJlZ2V4cF9lYXRIZXhEaWdpdHMiLCJpc1ZhbGlkVW5pY29kZSIsIkNoYXJTZXROb25lIiwiQ2hhclNldE9rIiwiQ2hhclNldFN0cmluZyIsImlzQ2hhcmFjdGVyQ2xhc3NFc2NhcGUiLCJuZWdhdGUiLCJyZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWVFeHByZXNzaW9uIiwicmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eU5hbWUiLCJyZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWUiLCJyZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lQW5kVmFsdWUiLCJyZWdleHBfZWF0TG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlIiwibmFtZU9yVmFsdWUiLCJyZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZSIsImlzVW5pY29kZVByb3BlcnR5TmFtZUNoYXJhY3RlciIsImlzVW5pY29kZVByb3BlcnR5VmFsdWVDaGFyYWN0ZXIiLCJyZWdleHBfY2xhc3NDb250ZW50cyIsInJlZ2V4cF9jbGFzc1NldEV4cHJlc3Npb24iLCJyZWdleHBfbm9uRW1wdHlDbGFzc1JhbmdlcyIsInJlZ2V4cF9lYXRDbGFzc0F0b20iLCJyZWdleHBfZWF0Q2xhc3NFc2NhcGUiLCJjaCQxIiwiaXNPY3RhbERpZ2l0IiwicmVnZXhwX2VhdENsYXNzQ29udHJvbExldHRlciIsInN1YlJlc3VsdCIsInJlZ2V4cF9lYXRDbGFzc1NldFJhbmdlIiwicmVnZXhwX2VhdENsYXNzU2V0T3BlcmFuZCIsInJlZ2V4cF9lYXRDbGFzc1NldENoYXJhY3RlciIsInJlZ2V4cF9lYXRDbGFzc1N0cmluZ0Rpc2p1bmN0aW9uIiwicmVnZXhwX2VhdE5lc3RlZENsYXNzIiwicmVzdWx0JDEiLCJyZWdleHBfY2xhc3NTdHJpbmdEaXNqdW5jdGlvbkNvbnRlbnRzIiwicmVnZXhwX2NsYXNzU3RyaW5nIiwiY291bnQiLCJyZWdleHBfZWF0Q2xhc3NTZXRSZXNlcnZlZFB1bmN0dWF0b3IiLCJpc0NsYXNzU2V0UmVzZXJ2ZWREb3VibGVQdW5jdHVhdG9yQ2hhcmFjdGVyIiwiaXNDbGFzc1NldFN5bnRheENoYXJhY3RlciIsImlzQ2xhc3NTZXRSZXNlcnZlZFB1bmN0dWF0b3IiLCJpc0hleERpZ2l0IiwiaGV4VG9JbnQiLCJyZWdleHBfZWF0T2N0YWxEaWdpdCIsIm4xIiwibjIiLCJUb2tlbiIsInBwIiwiaWdub3JlRXNjYXBlU2VxdWVuY2VJbktleXdvcmQiLCJnZXRUb2tlbiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwidGhpcyQxJDEiLCJkb25lIiwic2tpcFNwYWNlIiwiZmluaXNoVG9rZW4iLCJyZWFkVG9rZW4iLCJmdWxsQ2hhckNvZGVBdFBvcyIsInJlYWRXb3JkIiwiZ2V0VG9rZW5Gcm9tQ29kZSIsInNraXBCbG9ja0NvbW1lbnQiLCJzdGFydFNraXAiLCJsb29wIiwicmVhZFRva2VuX2RvdCIsInJlYWROdW1iZXIiLCJuZXh0MiIsInJlYWRUb2tlbl9zbGFzaCIsImZpbmlzaE9wIiwicmVhZFRva2VuX211bHRfbW9kdWxvX2V4cCIsInNpemUiLCJ0b2tlbnR5cGUiLCJyZWFkVG9rZW5fcGlwZV9hbXAiLCJyZWFkVG9rZW5fY2FyZXQiLCJyZWFkVG9rZW5fcGx1c19taW4iLCJyZWFkVG9rZW5fbHRfZ3QiLCJyZWFkVG9rZW5fZXFfZXhjbCIsInJlYWRUb2tlbl9xdWVzdGlvbiIsIm5leHQyJDEiLCJyZWFkVG9rZW5fbnVtYmVyU2lnbiIsInJlYWRXb3JkMSIsInJlYWRSYWRpeE51bWJlciIsInJlYWRTdHJpbmciLCJzdHIiLCJlc2NhcGVkIiwiaW5DbGFzcyIsImZsYWdzU3RhcnQiLCJlIiwicmVhZEludCIsInJhZGl4IiwibWF5YmVMZWdhY3lPY3RhbE51bWVyaWNMaXRlcmFsIiwiYWxsb3dTZXBhcmF0b3JzIiwiaXNMZWdhY3lPY3RhbE51bWVyaWNMaXRlcmFsIiwidG90YWwiLCJsYXN0Q29kZSIsIkluZmluaXR5Iiwic3RyaW5nVG9OdW1iZXIiLCJwYXJzZUludCIsInBhcnNlRmxvYXQiLCJzdHJpbmdUb0JpZ0ludCIsIkJpZ0ludCIsInN0YXJ0c1dpdGhEb3QiLCJvY3RhbCIsInZhbCQxIiwicmVhZENvZGVQb2ludCIsImNvZGVQb3MiLCJyZWFkSGV4Q2hhciIsImludmFsaWRTdHJpbmdUb2tlbiIsInF1b3RlIiwiY2h1bmtTdGFydCIsInJlYWRFc2NhcGVkQ2hhciIsIklOVkFMSURfVEVNUExBVEVfRVNDQVBFX0VSUk9SIiwiaW5UZW1wbGF0ZUVsZW1lbnQiLCJyZWFkVG1wbFRva2VuIiwicmVhZEludmFsaWRUZW1wbGF0ZVRva2VuIiwicG9zaXRpb24iLCJpblRlbXBsYXRlIiwib2N0YWxTdHIiLCJzdWJzdHIiLCJ3b3JkIiwiZXNjU3RhcnQiLCJlc2MiLCJ2ZXJzaW9uIiwiYWNvcm4iLCJ0b2tUeXBlcyIsImtleXdvcmRUeXBlcyIsInRva0NvbnRleHRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/acorn/dist/acorn.mjs\n");

/***/ })

};
;