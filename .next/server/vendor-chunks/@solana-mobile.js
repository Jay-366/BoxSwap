"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@solana-mobile";
exports.ids = ["vendor-chunks/@solana-mobile"];
exports.modules = {

/***/ "(ssr)/./node_modules/@solana-mobile/mobile-wallet-adapter-protocol-web3js/node_modules/base-x/src/index.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@solana-mobile/mobile-wallet-adapter-protocol-web3js/node_modules/base-x/src/index.js ***!
  \************************************************************************************************************/
/***/ ((module) => {

eval("\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base(ALPHABET) {\n    if (ALPHABET.length >= 255) {\n        throw new TypeError(\"Alphabet too long\");\n    }\n    var BASE_MAP = new Uint8Array(256);\n    for(var j = 0; j < BASE_MAP.length; j++){\n        BASE_MAP[j] = 255;\n    }\n    for(var i = 0; i < ALPHABET.length; i++){\n        var x = ALPHABET.charAt(i);\n        var xc = x.charCodeAt(0);\n        if (BASE_MAP[xc] !== 255) {\n            throw new TypeError(x + \" is ambiguous\");\n        }\n        BASE_MAP[xc] = i;\n    }\n    var BASE = ALPHABET.length;\n    var LEADER = ALPHABET.charAt(0);\n    var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n    ;\n    var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n    ;\n    function encode(source) {\n        if (source instanceof Uint8Array) {} else if (ArrayBuffer.isView(source)) {\n            source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n        } else if (Array.isArray(source)) {\n            source = Uint8Array.from(source);\n        }\n        if (!(source instanceof Uint8Array)) {\n            throw new TypeError(\"Expected Uint8Array\");\n        }\n        if (source.length === 0) {\n            return \"\";\n        }\n        // Skip & count leading zeroes.\n        var zeroes = 0;\n        var length = 0;\n        var pbegin = 0;\n        var pend = source.length;\n        while(pbegin !== pend && source[pbegin] === 0){\n            pbegin++;\n            zeroes++;\n        }\n        // Allocate enough space in big-endian base58 representation.\n        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;\n        var b58 = new Uint8Array(size);\n        // Process the bytes.\n        while(pbegin !== pend){\n            var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n            var i = 0;\n            for(var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++){\n                carry += 256 * b58[it1] >>> 0;\n                b58[it1] = carry % BASE >>> 0;\n                carry = carry / BASE >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error(\"Non-zero carry\");\n            }\n            length = i;\n            pbegin++;\n        }\n        // Skip leading zeroes in base58 result.\n        var it2 = size - length;\n        while(it2 !== size && b58[it2] === 0){\n            it2++;\n        }\n        // Translate the result into a string.\n        var str = LEADER.repeat(zeroes);\n        for(; it2 < size; ++it2){\n            str += ALPHABET.charAt(b58[it2]);\n        }\n        return str;\n    }\n    function decodeUnsafe(source) {\n        if (typeof source !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n        if (source.length === 0) {\n            return new Uint8Array();\n        }\n        var psz = 0;\n        // Skip and count leading '1's.\n        var zeroes = 0;\n        var length = 0;\n        while(source[psz] === LEADER){\n            zeroes++;\n            psz++;\n        }\n        // Allocate enough space in big-endian base256 representation.\n        var size = (source.length - psz) * FACTOR + 1 >>> 0 // log(58) / log(256), rounded up.\n        ;\n        var b256 = new Uint8Array(size);\n        // Process the characters.\n        while(source[psz]){\n            // Find code of next character\n            var charCode = source.charCodeAt(psz);\n            // Base map can not be indexed using char code\n            if (charCode > 255) {\n                return;\n            }\n            // Decode character\n            var carry = BASE_MAP[charCode];\n            // Invalid character\n            if (carry === 255) {\n                return;\n            }\n            var i = 0;\n            for(var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++){\n                carry += BASE * b256[it3] >>> 0;\n                b256[it3] = carry % 256 >>> 0;\n                carry = carry / 256 >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error(\"Non-zero carry\");\n            }\n            length = i;\n            psz++;\n        }\n        // Skip leading zeroes in b256.\n        var it4 = size - length;\n        while(it4 !== size && b256[it4] === 0){\n            it4++;\n        }\n        var vch = new Uint8Array(zeroes + (size - it4));\n        var j = zeroes;\n        while(it4 !== size){\n            vch[j++] = b256[it4++];\n        }\n        return vch;\n    }\n    function decode(string) {\n        var buffer = decodeUnsafe(string);\n        if (buffer) {\n            return buffer;\n        }\n        throw new Error(\"Non-base\" + BASE + \" character\");\n    }\n    return {\n        encode: encode,\n        decodeUnsafe: decodeUnsafe,\n        decode: decode\n    };\n}\nmodule.exports = base;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS1tb2JpbGUvbW9iaWxlLXdhbGxldC1hZGFwdGVyLXByb3RvY29sLXdlYjNqcy9ub2RlX21vZHVsZXMvYmFzZS14L3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLDZCQUE2QjtBQUM3Qix5Q0FBeUM7QUFDekMsbUVBQW1FO0FBQ25FLG1FQUFtRTtBQUNuRSxzRUFBc0U7QUFDdEUsU0FBU0EsS0FBTUMsUUFBUTtJQUNyQixJQUFJQSxTQUFTQyxNQUFNLElBQUksS0FBSztRQUFFLE1BQU0sSUFBSUMsVUFBVTtJQUFxQjtJQUN2RSxJQUFJQyxXQUFXLElBQUlDLFdBQVc7SUFDOUIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLFNBQVNGLE1BQU0sRUFBRUksSUFBSztRQUN4Q0YsUUFBUSxDQUFDRSxFQUFFLEdBQUc7SUFDaEI7SUFDQSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSU4sU0FBU0MsTUFBTSxFQUFFSyxJQUFLO1FBQ3hDLElBQUlDLElBQUlQLFNBQVNRLE1BQU0sQ0FBQ0Y7UUFDeEIsSUFBSUcsS0FBS0YsRUFBRUcsVUFBVSxDQUFDO1FBQ3RCLElBQUlQLFFBQVEsQ0FBQ00sR0FBRyxLQUFLLEtBQUs7WUFBRSxNQUFNLElBQUlQLFVBQVVLLElBQUk7UUFBaUI7UUFDckVKLFFBQVEsQ0FBQ00sR0FBRyxHQUFHSDtJQUNqQjtJQUNBLElBQUlLLE9BQU9YLFNBQVNDLE1BQU07SUFDMUIsSUFBSVcsU0FBU1osU0FBU1EsTUFBTSxDQUFDO0lBQzdCLElBQUlLLFNBQVNDLEtBQUtDLEdBQUcsQ0FBQ0osUUFBUUcsS0FBS0MsR0FBRyxDQUFDLEtBQUssbUNBQW1DOztJQUMvRSxJQUFJQyxVQUFVRixLQUFLQyxHQUFHLENBQUMsT0FBT0QsS0FBS0MsR0FBRyxDQUFDSixNQUFNLG1DQUFtQzs7SUFDaEYsU0FBU00sT0FBUUMsTUFBTTtRQUNyQixJQUFJQSxrQkFBa0JkLFlBQVksQ0FDbEMsT0FB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QU87WUFDNUIsSUFBSTFCLElBQUk7WUFDUixJQUFLLElBQUlvQyxNQUFNWixPQUFPLEdBQUcsQ0FBQ0UsVUFBVSxLQUFLMUIsSUFBSUwsTUFBSyxLQUFPeUMsUUFBUSxDQUFDLEdBQUlBLE9BQU9wQyxJQUFLO2dCQUNoRjBCLFNBQVMsT0FBUVEsSUFBSSxDQUFDRSxJQUFJLEtBQU07Z0JBQ2hDRixJQUFJLENBQUNFLElBQUksR0FBRyxRQUFTLFFBQVM7Z0JBQzlCVixRQUFRLFFBQVMsUUFBUztZQUM1QjtZQUNBLElBQUlBLFVBQVUsR0FBRztnQkFBRSxNQUFNLElBQUlFLE1BQU07WUFBa0I7WUFDckRqQyxTQUFTSztZQUNUaUM7UUFDRjtRQUNJLCtCQUErQjtRQUNuQyxJQUFJSSxNQUFNYixPQUFPN0I7UUFDakIsTUFBTzBDLFFBQVFiLFFBQVFVLElBQUksQ0FBQ0csSUFBSSxLQUFLLEVBQUc7WUFDdENBO1FBQ0Y7UUFDQSxJQUFJQyxNQUFNLElBQUl4QyxXQUFXdUIsU0FBVUcsQ0FBQUEsT0FBT2EsR0FBRTtRQUM1QyxJQUFJdEMsSUFBSXNCO1FBQ1IsTUFBT2dCLFFBQVFiLEtBQU07WUFDbkJjLEdBQUcsQ0FBQ3ZDLElBQUksR0FBR21DLElBQUksQ0FBQ0csTUFBTTtRQUN4QjtRQUNBLE9BQU9DO0lBQ1Q7SUFDQSxTQUFTQyxPQUFRQyxNQUFNO1FBQ3JCLElBQUl6QixTQUFTaUIsYUFBYVE7UUFDMUIsSUFBSXpCLFFBQVE7WUFBRSxPQUFPQTtRQUFPO1FBQzVCLE1BQU0sSUFBSWEsTUFBTSxhQUFhdkIsT0FBTztJQUN0QztJQUNBLE9BQU87UUFDTE0sUUFBUUE7UUFDUnFCLGNBQWNBO1FBQ2RPLFFBQVFBO0lBQ1Y7QUFDRjtBQUNBRSxPQUFPQyxPQUFPLEdBQUdqRCIsInNvdXJjZXMiOlsid2VicGFjazovL3NvbGFuYS1saXF1aWRpdHktcG9vbC8uL25vZGVfbW9kdWxlcy9Ac29sYW5hLW1vYmlsZS9tb2JpbGUtd2FsbGV0LWFkYXB0ZXItcHJvdG9jb2wtd2ViM2pzL25vZGVfbW9kdWxlcy9iYXNlLXgvc3JjL2luZGV4LmpzP2UxZGMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG4vLyBiYXNlLXggZW5jb2RpbmcgLyBkZWNvZGluZ1xuLy8gQ29weXJpZ2h0IChjKSAyMDE4IGJhc2UteCBjb250cmlidXRvcnNcbi8vIENvcHlyaWdodCAoYykgMjAxNC0yMDE4IFRoZSBCaXRjb2luIENvcmUgZGV2ZWxvcGVycyAoYmFzZTU4LmNwcClcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgc29mdHdhcmUgbGljZW5zZSwgc2VlIHRoZSBhY2NvbXBhbnlpbmdcbi8vIGZpbGUgTElDRU5TRSBvciBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocC5cbmZ1bmN0aW9uIGJhc2UgKEFMUEhBQkVUKSB7XG4gIGlmIChBTFBIQUJFVC5sZW5ndGggPj0gMjU1KSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscGhhYmV0IHRvbyBsb25nJykgfVxuICB2YXIgQkFTRV9NQVAgPSBuZXcgVWludDhBcnJheSgyNTYpXG4gIGZvciAodmFyIGogPSAwOyBqIDwgQkFTRV9NQVAubGVuZ3RoOyBqKyspIHtcbiAgICBCQVNFX01BUFtqXSA9IDI1NVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgQUxQSEFCRVQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgeCA9IEFMUEhBQkVULmNoYXJBdChpKVxuICAgIHZhciB4YyA9IHguY2hhckNvZGVBdCgwKVxuICAgIGlmIChCQVNFX01BUFt4Y10gIT09IDI1NSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKHggKyAnIGlzIGFtYmlndW91cycpIH1cbiAgICBCQVNFX01BUFt4Y10gPSBpXG4gIH1cbiAgdmFyIEJBU0UgPSBBTFBIQUJFVC5sZW5ndGhcbiAgdmFyIExFQURFUiA9IEFMUEhBQkVULmNoYXJBdCgwKVxuICB2YXIgRkFDVE9SID0gTWF0aC5sb2coQkFTRSkgLyBNYXRoLmxvZygyNTYpIC8vIGxvZyhCQVNFKSAvIGxvZygyNTYpLCByb3VuZGVkIHVwXG4gIHZhciBpRkFDVE9SID0gTWF0aC5sb2coMjU2KSAvIE1hdGgubG9nKEJBU0UpIC8vIGxvZygyNTYpIC8gbG9nKEJBU0UpLCByb3VuZGVkIHVwXG4gIGZ1bmN0aW9uIGVuY29kZSAoc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzb3VyY2UpKSB7XG4gICAgICBzb3VyY2UgPSBuZXcgVWludDhBcnJheShzb3VyY2UuYnVmZmVyLCBzb3VyY2UuYnl0ZU9mZnNldCwgc291cmNlLmJ5dGVMZW5ndGgpXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgIHNvdXJjZSA9IFVpbnQ4QXJyYXkuZnJvbShzb3VyY2UpXG4gICAgfVxuICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFVpbnQ4QXJyYXknKSB9XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHsgcmV0dXJuICcnIH1cbiAgICAgICAgLy8gU2tpcCAmIGNvdW50IGxlYWRpbmcgemVyb2VzLlxuICAgIHZhciB6ZXJvZXMgPSAwXG4gICAgdmFyIGxlbmd0aCA9IDBcbiAgICB2YXIgcGJlZ2luID0gMFxuICAgIHZhciBwZW5kID0gc291cmNlLmxlbmd0aFxuICAgIHdoaWxlIChwYmVnaW4gIT09IHBlbmQgJiYgc291cmNlW3BiZWdpbl0gPT09IDApIHtcbiAgICAgIHBiZWdpbisrXG4gICAgICB6ZXJvZXMrK1xuICAgIH1cbiAgICAgICAgLy8gQWxsb2NhdGUgZW5vdWdoIHNwYWNlIGluIGJpZy1lbmRpYW4gYmFzZTU4IHJlcHJlc2VudGF0aW9uLlxuICAgIHZhciBzaXplID0gKChwZW5kIC0gcGJlZ2luKSAqIGlGQUNUT1IgKyAxKSA+Pj4gMFxuICAgIHZhciBiNTggPSBuZXcgVWludDhBcnJheShzaXplKVxuICAgICAgICAvLyBQcm9jZXNzIHRoZSBieXRlcy5cbiAgICB3aGlsZSAocGJlZ2luICE9PSBwZW5kKSB7XG4gICAgICB2YXIgY2FycnkgPSBzb3VyY2VbcGJlZ2luXVxuICAgICAgICAgICAgLy8gQXBwbHkgXCJiNTggPSBiNTggKiAyNTYgKyBjaFwiLlxuICAgICAgdmFyIGkgPSAwXG4gICAgICBmb3IgKHZhciBpdDEgPSBzaXplIC0gMTsgKGNhcnJ5ICE9PSAwIHx8IGkgPCBsZW5ndGgpICYmIChpdDEgIT09IC0xKTsgaXQxLS0sIGkrKykge1xuICAgICAgICBjYXJyeSArPSAoMjU2ICogYjU4W2l0MV0pID4+PiAwXG4gICAgICAgIGI1OFtpdDFdID0gKGNhcnJ5ICUgQkFTRSkgPj4+IDBcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyBCQVNFKSA+Pj4gMFxuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7IHRocm93IG5ldyBFcnJvcignTm9uLXplcm8gY2FycnknKSB9XG4gICAgICBsZW5ndGggPSBpXG4gICAgICBwYmVnaW4rK1xuICAgIH1cbiAgICAgICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lcyBpbiBiYXNlNTggcmVzdWx0LlxuICAgIHZhciBpdDIgPSBzaXplIC0gbGVuZ3RoXG4gICAgd2hpbGUgKGl0MiAhPT0gc2l6ZSAmJiBiNThbaXQyXSA9PT0gMCkge1xuICAgICAgaXQyKytcbiAgICB9XG4gICAgICAgIC8vIFRyYW5zbGF0ZSB0aGUgcmVzdWx0IGludG8gYSBzdHJpbmcuXG4gICAgdmFyIHN0ciA9IExFQURFUi5yZXBlYXQoemVyb2VzKVxuICAgIGZvciAoOyBpdDIgPCBzaXplOyArK2l0MikgeyBzdHIgKz0gQUxQSEFCRVQuY2hhckF0KGI1OFtpdDJdKSB9XG4gICAgcmV0dXJuIHN0clxuICB9XG4gIGZ1bmN0aW9uIGRlY29kZVVuc2FmZSAoc291cmNlKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdzdHJpbmcnKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFN0cmluZycpIH1cbiAgICBpZiAoc291cmNlLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoKSB9XG4gICAgdmFyIHBzeiA9IDBcbiAgICAgICAgLy8gU2tpcCBhbmQgY291bnQgbGVhZGluZyAnMSdzLlxuICAgIHZhciB6ZXJvZXMgPSAwXG4gICAgdmFyIGxlbmd0aCA9IDBcbiAgICB3aGlsZSAoc291cmNlW3Bzel0gPT09IExFQURFUikge1xuICAgICAgemVyb2VzKytcbiAgICAgIHBzeisrXG4gICAgfVxuICAgICAgICAvLyBBbGxvY2F0ZSBlbm91Z2ggc3BhY2UgaW4gYmlnLWVuZGlhbiBiYXNlMjU2IHJlcHJlc2VudGF0aW9uLlxuICAgIHZhciBzaXplID0gKCgoc291cmNlLmxlbmd0aCAtIHBzeikgKiBGQUNUT1IpICsgMSkgPj4+IDAgLy8gbG9nKDU4KSAvIGxvZygyNTYpLCByb3VuZGVkIHVwLlxuICAgIHZhciBiMjU2ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSlcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgY2hhcmFjdGVycy5cbiAgICB3aGlsZSAoc291cmNlW3Bzel0pIHtcbiAgICAgICAgICAgIC8vIEZpbmQgY29kZSBvZiBuZXh0IGNoYXJhY3RlclxuICAgICAgdmFyIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocHN6KVxuICAgICAgICAgICAgLy8gQmFzZSBtYXAgY2FuIG5vdCBiZSBpbmRleGVkIHVzaW5nIGNoYXIgY29kZVxuICAgICAgaWYgKGNoYXJDb2RlID4gMjU1KSB7IHJldHVybiB9XG4gICAgICAgICAgICAvLyBEZWNvZGUgY2hhcmFjdGVyXG4gICAgICB2YXIgY2FycnkgPSBCQVNFX01BUFtjaGFyQ29kZV1cbiAgICAgICAgICAgIC8vIEludmFsaWQgY2hhcmFjdGVyXG4gICAgICBpZiAoY2FycnkgPT09IDI1NSkgeyByZXR1cm4gfVxuICAgICAgdmFyIGkgPSAwXG4gICAgICBmb3IgKHZhciBpdDMgPSBzaXplIC0gMTsgKGNhcnJ5ICE9PSAwIHx8IGkgPCBsZW5ndGgpICYmIChpdDMgIT09IC0xKTsgaXQzLS0sIGkrKykge1xuICAgICAgICBjYXJyeSArPSAoQkFTRSAqIGIyNTZbaXQzXSkgPj4+IDBcbiAgICAgICAgYjI1NltpdDNdID0gKGNhcnJ5ICUgMjU2KSA+Pj4gMFxuICAgICAgICBjYXJyeSA9IChjYXJyeSAvIDI1NikgPj4+IDBcbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoJ05vbi16ZXJvIGNhcnJ5JykgfVxuICAgICAgbGVuZ3RoID0gaVxuICAgICAgcHN6KytcbiAgICB9XG4gICAgICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXMgaW4gYjI1Ni5cbiAgICB2YXIgaXQ0ID0gc2l6ZSAtIGxlbmd0aFxuICAgIHdoaWxlIChpdDQgIT09IHNpemUgJiYgYjI1NltpdDRdID09PSAwKSB7XG4gICAgICBpdDQrK1xuICAgIH1cbiAgICB2YXIgdmNoID0gbmV3IFVpbnQ4QXJyYXkoemVyb2VzICsgKHNpemUgLSBpdDQpKVxuICAgIHZhciBqID0gemVyb2VzXG4gICAgd2hpbGUgKGl0NCAhPT0gc2l6ZSkge1xuICAgICAgdmNoW2orK10gPSBiMjU2W2l0NCsrXVxuICAgIH1cbiAgICByZXR1cm4gdmNoXG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlIChzdHJpbmcpIHtcbiAgICB2YXIgYnVmZmVyID0gZGVjb2RlVW5zYWZlKHN0cmluZylcbiAgICBpZiAoYnVmZmVyKSB7IHJldHVybiBidWZmZXIgfVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uLWJhc2UnICsgQkFTRSArICcgY2hhcmFjdGVyJylcbiAgfVxuICByZXR1cm4ge1xuICAgIGVuY29kZTogZW5jb2RlLFxuICAgIGRlY29kZVVuc2FmZTogZGVjb2RlVW5zYWZlLFxuICAgIGRlY29kZTogZGVjb2RlXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gYmFzZVxuIl0sIm5hbWVzIjpbImJhc2UiLCJBTFBIQUJFVCIsImxlbmd0aCIsIlR5cGVFcnJvciIsIkJBU0VfTUFQIiwiVWludDhBcnJheSIsImoiLCJpIiwieCIsImNoYXJBdCIsInhjIiwiY2hhckNvZGVBdCIsIkJBU0UiLCJMRUFERVIiLCJGQUNUT1IiLCJNYXRoIiwibG9nIiwiaUZBQ1RPUiIsImVuY29kZSIsInNvdXJjZSIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJBcnJheSIsImlzQXJyYXkiLCJmcm9tIiwiemVyb2VzIiwicGJlZ2luIiwicGVuZCIsInNpemUiLCJiNTgiLCJjYXJyeSIsIml0MSIsIkVycm9yIiwiaXQyIiwic3RyIiwicmVwZWF0IiwiZGVjb2RlVW5zYWZlIiwicHN6IiwiYjI1NiIsImNoYXJDb2RlIiwiaXQzIiwiaXQ0IiwidmNoIiwiZGVjb2RlIiwic3RyaW5nIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana-mobile/mobile-wallet-adapter-protocol-web3js/node_modules/base-x/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana-mobile/mobile-wallet-adapter-protocol-web3js/node_modules/bs58/index.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@solana-mobile/mobile-wallet-adapter-protocol-web3js/node_modules/bs58/index.js ***!
  \******************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst basex = __webpack_require__(/*! base-x */ \"(ssr)/./node_modules/@solana-mobile/mobile-wallet-adapter-protocol-web3js/node_modules/base-x/src/index.js\");\nconst ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nmodule.exports = basex(ALPHABET);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS1tb2JpbGUvbW9iaWxlLXdhbGxldC1hZGFwdGVyLXByb3RvY29sLXdlYjNqcy9ub2RlX21vZHVsZXMvYnM1OC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDdEIsTUFBTUMsV0FBVztBQUVqQkMsT0FBT0MsT0FBTyxHQUFHSixNQUFNRSIsInNvdXJjZXMiOlsid2VicGFjazovL3NvbGFuYS1saXF1aWRpdHktcG9vbC8uL25vZGVfbW9kdWxlcy9Ac29sYW5hLW1vYmlsZS9tb2JpbGUtd2FsbGV0LWFkYXB0ZXItcHJvdG9jb2wtd2ViM2pzL25vZGVfbW9kdWxlcy9iczU4L2luZGV4LmpzPzczNWUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgYmFzZXggPSByZXF1aXJlKCdiYXNlLXgnKVxuY29uc3QgQUxQSEFCRVQgPSAnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eidcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNleChBTFBIQUJFVClcbiJdLCJuYW1lcyI6WyJiYXNleCIsInJlcXVpcmUiLCJBTFBIQUJFVCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana-mobile/mobile-wallet-adapter-protocol-web3js/node_modules/bs58/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana-mobile/mobile-wallet-adapter-protocol-web3js/lib/esm/index.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@solana-mobile/mobile-wallet-adapter-protocol-web3js/lib/esm/index.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   transact: () => (/* binding */ transact),\n/* harmony export */   transactRemote: () => (/* binding */ transactRemote)\n/* harmony export */ });\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/./node_modules/@solana/web3.js/lib/index.esm.js\");\n/* harmony import */ var _solana_mobile_mobile_wallet_adapter_protocol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana-mobile/mobile-wallet-adapter-protocol */ \"(ssr)/./node_modules/@solana-mobile/mobile-wallet-adapter-protocol/lib/esm/index.js\");\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bs58 */ \"(ssr)/./node_modules/@solana-mobile/mobile-wallet-adapter-protocol-web3js/node_modules/bs58/index.js\");\n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ function __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nfunction __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction fromUint8Array(byteArray) {\n    return window.btoa(String.fromCharCode.call(null, ...byteArray));\n}\nfunction toUint8Array(base64EncodedByteArray) {\n    return new Uint8Array(window.atob(base64EncodedByteArray).split(\"\").map((c)=>c.charCodeAt(0)));\n}\nfunction getPayloadFromTransaction(transaction) {\n    const serializedTransaction = \"version\" in transaction ? transaction.serialize() : transaction.serialize({\n        requireAllSignatures: false,\n        verifySignatures: false\n    });\n    const payload = fromUint8Array(serializedTransaction);\n    return payload;\n}\nfunction getTransactionFromWireMessage(byteArray) {\n    const numSignatures = byteArray[0];\n    const messageOffset = numSignatures * _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.SIGNATURE_LENGTH_IN_BYTES + 1;\n    const version = _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.VersionedMessage.deserializeMessageVersion(byteArray.slice(messageOffset, byteArray.length));\n    if (version === \"legacy\") {\n        return _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction.from(byteArray);\n    } else {\n        return _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.VersionedTransaction.deserialize(byteArray);\n    }\n}\nfunction transact(callback, config) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const augmentedCallback = (wallet)=>{\n            const augmentedAPI = new Proxy({}, {\n                get (target, p) {\n                    if (target[p] == null) {\n                        switch(p){\n                            case \"signAndSendTransactions\":\n                                target[p] = function(_a) {\n                                    var { minContextSlot, commitment, skipPreflight, maxRetries, waitForCommitmentToSendNextTransaction, transactions } = _a, rest = __rest(_a, [\n                                        \"minContextSlot\",\n                                        \"commitment\",\n                                        \"skipPreflight\",\n                                        \"maxRetries\",\n                                        \"waitForCommitmentToSendNextTransaction\",\n                                        \"transactions\"\n                                    ]);\n                                    return __awaiter(this, void 0, void 0, function*() {\n                                        const payloads = transactions.map(getPayloadFromTransaction);\n                                        const options = {\n                                            min_context_slot: minContextSlot,\n                                            commitment: commitment,\n                                            skip_preflight: skipPreflight,\n                                            max_retries: maxRetries,\n                                            wait_for_commitment_to_send_next_transaction: waitForCommitmentToSendNextTransaction\n                                        };\n                                        const { signatures: base64EncodedSignatures } = yield wallet.signAndSendTransactions(Object.assign(Object.assign(Object.assign({}, rest), Object.values(options).some((element)=>element != null) ? {\n                                            options: options\n                                        } : null), {\n                                            payloads\n                                        }));\n                                        const signatures = base64EncodedSignatures.map(toUint8Array).map(bs58__WEBPACK_IMPORTED_MODULE_2__.encode);\n                                        return signatures;\n                                    });\n                                };\n                                break;\n                            case \"signMessages\":\n                                target[p] = function(_a) {\n                                    var { payloads } = _a, rest = __rest(_a, [\n                                        \"payloads\"\n                                    ]);\n                                    return __awaiter(this, void 0, void 0, function*() {\n                                        const base64EncodedPayloads = payloads.map(fromUint8Array);\n                                        const { signed_payloads: base64EncodedSignedMessages } = yield wallet.signMessages(Object.assign(Object.assign({}, rest), {\n                                            payloads: base64EncodedPayloads\n                                        }));\n                                        const signedMessages = base64EncodedSignedMessages.map(toUint8Array);\n                                        return signedMessages;\n                                    });\n                                };\n                                break;\n                            case \"signTransactions\":\n                                target[p] = function(_a) {\n                                    var { transactions } = _a, rest = __rest(_a, [\n                                        \"transactions\"\n                                    ]);\n                                    return __awaiter(this, void 0, void 0, function*() {\n                                        const payloads = transactions.map(getPayloadFromTransaction);\n                                        const { signed_payloads: base64EncodedCompiledTransactions } = yield wallet.signTransactions(Object.assign(Object.assign({}, rest), {\n                                            payloads\n                                        }));\n                                        const compiledTransactions = base64EncodedCompiledTransactions.map(toUint8Array);\n                                        const signedTransactions = compiledTransactions.map(getTransactionFromWireMessage);\n                                        return signedTransactions;\n                                    });\n                                };\n                                break;\n                            default:\n                                {\n                                    target[p] = wallet[p];\n                                    break;\n                                }\n                        }\n                    }\n                    return target[p];\n                },\n                defineProperty () {\n                    return false;\n                },\n                deleteProperty () {\n                    return false;\n                }\n            });\n            return callback(augmentedAPI);\n        };\n        return yield (0,_solana_mobile_mobile_wallet_adapter_protocol__WEBPACK_IMPORTED_MODULE_1__.transact)(augmentedCallback, config);\n    });\n}\nfunction transactRemote(callback, config) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const augmentedCallback = (wallet)=>{\n            const augmentedAPI = new Proxy({}, {\n                get (target, p) {\n                    if (target[p] == null) {\n                        switch(p){\n                            case \"signAndSendTransactions\":\n                                target[p] = function(_a) {\n                                    var { minContextSlot, commitment, skipPreflight, maxRetries, waitForCommitmentToSendNextTransaction, transactions } = _a, rest = __rest(_a, [\n                                        \"minContextSlot\",\n                                        \"commitment\",\n                                        \"skipPreflight\",\n                                        \"maxRetries\",\n                                        \"waitForCommitmentToSendNextTransaction\",\n                                        \"transactions\"\n                                    ]);\n                                    return __awaiter(this, void 0, void 0, function*() {\n                                        const payloads = transactions.map(getPayloadFromTransaction);\n                                        const options = {\n                                            min_context_slot: minContextSlot,\n                                            commitment: commitment,\n                                            skip_preflight: skipPreflight,\n                                            max_retries: maxRetries,\n                                            wait_for_commitment_to_send_next_transaction: waitForCommitmentToSendNextTransaction\n                                        };\n                                        const { signatures: base64EncodedSignatures } = yield wallet.signAndSendTransactions(Object.assign(Object.assign(Object.assign({}, rest), Object.values(options).some((element)=>element != null) ? {\n                                            options: options\n                                        } : null), {\n                                            payloads\n                                        }));\n                                        const signatures = base64EncodedSignatures.map(toUint8Array).map(bs58__WEBPACK_IMPORTED_MODULE_2__.encode);\n                                        return signatures;\n                                    });\n                                };\n                                break;\n                            case \"signMessages\":\n                                target[p] = function(_a) {\n                                    var { payloads } = _a, rest = __rest(_a, [\n                                        \"payloads\"\n                                    ]);\n                                    return __awaiter(this, void 0, void 0, function*() {\n                                        const base64EncodedPayloads = payloads.map(fromUint8Array);\n                                        const { signed_payloads: base64EncodedSignedMessages } = yield wallet.signMessages(Object.assign(Object.assign({}, rest), {\n                                            payloads: base64EncodedPayloads\n                                        }));\n                                        const signedMessages = base64EncodedSignedMessages.map(toUint8Array);\n                                        return signedMessages;\n                                    });\n                                };\n                                break;\n                            case \"signTransactions\":\n                                target[p] = function(_a) {\n                                    var { transactions } = _a, rest = __rest(_a, [\n                                        \"transactions\"\n                                    ]);\n                                    return __awaiter(this, void 0, void 0, function*() {\n                                        const payloads = transactions.map(getPayloadFromTransaction);\n                                        const { signed_payloads: base64EncodedCompiledTransactions } = yield wallet.signTransactions(Object.assign(Object.assign({}, rest), {\n                                            payloads\n                                        }));\n                                        const compiledTransactions = base64EncodedCompiledTransactions.map(toUint8Array);\n                                        const signedTransactions = compiledTransactions.map(getTransactionFromWireMessage);\n                                        return signedTransactions;\n                                    });\n                                };\n                                break;\n                            default:\n                                {\n                                    target[p] = wallet[p];\n                                    break;\n                                }\n                        }\n                    }\n                    return target[p];\n                },\n                defineProperty () {\n                    return false;\n                },\n                deleteProperty () {\n                    return false;\n                }\n            });\n            return callback(augmentedAPI);\n        };\n        return yield (0,_solana_mobile_mobile_wallet_adapter_protocol__WEBPACK_IMPORTED_MODULE_1__.transactRemote)(augmentedCallback, config);\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS1tb2JpbGUvbW9iaWxlLXdhbGxldC1hZGFwdGVyLXByb3RvY29sLXdlYjNqcy9saWIvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWlIO0FBQ1U7QUFDbkc7QUFFeEI7Ozs7Ozs7Ozs7Ozs7OEVBYThFLEdBRTlFLFNBQVNTLE9BQU9DLENBQUMsRUFBRUMsQ0FBQztJQUNoQixJQUFJQyxJQUFJLENBQUM7SUFDVCxJQUFLLElBQUlDLEtBQUtILEVBQUcsSUFBSUksT0FBT0MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ1AsR0FBR0csTUFBTUYsRUFBRU8sT0FBTyxDQUFDTCxLQUFLLEdBQzlFRCxDQUFDLENBQUNDLEVBQUUsR0FBR0gsQ0FBQyxDQUFDRyxFQUFFO0lBQ2YsSUFBSUgsS0FBSyxRQUFRLE9BQU9JLE9BQU9LLHFCQUFxQixLQUFLLFlBQ3JELElBQUssSUFBSUMsSUFBSSxHQUFHUCxJQUFJQyxPQUFPSyxxQkFBcUIsQ0FBQ1QsSUFBSVUsSUFBSVAsRUFBRVEsTUFBTSxFQUFFRCxJQUFLO1FBQ3BFLElBQUlULEVBQUVPLE9BQU8sQ0FBQ0wsQ0FBQyxDQUFDTyxFQUFFLElBQUksS0FBS04sT0FBT0MsU0FBUyxDQUFDTyxvQkFBb0IsQ0FBQ0wsSUFBSSxDQUFDUCxHQUFHRyxDQUFDLENBQUNPLEVBQUUsR0FDekVSLENBQUMsQ0FBQ0MsQ0FBQyxDQUFDTyxFQUFFLENBQUMsR0FBR1YsQ0FBQyxDQUFDRyxDQUFDLENBQUNPLEVBQUUsQ0FBQztJQUN6QjtJQUNKLE9BQU9SO0FBQ1g7QUFFQSxTQUFTVyxVQUFVQyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsQ0FBQyxFQUFFQyxTQUFTO0lBQ2hELFNBQVNDLE1BQU1DLEtBQUs7UUFBSSxPQUFPQSxpQkFBaUJILElBQUlHLFFBQVEsSUFBSUgsRUFBRSxTQUFVSSxPQUFPO1lBQUlBLFFBQVFEO1FBQVE7SUFBSTtJQUMzRyxPQUFPLElBQUtI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RDtBQUNKO0FBRW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc29sYW5hLWxpcXVpZGl0eS1wb29sLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEtbW9iaWxlL21vYmlsZS13YWxsZXQtYWRhcHRlci1wcm90b2NvbC13ZWIzanMvbGliL2VzbS9pbmRleC5qcz8wYjY4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZlcnNpb25lZE1lc3NhZ2UsIFRyYW5zYWN0aW9uLCBWZXJzaW9uZWRUcmFuc2FjdGlvbiwgU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUyB9IGZyb20gJ0Bzb2xhbmEvd2ViMy5qcyc7XG5pbXBvcnQgeyB0cmFuc2FjdCBhcyB0cmFuc2FjdCQxLCB0cmFuc2FjdFJlbW90ZSBhcyB0cmFuc2FjdFJlbW90ZSQxIH0gZnJvbSAnQHNvbGFuYS1tb2JpbGUvbW9iaWxlLXdhbGxldC1hZGFwdGVyLXByb3RvY29sJztcbmltcG9ydCBiczU4IGZyb20gJ2JzNTgnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxuXG5mdW5jdGlvbiBmcm9tVWludDhBcnJheShieXRlQXJyYXkpIHtcbiAgICByZXR1cm4gd2luZG93LmJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZS5jYWxsKG51bGwsIC4uLmJ5dGVBcnJheSkpO1xufVxuZnVuY3Rpb24gdG9VaW50OEFycmF5KGJhc2U2NEVuY29kZWRCeXRlQXJyYXkpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkod2luZG93XG4gICAgICAgIC5hdG9iKGJhc2U2NEVuY29kZWRCeXRlQXJyYXkpXG4gICAgICAgIC5zcGxpdCgnJylcbiAgICAgICAgLm1hcCgoYykgPT4gYy5jaGFyQ29kZUF0KDApKSk7XG59XG5cbmZ1bmN0aW9uIGdldFBheWxvYWRGcm9tVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICBjb25zdCBzZXJpYWxpemVkVHJhbnNhY3Rpb24gPSAndmVyc2lvbicgaW4gdHJhbnNhY3Rpb25cbiAgICAgICAgPyB0cmFuc2FjdGlvbi5zZXJpYWxpemUoKVxuICAgICAgICA6IHRyYW5zYWN0aW9uLnNlcmlhbGl6ZSh7XG4gICAgICAgICAgICByZXF1aXJlQWxsU2lnbmF0dXJlczogZmFsc2UsXG4gICAgICAgICAgICB2ZXJpZnlTaWduYXR1cmVzOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgY29uc3QgcGF5bG9hZCA9IGZyb21VaW50OEFycmF5KHNlcmlhbGl6ZWRUcmFuc2FjdGlvbik7XG4gICAgcmV0dXJuIHBheWxvYWQ7XG59XG5mdW5jdGlvbiBnZXRUcmFuc2FjdGlvbkZyb21XaXJlTWVzc2FnZShieXRlQXJyYXkpIHtcbiAgICBjb25zdCBudW1TaWduYXR1cmVzID0gYnl0ZUFycmF5WzBdO1xuICAgIGNvbnN0IG1lc3NhZ2VPZmZzZXQgPSBudW1TaWduYXR1cmVzICogU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUyArIDE7XG4gICAgY29uc3QgdmVyc2lvbiA9IFZlcnNpb25lZE1lc3NhZ2UuZGVzZXJpYWxpemVNZXNzYWdlVmVyc2lvbihieXRlQXJyYXkuc2xpY2UobWVzc2FnZU9mZnNldCwgYnl0ZUFycmF5Lmxlbmd0aCkpO1xuICAgIGlmICh2ZXJzaW9uID09PSAnbGVnYWN5Jykge1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb24uZnJvbShieXRlQXJyYXkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFZlcnNpb25lZFRyYW5zYWN0aW9uLmRlc2VyaWFsaXplKGJ5dGVBcnJheSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdHJhbnNhY3QoY2FsbGJhY2ssIGNvbmZpZykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IGF1Z21lbnRlZENhbGxiYWNrID0gKHdhbGxldCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXVnbWVudGVkQVBJID0gbmV3IFByb3h5KHt9LCB7XG4gICAgICAgICAgICAgICAgZ2V0KHRhcmdldCwgcCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0W3BdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NpZ25BbmRTZW5kVHJhbnNhY3Rpb25zJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W3BdID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeyBtaW5Db250ZXh0U2xvdCwgY29tbWl0bWVudCwgc2tpcFByZWZsaWdodCwgbWF4UmV0cmllcywgd2FpdEZvckNvbW1pdG1lbnRUb1NlbmROZXh0VHJhbnNhY3Rpb24sIHRyYW5zYWN0aW9ucyB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcIm1pbkNvbnRleHRTbG90XCIsIFwiY29tbWl0bWVudFwiLCBcInNraXBQcmVmbGlnaHRcIiwgXCJtYXhSZXRyaWVzXCIsIFwid2FpdEZvckNvbW1pdG1lbnRUb1NlbmROZXh0VHJhbnNhY3Rpb25cIiwgXCJ0cmFuc2FjdGlvbnNcIl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkcyA9IHRyYW5zYWN0aW9ucy5tYXAoZ2V0UGF5bG9hZEZyb21UcmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluX2NvbnRleHRfc2xvdDogbWluQ29udGV4dFNsb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1pdG1lbnQ6IGNvbW1pdG1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBfcHJlZmxpZ2h0OiBza2lwUHJlZmxpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhfcmV0cmllczogbWF4UmV0cmllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FpdF9mb3JfY29tbWl0bWVudF90b19zZW5kX25leHRfdHJhbnNhY3Rpb246IHdhaXRGb3JDb21taXRtZW50VG9TZW5kTmV4dFRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHNpZ25hdHVyZXM6IGJhc2U2NEVuY29kZWRTaWduYXR1cmVzIH0gPSB5aWVsZCB3YWxsZXQuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbnMoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3QpLCAoT2JqZWN0LnZhbHVlcyhvcHRpb25zKS5zb21lKGVsZW1lbnQgPT4gZWxlbWVudCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHsgb3B0aW9uczogb3B0aW9ucyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCkpLCB7IHBheWxvYWRzIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWduYXR1cmVzID0gYmFzZTY0RW5jb2RlZFNpZ25hdHVyZXMubWFwKHRvVWludDhBcnJheSkubWFwKGJzNTguZW5jb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmF0dXJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzaWduTWVzc2FnZXMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbcF0gPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB7IHBheWxvYWRzIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1wicGF5bG9hZHNcIl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiYXNlNjRFbmNvZGVkUGF5bG9hZHMgPSBwYXlsb2Fkcy5tYXAoZnJvbVVpbnQ4QXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2lnbmVkX3BheWxvYWRzOiBiYXNlNjRFbmNvZGVkU2lnbmVkTWVzc2FnZXMgfSA9IHlpZWxkIHdhbGxldC5zaWduTWVzc2FnZXMoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXN0KSwgeyBwYXlsb2FkczogYmFzZTY0RW5jb2RlZFBheWxvYWRzIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWduZWRNZXNzYWdlcyA9IGJhc2U2NEVuY29kZWRTaWduZWRNZXNzYWdlcy5tYXAodG9VaW50OEFycmF5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmVkTWVzc2FnZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2lnblRyYW5zYWN0aW9ucyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtwXSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHsgdHJhbnNhY3Rpb25zIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1widHJhbnNhY3Rpb25zXCJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF5bG9hZHMgPSB0cmFuc2FjdGlvbnMubWFwKGdldFBheWxvYWRGcm9tVHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2lnbmVkX3BheWxvYWRzOiBiYXNlNjRFbmNvZGVkQ29tcGlsZWRUcmFuc2FjdGlvbnMgfSA9IHlpZWxkIHdhbGxldC5zaWduVHJhbnNhY3Rpb25zKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzdCksIHsgcGF5bG9hZHMgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBpbGVkVHJhbnNhY3Rpb25zID0gYmFzZTY0RW5jb2RlZENvbXBpbGVkVHJhbnNhY3Rpb25zLm1hcCh0b1VpbnQ4QXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9ucyA9IGNvbXBpbGVkVHJhbnNhY3Rpb25zLm1hcChnZXRUcmFuc2FjdGlvbkZyb21XaXJlTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25lZFRyYW5zYWN0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtwXSA9IHdhbGxldFtwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRbcF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVsZXRlUHJvcGVydHkoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soYXVnbWVudGVkQVBJKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHlpZWxkIHRyYW5zYWN0JDEoYXVnbWVudGVkQ2FsbGJhY2ssIGNvbmZpZyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB0cmFuc2FjdFJlbW90ZShjYWxsYmFjaywgY29uZmlnKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgYXVnbWVudGVkQ2FsbGJhY2sgPSAod2FsbGV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhdWdtZW50ZWRBUEkgPSBuZXcgUHJveHkoe30sIHtcbiAgICAgICAgICAgICAgICBnZXQodGFyZ2V0LCBwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRbcF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2lnbkFuZFNlbmRUcmFuc2FjdGlvbnMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbcF0gPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB7IG1pbkNvbnRleHRTbG90LCBjb21taXRtZW50LCBza2lwUHJlZmxpZ2h0LCBtYXhSZXRyaWVzLCB3YWl0Rm9yQ29tbWl0bWVudFRvU2VuZE5leHRUcmFuc2FjdGlvbiwgdHJhbnNhY3Rpb25zIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1wibWluQ29udGV4dFNsb3RcIiwgXCJjb21taXRtZW50XCIsIFwic2tpcFByZWZsaWdodFwiLCBcIm1heFJldHJpZXNcIiwgXCJ3YWl0Rm9yQ29tbWl0bWVudFRvU2VuZE5leHRUcmFuc2FjdGlvblwiLCBcInRyYW5zYWN0aW9uc1wiXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWRzID0gdHJhbnNhY3Rpb25zLm1hcChnZXRQYXlsb2FkRnJvbVRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5fY29udGV4dF9zbG90OiBtaW5Db250ZXh0U2xvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWl0bWVudDogY29tbWl0bWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcF9wcmVmbGlnaHQ6IHNraXBQcmVmbGlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heF9yZXRyaWVzOiBtYXhSZXRyaWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YWl0X2Zvcl9jb21taXRtZW50X3RvX3NlbmRfbmV4dF90cmFuc2FjdGlvbjogd2FpdEZvckNvbW1pdG1lbnRUb1NlbmROZXh0VHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2lnbmF0dXJlczogYmFzZTY0RW5jb2RlZFNpZ25hdHVyZXMgfSA9IHlpZWxkIHdhbGxldC5zaWduQW5kU2VuZFRyYW5zYWN0aW9ucyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzdCksIChPYmplY3QudmFsdWVzKG9wdGlvbnMpLnNvbWUoZWxlbWVudCA9PiBlbGVtZW50ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8geyBvcHRpb25zOiBvcHRpb25zIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsKSksIHsgcGF5bG9hZHMgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZXMgPSBiYXNlNjRFbmNvZGVkU2lnbmF0dXJlcy5tYXAodG9VaW50OEFycmF5KS5tYXAoYnM1OC5lbmNvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWduYXR1cmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NpZ25NZXNzYWdlcyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtwXSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHsgcGF5bG9hZHMgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJwYXlsb2Fkc1wiXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhc2U2NEVuY29kZWRQYXlsb2FkcyA9IHBheWxvYWRzLm1hcChmcm9tVWludDhBcnJheSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzaWduZWRfcGF5bG9hZHM6IGJhc2U2NEVuY29kZWRTaWduZWRNZXNzYWdlcyB9ID0geWllbGQgd2FsbGV0LnNpZ25NZXNzYWdlcyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3QpLCB7IHBheWxvYWRzOiBiYXNlNjRFbmNvZGVkUGF5bG9hZHMgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25lZE1lc3NhZ2VzID0gYmFzZTY0RW5jb2RlZFNpZ25lZE1lc3NhZ2VzLm1hcCh0b1VpbnQ4QXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWduZWRNZXNzYWdlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzaWduVHJhbnNhY3Rpb25zJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W3BdID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeyB0cmFuc2FjdGlvbnMgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJ0cmFuc2FjdGlvbnNcIl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkcyA9IHRyYW5zYWN0aW9ucy5tYXAoZ2V0UGF5bG9hZEZyb21UcmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzaWduZWRfcGF5bG9hZHM6IGJhc2U2NEVuY29kZWRDb21waWxlZFRyYW5zYWN0aW9ucyB9ID0geWllbGQgd2FsbGV0LnNpZ25UcmFuc2FjdGlvbnMoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXN0KSwgeyBwYXlsb2FkcyB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcGlsZWRUcmFuc2FjdGlvbnMgPSBiYXNlNjRFbmNvZGVkQ29tcGlsZWRUcmFuc2FjdGlvbnMubWFwKHRvVWludDhBcnJheSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2lnbmVkVHJhbnNhY3Rpb25zID0gY29tcGlsZWRUcmFuc2FjdGlvbnMubWFwKGdldFRyYW5zYWN0aW9uRnJvbVdpcmVNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmVkVHJhbnNhY3Rpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W3BdID0gd2FsbGV0W3BdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkZWxldGVQcm9wZXJ0eSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhhdWdtZW50ZWRBUEkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4geWllbGQgdHJhbnNhY3RSZW1vdGUkMShhdWdtZW50ZWRDYWxsYmFjaywgY29uZmlnKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IHsgdHJhbnNhY3QsIHRyYW5zYWN0UmVtb3RlIH07XG4iXSwibmFtZXMiOlsiVmVyc2lvbmVkTWVzc2FnZSIsIlRyYW5zYWN0aW9uIiwiVmVyc2lvbmVkVHJhbnNhY3Rpb24iLCJTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTIiwidHJhbnNhY3QiLCJ0cmFuc2FjdCQxIiwidHJhbnNhY3RSZW1vdGUiLCJ0cmFuc2FjdFJlbW90ZSQxIiwiYnM1OCIsIl9fcmVzdCIsInMiLCJlIiwidCIsInAiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpbmRleE9mIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiaSIsImxlbmd0aCIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJ2YWx1ZSIsInJlc29sdmUiLCJQcm9taXNlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwic3RlcCIsIm5leHQiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJmcm9tVWludDhBcnJheSIsImJ5dGVBcnJheSIsIndpbmRvdyIsImJ0b2EiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJ0b1VpbnQ4QXJyYXkiLCJiYXNlNjRFbmNvZGVkQnl0ZUFycmF5IiwiVWludDhBcnJheSIsImF0b2IiLCJzcGxpdCIsIm1hcCIsImMiLCJjaGFyQ29kZUF0IiwiZ2V0UGF5bG9hZEZyb21UcmFuc2FjdGlvbiIsInRyYW5zYWN0aW9uIiwic2VyaWFsaXplZFRyYW5zYWN0aW9uIiwic2VyaWFsaXplIiwicmVxdWlyZUFsbFNpZ25hdHVyZXMiLCJ2ZXJpZnlTaWduYXR1cmVzIiwicGF5bG9hZCIsImdldFRyYW5zYWN0aW9uRnJvbVdpcmVNZXNzYWdlIiwibnVtU2lnbmF0dXJlcyIsIm1lc3NhZ2VPZmZzZXQiLCJ2ZXJzaW9uIiwiZGVzZXJpYWxpemVNZXNzYWdlVmVyc2lvbiIsInNsaWNlIiwiZnJvbSIsImRlc2VyaWFsaXplIiwiY2FsbGJhY2siLCJjb25maWciLCJhdWdtZW50ZWRDYWxsYmFjayIsIndhbGxldCIsImF1Z21lbnRlZEFQSSIsIlByb3h5IiwiZ2V0IiwidGFyZ2V0IiwiX2EiLCJtaW5Db250ZXh0U2xvdCIsImNvbW1pdG1lbnQiLCJza2lwUHJlZmxpZ2h0IiwibWF4UmV0cmllcyIsIndhaXRGb3JDb21taXRtZW50VG9TZW5kTmV4dFRyYW5zYWN0aW9uIiwidHJhbnNhY3Rpb25zIiwicmVzdCIsInBheWxvYWRzIiwib3B0aW9ucyIsIm1pbl9jb250ZXh0X3Nsb3QiLCJza2lwX3ByZWZsaWdodCIsIm1heF9yZXRyaWVzIiwid2FpdF9mb3JfY29tbWl0bWVudF90b19zZW5kX25leHRfdHJhbnNhY3Rpb24iLCJzaWduYXR1cmVzIiwiYmFzZTY0RW5jb2RlZFNpZ25hdHVyZXMiLCJzaWduQW5kU2VuZFRyYW5zYWN0aW9ucyIsImFzc2lnbiIsInZhbHVlcyIsInNvbWUiLCJlbGVtZW50IiwiZW5jb2RlIiwiYmFzZTY0RW5jb2RlZFBheWxvYWRzIiwic2lnbmVkX3BheWxvYWRzIiwiYmFzZTY0RW5jb2RlZFNpZ25lZE1lc3NhZ2VzIiwic2lnbk1lc3NhZ2VzIiwic2lnbmVkTWVzc2FnZXMiLCJiYXNlNjRFbmNvZGVkQ29tcGlsZWRUcmFuc2FjdGlvbnMiLCJzaWduVHJhbnNhY3Rpb25zIiwiY29tcGlsZWRUcmFuc2FjdGlvbnMiLCJzaWduZWRUcmFuc2FjdGlvbnMiLCJkZWZpbmVQcm9wZXJ0eSIsImRlbGV0ZVByb3BlcnR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana-mobile/mobile-wallet-adapter-protocol-web3js/lib/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana-mobile/mobile-wallet-adapter-protocol/lib/esm/index.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@solana-mobile/mobile-wallet-adapter-protocol/lib/esm/index.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolanaCloneAuthorization: () => (/* binding */ SolanaCloneAuthorization),\n/* harmony export */   SolanaMobileWalletAdapterError: () => (/* binding */ SolanaMobileWalletAdapterError),\n/* harmony export */   SolanaMobileWalletAdapterErrorCode: () => (/* binding */ SolanaMobileWalletAdapterErrorCode),\n/* harmony export */   SolanaMobileWalletAdapterProtocolError: () => (/* binding */ SolanaMobileWalletAdapterProtocolError),\n/* harmony export */   SolanaMobileWalletAdapterProtocolErrorCode: () => (/* binding */ SolanaMobileWalletAdapterProtocolErrorCode),\n/* harmony export */   SolanaSignInWithSolana: () => (/* binding */ SolanaSignInWithSolana),\n/* harmony export */   SolanaSignTransactions: () => (/* binding */ SolanaSignTransactions),\n/* harmony export */   transact: () => (/* binding */ transact),\n/* harmony export */   transactRemote: () => (/* binding */ transactRemote)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_standard_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/wallet-standard-util */ \"(ssr)/./node_modules/@solana/wallet-standard-util/lib/esm/signIn.js\");\n\n// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/\nconst SolanaMobileWalletAdapterErrorCode = {\n    ERROR_ASSOCIATION_PORT_OUT_OF_RANGE: \"ERROR_ASSOCIATION_PORT_OUT_OF_RANGE\",\n    ERROR_REFLECTOR_ID_OUT_OF_RANGE: \"ERROR_REFLECTOR_ID_OUT_OF_RANGE\",\n    ERROR_FORBIDDEN_WALLET_BASE_URL: \"ERROR_FORBIDDEN_WALLET_BASE_URL\",\n    ERROR_SECURE_CONTEXT_REQUIRED: \"ERROR_SECURE_CONTEXT_REQUIRED\",\n    ERROR_SESSION_CLOSED: \"ERROR_SESSION_CLOSED\",\n    ERROR_SESSION_TIMEOUT: \"ERROR_SESSION_TIMEOUT\",\n    ERROR_WALLET_NOT_FOUND: \"ERROR_WALLET_NOT_FOUND\",\n    ERROR_INVALID_PROTOCOL_VERSION: \"ERROR_INVALID_PROTOCOL_VERSION\"\n};\nclass SolanaMobileWalletAdapterError extends Error {\n    constructor(...args){\n        const [code, message, data] = args;\n        super(message);\n        this.code = code;\n        this.data = data;\n        this.name = \"SolanaMobileWalletAdapterError\";\n    }\n}\n// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/\nconst SolanaMobileWalletAdapterProtocolErrorCode = {\n    // Keep these in sync with `mobilewalletadapter/common/ProtocolContract.java`.\n    ERROR_AUTHORIZATION_FAILED: -1,\n    ERROR_INVALID_PAYLOADS: -2,\n    ERROR_NOT_SIGNED: -3,\n    ERROR_NOT_SUBMITTED: -4,\n    ERROR_TOO_MANY_PAYLOADS: -5,\n    ERROR_ATTEST_ORIGIN_ANDROID: -100\n};\nclass SolanaMobileWalletAdapterProtocolError extends Error {\n    constructor(...args){\n        const [jsonRpcMessageId, code, message, data] = args;\n        super(message);\n        this.code = code;\n        this.data = data;\n        this.jsonRpcMessageId = jsonRpcMessageId;\n        this.name = \"SolanaMobileWalletAdapterProtocolError\";\n    }\n}\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ function __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction createHelloReq(ecdhPublicKey, associationKeypairPrivateKey) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const publicKeyBuffer = yield crypto.subtle.exportKey(\"raw\", ecdhPublicKey);\n        const signatureBuffer = yield crypto.subtle.sign({\n            hash: \"SHA-256\",\n            name: \"ECDSA\"\n        }, associationKeypairPrivateKey, publicKeyBuffer);\n        const response = new Uint8Array(publicKeyBuffer.byteLength + signatureBuffer.byteLength);\n        response.set(new Uint8Array(publicKeyBuffer), 0);\n        response.set(new Uint8Array(signatureBuffer), publicKeyBuffer.byteLength);\n        return response;\n    });\n}\nfunction encode(input) {\n    return window.btoa(input);\n}\nfunction createSIWSMessage(payload) {\n    return (0,_solana_wallet_standard_util__WEBPACK_IMPORTED_MODULE_0__.createSignInMessageText)(payload);\n}\nfunction createSIWSMessageBase64(payload) {\n    return encode(createSIWSMessage(payload));\n}\n// optional features\nconst SolanaSignTransactions = \"solana:signTransactions\";\nconst SolanaCloneAuthorization = \"solana:cloneAuthorization\";\nconst SolanaSignInWithSolana = \"solana:signInWithSolana\";\n/**\n * Creates a {@link MobileWallet} proxy that handles backwards compatibility and API to RPC conversion.\n *\n * @param protocolVersion the protocol version in use for this session/request\n * @param protocolRequestHandler callback function that handles sending the RPC request to the wallet endpoint.\n * @returns a {@link MobileWallet} proxy\n */ function createMobileWalletProxy(protocolVersion, protocolRequestHandler) {\n    return new Proxy({}, {\n        get (target, p) {\n            if (target[p] == null) {\n                target[p] = function(inputParams) {\n                    return __awaiter(this, void 0, void 0, function*() {\n                        const { method, params } = handleMobileWalletRequest(p, inputParams, protocolVersion);\n                        const result = yield protocolRequestHandler(method, params);\n                        // if the request tried to sign in but the wallet did not return a sign in result, fallback on message signing\n                        if (method === \"authorize\" && params.sign_in_payload && !result.sign_in_result) {\n                            result[\"sign_in_result\"] = yield signInFallback(params.sign_in_payload, result, protocolRequestHandler);\n                        }\n                        return handleMobileWalletResponse(p, result, protocolVersion);\n                    });\n                };\n            }\n            return target[p];\n        },\n        defineProperty () {\n            return false;\n        },\n        deleteProperty () {\n            return false;\n        }\n    });\n}\n/**\n * Handles all {@link MobileWallet} API requests and determines the correct MWA RPC method and params to call.\n * This handles backwards compatibility, based on the provided @protocolVersion.\n *\n * @param methodName the name of {@link MobileWallet} method that was called\n * @param methodParams the parameters that were passed to the method\n * @param protocolVersion the protocol version in use for this session/request\n * @returns the RPC request method and params that should be sent to the wallet endpoint\n */ function handleMobileWalletRequest(methodName, methodParams, protocolVersion) {\n    let params = methodParams;\n    let method = methodName.toString().replace(/[A-Z]/g, (letter)=>`_${letter.toLowerCase()}`).toLowerCase();\n    switch(methodName){\n        case \"authorize\":\n            {\n                let { chain } = params;\n                if (protocolVersion === \"legacy\") {\n                    switch(chain){\n                        case \"solana:testnet\":\n                            {\n                                chain = \"testnet\";\n                                break;\n                            }\n                        case \"solana:devnet\":\n                            {\n                                chain = \"devnet\";\n                                break;\n                            }\n                        case \"solana:mainnet\":\n                            {\n                                chain = \"mainnet-beta\";\n                                break;\n                            }\n                        default:\n                            {\n                                chain = params.cluster;\n                            }\n                    }\n                    params.cluster = chain;\n                } else {\n                    switch(chain){\n                        case \"testnet\":\n                        case \"devnet\":\n                            {\n                                chain = `solana:${chain}`;\n                                break;\n                            }\n                        case \"mainnet-beta\":\n                            {\n                                chain = \"solana:mainnet\";\n                                break;\n                            }\n                    }\n                    params.chain = chain;\n                }\n            }\n        case \"reauthorize\":\n            {\n                const { auth_token, identity } = params;\n                if (auth_token) {\n                    switch(protocolVersion){\n                        case \"legacy\":\n                            {\n                                method = \"reauthorize\";\n                                params = {\n                                    auth_token: auth_token,\n                                    identity: identity\n                                };\n                                break;\n                            }\n                        default:\n                            {\n                                method = \"authorize\";\n                                break;\n                            }\n                    }\n                }\n                break;\n            }\n    }\n    return {\n        method,\n        params\n    };\n}\n/**\n * Handles all {@link MobileWallet} API responses and modifies the response for backwards compatibility, if needed\n *\n * @param method the {@link MobileWallet} method that was called\n * @param response the original response that was returned by the method call\n * @param protocolVersion the protocol version in use for this session/request\n * @returns the possibly modified response\n */ function handleMobileWalletResponse(method, response, protocolVersion) {\n    switch(method){\n        case \"getCapabilities\":\n            {\n                const capabilities = response;\n                switch(protocolVersion){\n                    case \"legacy\":\n                        {\n                            const features = [\n                                SolanaSignTransactions\n                            ];\n                            if (capabilities.supports_clone_authorization === true) {\n                                features.push(SolanaCloneAuthorization);\n                            }\n                            return Object.assign(Object.assign({}, capabilities), {\n                                features: features\n                            });\n                        }\n                    case \"v1\":\n                        {\n                            return Object.assign(Object.assign({}, capabilities), {\n                                supports_sign_and_send_transactions: true,\n                                supports_clone_authorization: capabilities.features.includes(SolanaCloneAuthorization)\n                            });\n                        }\n                }\n            }\n    }\n    return response;\n}\nfunction signInFallback(signInPayload, authorizationResult, protocolRequestHandler) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function*() {\n        const domain = (_a = signInPayload.domain) !== null && _a !== void 0 ? _a : window.location.host;\n        const address = authorizationResult.accounts[0].address;\n        const siwsMessage = createSIWSMessageBase64(Object.assign(Object.assign({}, signInPayload), {\n            domain,\n            address\n        }));\n        const signMessageResult = yield protocolRequestHandler(\"sign_messages\", {\n            addresses: [\n                address\n            ],\n            payloads: [\n                siwsMessage\n            ]\n        });\n        const signInResult = {\n            address: address,\n            signed_message: siwsMessage,\n            signature: signMessageResult.signed_payloads[0].slice(siwsMessage.length)\n        };\n        return signInResult;\n    });\n}\nconst SEQUENCE_NUMBER_BYTES = 4;\nfunction createSequenceNumberVector(sequenceNumber) {\n    if (sequenceNumber >= 4294967296) {\n        throw new Error(\"Outbound sequence number overflow. The maximum sequence number is 32-bytes.\");\n    }\n    const byteArray = new ArrayBuffer(SEQUENCE_NUMBER_BYTES);\n    const view = new DataView(byteArray);\n    view.setUint32(0, sequenceNumber, /* littleEndian */ false);\n    return new Uint8Array(byteArray);\n}\nconst INITIALIZATION_VECTOR_BYTES = 12;\nconst ENCODED_PUBLIC_KEY_LENGTH_BYTES = 65;\nfunction encryptMessage(plaintext, sequenceNumber, sharedSecret) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const sequenceNumberVector = createSequenceNumberVector(sequenceNumber);\n        const initializationVector = new Uint8Array(INITIALIZATION_VECTOR_BYTES);\n        crypto.getRandomValues(initializationVector);\n        const ciphertext = yield crypto.subtle.encrypt(getAlgorithmParams(sequenceNumberVector, initializationVector), sharedSecret, new TextEncoder().encode(plaintext));\n        const response = new Uint8Array(sequenceNumberVector.byteLength + initializationVector.byteLength + ciphertext.byteLength);\n        response.set(new Uint8Array(sequenceNumberVector), 0);\n        response.set(new Uint8Array(initializationVector), sequenceNumberVector.byteLength);\n        response.set(new Uint8Array(ciphertext), sequenceNumberVector.byteLength + initializationVector.byteLength);\n        return response;\n    });\n}\nfunction decryptMessage(message, sharedSecret) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const sequenceNumberVector = message.slice(0, SEQUENCE_NUMBER_BYTES);\n        const initializationVector = message.slice(SEQUENCE_NUMBER_BYTES, SEQUENCE_NUMBER_BYTES + INITIALIZATION_VECTOR_BYTES);\n        const ciphertext = message.slice(SEQUENCE_NUMBER_BYTES + INITIALIZATION_VECTOR_BYTES);\n        const plaintextBuffer = yield crypto.subtle.decrypt(getAlgorithmParams(sequenceNumberVector, initializationVector), sharedSecret, ciphertext);\n        const plaintext = getUtf8Decoder().decode(plaintextBuffer);\n        return plaintext;\n    });\n}\nfunction getAlgorithmParams(sequenceNumber, initializationVector) {\n    return {\n        additionalData: sequenceNumber,\n        iv: initializationVector,\n        name: \"AES-GCM\",\n        tagLength: 128\n    };\n}\nlet _utf8Decoder;\nfunction getUtf8Decoder() {\n    if (_utf8Decoder === undefined) {\n        _utf8Decoder = new TextDecoder(\"utf-8\");\n    }\n    return _utf8Decoder;\n}\nfunction generateAssociationKeypair() {\n    return __awaiter(this, void 0, void 0, function*() {\n        return yield crypto.subtle.generateKey({\n            name: \"ECDSA\",\n            namedCurve: \"P-256\"\n        }, false, [\n            \"sign\"\n        ]);\n    });\n}\nfunction generateECDHKeypair() {\n    return __awaiter(this, void 0, void 0, function*() {\n        return yield crypto.subtle.generateKey({\n            name: \"ECDH\",\n            namedCurve: \"P-256\"\n        }, false, [\n            \"deriveKey\",\n            \"deriveBits\"\n        ]);\n    });\n}\nfunction encryptJsonRpcMessage(jsonRpcMessage, sharedSecret) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const plaintext = JSON.stringify(jsonRpcMessage);\n        const sequenceNumber = jsonRpcMessage.id;\n        return encryptMessage(plaintext, sequenceNumber, sharedSecret);\n    });\n}\nfunction decryptJsonRpcMessage(message, sharedSecret) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const plaintext = yield decryptMessage(message, sharedSecret);\n        const jsonRpcMessage = JSON.parse(plaintext);\n        if (Object.hasOwnProperty.call(jsonRpcMessage, \"error\")) {\n            throw new SolanaMobileWalletAdapterProtocolError(jsonRpcMessage.id, jsonRpcMessage.error.code, jsonRpcMessage.error.message);\n        }\n        return jsonRpcMessage;\n    });\n}\nfunction parseHelloRsp(payloadBuffer, associationPublicKey, ecdhPrivateKey) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const [associationPublicKeyBuffer, walletPublicKey] = yield Promise.all([\n            crypto.subtle.exportKey(\"raw\", associationPublicKey),\n            crypto.subtle.importKey(\"raw\", payloadBuffer.slice(0, ENCODED_PUBLIC_KEY_LENGTH_BYTES), {\n                name: \"ECDH\",\n                namedCurve: \"P-256\"\n            }, false, [])\n        ]);\n        const sharedSecret = yield crypto.subtle.deriveBits({\n            name: \"ECDH\",\n            public: walletPublicKey\n        }, ecdhPrivateKey, 256);\n        const ecdhSecretKey = yield crypto.subtle.importKey(\"raw\", sharedSecret, \"HKDF\", false, [\n            \"deriveKey\"\n        ]);\n        const aesKeyMaterialVal = yield crypto.subtle.deriveKey({\n            name: \"HKDF\",\n            hash: \"SHA-256\",\n            salt: new Uint8Array(associationPublicKeyBuffer),\n            info: new Uint8Array()\n        }, ecdhSecretKey, {\n            name: \"AES-GCM\",\n            length: 128\n        }, false, [\n            \"encrypt\",\n            \"decrypt\"\n        ]);\n        return aesKeyMaterialVal;\n    });\n}\nfunction parseSessionProps(message, sharedSecret) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const plaintext = yield decryptMessage(message, sharedSecret);\n        const jsonProperties = JSON.parse(plaintext);\n        let protocolVersion = \"legacy\";\n        if (Object.hasOwnProperty.call(jsonProperties, \"v\")) {\n            switch(jsonProperties.v){\n                case 1:\n                case \"1\":\n                case \"v1\":\n                    protocolVersion = \"v1\";\n                    break;\n                case \"legacy\":\n                    protocolVersion = \"legacy\";\n                    break;\n                default:\n                    throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_INVALID_PROTOCOL_VERSION, `Unknown/unsupported protocol version: ${jsonProperties.v}`);\n            }\n        }\n        return {\n            protocol_version: protocolVersion\n        };\n    });\n}\nfunction getRandomAssociationPort() {\n    return assertAssociationPort(49152 + Math.floor(Math.random() * (65535 - 49152 + 1)));\n}\nfunction assertAssociationPort(port) {\n    if (port < 49152 || port > 65535) {\n        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_ASSOCIATION_PORT_OUT_OF_RANGE, `Association port number must be between 49152 and 65535. ${port} given.`, {\n            port\n        });\n    }\n    return port;\n}\n// https://stackoverflow.com/a/9458996/802047\nfunction arrayBufferToBase64String(buffer) {\n    let binary = \"\";\n    const bytes = new Uint8Array(buffer);\n    const len = bytes.byteLength;\n    for(let ii = 0; ii < len; ii++){\n        binary += String.fromCharCode(bytes[ii]);\n    }\n    return window.btoa(binary);\n}\nfunction getStringWithURLUnsafeCharactersReplaced(unsafeBase64EncodedString) {\n    return unsafeBase64EncodedString.replace(/[/+=]/g, (m)=>({\n            \"/\": \"_\",\n            \"+\": \"-\",\n            \"=\": \".\"\n        })[m]);\n}\nfunction getRandomReflectorId() {\n    return assertReflectorId(getRandomInt(0, 9007199254740991)); // 0 < id < 2^53 - 1\n}\nfunction getRandomInt(min, max) {\n    const randomBuffer = new Uint32Array(1);\n    window.crypto.getRandomValues(randomBuffer);\n    let randomNumber = randomBuffer[0] / (0xffffffff + 1);\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return Math.floor(randomNumber * (max - min + 1)) + min;\n}\nfunction assertReflectorId(id) {\n    if (id < 0 || id > 9007199254740991) {\n        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_REFLECTOR_ID_OUT_OF_RANGE, `Association port number must be between 49152 and 65535. ${id} given.`, {\n            id\n        });\n    }\n    return id;\n}\nconst INTENT_NAME = \"solana-wallet\";\nfunction getPathParts(pathString) {\n    return pathString// Strip leading and trailing slashes\n    .replace(/(^\\/+|\\/+$)/g, \"\")// Return an array of directories\n    .split(\"/\");\n}\nfunction getIntentURL(methodPathname, intentUrlBase) {\n    let baseUrl = null;\n    if (intentUrlBase) {\n        try {\n            baseUrl = new URL(intentUrlBase);\n        } catch (_a) {} // eslint-disable-line no-empty\n        if ((baseUrl === null || baseUrl === void 0 ? void 0 : baseUrl.protocol) !== \"https:\") {\n            throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL, \"Base URLs supplied by wallets must be valid `https` URLs\");\n        }\n    }\n    baseUrl || (baseUrl = new URL(`${INTENT_NAME}:/`));\n    const pathname = methodPathname.startsWith(\"/\") ? methodPathname : [\n        ...getPathParts(baseUrl.pathname),\n        ...getPathParts(methodPathname)\n    ].join(\"/\");\n    return new URL(pathname, baseUrl);\n}\nfunction getAssociateAndroidIntentURL(associationPublicKey, putativePort, associationURLBase, protocolVersions = [\n    \"v1\"\n]) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const associationPort = assertAssociationPort(putativePort);\n        const exportedKey = yield crypto.subtle.exportKey(\"raw\", associationPublicKey);\n        const encodedKey = arrayBufferToBase64String(exportedKey);\n        const url = getIntentURL(\"v1/associate/local\", associationURLBase);\n        url.searchParams.set(\"association\", getStringWithURLUnsafeCharactersReplaced(encodedKey));\n        url.searchParams.set(\"port\", `${associationPort}`);\n        protocolVersions.forEach((version)=>{\n            url.searchParams.set(\"v\", version);\n        });\n        return url;\n    });\n}\nfunction getRemoteAssociateAndroidIntentURL(associationPublicKey, hostAuthority, putativeId, associationURLBase, protocolVersions = [\n    \"v1\"\n]) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const reflectorId = assertReflectorId(putativeId);\n        const exportedKey = yield crypto.subtle.exportKey(\"raw\", associationPublicKey);\n        const encodedKey = arrayBufferToBase64String(exportedKey);\n        const url = getIntentURL(\"v1/associate/remote\", associationURLBase);\n        url.searchParams.set(\"association\", getStringWithURLUnsafeCharactersReplaced(encodedKey));\n        url.searchParams.set(\"reflector\", `${hostAuthority}`);\n        url.searchParams.set(\"id\", `${reflectorId}`);\n        protocolVersions.forEach((version)=>{\n            url.searchParams.set(\"v\", version);\n        });\n        return url;\n    });\n}\n// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/\nconst Browser = {\n    Firefox: 0,\n    Other: 1\n};\nfunction assertUnreachable(x) {\n    return x;\n}\nfunction getBrowser() {\n    return navigator.userAgent.indexOf(\"Firefox/\") !== -1 ? Browser.Firefox : Browser.Other;\n}\nfunction getDetectionPromise() {\n    // Chrome and others silently fail if a custom protocol is not supported.\n    // For these, we wait to see if the browser is navigated away from in\n    // a reasonable amount of time (ie. the native wallet opened).\n    return new Promise((resolve, reject)=>{\n        function cleanup() {\n            clearTimeout(timeoutId);\n            window.removeEventListener(\"blur\", handleBlur);\n        }\n        function handleBlur() {\n            cleanup();\n            resolve();\n        }\n        window.addEventListener(\"blur\", handleBlur);\n        const timeoutId = setTimeout(()=>{\n            cleanup();\n            reject();\n        }, 2000);\n    });\n}\nlet _frame = null;\nfunction launchUrlThroughHiddenFrame(url) {\n    if (_frame == null) {\n        _frame = document.createElement(\"iframe\");\n        _frame.style.display = \"none\";\n        document.body.appendChild(_frame);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    _frame.contentWindow.location.href = url.toString();\n}\nfunction launchAssociation(associationUrl) {\n    return __awaiter(this, void 0, void 0, function*() {\n        if (associationUrl.protocol === \"https:\") {\n            // The association URL is an Android 'App Link' or iOS 'Universal Link'.\n            // These are regular web URLs that are designed to launch an app if it\n            // is installed or load the actual target webpage if not.\n            window.location.assign(associationUrl);\n        } else {\n            // The association URL has a custom protocol (eg. `solana-wallet:`)\n            try {\n                const browser = getBrowser();\n                switch(browser){\n                    case Browser.Firefox:\n                        // If a custom protocol is not supported in Firefox, it throws.\n                        launchUrlThroughHiddenFrame(associationUrl);\n                        break;\n                    case Browser.Other:\n                        {\n                            const detectionPromise = getDetectionPromise();\n                            window.location.assign(associationUrl);\n                            yield detectionPromise;\n                            break;\n                        }\n                    default:\n                        assertUnreachable(browser);\n                }\n            } catch (e) {\n                throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_WALLET_NOT_FOUND, \"Found no installed wallet that supports the mobile wallet protocol.\");\n            }\n        }\n    });\n}\nfunction startSession(associationPublicKey, associationURLBase) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const randomAssociationPort = getRandomAssociationPort();\n        const associationUrl = yield getAssociateAndroidIntentURL(associationPublicKey, randomAssociationPort, associationURLBase);\n        yield launchAssociation(associationUrl);\n        return randomAssociationPort;\n    });\n}\nfunction getRemoteSessionUrl(associationPublicKey, hostAuthority, associationURLBase) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const randomReflectorId = getRandomReflectorId();\n        const associationUrl = yield getRemoteAssociateAndroidIntentURL(associationPublicKey, hostAuthority, randomReflectorId, associationURLBase);\n        return {\n            associationUrl,\n            reflectorId: randomReflectorId\n        };\n    });\n}\nconst WEBSOCKET_CONNECTION_CONFIG = {\n    /**\n     * 300 milliseconds is a generally accepted threshold for what someone\n     * would consider an acceptable response time for a user interface\n     * after having performed a low-attention tapping task. We set the initial\n     * interval at which we wait for the wallet to set up the websocket at\n     * half this, as per the Nyquist frequency, with a progressive backoff\n     * sequence from there. The total wait time is 30s, which allows for the\n     * user to be presented with a disambiguation dialog, select a wallet, and\n     * for the wallet app to subsequently start.\n     */ retryDelayScheduleMs: [\n        150,\n        150,\n        200,\n        500,\n        500,\n        750,\n        750,\n        1000\n    ],\n    timeoutMs: 30000\n};\nconst WEBSOCKET_PROTOCOL = \"com.solana.mobilewalletadapter.v1\";\nfunction assertSecureContext() {\n    if (true) {\n        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SECURE_CONTEXT_REQUIRED, \"The mobile wallet adapter protocol must be used in a secure context (`https`).\");\n    }\n}\nfunction assertSecureEndpointSpecificURI(walletUriBase) {\n    let url;\n    try {\n        url = new URL(walletUriBase);\n    } catch (_a) {\n        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL, \"Invalid base URL supplied by wallet\");\n    }\n    if (url.protocol !== \"https:\") {\n        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL, \"Base URLs supplied by wallets must be valid `https` URLs\");\n    }\n}\nfunction getSequenceNumberFromByteArray(byteArray) {\n    const view = new DataView(byteArray);\n    return view.getUint32(0, /* littleEndian */ false);\n}\nfunction transact(callback, config) {\n    return __awaiter(this, void 0, void 0, function*() {\n        assertSecureContext();\n        const associationKeypair = yield generateAssociationKeypair();\n        const sessionPort = yield startSession(associationKeypair.publicKey, config === null || config === void 0 ? void 0 : config.baseUri);\n        const websocketURL = `ws://localhost:${sessionPort}/solana-wallet`;\n        let connectionStartTime;\n        const getNextRetryDelayMs = (()=>{\n            const schedule = [\n                ...WEBSOCKET_CONNECTION_CONFIG.retryDelayScheduleMs\n            ];\n            return ()=>schedule.length > 1 ? schedule.shift() : schedule[0];\n        })();\n        let nextJsonRpcMessageId = 1;\n        let lastKnownInboundSequenceNumber = 0;\n        let state = {\n            __type: \"disconnected\"\n        };\n        return new Promise((resolve, reject)=>{\n            let socket;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const jsonRpcResponsePromises = {};\n            const handleOpen = ()=>__awaiter(this, void 0, void 0, function*() {\n                    if (state.__type !== \"connecting\") {\n                        console.warn(\"Expected adapter state to be `connecting` at the moment the websocket opens. \" + `Got \\`${state.__type}\\`.`);\n                        return;\n                    }\n                    socket.removeEventListener(\"open\", handleOpen);\n                    // previous versions of this library and walletlib incorrectly implemented the MWA session \n                    // establishment protocol for local connections. The dapp is supposed to wait for the \n                    // APP_PING message before sending the HELLO_REQ. Instead, the dapp was sending the HELLO_REQ \n                    // immediately upon connection to the websocket server regardless of wether or not an \n                    // APP_PING was sent by the wallet/websocket server. We must continue to support this behavior \n                    // in case the user is using a wallet that has not updated their walletlib implementation. \n                    const { associationKeypair } = state;\n                    const ecdhKeypair = yield generateECDHKeypair();\n                    socket.send((yield createHelloReq(ecdhKeypair.publicKey, associationKeypair.privateKey)));\n                    state = {\n                        __type: \"hello_req_sent\",\n                        associationPublicKey: associationKeypair.publicKey,\n                        ecdhPrivateKey: ecdhKeypair.privateKey\n                    };\n                });\n            const handleClose = (evt)=>{\n                if (evt.wasClean) {\n                    state = {\n                        __type: \"disconnected\"\n                    };\n                } else {\n                    reject(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_CLOSED, `The wallet session dropped unexpectedly (${evt.code}: ${evt.reason}).`, {\n                        closeEvent: evt\n                    }));\n                }\n                disposeSocket();\n            };\n            const handleError = (_evt)=>__awaiter(this, void 0, void 0, function*() {\n                    disposeSocket();\n                    if (Date.now() - connectionStartTime >= WEBSOCKET_CONNECTION_CONFIG.timeoutMs) {\n                        reject(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_TIMEOUT, `Failed to connect to the wallet websocket at ${websocketURL}.`));\n                    } else {\n                        yield new Promise((resolve)=>{\n                            const retryDelayMs = getNextRetryDelayMs();\n                            retryWaitTimeoutId = window.setTimeout(resolve, retryDelayMs);\n                        });\n                        attemptSocketConnection();\n                    }\n                });\n            const handleMessage = (evt)=>__awaiter(this, void 0, void 0, function*() {\n                    const responseBuffer = yield evt.data.arrayBuffer();\n                    switch(state.__type){\n                        case \"connecting\":\n                            if (responseBuffer.byteLength !== 0) {\n                                throw new Error(\"Encountered unexpected message while connecting\");\n                            }\n                            const ecdhKeypair = yield generateECDHKeypair();\n                            socket.send((yield createHelloReq(ecdhKeypair.publicKey, associationKeypair.privateKey)));\n                            state = {\n                                __type: \"hello_req_sent\",\n                                associationPublicKey: associationKeypair.publicKey,\n                                ecdhPrivateKey: ecdhKeypair.privateKey\n                            };\n                            break;\n                        case \"connected\":\n                            try {\n                                const sequenceNumberVector = responseBuffer.slice(0, SEQUENCE_NUMBER_BYTES);\n                                const sequenceNumber = getSequenceNumberFromByteArray(sequenceNumberVector);\n                                if (sequenceNumber !== lastKnownInboundSequenceNumber + 1) {\n                                    throw new Error(\"Encrypted message has invalid sequence number\");\n                                }\n                                lastKnownInboundSequenceNumber = sequenceNumber;\n                                const jsonRpcMessage = yield decryptJsonRpcMessage(responseBuffer, state.sharedSecret);\n                                const responsePromise = jsonRpcResponsePromises[jsonRpcMessage.id];\n                                delete jsonRpcResponsePromises[jsonRpcMessage.id];\n                                responsePromise.resolve(jsonRpcMessage.result);\n                            } catch (e) {\n                                if (e instanceof SolanaMobileWalletAdapterProtocolError) {\n                                    const responsePromise = jsonRpcResponsePromises[e.jsonRpcMessageId];\n                                    delete jsonRpcResponsePromises[e.jsonRpcMessageId];\n                                    responsePromise.reject(e);\n                                } else {\n                                    throw e;\n                                }\n                            }\n                            break;\n                        case \"hello_req_sent\":\n                            {\n                                // if we receive an APP_PING message (empty message), resend the HELLO_REQ (see above)\n                                if (responseBuffer.byteLength === 0) {\n                                    const ecdhKeypair = yield generateECDHKeypair();\n                                    socket.send((yield createHelloReq(ecdhKeypair.publicKey, associationKeypair.privateKey)));\n                                    state = {\n                                        __type: \"hello_req_sent\",\n                                        associationPublicKey: associationKeypair.publicKey,\n                                        ecdhPrivateKey: ecdhKeypair.privateKey\n                                    };\n                                    break;\n                                }\n                                const sharedSecret = yield parseHelloRsp(responseBuffer, state.associationPublicKey, state.ecdhPrivateKey);\n                                const sessionPropertiesBuffer = responseBuffer.slice(ENCODED_PUBLIC_KEY_LENGTH_BYTES);\n                                const sessionProperties = sessionPropertiesBuffer.byteLength !== 0 ? yield (()=>__awaiter(this, void 0, void 0, function*() {\n                                        const sequenceNumberVector = sessionPropertiesBuffer.slice(0, SEQUENCE_NUMBER_BYTES);\n                                        const sequenceNumber = getSequenceNumberFromByteArray(sequenceNumberVector);\n                                        if (sequenceNumber !== lastKnownInboundSequenceNumber + 1) {\n                                            throw new Error(\"Encrypted message has invalid sequence number\");\n                                        }\n                                        lastKnownInboundSequenceNumber = sequenceNumber;\n                                        return parseSessionProps(sessionPropertiesBuffer, sharedSecret);\n                                    }))() : {\n                                    protocol_version: \"legacy\"\n                                };\n                                state = {\n                                    __type: \"connected\",\n                                    sharedSecret,\n                                    sessionProperties\n                                };\n                                const wallet = createMobileWalletProxy(sessionProperties.protocol_version, (method, params)=>__awaiter(this, void 0, void 0, function*() {\n                                        const id = nextJsonRpcMessageId++;\n                                        socket.send((yield encryptJsonRpcMessage({\n                                            id,\n                                            jsonrpc: \"2.0\",\n                                            method,\n                                            params: params !== null && params !== void 0 ? params : {}\n                                        }, sharedSecret)));\n                                        return new Promise((resolve, reject)=>{\n                                            jsonRpcResponsePromises[id] = {\n                                                resolve (result) {\n                                                    switch(method){\n                                                        case \"authorize\":\n                                                        case \"reauthorize\":\n                                                            {\n                                                                const { wallet_uri_base } = result;\n                                                                if (wallet_uri_base != null) {\n                                                                    try {\n                                                                        assertSecureEndpointSpecificURI(wallet_uri_base);\n                                                                    } catch (e) {\n                                                                        reject(e);\n                                                                        return;\n                                                                    }\n                                                                }\n                                                                break;\n                                                            }\n                                                    }\n                                                    resolve(result);\n                                                },\n                                                reject\n                                            };\n                                        });\n                                    }));\n                                try {\n                                    resolve((yield callback(wallet)));\n                                } catch (e) {\n                                    reject(e);\n                                } finally{\n                                    disposeSocket();\n                                    socket.close();\n                                }\n                                break;\n                            }\n                    }\n                });\n            let disposeSocket;\n            let retryWaitTimeoutId;\n            const attemptSocketConnection = ()=>{\n                if (disposeSocket) {\n                    disposeSocket();\n                }\n                state = {\n                    __type: \"connecting\",\n                    associationKeypair\n                };\n                if (connectionStartTime === undefined) {\n                    connectionStartTime = Date.now();\n                }\n                socket = new WebSocket(websocketURL, [\n                    WEBSOCKET_PROTOCOL\n                ]);\n                socket.addEventListener(\"open\", handleOpen);\n                socket.addEventListener(\"close\", handleClose);\n                socket.addEventListener(\"error\", handleError);\n                socket.addEventListener(\"message\", handleMessage);\n                disposeSocket = ()=>{\n                    window.clearTimeout(retryWaitTimeoutId);\n                    socket.removeEventListener(\"open\", handleOpen);\n                    socket.removeEventListener(\"close\", handleClose);\n                    socket.removeEventListener(\"error\", handleError);\n                    socket.removeEventListener(\"message\", handleMessage);\n                };\n            };\n            attemptSocketConnection();\n        });\n    });\n}\nfunction transactRemote(callback, config) {\n    return __awaiter(this, void 0, void 0, function*() {\n        assertSecureContext();\n        const associationKeypair = yield generateAssociationKeypair();\n        const { associationUrl, reflectorId } = yield getRemoteSessionUrl(associationKeypair.publicKey, config.remoteHostAuthority, config === null || config === void 0 ? void 0 : config.baseUri);\n        const websocketURL = `wss://${config === null || config === void 0 ? void 0 : config.remoteHostAuthority}/reflect?id=${reflectorId}`;\n        let connectionStartTime;\n        const getNextRetryDelayMs = (()=>{\n            const schedule = [\n                ...WEBSOCKET_CONNECTION_CONFIG.retryDelayScheduleMs\n            ];\n            return ()=>schedule.length > 1 ? schedule.shift() : schedule[0];\n        })();\n        let nextJsonRpcMessageId = 1;\n        let lastKnownInboundSequenceNumber = 0;\n        let state = {\n            __type: \"disconnected\"\n        };\n        return {\n            associationUrl,\n            result: new Promise((resolve, reject)=>{\n                let socket;\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                const jsonRpcResponsePromises = {};\n                const handleOpen = ()=>__awaiter(this, void 0, void 0, function*() {\n                        if (state.__type !== \"connecting\") {\n                            console.warn(\"Expected adapter state to be `connecting` at the moment the websocket opens. \" + `Got \\`${state.__type}\\`.`);\n                            return;\n                        }\n                        socket.removeEventListener(\"open\", handleOpen);\n                    });\n                const handleClose = (evt)=>{\n                    if (evt.wasClean) {\n                        state = {\n                            __type: \"disconnected\"\n                        };\n                    } else {\n                        reject(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_CLOSED, `The wallet session dropped unexpectedly (${evt.code}: ${evt.reason}).`, {\n                            closeEvent: evt\n                        }));\n                    }\n                    disposeSocket();\n                };\n                const handleError = (_evt)=>__awaiter(this, void 0, void 0, function*() {\n                        disposeSocket();\n                        if (Date.now() - connectionStartTime >= WEBSOCKET_CONNECTION_CONFIG.timeoutMs) {\n                            reject(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_TIMEOUT, `Failed to connect to the wallet websocket at ${websocketURL}.`));\n                        } else {\n                            yield new Promise((resolve)=>{\n                                const retryDelayMs = getNextRetryDelayMs();\n                                retryWaitTimeoutId = window.setTimeout(resolve, retryDelayMs);\n                            });\n                            attemptSocketConnection();\n                        }\n                    });\n                const handleMessage = (evt)=>__awaiter(this, void 0, void 0, function*() {\n                        const responseBuffer = yield evt.data.arrayBuffer();\n                        switch(state.__type){\n                            case \"connecting\":\n                                if (responseBuffer.byteLength !== 0) {\n                                    throw new Error(\"Encountered unexpected message while connecting\");\n                                }\n                                const ecdhKeypair = yield generateECDHKeypair();\n                                socket.send((yield createHelloReq(ecdhKeypair.publicKey, associationKeypair.privateKey)));\n                                state = {\n                                    __type: \"hello_req_sent\",\n                                    associationPublicKey: associationKeypair.publicKey,\n                                    ecdhPrivateKey: ecdhKeypair.privateKey\n                                };\n                                break;\n                            case \"connected\":\n                                try {\n                                    const sequenceNumberVector = responseBuffer.slice(0, SEQUENCE_NUMBER_BYTES);\n                                    const sequenceNumber = getSequenceNumberFromByteArray(sequenceNumberVector);\n                                    if (sequenceNumber !== lastKnownInboundSequenceNumber + 1) {\n                                        throw new Error(\"Encrypted message has invalid sequence number\");\n                                    }\n                                    lastKnownInboundSequenceNumber = sequenceNumber;\n                                    const jsonRpcMessage = yield decryptJsonRpcMessage(responseBuffer, state.sharedSecret);\n                                    const responsePromise = jsonRpcResponsePromises[jsonRpcMessage.id];\n                                    delete jsonRpcResponsePromises[jsonRpcMessage.id];\n                                    responsePromise.resolve(jsonRpcMessage.result);\n                                } catch (e) {\n                                    if (e instanceof SolanaMobileWalletAdapterProtocolError) {\n                                        const responsePromise = jsonRpcResponsePromises[e.jsonRpcMessageId];\n                                        delete jsonRpcResponsePromises[e.jsonRpcMessageId];\n                                        responsePromise.reject(e);\n                                    } else {\n                                        throw e;\n                                    }\n                                }\n                                break;\n                            case \"hello_req_sent\":\n                                {\n                                    const sharedSecret = yield parseHelloRsp(responseBuffer, state.associationPublicKey, state.ecdhPrivateKey);\n                                    const sessionPropertiesBuffer = responseBuffer.slice(ENCODED_PUBLIC_KEY_LENGTH_BYTES);\n                                    const sessionProperties = sessionPropertiesBuffer.byteLength !== 0 ? yield (()=>__awaiter(this, void 0, void 0, function*() {\n                                            const sequenceNumberVector = sessionPropertiesBuffer.slice(0, SEQUENCE_NUMBER_BYTES);\n                                            const sequenceNumber = getSequenceNumberFromByteArray(sequenceNumberVector);\n                                            if (sequenceNumber !== lastKnownInboundSequenceNumber + 1) {\n                                                throw new Error(\"Encrypted message has invalid sequence number\");\n                                            }\n                                            lastKnownInboundSequenceNumber = sequenceNumber;\n                                            return parseSessionProps(sessionPropertiesBuffer, sharedSecret);\n                                        }))() : {\n                                        protocol_version: \"legacy\"\n                                    };\n                                    state = {\n                                        __type: \"connected\",\n                                        sharedSecret,\n                                        sessionProperties\n                                    };\n                                    const wallet = createMobileWalletProxy(sessionProperties.protocol_version, (method, params)=>__awaiter(this, void 0, void 0, function*() {\n                                            const id = nextJsonRpcMessageId++;\n                                            socket.send((yield encryptJsonRpcMessage({\n                                                id,\n                                                jsonrpc: \"2.0\",\n                                                method,\n                                                params: params !== null && params !== void 0 ? params : {}\n                                            }, sharedSecret)));\n                                            return new Promise((resolve, reject)=>{\n                                                jsonRpcResponsePromises[id] = {\n                                                    resolve (result) {\n                                                        switch(method){\n                                                            case \"authorize\":\n                                                            case \"reauthorize\":\n                                                                {\n                                                                    const { wallet_uri_base } = result;\n                                                                    if (wallet_uri_base != null) {\n                                                                        try {\n                                                                            assertSecureEndpointSpecificURI(wallet_uri_base);\n                                                                        } catch (e) {\n                                                                            reject(e);\n                                                                            return;\n                                                                        }\n                                                                    }\n                                                                    break;\n                                                                }\n                                                        }\n                                                        resolve(result);\n                                                    },\n                                                    reject\n                                                };\n                                            });\n                                        }));\n                                    try {\n                                        resolve((yield callback(new Proxy(wallet, {\n                                            get (target, p) {\n                                                if (p == \"terminateSession\") {\n                                                    return function() {\n                                                        return __awaiter(this, void 0, void 0, function*() {\n                                                            disposeSocket();\n                                                            socket.close();\n                                                            return;\n                                                        });\n                                                    };\n                                                } else return target[p];\n                                            }\n                                        }))));\n                                    } catch (e) {\n                                        reject(e);\n                                    }\n                                    break;\n                                }\n                        }\n                    });\n                let disposeSocket;\n                let retryWaitTimeoutId;\n                const attemptSocketConnection = ()=>{\n                    if (disposeSocket) {\n                        disposeSocket();\n                    }\n                    state = {\n                        __type: \"connecting\",\n                        associationKeypair\n                    };\n                    if (connectionStartTime === undefined) {\n                        connectionStartTime = Date.now();\n                    }\n                    socket = new WebSocket(websocketURL, [\n                        WEBSOCKET_PROTOCOL\n                    ]);\n                    socket.addEventListener(\"open\", handleOpen);\n                    socket.addEventListener(\"close\", handleClose);\n                    socket.addEventListener(\"error\", handleError);\n                    socket.addEventListener(\"message\", handleMessage);\n                    disposeSocket = ()=>{\n                        window.clearTimeout(retryWaitTimeoutId);\n                        socket.removeEventListener(\"open\", handleOpen);\n                        socket.removeEventListener(\"close\", handleClose);\n                        socket.removeEventListener(\"error\", handleError);\n                        socket.removeEventListener(\"message\", handleMessage);\n                    };\n                };\n                attemptSocketConnection();\n            })\n        };\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS1tb2JpbGUvbW9iaWxlLXdhbGxldC1hZGFwdGVyLXByb3RvY29sL2xpYi9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUF1RTtBQUV2RSwrRUFBK0U7QUFDL0UsTUFBTUMscUNBQXFDO0lBQ3ZDQyxxQ0FBcUM7SUFDckNDLGlDQUFpQztJQUNqQ0MsaUNBQWlDO0lBQ2pDQywrQkFBK0I7SUFDL0JDLHNCQUFzQjtJQUN0QkMsdUJBQXVCO0lBQ3ZCQyx3QkFBd0I7SUFDeEJDLGdDQUFnQztBQUNwQztBQUNBLE1BQU1DLHVDQUF1Q0M7SUFDekNDLFlBQVksR0FBR0MsSUFBSSxDQUFFO1FBQ2pCLE1BQU0sQ0FBQ0MsTUFBTUMsU0FBU0MsS0FBSyxHQUFHSDtRQUM5QixLQUFLLENBQUNFO1FBQ04sSUFBSSxDQUFDRCxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDRSxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDaEI7QUFDSjtBQUNBLCtFQUErRTtBQUMvRSxNQUFNQyw2Q0FBNkM7SUFDL0MsOEVBQThFO0lBQzlFQyw0QkFBNEIsQ0FBQztJQUM3QkMsd0JBQXdCLENBQUM7SUFDekJDLGtCQUFrQixDQUFDO0lBQ25CQyxxQkFBcUIsQ0FBQztJQUN0QkMseUJBQXlCLENBQUM7SUFDMUJDLDZCQUE2QixDQUFDO0FBQ2xDO0FBQ0EsTUFBTUMsK0NBQStDZDtJQUNqREMsWUFBWSxHQUFHQyxJQUFJLENBQUU7UUFDakIsTUFBTSxDQUFDYSxrQkFBa0JaLE1BQU1DLFNBQVNDLEtBQUssR0FBR0g7UUFDaEQsS0FBSyxDQUFDRTtRQUNOLElBQUksQ0FBQ0QsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0UsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ1UsZ0JBQWdCLEdBQUdBO1FBQ3hCLElBQUksQ0FBQ1QsSUFBSSxHQUFHO0lBQ2hCO0FBQ0o7QUFFQTs7Ozs7Ozs7Ozs7Ozs4RUFh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UUFBUWdEO29CQUNoQ0YsT0FBTzlDLGdCQUFnQixDQUFDLFNBQVNzRDtvQkFDakNSLE9BQU85QyxnQkFBZ0IsQ0FBQyxTQUFTNEQ7b0JBQ2pDZCxPQUFPOUMsZ0JBQWdCLENBQUMsV0FBV21FO29CQUNuQ1IsZ0JBQWdCO3dCQUNaN1AsT0FBTzhMLFlBQVksQ0FBQ3FFO3dCQUNwQm5CLE9BQU9oRCxtQkFBbUIsQ0FBQyxRQUFRa0Q7d0JBQ25DRixPQUFPaEQsbUJBQW1CLENBQUMsU0FBU3dEO3dCQUNwQ1IsT0FBT2hELG1CQUFtQixDQUFDLFNBQVM4RDt3QkFDcENkLE9BQU9oRCxtQkFBbUIsQ0FBQyxXQUFXcUU7b0JBQzFDO2dCQUNKO2dCQUNBRDtZQUNKO1FBQUc7SUFDWDtBQUNKO0FBRXNRIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc29sYW5hLWxpcXVpZGl0eS1wb29sLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEtbW9iaWxlL21vYmlsZS13YWxsZXQtYWRhcHRlci1wcm90b2NvbC9saWIvZXNtL2luZGV4LmpzPzc3NjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlU2lnbkluTWVzc2FnZVRleHQgfSBmcm9tICdAc29sYW5hL3dhbGxldC1zdGFuZGFyZC11dGlsJztcblxuLy8gVHlwZXNjcmlwdCBgZW51bXNgIHRod2FydCB0cmVlLXNoYWtpbmcuIFNlZSBodHRwczovL2JhcmdzdGVuLm9yZy9qc3RzL2VudW1zL1xuY29uc3QgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yQ29kZSA9IHtcbiAgICBFUlJPUl9BU1NPQ0lBVElPTl9QT1JUX09VVF9PRl9SQU5HRTogJ0VSUk9SX0FTU09DSUFUSU9OX1BPUlRfT1VUX09GX1JBTkdFJyxcbiAgICBFUlJPUl9SRUZMRUNUT1JfSURfT1VUX09GX1JBTkdFOiAnRVJST1JfUkVGTEVDVE9SX0lEX09VVF9PRl9SQU5HRScsXG4gICAgRVJST1JfRk9SQklEREVOX1dBTExFVF9CQVNFX1VSTDogJ0VSUk9SX0ZPUkJJRERFTl9XQUxMRVRfQkFTRV9VUkwnLFxuICAgIEVSUk9SX1NFQ1VSRV9DT05URVhUX1JFUVVJUkVEOiAnRVJST1JfU0VDVVJFX0NPTlRFWFRfUkVRVUlSRUQnLFxuICAgIEVSUk9SX1NFU1NJT05fQ0xPU0VEOiAnRVJST1JfU0VTU0lPTl9DTE9TRUQnLFxuICAgIEVSUk9SX1NFU1NJT05fVElNRU9VVDogJ0VSUk9SX1NFU1NJT05fVElNRU9VVCcsXG4gICAgRVJST1JfV0FMTEVUX05PVF9GT1VORDogJ0VSUk9SX1dBTExFVF9OT1RfRk9VTkQnLFxuICAgIEVSUk9SX0lOVkFMSURfUFJPVE9DT0xfVkVSU0lPTjogJ0VSUk9SX0lOVkFMSURfUFJPVE9DT0xfVkVSU0lPTicsXG59O1xuY2xhc3MgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgW2NvZGUsIG1lc3NhZ2UsIGRhdGFdID0gYXJncztcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMubmFtZSA9ICdTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3InO1xuICAgIH1cbn1cbi8vIFR5cGVzY3JpcHQgYGVudW1zYCB0aHdhcnQgdHJlZS1zaGFraW5nLiBTZWUgaHR0cHM6Ly9iYXJnc3Rlbi5vcmcvanN0cy9lbnVtcy9cbmNvbnN0IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJQcm90b2NvbEVycm9yQ29kZSA9IHtcbiAgICAvLyBLZWVwIHRoZXNlIGluIHN5bmMgd2l0aCBgbW9iaWxld2FsbGV0YWRhcHRlci9jb21tb24vUHJvdG9jb2xDb250cmFjdC5qYXZhYC5cbiAgICBFUlJPUl9BVVRIT1JJWkFUSU9OX0ZBSUxFRDogLTEsXG4gICAgRVJST1JfSU5WQUxJRF9QQVlMT0FEUzogLTIsXG4gICAgRVJST1JfTk9UX1NJR05FRDogLTMsXG4gICAgRVJST1JfTk9UX1NVQk1JVFRFRDogLTQsXG4gICAgRVJST1JfVE9PX01BTllfUEFZTE9BRFM6IC01LFxuICAgIEVSUk9SX0FUVEVTVF9PUklHSU5fQU5EUk9JRDogLTEwMCxcbn07XG5jbGFzcyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyUHJvdG9jb2xFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IFtqc29uUnBjTWVzc2FnZUlkLCBjb2RlLCBtZXNzYWdlLCBkYXRhXSA9IGFyZ3M7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmpzb25ScGNNZXNzYWdlSWQgPSBqc29uUnBjTWVzc2FnZUlkO1xuICAgICAgICB0aGlzLm5hbWUgPSAnU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlclByb3RvY29sRXJyb3InO1xuICAgIH1cbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhlbGxvUmVxKGVjZGhQdWJsaWNLZXksIGFzc29jaWF0aW9uS2V5cGFpclByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBwdWJsaWNLZXlCdWZmZXIgPSB5aWVsZCBjcnlwdG8uc3VidGxlLmV4cG9ydEtleSgncmF3JywgZWNkaFB1YmxpY0tleSk7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZUJ1ZmZlciA9IHlpZWxkIGNyeXB0by5zdWJ0bGUuc2lnbih7IGhhc2g6ICdTSEEtMjU2JywgbmFtZTogJ0VDRFNBJyB9LCBhc3NvY2lhdGlvbktleXBhaXJQcml2YXRlS2V5LCBwdWJsaWNLZXlCdWZmZXIpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IG5ldyBVaW50OEFycmF5KHB1YmxpY0tleUJ1ZmZlci5ieXRlTGVuZ3RoICsgc2lnbmF0dXJlQnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXNwb25zZS5zZXQobmV3IFVpbnQ4QXJyYXkocHVibGljS2V5QnVmZmVyKSwgMCk7XG4gICAgICAgIHJlc3BvbnNlLnNldChuZXcgVWludDhBcnJheShzaWduYXR1cmVCdWZmZXIpLCBwdWJsaWNLZXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG4gICAgcmV0dXJuIHdpbmRvdy5idG9hKGlucHV0KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU0lXU01lc3NhZ2UocGF5bG9hZCkge1xuICAgIHJldHVybiBjcmVhdGVTaWduSW5NZXNzYWdlVGV4dChwYXlsb2FkKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNJV1NNZXNzYWdlQmFzZTY0KHBheWxvYWQpIHtcbiAgICByZXR1cm4gZW5jb2RlKGNyZWF0ZVNJV1NNZXNzYWdlKHBheWxvYWQpKTtcbn1cblxuLy8gb3B0aW9uYWwgZmVhdHVyZXNcbmNvbnN0IFNvbGFuYVNpZ25UcmFuc2FjdGlvbnMgPSAnc29sYW5hOnNpZ25UcmFuc2FjdGlvbnMnO1xuY29uc3QgU29sYW5hQ2xvbmVBdXRob3JpemF0aW9uID0gJ3NvbGFuYTpjbG9uZUF1dGhvcml6YXRpb24nO1xuY29uc3QgU29sYW5hU2lnbkluV2l0aFNvbGFuYSA9ICdzb2xhbmE6c2lnbkluV2l0aFNvbGFuYSc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBNb2JpbGVXYWxsZXR9IHByb3h5IHRoYXQgaGFuZGxlcyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBhbmQgQVBJIHRvIFJQQyBjb252ZXJzaW9uLlxuICpcbiAqIEBwYXJhbSBwcm90b2NvbFZlcnNpb24gdGhlIHByb3RvY29sIHZlcnNpb24gaW4gdXNlIGZvciB0aGlzIHNlc3Npb24vcmVxdWVzdFxuICogQHBhcmFtIHByb3RvY29sUmVxdWVzdEhhbmRsZXIgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBoYW5kbGVzIHNlbmRpbmcgdGhlIFJQQyByZXF1ZXN0IHRvIHRoZSB3YWxsZXQgZW5kcG9pbnQuXG4gKiBAcmV0dXJucyBhIHtAbGluayBNb2JpbGVXYWxsZXR9IHByb3h5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1vYmlsZVdhbGxldFByb3h5KHByb3RvY29sVmVyc2lvbiwgcHJvdG9jb2xSZXF1ZXN0SGFuZGxlcikge1xuICAgIHJldHVybiBuZXcgUHJveHkoe30sIHtcbiAgICAgICAgZ2V0KHRhcmdldCwgcCkge1xuICAgICAgICAgICAgaWYgKHRhcmdldFtwXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3BdID0gZnVuY3Rpb24gKGlucHV0UGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG1ldGhvZCwgcGFyYW1zIH0gPSBoYW5kbGVNb2JpbGVXYWxsZXRSZXF1ZXN0KHAsIGlucHV0UGFyYW1zLCBwcm90b2NvbFZlcnNpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgcHJvdG9jb2xSZXF1ZXN0SGFuZGxlcihtZXRob2QsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcmVxdWVzdCB0cmllZCB0byBzaWduIGluIGJ1dCB0aGUgd2FsbGV0IGRpZCBub3QgcmV0dXJuIGEgc2lnbiBpbiByZXN1bHQsIGZhbGxiYWNrIG9uIG1lc3NhZ2Ugc2lnbmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ2F1dGhvcml6ZScgJiYgcGFyYW1zLnNpZ25faW5fcGF5bG9hZCAmJiAhcmVzdWx0LnNpZ25faW5fcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0WydzaWduX2luX3Jlc3VsdCddID0geWllbGQgc2lnbkluRmFsbGJhY2socGFyYW1zLnNpZ25faW5fcGF5bG9hZCwgcmVzdWx0LCBwcm90b2NvbFJlcXVlc3RIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVNb2JpbGVXYWxsZXRSZXNwb25zZShwLCByZXN1bHQsIHByb3RvY29sVmVyc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0W3BdO1xuICAgICAgICB9LFxuICAgICAgICBkZWZpbmVQcm9wZXJ0eSgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVsZXRlUHJvcGVydHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIEhhbmRsZXMgYWxsIHtAbGluayBNb2JpbGVXYWxsZXR9IEFQSSByZXF1ZXN0cyBhbmQgZGV0ZXJtaW5lcyB0aGUgY29ycmVjdCBNV0EgUlBDIG1ldGhvZCBhbmQgcGFyYW1zIHRvIGNhbGwuXG4gKiBUaGlzIGhhbmRsZXMgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBAcHJvdG9jb2xWZXJzaW9uLlxuICpcbiAqIEBwYXJhbSBtZXRob2ROYW1lIHRoZSBuYW1lIG9mIHtAbGluayBNb2JpbGVXYWxsZXR9IG1ldGhvZCB0aGF0IHdhcyBjYWxsZWRcbiAqIEBwYXJhbSBtZXRob2RQYXJhbXMgdGhlIHBhcmFtZXRlcnMgdGhhdCB3ZXJlIHBhc3NlZCB0byB0aGUgbWV0aG9kXG4gKiBAcGFyYW0gcHJvdG9jb2xWZXJzaW9uIHRoZSBwcm90b2NvbCB2ZXJzaW9uIGluIHVzZSBmb3IgdGhpcyBzZXNzaW9uL3JlcXVlc3RcbiAqIEByZXR1cm5zIHRoZSBSUEMgcmVxdWVzdCBtZXRob2QgYW5kIHBhcmFtcyB0aGF0IHNob3VsZCBiZSBzZW50IHRvIHRoZSB3YWxsZXQgZW5kcG9pbnRcbiAqL1xuZnVuY3Rpb24gaGFuZGxlTW9iaWxlV2FsbGV0UmVxdWVzdChtZXRob2ROYW1lLCBtZXRob2RQYXJhbXMsIHByb3RvY29sVmVyc2lvbikge1xuICAgIGxldCBwYXJhbXMgPSBtZXRob2RQYXJhbXM7XG4gICAgbGV0IG1ldGhvZCA9IG1ldGhvZE5hbWVcbiAgICAgICAgLnRvU3RyaW5nKClcbiAgICAgICAgLnJlcGxhY2UoL1tBLVpdL2csIChsZXR0ZXIpID0+IGBfJHtsZXR0ZXIudG9Mb3dlckNhc2UoKX1gKVxuICAgICAgICAudG9Mb3dlckNhc2UoKTtcbiAgICBzd2l0Y2ggKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgY2FzZSAnYXV0aG9yaXplJzoge1xuICAgICAgICAgICAgbGV0IHsgY2hhaW4gfSA9IHBhcmFtcztcbiAgICAgICAgICAgIGlmIChwcm90b2NvbFZlcnNpb24gPT09ICdsZWdhY3knKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjaGFpbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzb2xhbmE6dGVzdG5ldCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluID0gJ3Rlc3RuZXQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc29sYW5hOmRldm5ldCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluID0gJ2Rldm5ldCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzb2xhbmE6bWFpbm5ldCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluID0gJ21haW5uZXQtYmV0YSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbiA9IHBhcmFtcy5jbHVzdGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmFtcy5jbHVzdGVyID0gY2hhaW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Rlc3RuZXQnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdkZXZuZXQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbiA9IGBzb2xhbmE6JHtjaGFpbn1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWFpbm5ldC1iZXRhJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW4gPSAnc29sYW5hOm1haW5uZXQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyYW1zLmNoYWluID0gY2hhaW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAncmVhdXRob3JpemUnOiB7XG4gICAgICAgICAgICBjb25zdCB7IGF1dGhfdG9rZW4sIGlkZW50aXR5IH0gPSBwYXJhbXM7XG4gICAgICAgICAgICBpZiAoYXV0aF90b2tlbikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvdG9jb2xWZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xlZ2FjeSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCA9ICdyZWF1dGhvcml6ZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSB7IGF1dGhfdG9rZW46IGF1dGhfdG9rZW4sIGlkZW50aXR5OiBpZGVudGl0eSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kID0gJ2F1dGhvcml6ZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG1ldGhvZCwgcGFyYW1zIH07XG59XG4vKipcbiAqIEhhbmRsZXMgYWxsIHtAbGluayBNb2JpbGVXYWxsZXR9IEFQSSByZXNwb25zZXMgYW5kIG1vZGlmaWVzIHRoZSByZXNwb25zZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIGlmIG5lZWRlZFxuICpcbiAqIEBwYXJhbSBtZXRob2QgdGhlIHtAbGluayBNb2JpbGVXYWxsZXR9IG1ldGhvZCB0aGF0IHdhcyBjYWxsZWRcbiAqIEBwYXJhbSByZXNwb25zZSB0aGUgb3JpZ2luYWwgcmVzcG9uc2UgdGhhdCB3YXMgcmV0dXJuZWQgYnkgdGhlIG1ldGhvZCBjYWxsXG4gKiBAcGFyYW0gcHJvdG9jb2xWZXJzaW9uIHRoZSBwcm90b2NvbCB2ZXJzaW9uIGluIHVzZSBmb3IgdGhpcyBzZXNzaW9uL3JlcXVlc3RcbiAqIEByZXR1cm5zIHRoZSBwb3NzaWJseSBtb2RpZmllZCByZXNwb25zZVxuICovXG5mdW5jdGlvbiBoYW5kbGVNb2JpbGVXYWxsZXRSZXNwb25zZShtZXRob2QsIHJlc3BvbnNlLCBwcm90b2NvbFZlcnNpb24pIHtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICBjYXNlICdnZXRDYXBhYmlsaXRpZXMnOiB7XG4gICAgICAgICAgICBjb25zdCBjYXBhYmlsaXRpZXMgPSByZXNwb25zZTtcbiAgICAgICAgICAgIHN3aXRjaCAocHJvdG9jb2xWZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbGVnYWN5Jzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmZWF0dXJlcyA9IFtTb2xhbmFTaWduVHJhbnNhY3Rpb25zXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhcGFiaWxpdGllcy5zdXBwb3J0c19jbG9uZV9hdXRob3JpemF0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlcy5wdXNoKFNvbGFuYUNsb25lQXV0aG9yaXphdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY2FwYWJpbGl0aWVzKSwgeyBmZWF0dXJlczogZmVhdHVyZXMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3YxJzoge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjYXBhYmlsaXRpZXMpLCB7IHN1cHBvcnRzX3NpZ25fYW5kX3NlbmRfdHJhbnNhY3Rpb25zOiB0cnVlLCBzdXBwb3J0c19jbG9uZV9hdXRob3JpemF0aW9uOiBjYXBhYmlsaXRpZXMuZmVhdHVyZXMuaW5jbHVkZXMoU29sYW5hQ2xvbmVBdXRob3JpemF0aW9uKSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xufVxuZnVuY3Rpb24gc2lnbkluRmFsbGJhY2soc2lnbkluUGF5bG9hZCwgYXV0aG9yaXphdGlvblJlc3VsdCwgcHJvdG9jb2xSZXF1ZXN0SGFuZGxlcikge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBkb21haW4gPSAoX2EgPSBzaWduSW5QYXlsb2FkLmRvbWFpbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogd2luZG93LmxvY2F0aW9uLmhvc3Q7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhdXRob3JpemF0aW9uUmVzdWx0LmFjY291bnRzWzBdLmFkZHJlc3M7XG4gICAgICAgIGNvbnN0IHNpd3NNZXNzYWdlID0gY3JlYXRlU0lXU01lc3NhZ2VCYXNlNjQoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzaWduSW5QYXlsb2FkKSwgeyBkb21haW4sIGFkZHJlc3MgfSkpO1xuICAgICAgICBjb25zdCBzaWduTWVzc2FnZVJlc3VsdCA9IHlpZWxkIHByb3RvY29sUmVxdWVzdEhhbmRsZXIoJ3NpZ25fbWVzc2FnZXMnLCB7XG4gICAgICAgICAgICBhZGRyZXNzZXM6IFthZGRyZXNzXSxcbiAgICAgICAgICAgIHBheWxvYWRzOiBbc2l3c01lc3NhZ2VdXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzaWduSW5SZXN1bHQgPSB7XG4gICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICAgICAgc2lnbmVkX21lc3NhZ2U6IHNpd3NNZXNzYWdlLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBzaWduTWVzc2FnZVJlc3VsdC5zaWduZWRfcGF5bG9hZHNbMF0uc2xpY2Uoc2l3c01lc3NhZ2UubGVuZ3RoKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc2lnbkluUmVzdWx0O1xuICAgIH0pO1xufVxuXG5jb25zdCBTRVFVRU5DRV9OVU1CRVJfQllURVMgPSA0O1xuZnVuY3Rpb24gY3JlYXRlU2VxdWVuY2VOdW1iZXJWZWN0b3Ioc2VxdWVuY2VOdW1iZXIpIHtcbiAgICBpZiAoc2VxdWVuY2VOdW1iZXIgPj0gNDI5NDk2NzI5Nikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ091dGJvdW5kIHNlcXVlbmNlIG51bWJlciBvdmVyZmxvdy4gVGhlIG1heGltdW0gc2VxdWVuY2UgbnVtYmVyIGlzIDMyLWJ5dGVzLicpO1xuICAgIH1cbiAgICBjb25zdCBieXRlQXJyYXkgPSBuZXcgQXJyYXlCdWZmZXIoU0VRVUVOQ0VfTlVNQkVSX0JZVEVTKTtcbiAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ5dGVBcnJheSk7XG4gICAgdmlldy5zZXRVaW50MzIoMCwgc2VxdWVuY2VOdW1iZXIsIC8qIGxpdHRsZUVuZGlhbiAqLyBmYWxzZSk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVBcnJheSk7XG59XG5cbmNvbnN0IElOSVRJQUxJWkFUSU9OX1ZFQ1RPUl9CWVRFUyA9IDEyO1xuY29uc3QgRU5DT0RFRF9QVUJMSUNfS0VZX0xFTkdUSF9CWVRFUyA9IDY1O1xuZnVuY3Rpb24gZW5jcnlwdE1lc3NhZ2UocGxhaW50ZXh0LCBzZXF1ZW5jZU51bWJlciwgc2hhcmVkU2VjcmV0KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3Qgc2VxdWVuY2VOdW1iZXJWZWN0b3IgPSBjcmVhdGVTZXF1ZW5jZU51bWJlclZlY3RvcihzZXF1ZW5jZU51bWJlcik7XG4gICAgICAgIGNvbnN0IGluaXRpYWxpemF0aW9uVmVjdG9yID0gbmV3IFVpbnQ4QXJyYXkoSU5JVElBTElaQVRJT05fVkVDVE9SX0JZVEVTKTtcbiAgICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhpbml0aWFsaXphdGlvblZlY3Rvcik7XG4gICAgICAgIGNvbnN0IGNpcGhlcnRleHQgPSB5aWVsZCBjcnlwdG8uc3VidGxlLmVuY3J5cHQoZ2V0QWxnb3JpdGhtUGFyYW1zKHNlcXVlbmNlTnVtYmVyVmVjdG9yLCBpbml0aWFsaXphdGlvblZlY3RvciksIHNoYXJlZFNlY3JldCwgbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHBsYWludGV4dCkpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IG5ldyBVaW50OEFycmF5KHNlcXVlbmNlTnVtYmVyVmVjdG9yLmJ5dGVMZW5ndGggKyBpbml0aWFsaXphdGlvblZlY3Rvci5ieXRlTGVuZ3RoICsgY2lwaGVydGV4dC5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmVzcG9uc2Uuc2V0KG5ldyBVaW50OEFycmF5KHNlcXVlbmNlTnVtYmVyVmVjdG9yKSwgMCk7XG4gICAgICAgIHJlc3BvbnNlLnNldChuZXcgVWludDhBcnJheShpbml0aWFsaXphdGlvblZlY3RvciksIHNlcXVlbmNlTnVtYmVyVmVjdG9yLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXNwb25zZS5zZXQobmV3IFVpbnQ4QXJyYXkoY2lwaGVydGV4dCksIHNlcXVlbmNlTnVtYmVyVmVjdG9yLmJ5dGVMZW5ndGggKyBpbml0aWFsaXphdGlvblZlY3Rvci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZGVjcnlwdE1lc3NhZ2UobWVzc2FnZSwgc2hhcmVkU2VjcmV0KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3Qgc2VxdWVuY2VOdW1iZXJWZWN0b3IgPSBtZXNzYWdlLnNsaWNlKDAsIFNFUVVFTkNFX05VTUJFUl9CWVRFUyk7XG4gICAgICAgIGNvbnN0IGluaXRpYWxpemF0aW9uVmVjdG9yID0gbWVzc2FnZS5zbGljZShTRVFVRU5DRV9OVU1CRVJfQllURVMsIFNFUVVFTkNFX05VTUJFUl9CWVRFUyArIElOSVRJQUxJWkFUSU9OX1ZFQ1RPUl9CWVRFUyk7XG4gICAgICAgIGNvbnN0IGNpcGhlcnRleHQgPSBtZXNzYWdlLnNsaWNlKFNFUVVFTkNFX05VTUJFUl9CWVRFUyArIElOSVRJQUxJWkFUSU9OX1ZFQ1RPUl9CWVRFUyk7XG4gICAgICAgIGNvbnN0IHBsYWludGV4dEJ1ZmZlciA9IHlpZWxkIGNyeXB0by5zdWJ0bGUuZGVjcnlwdChnZXRBbGdvcml0aG1QYXJhbXMoc2VxdWVuY2VOdW1iZXJWZWN0b3IsIGluaXRpYWxpemF0aW9uVmVjdG9yKSwgc2hhcmVkU2VjcmV0LCBjaXBoZXJ0ZXh0KTtcbiAgICAgICAgY29uc3QgcGxhaW50ZXh0ID0gZ2V0VXRmOERlY29kZXIoKS5kZWNvZGUocGxhaW50ZXh0QnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldEFsZ29yaXRobVBhcmFtcyhzZXF1ZW5jZU51bWJlciwgaW5pdGlhbGl6YXRpb25WZWN0b3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRpdGlvbmFsRGF0YTogc2VxdWVuY2VOdW1iZXIsXG4gICAgICAgIGl2OiBpbml0aWFsaXphdGlvblZlY3RvcixcbiAgICAgICAgbmFtZTogJ0FFUy1HQ00nLFxuICAgICAgICB0YWdMZW5ndGg6IDEyOCwgLy8gMTYgYnl0ZSB0YWcgPT4gMTI4IGJpdHNcbiAgICB9O1xufVxubGV0IF91dGY4RGVjb2RlcjtcbmZ1bmN0aW9uIGdldFV0ZjhEZWNvZGVyKCkge1xuICAgIGlmIChfdXRmOERlY29kZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBfdXRmOERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi04Jyk7XG4gICAgfVxuICAgIHJldHVybiBfdXRmOERlY29kZXI7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQXNzb2NpYXRpb25LZXlwYWlyKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHJldHVybiB5aWVsZCBjcnlwdG8uc3VidGxlLmdlbmVyYXRlS2V5KHtcbiAgICAgICAgICAgIG5hbWU6ICdFQ0RTQScsXG4gICAgICAgICAgICBuYW1lZEN1cnZlOiAnUC0yNTYnLFxuICAgICAgICB9LCBmYWxzZSAvKiBleHRyYWN0YWJsZSAqLywgWydzaWduJ10gLyoga2V5VXNhZ2VzICovKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVFQ0RIS2V5cGFpcigpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICByZXR1cm4geWllbGQgY3J5cHRvLnN1YnRsZS5nZW5lcmF0ZUtleSh7XG4gICAgICAgICAgICBuYW1lOiAnRUNESCcsXG4gICAgICAgICAgICBuYW1lZEN1cnZlOiAnUC0yNTYnLFxuICAgICAgICB9LCBmYWxzZSAvKiBleHRyYWN0YWJsZSAqLywgWydkZXJpdmVLZXknLCAnZGVyaXZlQml0cyddIC8qIGtleVVzYWdlcyAqLyk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGVuY3J5cHRKc29uUnBjTWVzc2FnZShqc29uUnBjTWVzc2FnZSwgc2hhcmVkU2VjcmV0KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgcGxhaW50ZXh0ID0gSlNPTi5zdHJpbmdpZnkoanNvblJwY01lc3NhZ2UpO1xuICAgICAgICBjb25zdCBzZXF1ZW5jZU51bWJlciA9IGpzb25ScGNNZXNzYWdlLmlkO1xuICAgICAgICByZXR1cm4gZW5jcnlwdE1lc3NhZ2UocGxhaW50ZXh0LCBzZXF1ZW5jZU51bWJlciwgc2hhcmVkU2VjcmV0KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGRlY3J5cHRKc29uUnBjTWVzc2FnZShtZXNzYWdlLCBzaGFyZWRTZWNyZXQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBwbGFpbnRleHQgPSB5aWVsZCBkZWNyeXB0TWVzc2FnZShtZXNzYWdlLCBzaGFyZWRTZWNyZXQpO1xuICAgICAgICBjb25zdCBqc29uUnBjTWVzc2FnZSA9IEpTT04ucGFyc2UocGxhaW50ZXh0KTtcbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGpzb25ScGNNZXNzYWdlLCAnZXJyb3InKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJQcm90b2NvbEVycm9yKGpzb25ScGNNZXNzYWdlLmlkLCBqc29uUnBjTWVzc2FnZS5lcnJvci5jb2RlLCBqc29uUnBjTWVzc2FnZS5lcnJvci5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNvblJwY01lc3NhZ2U7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlSGVsbG9Sc3AocGF5bG9hZEJ1ZmZlciwgLy8gVGhlIFg5LjYyLWVuY29kZWQgd2FsbGV0IGVuZHBvaW50IGVwaGVtZXJhbCBFQ0RIIHB1YmxpYyBrZXlwb2ludC5cbmFzc29jaWF0aW9uUHVibGljS2V5LCBlY2RoUHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IFthc3NvY2lhdGlvblB1YmxpY0tleUJ1ZmZlciwgd2FsbGV0UHVibGljS2V5XSA9IHlpZWxkIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIGNyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KCdyYXcnLCBhc3NvY2lhdGlvblB1YmxpY0tleSksXG4gICAgICAgICAgICBjcnlwdG8uc3VidGxlLmltcG9ydEtleSgncmF3JywgcGF5bG9hZEJ1ZmZlci5zbGljZSgwLCBFTkNPREVEX1BVQkxJQ19LRVlfTEVOR1RIX0JZVEVTKSwgeyBuYW1lOiAnRUNESCcsIG5hbWVkQ3VydmU6ICdQLTI1NicgfSwgZmFsc2UgLyogZXh0cmFjdGFibGUgKi8sIFtdIC8qIGtleVVzYWdlcyAqLyksXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBzaGFyZWRTZWNyZXQgPSB5aWVsZCBjcnlwdG8uc3VidGxlLmRlcml2ZUJpdHMoeyBuYW1lOiAnRUNESCcsIHB1YmxpYzogd2FsbGV0UHVibGljS2V5IH0sIGVjZGhQcml2YXRlS2V5LCAyNTYpO1xuICAgICAgICBjb25zdCBlY2RoU2VjcmV0S2V5ID0geWllbGQgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIHNoYXJlZFNlY3JldCwgJ0hLREYnLCBmYWxzZSAvKiBleHRyYWN0YWJsZSAqLywgWydkZXJpdmVLZXknXSAvKiBrZXlVc2FnZXMgKi8pO1xuICAgICAgICBjb25zdCBhZXNLZXlNYXRlcmlhbFZhbCA9IHlpZWxkIGNyeXB0by5zdWJ0bGUuZGVyaXZlS2V5KHtcbiAgICAgICAgICAgIG5hbWU6ICdIS0RGJyxcbiAgICAgICAgICAgIGhhc2g6ICdTSEEtMjU2JyxcbiAgICAgICAgICAgIHNhbHQ6IG5ldyBVaW50OEFycmF5KGFzc29jaWF0aW9uUHVibGljS2V5QnVmZmVyKSxcbiAgICAgICAgICAgIGluZm86IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIH0sIGVjZGhTZWNyZXRLZXksIHsgbmFtZTogJ0FFUy1HQ00nLCBsZW5ndGg6IDEyOCB9LCBmYWxzZSAvKiBleHRyYWN0YWJsZSAqLywgWydlbmNyeXB0JywgJ2RlY3J5cHQnXSk7XG4gICAgICAgIHJldHVybiBhZXNLZXlNYXRlcmlhbFZhbDtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcGFyc2VTZXNzaW9uUHJvcHMobWVzc2FnZSwgc2hhcmVkU2VjcmV0KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgcGxhaW50ZXh0ID0geWllbGQgZGVjcnlwdE1lc3NhZ2UobWVzc2FnZSwgc2hhcmVkU2VjcmV0KTtcbiAgICAgICAgY29uc3QganNvblByb3BlcnRpZXMgPSBKU09OLnBhcnNlKHBsYWludGV4dCk7XG4gICAgICAgIGxldCBwcm90b2NvbFZlcnNpb24gPSAnbGVnYWN5JztcbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGpzb25Qcm9wZXJ0aWVzLCAndicpKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGpzb25Qcm9wZXJ0aWVzLnYpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgY2FzZSAnMSc6XG4gICAgICAgICAgICAgICAgY2FzZSAndjEnOlxuICAgICAgICAgICAgICAgICAgICBwcm90b2NvbFZlcnNpb24gPSAndjEnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdsZWdhY3knOlxuICAgICAgICAgICAgICAgICAgICBwcm90b2NvbFZlcnNpb24gPSAnbGVnYWN5JztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcihTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLkVSUk9SX0lOVkFMSURfUFJPVE9DT0xfVkVSU0lPTiwgYFVua25vd24vdW5zdXBwb3J0ZWQgcHJvdG9jb2wgdmVyc2lvbjogJHtqc29uUHJvcGVydGllcy52fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgcHJvdG9jb2xfdmVyc2lvbjogcHJvdG9jb2xWZXJzaW9uXG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRSYW5kb21Bc3NvY2lhdGlvblBvcnQoKSB7XG4gICAgcmV0dXJuIGFzc2VydEFzc29jaWF0aW9uUG9ydCg0OTE1MiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICg2NTUzNSAtIDQ5MTUyICsgMSkpKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEFzc29jaWF0aW9uUG9ydChwb3J0KSB7XG4gICAgaWYgKHBvcnQgPCA0OTE1MiB8fCBwb3J0ID4gNjU1MzUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcihTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLkVSUk9SX0FTU09DSUFUSU9OX1BPUlRfT1VUX09GX1JBTkdFLCBgQXNzb2NpYXRpb24gcG9ydCBudW1iZXIgbXVzdCBiZSBiZXR3ZWVuIDQ5MTUyIGFuZCA2NTUzNS4gJHtwb3J0fSBnaXZlbi5gLCB7IHBvcnQgfSk7XG4gICAgfVxuICAgIHJldHVybiBwb3J0O1xufVxuXG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvOTQ1ODk5Ni84MDIwNDdcbmZ1bmN0aW9uIGFycmF5QnVmZmVyVG9CYXNlNjRTdHJpbmcoYnVmZmVyKSB7XG4gICAgbGV0IGJpbmFyeSA9ICcnO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBjb25zdCBsZW4gPSBieXRlcy5ieXRlTGVuZ3RoO1xuICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCBsZW47IGlpKyspIHtcbiAgICAgICAgYmluYXJ5ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaWldKTtcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdy5idG9hKGJpbmFyeSk7XG59XG5cbmZ1bmN0aW9uIGdldFN0cmluZ1dpdGhVUkxVbnNhZmVDaGFyYWN0ZXJzUmVwbGFjZWQodW5zYWZlQmFzZTY0RW5jb2RlZFN0cmluZykge1xuICAgIHJldHVybiB1bnNhZmVCYXNlNjRFbmNvZGVkU3RyaW5nLnJlcGxhY2UoL1svKz1dL2csIChtKSA9PiAoe1xuICAgICAgICAnLyc6ICdfJyxcbiAgICAgICAgJysnOiAnLScsXG4gICAgICAgICc9JzogJy4nLFxuICAgIH1bbV0pKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmFuZG9tUmVmbGVjdG9ySWQoKSB7XG4gICAgcmV0dXJuIGFzc2VydFJlZmxlY3RvcklkKGdldFJhbmRvbUludCgwLCA5MDA3MTk5MjU0NzQwOTkxKSk7IC8vIDAgPCBpZCA8IDJeNTMgLSAxXG59XG5mdW5jdGlvbiBnZXRSYW5kb21JbnQobWluLCBtYXgpIHtcbiAgICBjb25zdCByYW5kb21CdWZmZXIgPSBuZXcgVWludDMyQXJyYXkoMSk7XG4gICAgd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMocmFuZG9tQnVmZmVyKTtcbiAgICBsZXQgcmFuZG9tTnVtYmVyID0gcmFuZG9tQnVmZmVyWzBdIC8gKDB4ZmZmZmZmZmYgKyAxKTtcbiAgICBtaW4gPSBNYXRoLmNlaWwobWluKTtcbiAgICBtYXggPSBNYXRoLmZsb29yKG1heCk7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IocmFuZG9tTnVtYmVyICogKG1heCAtIG1pbiArIDEpKSArIG1pbjtcbn1cbmZ1bmN0aW9uIGFzc2VydFJlZmxlY3RvcklkKGlkKSB7XG4gICAgaWYgKGlkIDwgMCB8fCBpZCA+IDkwMDcxOTkyNTQ3NDA5OTEpIHsgLy8gMCA8IGlkIDwgMl41MyAtIDFcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcihTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLkVSUk9SX1JFRkxFQ1RPUl9JRF9PVVRfT0ZfUkFOR0UsIGBBc3NvY2lhdGlvbiBwb3J0IG51bWJlciBtdXN0IGJlIGJldHdlZW4gNDkxNTIgYW5kIDY1NTM1LiAke2lkfSBnaXZlbi5gLCB7IGlkIH0pO1xuICAgIH1cbiAgICByZXR1cm4gaWQ7XG59XG5cbmNvbnN0IElOVEVOVF9OQU1FID0gJ3NvbGFuYS13YWxsZXQnO1xuZnVuY3Rpb24gZ2V0UGF0aFBhcnRzKHBhdGhTdHJpbmcpIHtcbiAgICByZXR1cm4gKHBhdGhTdHJpbmdcbiAgICAgICAgLy8gU3RyaXAgbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlc1xuICAgICAgICAucmVwbGFjZSgvKF5cXC8rfFxcLyskKS9nLCAnJylcbiAgICAgICAgLy8gUmV0dXJuIGFuIGFycmF5IG9mIGRpcmVjdG9yaWVzXG4gICAgICAgIC5zcGxpdCgnLycpKTtcbn1cbmZ1bmN0aW9uIGdldEludGVudFVSTChtZXRob2RQYXRobmFtZSwgaW50ZW50VXJsQmFzZSkge1xuICAgIGxldCBiYXNlVXJsID0gbnVsbDtcbiAgICBpZiAoaW50ZW50VXJsQmFzZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYmFzZVVybCA9IG5ldyBVUkwoaW50ZW50VXJsQmFzZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuICAgICAgICBpZiAoKGJhc2VVcmwgPT09IG51bGwgfHwgYmFzZVVybCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmFzZVVybC5wcm90b2NvbCkgIT09ICdodHRwczonKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yKFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvckNvZGUuRVJST1JfRk9SQklEREVOX1dBTExFVF9CQVNFX1VSTCwgJ0Jhc2UgVVJMcyBzdXBwbGllZCBieSB3YWxsZXRzIG11c3QgYmUgdmFsaWQgYGh0dHBzYCBVUkxzJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYmFzZVVybCB8fCAoYmFzZVVybCA9IG5ldyBVUkwoYCR7SU5URU5UX05BTUV9Oi9gKSk7XG4gICAgY29uc3QgcGF0aG5hbWUgPSBtZXRob2RQYXRobmFtZS5zdGFydHNXaXRoKCcvJylcbiAgICAgICAgPyAvLyBNZXRob2QgaXMgYW4gYWJzb2x1dGUgcGF0aC4gUmVwbGFjZSBpdCB3aG9sZXNhbGUuXG4gICAgICAgICAgICBtZXRob2RQYXRobmFtZVxuICAgICAgICA6IC8vIE1ldGhvZCBpcyBhIHJlbGF0aXZlIHBhdGguIE1lcmdlIGl0IHdpdGggdGhlIGV4aXN0aW5nIG9uZS5cbiAgICAgICAgICAgIFsuLi5nZXRQYXRoUGFydHMoYmFzZVVybC5wYXRobmFtZSksIC4uLmdldFBhdGhQYXJ0cyhtZXRob2RQYXRobmFtZSldLmpvaW4oJy8nKTtcbiAgICByZXR1cm4gbmV3IFVSTChwYXRobmFtZSwgYmFzZVVybCk7XG59XG5mdW5jdGlvbiBnZXRBc3NvY2lhdGVBbmRyb2lkSW50ZW50VVJMKGFzc29jaWF0aW9uUHVibGljS2V5LCBwdXRhdGl2ZVBvcnQsIGFzc29jaWF0aW9uVVJMQmFzZSwgcHJvdG9jb2xWZXJzaW9ucyA9IFsndjEnXSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IGFzc29jaWF0aW9uUG9ydCA9IGFzc2VydEFzc29jaWF0aW9uUG9ydChwdXRhdGl2ZVBvcnQpO1xuICAgICAgICBjb25zdCBleHBvcnRlZEtleSA9IHlpZWxkIGNyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KCdyYXcnLCBhc3NvY2lhdGlvblB1YmxpY0tleSk7XG4gICAgICAgIGNvbnN0IGVuY29kZWRLZXkgPSBhcnJheUJ1ZmZlclRvQmFzZTY0U3RyaW5nKGV4cG9ydGVkS2V5KTtcbiAgICAgICAgY29uc3QgdXJsID0gZ2V0SW50ZW50VVJMKCd2MS9hc3NvY2lhdGUvbG9jYWwnLCBhc3NvY2lhdGlvblVSTEJhc2UpO1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnYXNzb2NpYXRpb24nLCBnZXRTdHJpbmdXaXRoVVJMVW5zYWZlQ2hhcmFjdGVyc1JlcGxhY2VkKGVuY29kZWRLZXkpKTtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3BvcnQnLCBgJHthc3NvY2lhdGlvblBvcnR9YCk7XG4gICAgICAgIHByb3RvY29sVmVyc2lvbnMuZm9yRWFjaCgodmVyc2lvbikgPT4ge1xuICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3YnLCB2ZXJzaW9uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRSZW1vdGVBc3NvY2lhdGVBbmRyb2lkSW50ZW50VVJMKGFzc29jaWF0aW9uUHVibGljS2V5LCBob3N0QXV0aG9yaXR5LCBwdXRhdGl2ZUlkLCBhc3NvY2lhdGlvblVSTEJhc2UsIHByb3RvY29sVmVyc2lvbnMgPSBbJ3YxJ10pIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCByZWZsZWN0b3JJZCA9IGFzc2VydFJlZmxlY3RvcklkKHB1dGF0aXZlSWQpO1xuICAgICAgICBjb25zdCBleHBvcnRlZEtleSA9IHlpZWxkIGNyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KCdyYXcnLCBhc3NvY2lhdGlvblB1YmxpY0tleSk7XG4gICAgICAgIGNvbnN0IGVuY29kZWRLZXkgPSBhcnJheUJ1ZmZlclRvQmFzZTY0U3RyaW5nKGV4cG9ydGVkS2V5KTtcbiAgICAgICAgY29uc3QgdXJsID0gZ2V0SW50ZW50VVJMKCd2MS9hc3NvY2lhdGUvcmVtb3RlJywgYXNzb2NpYXRpb25VUkxCYXNlKTtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2Fzc29jaWF0aW9uJywgZ2V0U3RyaW5nV2l0aFVSTFVuc2FmZUNoYXJhY3RlcnNSZXBsYWNlZChlbmNvZGVkS2V5KSk7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdyZWZsZWN0b3InLCBgJHtob3N0QXV0aG9yaXR5fWApO1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnaWQnLCBgJHtyZWZsZWN0b3JJZH1gKTtcbiAgICAgICAgcHJvdG9jb2xWZXJzaW9ucy5mb3JFYWNoKCh2ZXJzaW9uKSA9PiB7XG4gICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgndicsIHZlcnNpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9KTtcbn1cblxuLy8gVHlwZXNjcmlwdCBgZW51bXNgIHRod2FydCB0cmVlLXNoYWtpbmcuIFNlZSBodHRwczovL2JhcmdzdGVuLm9yZy9qc3RzL2VudW1zL1xuY29uc3QgQnJvd3NlciA9IHtcbiAgICBGaXJlZm94OiAwLFxuICAgIE90aGVyOiAxLFxufTtcbmZ1bmN0aW9uIGFzc2VydFVucmVhY2hhYmxlKHgpIHtcbiAgICByZXR1cm4geDtcbn1cbmZ1bmN0aW9uIGdldEJyb3dzZXIoKSB7XG4gICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveC8nKSAhPT0gLTEgPyBCcm93c2VyLkZpcmVmb3ggOiBCcm93c2VyLk90aGVyO1xufVxuZnVuY3Rpb24gZ2V0RGV0ZWN0aW9uUHJvbWlzZSgpIHtcbiAgICAvLyBDaHJvbWUgYW5kIG90aGVycyBzaWxlbnRseSBmYWlsIGlmIGEgY3VzdG9tIHByb3RvY29sIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAgLy8gRm9yIHRoZXNlLCB3ZSB3YWl0IHRvIHNlZSBpZiB0aGUgYnJvd3NlciBpcyBuYXZpZ2F0ZWQgYXdheSBmcm9tIGluXG4gICAgLy8gYSByZWFzb25hYmxlIGFtb3VudCBvZiB0aW1lIChpZS4gdGhlIG5hdGl2ZSB3YWxsZXQgb3BlbmVkKS5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIGhhbmRsZUJsdXIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZUJsdXIoKSB7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBoYW5kbGVCbHVyKTtcbiAgICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgfSwgMjAwMCk7XG4gICAgfSk7XG59XG5sZXQgX2ZyYW1lID0gbnVsbDtcbmZ1bmN0aW9uIGxhdW5jaFVybFRocm91Z2hIaWRkZW5GcmFtZSh1cmwpIHtcbiAgICBpZiAoX2ZyYW1lID09IG51bGwpIHtcbiAgICAgICAgX2ZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICAgIF9mcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKF9mcmFtZSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgX2ZyYW1lLmNvbnRlbnRXaW5kb3cubG9jYXRpb24uaHJlZiA9IHVybC50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gbGF1bmNoQXNzb2NpYXRpb24oYXNzb2NpYXRpb25VcmwpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBpZiAoYXNzb2NpYXRpb25VcmwucHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgICAgICAgICAvLyBUaGUgYXNzb2NpYXRpb24gVVJMIGlzIGFuIEFuZHJvaWQgJ0FwcCBMaW5rJyBvciBpT1MgJ1VuaXZlcnNhbCBMaW5rJy5cbiAgICAgICAgICAgIC8vIFRoZXNlIGFyZSByZWd1bGFyIHdlYiBVUkxzIHRoYXQgYXJlIGRlc2lnbmVkIHRvIGxhdW5jaCBhbiBhcHAgaWYgaXRcbiAgICAgICAgICAgIC8vIGlzIGluc3RhbGxlZCBvciBsb2FkIHRoZSBhY3R1YWwgdGFyZ2V0IHdlYnBhZ2UgaWYgbm90LlxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbihhc3NvY2lhdGlvblVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGUgYXNzb2NpYXRpb24gVVJMIGhhcyBhIGN1c3RvbSBwcm90b2NvbCAoZWcuIGBzb2xhbmEtd2FsbGV0OmApXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJyb3dzZXIgPSBnZXRCcm93c2VyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChicm93c2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQnJvd3Nlci5GaXJlZm94OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBjdXN0b20gcHJvdG9jb2wgaXMgbm90IHN1cHBvcnRlZCBpbiBGaXJlZm94LCBpdCB0aHJvd3MuXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXVuY2hVcmxUaHJvdWdoSGlkZGVuRnJhbWUoYXNzb2NpYXRpb25VcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCB0aGlzIGxpbmUsIGl0J3Mgc3VwcG9ydGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQnJvd3Nlci5PdGhlcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGV0ZWN0aW9uUHJvbWlzZSA9IGdldERldGVjdGlvblByb21pc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24oYXNzb2NpYXRpb25VcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgZGV0ZWN0aW9uUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRVbnJlYWNoYWJsZShicm93c2VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3IoU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yQ29kZS5FUlJPUl9XQUxMRVRfTk9UX0ZPVU5ELCAnRm91bmQgbm8gaW5zdGFsbGVkIHdhbGxldCB0aGF0IHN1cHBvcnRzIHRoZSBtb2JpbGUgd2FsbGV0IHByb3RvY29sLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzdGFydFNlc3Npb24oYXNzb2NpYXRpb25QdWJsaWNLZXksIGFzc29jaWF0aW9uVVJMQmFzZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHJhbmRvbUFzc29jaWF0aW9uUG9ydCA9IGdldFJhbmRvbUFzc29jaWF0aW9uUG9ydCgpO1xuICAgICAgICBjb25zdCBhc3NvY2lhdGlvblVybCA9IHlpZWxkIGdldEFzc29jaWF0ZUFuZHJvaWRJbnRlbnRVUkwoYXNzb2NpYXRpb25QdWJsaWNLZXksIHJhbmRvbUFzc29jaWF0aW9uUG9ydCwgYXNzb2NpYXRpb25VUkxCYXNlKTtcbiAgICAgICAgeWllbGQgbGF1bmNoQXNzb2NpYXRpb24oYXNzb2NpYXRpb25VcmwpO1xuICAgICAgICByZXR1cm4gcmFuZG9tQXNzb2NpYXRpb25Qb3J0O1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0UmVtb3RlU2Vzc2lvblVybChhc3NvY2lhdGlvblB1YmxpY0tleSwgaG9zdEF1dGhvcml0eSwgYXNzb2NpYXRpb25VUkxCYXNlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgcmFuZG9tUmVmbGVjdG9ySWQgPSBnZXRSYW5kb21SZWZsZWN0b3JJZCgpO1xuICAgICAgICBjb25zdCBhc3NvY2lhdGlvblVybCA9IHlpZWxkIGdldFJlbW90ZUFzc29jaWF0ZUFuZHJvaWRJbnRlbnRVUkwoYXNzb2NpYXRpb25QdWJsaWNLZXksIGhvc3RBdXRob3JpdHksIHJhbmRvbVJlZmxlY3RvcklkLCBhc3NvY2lhdGlvblVSTEJhc2UpO1xuICAgICAgICByZXR1cm4geyBhc3NvY2lhdGlvblVybCwgcmVmbGVjdG9ySWQ6IHJhbmRvbVJlZmxlY3RvcklkIH07XG4gICAgfSk7XG59XG5cbmNvbnN0IFdFQlNPQ0tFVF9DT05ORUNUSU9OX0NPTkZJRyA9IHtcbiAgICAvKipcbiAgICAgKiAzMDAgbWlsbGlzZWNvbmRzIGlzIGEgZ2VuZXJhbGx5IGFjY2VwdGVkIHRocmVzaG9sZCBmb3Igd2hhdCBzb21lb25lXG4gICAgICogd291bGQgY29uc2lkZXIgYW4gYWNjZXB0YWJsZSByZXNwb25zZSB0aW1lIGZvciBhIHVzZXIgaW50ZXJmYWNlXG4gICAgICogYWZ0ZXIgaGF2aW5nIHBlcmZvcm1lZCBhIGxvdy1hdHRlbnRpb24gdGFwcGluZyB0YXNrLiBXZSBzZXQgdGhlIGluaXRpYWxcbiAgICAgKiBpbnRlcnZhbCBhdCB3aGljaCB3ZSB3YWl0IGZvciB0aGUgd2FsbGV0IHRvIHNldCB1cCB0aGUgd2Vic29ja2V0IGF0XG4gICAgICogaGFsZiB0aGlzLCBhcyBwZXIgdGhlIE55cXVpc3QgZnJlcXVlbmN5LCB3aXRoIGEgcHJvZ3Jlc3NpdmUgYmFja29mZlxuICAgICAqIHNlcXVlbmNlIGZyb20gdGhlcmUuIFRoZSB0b3RhbCB3YWl0IHRpbWUgaXMgMzBzLCB3aGljaCBhbGxvd3MgZm9yIHRoZVxuICAgICAqIHVzZXIgdG8gYmUgcHJlc2VudGVkIHdpdGggYSBkaXNhbWJpZ3VhdGlvbiBkaWFsb2csIHNlbGVjdCBhIHdhbGxldCwgYW5kXG4gICAgICogZm9yIHRoZSB3YWxsZXQgYXBwIHRvIHN1YnNlcXVlbnRseSBzdGFydC5cbiAgICAgKi9cbiAgICByZXRyeURlbGF5U2NoZWR1bGVNczogWzE1MCwgMTUwLCAyMDAsIDUwMCwgNTAwLCA3NTAsIDc1MCwgMTAwMF0sXG4gICAgdGltZW91dE1zOiAzMDAwMCxcbn07XG5jb25zdCBXRUJTT0NLRVRfUFJPVE9DT0wgPSAnY29tLnNvbGFuYS5tb2JpbGV3YWxsZXRhZGFwdGVyLnYxJztcbmZ1bmN0aW9uIGFzc2VydFNlY3VyZUNvbnRleHQoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8IHdpbmRvdy5pc1NlY3VyZUNvbnRleHQgIT09IHRydWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcihTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLkVSUk9SX1NFQ1VSRV9DT05URVhUX1JFUVVJUkVELCAnVGhlIG1vYmlsZSB3YWxsZXQgYWRhcHRlciBwcm90b2NvbCBtdXN0IGJlIHVzZWQgaW4gYSBzZWN1cmUgY29udGV4dCAoYGh0dHBzYCkuJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0U2VjdXJlRW5kcG9pbnRTcGVjaWZpY1VSSSh3YWxsZXRVcmlCYXNlKSB7XG4gICAgbGV0IHVybDtcbiAgICB0cnkge1xuICAgICAgICB1cmwgPSBuZXcgVVJMKHdhbGxldFVyaUJhc2UpO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcihTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLkVSUk9SX0ZPUkJJRERFTl9XQUxMRVRfQkFTRV9VUkwsICdJbnZhbGlkIGJhc2UgVVJMIHN1cHBsaWVkIGJ5IHdhbGxldCcpO1xuICAgIH1cbiAgICBpZiAodXJsLnByb3RvY29sICE9PSAnaHR0cHM6Jykge1xuICAgICAgICB0aHJvdyBuZXcgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yKFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvckNvZGUuRVJST1JfRk9SQklEREVOX1dBTExFVF9CQVNFX1VSTCwgJ0Jhc2UgVVJMcyBzdXBwbGllZCBieSB3YWxsZXRzIG11c3QgYmUgdmFsaWQgYGh0dHBzYCBVUkxzJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0U2VxdWVuY2VOdW1iZXJGcm9tQnl0ZUFycmF5KGJ5dGVBcnJheSkge1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnl0ZUFycmF5KTtcbiAgICByZXR1cm4gdmlldy5nZXRVaW50MzIoMCwgLyogbGl0dGxlRW5kaWFuICovIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHRyYW5zYWN0KGNhbGxiYWNrLCBjb25maWcpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBhc3NlcnRTZWN1cmVDb250ZXh0KCk7XG4gICAgICAgIGNvbnN0IGFzc29jaWF0aW9uS2V5cGFpciA9IHlpZWxkIGdlbmVyYXRlQXNzb2NpYXRpb25LZXlwYWlyKCk7XG4gICAgICAgIGNvbnN0IHNlc3Npb25Qb3J0ID0geWllbGQgc3RhcnRTZXNzaW9uKGFzc29jaWF0aW9uS2V5cGFpci5wdWJsaWNLZXksIGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5iYXNlVXJpKTtcbiAgICAgICAgY29uc3Qgd2Vic29ja2V0VVJMID0gYHdzOi8vbG9jYWxob3N0OiR7c2Vzc2lvblBvcnR9L3NvbGFuYS13YWxsZXRgO1xuICAgICAgICBsZXQgY29ubmVjdGlvblN0YXJ0VGltZTtcbiAgICAgICAgY29uc3QgZ2V0TmV4dFJldHJ5RGVsYXlNcyA9ICgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY2hlZHVsZSA9IFsuLi5XRUJTT0NLRVRfQ09OTkVDVElPTl9DT05GSUcucmV0cnlEZWxheVNjaGVkdWxlTXNdO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IChzY2hlZHVsZS5sZW5ndGggPiAxID8gc2NoZWR1bGUuc2hpZnQoKSA6IHNjaGVkdWxlWzBdKTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgbGV0IG5leHRKc29uUnBjTWVzc2FnZUlkID0gMTtcbiAgICAgICAgbGV0IGxhc3RLbm93bkluYm91bmRTZXF1ZW5jZU51bWJlciA9IDA7XG4gICAgICAgIGxldCBzdGF0ZSA9IHsgX190eXBlOiAnZGlzY29ubmVjdGVkJyB9O1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbGV0IHNvY2tldDtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBjb25zdCBqc29uUnBjUmVzcG9uc2VQcm9taXNlcyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlT3BlbiA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuX190eXBlICE9PSAnY29ubmVjdGluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdFeHBlY3RlZCBhZGFwdGVyIHN0YXRlIHRvIGJlIGBjb25uZWN0aW5nYCBhdCB0aGUgbW9tZW50IHRoZSB3ZWJzb2NrZXQgb3BlbnMuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYEdvdCBcXGAke3N0YXRlLl9fdHlwZX1cXGAuYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29wZW4nLCBoYW5kbGVPcGVuKTtcbiAgICAgICAgICAgICAgICAvLyBwcmV2aW91cyB2ZXJzaW9ucyBvZiB0aGlzIGxpYnJhcnkgYW5kIHdhbGxldGxpYiBpbmNvcnJlY3RseSBpbXBsZW1lbnRlZCB0aGUgTVdBIHNlc3Npb24gXG4gICAgICAgICAgICAgICAgLy8gZXN0YWJsaXNobWVudCBwcm90b2NvbCBmb3IgbG9jYWwgY29ubmVjdGlvbnMuIFRoZSBkYXBwIGlzIHN1cHBvc2VkIHRvIHdhaXQgZm9yIHRoZSBcbiAgICAgICAgICAgICAgICAvLyBBUFBfUElORyBtZXNzYWdlIGJlZm9yZSBzZW5kaW5nIHRoZSBIRUxMT19SRVEuIEluc3RlYWQsIHRoZSBkYXBwIHdhcyBzZW5kaW5nIHRoZSBIRUxMT19SRVEgXG4gICAgICAgICAgICAgICAgLy8gaW1tZWRpYXRlbHkgdXBvbiBjb25uZWN0aW9uIHRvIHRoZSB3ZWJzb2NrZXQgc2VydmVyIHJlZ2FyZGxlc3Mgb2Ygd2V0aGVyIG9yIG5vdCBhbiBcbiAgICAgICAgICAgICAgICAvLyBBUFBfUElORyB3YXMgc2VudCBieSB0aGUgd2FsbGV0L3dlYnNvY2tldCBzZXJ2ZXIuIFdlIG11c3QgY29udGludWUgdG8gc3VwcG9ydCB0aGlzIGJlaGF2aW9yIFxuICAgICAgICAgICAgICAgIC8vIGluIGNhc2UgdGhlIHVzZXIgaXMgdXNpbmcgYSB3YWxsZXQgdGhhdCBoYXMgbm90IHVwZGF0ZWQgdGhlaXIgd2FsbGV0bGliIGltcGxlbWVudGF0aW9uLiBcbiAgICAgICAgICAgICAgICBjb25zdCB7IGFzc29jaWF0aW9uS2V5cGFpciB9ID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgY29uc3QgZWNkaEtleXBhaXIgPSB5aWVsZCBnZW5lcmF0ZUVDREhLZXlwYWlyKCk7XG4gICAgICAgICAgICAgICAgc29ja2V0LnNlbmQoeWllbGQgY3JlYXRlSGVsbG9SZXEoZWNkaEtleXBhaXIucHVibGljS2V5LCBhc3NvY2lhdGlvbktleXBhaXIucHJpdmF0ZUtleSkpO1xuICAgICAgICAgICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICBfX3R5cGU6ICdoZWxsb19yZXFfc2VudCcsXG4gICAgICAgICAgICAgICAgICAgIGFzc29jaWF0aW9uUHVibGljS2V5OiBhc3NvY2lhdGlvbktleXBhaXIucHVibGljS2V5LFxuICAgICAgICAgICAgICAgICAgICBlY2RoUHJpdmF0ZUtleTogZWNkaEtleXBhaXIucHJpdmF0ZUtleSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVDbG9zZSA9IChldnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXZ0Lndhc0NsZWFuKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0geyBfX3R5cGU6ICdkaXNjb25uZWN0ZWQnIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcihTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLkVSUk9SX1NFU1NJT05fQ0xPU0VELCBgVGhlIHdhbGxldCBzZXNzaW9uIGRyb3BwZWQgdW5leHBlY3RlZGx5ICgke2V2dC5jb2RlfTogJHtldnQucmVhc29ufSkuYCwgeyBjbG9zZUV2ZW50OiBldnQgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNwb3NlU29ja2V0KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlRXJyb3IgPSAoX2V2dCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2VTb2NrZXQoKTtcbiAgICAgICAgICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIGNvbm5lY3Rpb25TdGFydFRpbWUgPj0gV0VCU09DS0VUX0NPTk5FQ1RJT05fQ09ORklHLnRpbWVvdXRNcykge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcihTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLkVSUk9SX1NFU1NJT05fVElNRU9VVCwgYEZhaWxlZCB0byBjb25uZWN0IHRvIHRoZSB3YWxsZXQgd2Vic29ja2V0IGF0ICR7d2Vic29ja2V0VVJMfS5gKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0cnlEZWxheU1zID0gZ2V0TmV4dFJldHJ5RGVsYXlNcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlXYWl0VGltZW91dElkID0gd2luZG93LnNldFRpbWVvdXQocmVzb2x2ZSwgcmV0cnlEZWxheU1zKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHRTb2NrZXRDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVNZXNzYWdlID0gKGV2dCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQnVmZmVyID0geWllbGQgZXZ0LmRhdGEuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0YXRlLl9fdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb25uZWN0aW5nJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZUJ1ZmZlci5ieXRlTGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNvdW50ZXJlZCB1bmV4cGVjdGVkIG1lc3NhZ2Ugd2hpbGUgY29ubmVjdGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZWNkaEtleXBhaXIgPSB5aWVsZCBnZW5lcmF0ZUVDREhLZXlwYWlyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZCh5aWVsZCBjcmVhdGVIZWxsb1JlcShlY2RoS2V5cGFpci5wdWJsaWNLZXksIGFzc29jaWF0aW9uS2V5cGFpci5wcml2YXRlS2V5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3R5cGU6ICdoZWxsb19yZXFfc2VudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzb2NpYXRpb25QdWJsaWNLZXk6IGFzc29jaWF0aW9uS2V5cGFpci5wdWJsaWNLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWNkaFByaXZhdGVLZXk6IGVjZGhLZXlwYWlyLnByaXZhdGVLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcXVlbmNlTnVtYmVyVmVjdG9yID0gcmVzcG9uc2VCdWZmZXIuc2xpY2UoMCwgU0VRVUVOQ0VfTlVNQkVSX0JZVEVTKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXF1ZW5jZU51bWJlciA9IGdldFNlcXVlbmNlTnVtYmVyRnJvbUJ5dGVBcnJheShzZXF1ZW5jZU51bWJlclZlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlcXVlbmNlTnVtYmVyICE9PSAobGFzdEtub3duSW5ib3VuZFNlcXVlbmNlTnVtYmVyICsgMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0ZWQgbWVzc2FnZSBoYXMgaW52YWxpZCBzZXF1ZW5jZSBudW1iZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEtub3duSW5ib3VuZFNlcXVlbmNlTnVtYmVyID0gc2VxdWVuY2VOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QganNvblJwY01lc3NhZ2UgPSB5aWVsZCBkZWNyeXB0SnNvblJwY01lc3NhZ2UocmVzcG9uc2VCdWZmZXIsIHN0YXRlLnNoYXJlZFNlY3JldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VQcm9taXNlID0ganNvblJwY1Jlc3BvbnNlUHJvbWlzZXNbanNvblJwY01lc3NhZ2UuaWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBqc29uUnBjUmVzcG9uc2VQcm9taXNlc1tqc29uUnBjTWVzc2FnZS5pZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlc29sdmUoanNvblJwY01lc3NhZ2UucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyUHJvdG9jb2xFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZVByb21pc2UgPSBqc29uUnBjUmVzcG9uc2VQcm9taXNlc1tlLmpzb25ScGNNZXNzYWdlSWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUganNvblJwY1Jlc3BvbnNlUHJvbWlzZXNbZS5qc29uUnBjTWVzc2FnZUlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2hlbGxvX3JlcV9zZW50Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgcmVjZWl2ZSBhbiBBUFBfUElORyBtZXNzYWdlIChlbXB0eSBtZXNzYWdlKSwgcmVzZW5kIHRoZSBIRUxMT19SRVEgKHNlZSBhYm92ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZUJ1ZmZlci5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZWNkaEtleXBhaXIgPSB5aWVsZCBnZW5lcmF0ZUVDREhLZXlwYWlyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0LnNlbmQoeWllbGQgY3JlYXRlSGVsbG9SZXEoZWNkaEtleXBhaXIucHVibGljS2V5LCBhc3NvY2lhdGlvbktleXBhaXIucHJpdmF0ZUtleSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3R5cGU6ICdoZWxsb19yZXFfc2VudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc29jaWF0aW9uUHVibGljS2V5OiBhc3NvY2lhdGlvbktleXBhaXIucHVibGljS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlY2RoUHJpdmF0ZUtleTogZWNkaEtleXBhaXIucHJpdmF0ZUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hhcmVkU2VjcmV0ID0geWllbGQgcGFyc2VIZWxsb1JzcChyZXNwb25zZUJ1ZmZlciwgc3RhdGUuYXNzb2NpYXRpb25QdWJsaWNLZXksIHN0YXRlLmVjZGhQcml2YXRlS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25Qcm9wZXJ0aWVzQnVmZmVyID0gcmVzcG9uc2VCdWZmZXIuc2xpY2UoRU5DT0RFRF9QVUJMSUNfS0VZX0xFTkdUSF9CWVRFUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uUHJvcGVydGllcyA9IHNlc3Npb25Qcm9wZXJ0aWVzQnVmZmVyLmJ5dGVMZW5ndGggIT09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHlpZWxkICgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcXVlbmNlTnVtYmVyVmVjdG9yID0gc2Vzc2lvblByb3BlcnRpZXNCdWZmZXIuc2xpY2UoMCwgU0VRVUVOQ0VfTlVNQkVSX0JZVEVTKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VxdWVuY2VOdW1iZXIgPSBnZXRTZXF1ZW5jZU51bWJlckZyb21CeXRlQXJyYXkoc2VxdWVuY2VOdW1iZXJWZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VxdWVuY2VOdW1iZXIgIT09IChsYXN0S25vd25JbmJvdW5kU2VxdWVuY2VOdW1iZXIgKyAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0ZWQgbWVzc2FnZSBoYXMgaW52YWxpZCBzZXF1ZW5jZSBudW1iZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0S25vd25JbmJvdW5kU2VxdWVuY2VOdW1iZXIgPSBzZXF1ZW5jZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlU2Vzc2lvblByb3BzKHNlc3Npb25Qcm9wZXJ0aWVzQnVmZmVyLCBzaGFyZWRTZWNyZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSgpIDogeyBwcm90b2NvbF92ZXJzaW9uOiAnbGVnYWN5JyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB7IF9fdHlwZTogJ2Nvbm5lY3RlZCcsIHNoYXJlZFNlY3JldCwgc2Vzc2lvblByb3BlcnRpZXMgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdhbGxldCA9IGNyZWF0ZU1vYmlsZVdhbGxldFByb3h5KHNlc3Npb25Qcm9wZXJ0aWVzLnByb3RvY29sX3ZlcnNpb24sIChtZXRob2QsIHBhcmFtcykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gbmV4dEpzb25ScGNNZXNzYWdlSWQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZCh5aWVsZCBlbmNyeXB0SnNvblJwY01lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBzaGFyZWRTZWNyZXQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uUnBjUmVzcG9uc2VQcm9taXNlc1tpZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2F1dGhvcml6ZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JlYXV0aG9yaXplJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB3YWxsZXRfdXJpX2Jhc2UgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3YWxsZXRfdXJpX2Jhc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydFNlY3VyZUVuZHBvaW50U3BlY2lmaWNVUkkod2FsbGV0X3VyaV9iYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh5aWVsZCBjYWxsYmFjayh3YWxsZXQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcG9zZVNvY2tldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBkaXNwb3NlU29ja2V0O1xuICAgICAgICAgICAgbGV0IHJldHJ5V2FpdFRpbWVvdXRJZDtcbiAgICAgICAgICAgIGNvbnN0IGF0dGVtcHRTb2NrZXRDb25uZWN0aW9uID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChkaXNwb3NlU29ja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2VTb2NrZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUgPSB7IF9fdHlwZTogJ2Nvbm5lY3RpbmcnLCBhc3NvY2lhdGlvbktleXBhaXIgfTtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvblN0YXJ0VGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25TdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzb2NrZXQgPSBuZXcgV2ViU29ja2V0KHdlYnNvY2tldFVSTCwgW1dFQlNPQ0tFVF9QUk9UT0NPTF0pO1xuICAgICAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgaGFuZGxlT3Blbik7XG4gICAgICAgICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgaGFuZGxlQ2xvc2UpO1xuICAgICAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGhhbmRsZUVycm9yKTtcbiAgICAgICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZU1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGRpc3Bvc2VTb2NrZXQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQocmV0cnlXYWl0VGltZW91dElkKTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29wZW4nLCBoYW5kbGVPcGVuKTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgaGFuZGxlQ2xvc2UpO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhdHRlbXB0U29ja2V0Q29ubmVjdGlvbigpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHRyYW5zYWN0UmVtb3RlKGNhbGxiYWNrLCBjb25maWcpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBhc3NlcnRTZWN1cmVDb250ZXh0KCk7XG4gICAgICAgIGNvbnN0IGFzc29jaWF0aW9uS2V5cGFpciA9IHlpZWxkIGdlbmVyYXRlQXNzb2NpYXRpb25LZXlwYWlyKCk7XG4gICAgICAgIGNvbnN0IHsgYXNzb2NpYXRpb25VcmwsIHJlZmxlY3RvcklkIH0gPSB5aWVsZCBnZXRSZW1vdGVTZXNzaW9uVXJsKGFzc29jaWF0aW9uS2V5cGFpci5wdWJsaWNLZXksIGNvbmZpZy5yZW1vdGVIb3N0QXV0aG9yaXR5LCBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuYmFzZVVyaSk7XG4gICAgICAgIGNvbnN0IHdlYnNvY2tldFVSTCA9IGB3c3M6Ly8ke2NvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5yZW1vdGVIb3N0QXV0aG9yaXR5fS9yZWZsZWN0P2lkPSR7cmVmbGVjdG9ySWR9YDtcbiAgICAgICAgbGV0IGNvbm5lY3Rpb25TdGFydFRpbWU7XG4gICAgICAgIGNvbnN0IGdldE5leHRSZXRyeURlbGF5TXMgPSAoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2NoZWR1bGUgPSBbLi4uV0VCU09DS0VUX0NPTk5FQ1RJT05fQ09ORklHLnJldHJ5RGVsYXlTY2hlZHVsZU1zXTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiAoc2NoZWR1bGUubGVuZ3RoID4gMSA/IHNjaGVkdWxlLnNoaWZ0KCkgOiBzY2hlZHVsZVswXSk7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIGxldCBuZXh0SnNvblJwY01lc3NhZ2VJZCA9IDE7XG4gICAgICAgIGxldCBsYXN0S25vd25JbmJvdW5kU2VxdWVuY2VOdW1iZXIgPSAwO1xuICAgICAgICBsZXQgc3RhdGUgPSB7IF9fdHlwZTogJ2Rpc2Nvbm5lY3RlZCcgfTtcbiAgICAgICAgcmV0dXJuIHsgYXNzb2NpYXRpb25VcmwsIHJlc3VsdDogbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBzb2NrZXQ7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBjb25zdCBqc29uUnBjUmVzcG9uc2VQcm9taXNlcyA9IHt9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZU9wZW4gPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5fX3R5cGUgIT09ICdjb25uZWN0aW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdFeHBlY3RlZCBhZGFwdGVyIHN0YXRlIHRvIGJlIGBjb25uZWN0aW5nYCBhdCB0aGUgbW9tZW50IHRoZSB3ZWJzb2NrZXQgb3BlbnMuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBHb3QgXFxgJHtzdGF0ZS5fX3R5cGV9XFxgLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdvcGVuJywgaGFuZGxlT3Blbik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlQ2xvc2UgPSAoZXZ0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldnQud2FzQ2xlYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0geyBfX3R5cGU6ICdkaXNjb25uZWN0ZWQnIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcihTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLkVSUk9SX1NFU1NJT05fQ0xPU0VELCBgVGhlIHdhbGxldCBzZXNzaW9uIGRyb3BwZWQgdW5leHBlY3RlZGx5ICgke2V2dC5jb2RlfTogJHtldnQucmVhc29ufSkuYCwgeyBjbG9zZUV2ZW50OiBldnQgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2VTb2NrZXQoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZUVycm9yID0gKF9ldnQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcG9zZVNvY2tldCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIGNvbm5lY3Rpb25TdGFydFRpbWUgPj0gV0VCU09DS0VUX0NPTk5FQ1RJT05fQ09ORklHLnRpbWVvdXRNcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3IoU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yQ29kZS5FUlJPUl9TRVNTSU9OX1RJTUVPVVQsIGBGYWlsZWQgdG8gY29ubmVjdCB0byB0aGUgd2FsbGV0IHdlYnNvY2tldCBhdCAke3dlYnNvY2tldFVSTH0uYCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXRyeURlbGF5TXMgPSBnZXROZXh0UmV0cnlEZWxheU1zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlXYWl0VGltZW91dElkID0gd2luZG93LnNldFRpbWVvdXQocmVzb2x2ZSwgcmV0cnlEZWxheU1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdFNvY2tldENvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZU1lc3NhZ2UgPSAoZXZ0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQnVmZmVyID0geWllbGQgZXZ0LmRhdGEuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdGF0ZS5fX3R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RpbmcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZUJ1ZmZlci5ieXRlTGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jb3VudGVyZWQgdW5leHBlY3RlZCBtZXNzYWdlIHdoaWxlIGNvbm5lY3RpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZWNkaEtleXBhaXIgPSB5aWVsZCBnZW5lcmF0ZUVDREhLZXlwYWlyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0LnNlbmQoeWllbGQgY3JlYXRlSGVsbG9SZXEoZWNkaEtleXBhaXIucHVibGljS2V5LCBhc3NvY2lhdGlvbktleXBhaXIucHJpdmF0ZUtleSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3R5cGU6ICdoZWxsb19yZXFfc2VudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc29jaWF0aW9uUHVibGljS2V5OiBhc3NvY2lhdGlvbktleXBhaXIucHVibGljS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlY2RoUHJpdmF0ZUtleTogZWNkaEtleXBhaXIucHJpdmF0ZUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXF1ZW5jZU51bWJlclZlY3RvciA9IHJlc3BvbnNlQnVmZmVyLnNsaWNlKDAsIFNFUVVFTkNFX05VTUJFUl9CWVRFUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcXVlbmNlTnVtYmVyID0gZ2V0U2VxdWVuY2VOdW1iZXJGcm9tQnl0ZUFycmF5KHNlcXVlbmNlTnVtYmVyVmVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlcXVlbmNlTnVtYmVyICE9PSAobGFzdEtub3duSW5ib3VuZFNlcXVlbmNlTnVtYmVyICsgMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGVkIG1lc3NhZ2UgaGFzIGludmFsaWQgc2VxdWVuY2UgbnVtYmVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEtub3duSW5ib3VuZFNlcXVlbmNlTnVtYmVyID0gc2VxdWVuY2VOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGpzb25ScGNNZXNzYWdlID0geWllbGQgZGVjcnlwdEpzb25ScGNNZXNzYWdlKHJlc3BvbnNlQnVmZmVyLCBzdGF0ZS5zaGFyZWRTZWNyZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZVByb21pc2UgPSBqc29uUnBjUmVzcG9uc2VQcm9taXNlc1tqc29uUnBjTWVzc2FnZS5pZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBqc29uUnBjUmVzcG9uc2VQcm9taXNlc1tqc29uUnBjTWVzc2FnZS5pZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZS5yZXNvbHZlKGpzb25ScGNNZXNzYWdlLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlclByb3RvY29sRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlUHJvbWlzZSA9IGpzb25ScGNSZXNwb25zZVByb21pc2VzW2UuanNvblJwY01lc3NhZ2VJZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUganNvblJwY1Jlc3BvbnNlUHJvbWlzZXNbZS5qc29uUnBjTWVzc2FnZUlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnaGVsbG9fcmVxX3NlbnQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hhcmVkU2VjcmV0ID0geWllbGQgcGFyc2VIZWxsb1JzcChyZXNwb25zZUJ1ZmZlciwgc3RhdGUuYXNzb2NpYXRpb25QdWJsaWNLZXksIHN0YXRlLmVjZGhQcml2YXRlS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uUHJvcGVydGllc0J1ZmZlciA9IHJlc3BvbnNlQnVmZmVyLnNsaWNlKEVOQ09ERURfUFVCTElDX0tFWV9MRU5HVEhfQllURVMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25Qcm9wZXJ0aWVzID0gc2Vzc2lvblByb3BlcnRpZXNCdWZmZXIuYnl0ZUxlbmd0aCAhPT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHlpZWxkICgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXF1ZW5jZU51bWJlclZlY3RvciA9IHNlc3Npb25Qcm9wZXJ0aWVzQnVmZmVyLnNsaWNlKDAsIFNFUVVFTkNFX05VTUJFUl9CWVRFUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXF1ZW5jZU51bWJlciA9IGdldFNlcXVlbmNlTnVtYmVyRnJvbUJ5dGVBcnJheShzZXF1ZW5jZU51bWJlclZlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VxdWVuY2VOdW1iZXIgIT09IChsYXN0S25vd25JbmJvdW5kU2VxdWVuY2VOdW1iZXIgKyAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGVkIG1lc3NhZ2UgaGFzIGludmFsaWQgc2VxdWVuY2UgbnVtYmVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0S25vd25JbmJvdW5kU2VxdWVuY2VOdW1iZXIgPSBzZXF1ZW5jZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVNlc3Npb25Qcm9wcyhzZXNzaW9uUHJvcGVydGllc0J1ZmZlciwgc2hhcmVkU2VjcmV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpKCkgOiB7IHByb3RvY29sX3ZlcnNpb246ICdsZWdhY3knIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB7IF9fdHlwZTogJ2Nvbm5lY3RlZCcsIHNoYXJlZFNlY3JldCwgc2Vzc2lvblByb3BlcnRpZXMgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3YWxsZXQgPSBjcmVhdGVNb2JpbGVXYWxsZXRQcm94eShzZXNzaW9uUHJvcGVydGllcy5wcm90b2NvbF92ZXJzaW9uLCAobWV0aG9kLCBwYXJhbXMpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaWQgPSBuZXh0SnNvblJwY01lc3NhZ2VJZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZCh5aWVsZCBlbmNyeXB0SnNvblJwY01lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHNoYXJlZFNlY3JldCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvblJwY1Jlc3BvbnNlUHJvbWlzZXNbaWRdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdhdXRob3JpemUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmVhdXRob3JpemUnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB3YWxsZXRfdXJpX2Jhc2UgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2FsbGV0X3VyaV9iYXNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydFNlY3VyZUVuZHBvaW50U3BlY2lmaWNVUkkod2FsbGV0X3VyaV9iYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHlpZWxkIGNhbGxiYWNrKG5ldyBQcm94eSh3YWxsZXQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCh0YXJnZXQsIHApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocCA9PSAndGVybWluYXRlU2Vzc2lvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcG9zZVNvY2tldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRbcF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGV0IGRpc3Bvc2VTb2NrZXQ7XG4gICAgICAgICAgICAgICAgbGV0IHJldHJ5V2FpdFRpbWVvdXRJZDtcbiAgICAgICAgICAgICAgICBjb25zdCBhdHRlbXB0U29ja2V0Q29ubmVjdGlvbiA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3Bvc2VTb2NrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3Bvc2VTb2NrZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHsgX190eXBlOiAnY29ubmVjdGluZycsIGFzc29jaWF0aW9uS2V5cGFpciB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvblN0YXJ0VGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uU3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzb2NrZXQgPSBuZXcgV2ViU29ja2V0KHdlYnNvY2tldFVSTCwgW1dFQlNPQ0tFVF9QUk9UT0NPTF0pO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsIGhhbmRsZU9wZW4pO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCBoYW5kbGVDbG9zZSk7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGhhbmRsZUVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcG9zZVNvY2tldCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQocmV0cnlXYWl0VGltZW91dElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdvcGVuJywgaGFuZGxlT3Blbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xvc2UnLCBoYW5kbGVDbG9zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZU1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYXR0ZW1wdFNvY2tldENvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIH0pIH07XG4gICAgfSk7XG59XG5cbmV4cG9ydCB7IFNvbGFuYUNsb25lQXV0aG9yaXphdGlvbiwgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yLCBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLCBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyUHJvdG9jb2xFcnJvciwgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlclByb3RvY29sRXJyb3JDb2RlLCBTb2xhbmFTaWduSW5XaXRoU29sYW5hLCBTb2xhbmFTaWduVHJhbnNhY3Rpb25zLCB0cmFuc2FjdCwgdHJhbnNhY3RSZW1vdGUgfTtcbiJdLCJuYW1lcyI6WyJjcmVhdGVTaWduSW5NZXNzYWdlVGV4dCIsIlNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvckNvZGUiLCJFUlJPUl9BU1NPQ0lBVElPTl9QT1JUX09VVF9PRl9SQU5HRSIsIkVSUk9SX1JFRkxFQ1RPUl9JRF9PVVRfT0ZfUkFOR0UiLCJFUlJPUl9GT1JCSURERU5fV0FMTEVUX0JBU0VfVVJMIiwiRVJST1JfU0VDVVJFX0NPTlRFWFRfUkVRVUlSRUQiLCJFUlJPUl9TRVNTSU9OX0NMT1NFRCIsIkVSUk9SX1NFU1NJT05fVElNRU9VVCIsIkVSUk9SX1dBTExFVF9OT1RfRk9VTkQiLCJFUlJPUl9JTlZBTElEX1BST1RPQ09MX1ZFUlNJT04iLCJTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwiYXJncyIsImNvZGUiLCJtZXNzYWdlIiwiZGF0YSIsIm5hbWUiLCJTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyUHJvdG9jb2xFcnJvckNvZGUiLCJFUlJPUl9BVVRIT1JJWkFUSU9OX0ZBSUxFRCIsIkVSUk9SX0lOVkFMSURfUEFZTE9BRFMiLCJFUlJPUl9OT1RfU0lHTkVEIiwiRVJST1JfTk9UX1NVQk1JVFRFRCIsIkVSUk9SX1RPT19NQU5ZX1BBWUxPQURTIiwiRVJST1JfQVRURVNUX09SSUdJTl9BTkRST0lEIiwiU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlclByb3RvY29sRXJyb3IiLCJqc29uUnBjTWVzc2FnZUlkIiwiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJ2YWx1ZSIsInJlc29sdmUiLCJQcm9taXNlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwiY3JlYXRlSGVsbG9SZXEiLCJlY2RoUHVibGljS2V5IiwiYXNzb2NpYXRpb25LZXlwYWlyUHJpdmF0ZUtleSIsInB1YmxpY0tleUJ1ZmZlciIsImNyeXB0byIsInN1YnRsZSIsImV4cG9ydEtleSIsInNpZ25hdHVyZUJ1ZmZlciIsInNpZ24iLCJoYXNoIiwicmVzcG9uc2UiLCJVaW50OEFycmF5IiwiYnl0ZUxlbmd0aCIsInNldCIsImVuY29kZSIsImlucHV0Iiwid2luZG93IiwiYnRvYSIsImNyZWF0ZVNJV1NNZXNzYWdlIiwicGF5bG9hZCIsImNyZWF0ZVNJV1NNZXNzYWdlQmFzZTY0IiwiU29sYW5hU2lnblRyYW5zYWN0aW9ucyIsIlNvbGFuYUNsb25lQXV0aG9yaXphdGlvbiIsIlNvbGFuYVNpZ25JbldpdGhTb2xhbmEiLCJjcmVhdGVNb2JpbGVXYWxsZXRQcm94eSIsInByb3RvY29sVmVyc2lvbiIsInByb3RvY29sUmVxdWVzdEhhbmRsZXIiLCJQcm94eSIsImdldCIsInRhcmdldCIsInAiLCJpbnB1dFBhcmFtcyIsIm1ldGhvZCIsInBhcmFtcyIsImhhbmRsZU1vYmlsZVdhbGxldFJlcXVlc3QiLCJzaWduX2luX3BheWxvYWQiLCJzaWduX2luX3Jlc3VsdCIsInNpZ25JbkZhbGxiYWNrIiwiaGFuZGxlTW9iaWxlV2FsbGV0UmVzcG9uc2UiLCJkZWZpbmVQcm9wZXJ0eSIsImRlbGV0ZVByb3BlcnR5IiwibWV0aG9kTmFtZSIsIm1ldGhvZFBhcmFtcyIsInRvU3RyaW5nIiwicmVwbGFjZSIsImxldHRlciIsInRvTG93ZXJDYXNlIiwiY2hhaW4iLCJjbHVzdGVyIiwiYXV0aF90b2tlbiIsImlkZW50aXR5IiwiY2FwYWJpbGl0aWVzIiwiZmVhdHVyZXMiLCJzdXBwb3J0c19jbG9uZV9hdXRob3JpemF0aW9uIiwicHVzaCIsIk9iamVjdCIsImFzc2lnbiIsInN1cHBvcnRzX3NpZ25fYW5kX3NlbmRfdHJhbnNhY3Rpb25zIiwiaW5jbHVkZXMiLCJzaWduSW5QYXlsb2FkIiwiYXV0aG9yaXphdGlvblJlc3VsdCIsIl9hIiwiZG9tYWluIiwibG9jYXRpb24iLCJob3N0IiwiYWRkcmVzcyIsImFjY291bnRzIiwic2l3c01lc3NhZ2UiLCJzaWduTWVzc2FnZVJlc3VsdCIsImFkZHJlc3NlcyIsInBheWxvYWRzIiwic2lnbkluUmVzdWx0Iiwic2lnbmVkX21lc3NhZ2UiLCJzaWduYXR1cmUiLCJzaWduZWRfcGF5bG9hZHMiLCJzbGljZSIsImxlbmd0aCIsIlNFUVVFTkNFX05VTUJFUl9CWVRFUyIsImNyZWF0ZVNlcXVlbmNlTnVtYmVyVmVjdG9yIiwic2VxdWVuY2VOdW1iZXIiLCJieXRlQXJyYXkiLCJBcnJheUJ1ZmZlciIsInZpZXciLCJEYXRhVmlldyIsInNldFVpbnQzMiIsIklOSVRJQUxJWkFUSU9OX1ZFQ1RPUl9CWVRFUyIsIkVOQ09ERURfUFVCTElDX0tFWV9MRU5HVEhfQllURVMiLCJlbmNyeXB0TWVzc2FnZSIsInBsYWludGV4dCIsInNoYXJlZFNlY3JldCIsInNlcXVlbmNlTnVtYmVyVmVjdG9yIiwiaW5pdGlhbGl6YXRpb25WZWN0b3IiLCJnZXRSYW5kb21WYWx1ZXMiLCJjaXBoZXJ0ZXh0IiwiZW5jcnlwdCIsImdldEFsZ29yaXRobVBhcmFtcyIsIlRleHRFbmNvZGVyIiwiZGVjcnlwdE1lc3NhZ2UiLCJwbGFpbnRleHRCdWZmZXIiLCJkZWNyeXB0IiwiZ2V0VXRmOERlY29kZXIiLCJkZWNvZGUiLCJhZGRpdGlvbmFsRGF0YSIsIml2IiwidGFnTGVuZ3RoIiwiX3V0ZjhEZWNvZGVyIiwidW5kZWZpbmVkIiwiVGV4dERlY29kZXIiLCJnZW5lcmF0ZUFzc29jaWF0aW9uS2V5cGFpciIsImdlbmVyYXRlS2V5IiwibmFtZWRDdXJ2ZSIsImdlbmVyYXRlRUNESEtleXBhaXIiLCJlbmNyeXB0SnNvblJwY01lc3NhZ2UiLCJqc29uUnBjTWVzc2FnZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJpZCIsImRlY3J5cHRKc29uUnBjTWVzc2FnZSIsInBhcnNlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiZXJyb3IiLCJwYXJzZUhlbGxvUnNwIiwicGF5bG9hZEJ1ZmZlciIsImFzc29jaWF0aW9uUHVibGljS2V5IiwiZWNkaFByaXZhdGVLZXkiLCJhc3NvY2lhdGlvblB1YmxpY0tleUJ1ZmZlciIsIndhbGxldFB1YmxpY0tleSIsImFsbCIsImltcG9ydEtleSIsImRlcml2ZUJpdHMiLCJwdWJsaWMiLCJlY2RoU2VjcmV0S2V5IiwiYWVzS2V5TWF0ZXJpYWxWYWwiLCJkZXJpdmVLZXkiLCJzYWx0IiwiaW5mbyIsInBhcnNlU2Vzc2lvblByb3BzIiwianNvblByb3BlcnRpZXMiLCJ2IiwicHJvdG9jb2xfdmVyc2lvbiIsImdldFJhbmRvbUFzc29jaWF0aW9uUG9ydCIsImFzc2VydEFzc29jaWF0aW9uUG9ydCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsInBvcnQiLCJhcnJheUJ1ZmZlclRvQmFzZTY0U3RyaW5nIiwiYnVmZmVyIiwiYmluYXJ5IiwiYnl0ZXMiLCJsZW4iLCJpaSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImdldFN0cmluZ1dpdGhVUkxVbnNhZmVDaGFyYWN0ZXJzUmVwbGFjZWQiLCJ1bnNhZmVCYXNlNjRFbmNvZGVkU3RyaW5nIiwibSIsImdldFJhbmRvbVJlZmxlY3RvcklkIiwiYXNzZXJ0UmVmbGVjdG9ySWQiLCJnZXRSYW5kb21JbnQiLCJtaW4iLCJtYXgiLCJyYW5kb21CdWZmZXIiLCJVaW50MzJBcnJheSIsInJhbmRvbU51bWJlciIsImNlaWwiLCJJTlRFTlRfTkFNRSIsImdldFBhdGhQYXJ0cyIsInBhdGhTdHJpbmciLCJzcGxpdCIsImdldEludGVudFVSTCIsIm1ldGhvZFBhdGhuYW1lIiwiaW50ZW50VXJsQmFzZSIsImJhc2VVcmwiLCJVUkwiLCJwcm90b2NvbCIsInBhdGhuYW1lIiwic3RhcnRzV2l0aCIsImpvaW4iLCJnZXRBc3NvY2lhdGVBbmRyb2lkSW50ZW50VVJMIiwicHV0YXRpdmVQb3J0IiwiYXNzb2NpYXRpb25VUkxCYXNlIiwicHJvdG9jb2xWZXJzaW9ucyIsImFzc29jaWF0aW9uUG9ydCIsImV4cG9ydGVkS2V5IiwiZW5jb2RlZEtleSIsInVybCIsInNlYXJjaFBhcmFtcyIsImZvckVhY2giLCJ2ZXJzaW9uIiwiZ2V0UmVtb3RlQXNzb2NpYXRlQW5kcm9pZEludGVudFVSTCIsImhvc3RBdXRob3JpdHkiLCJwdXRhdGl2ZUlkIiwicmVmbGVjdG9ySWQiLCJCcm93c2VyIiwiRmlyZWZveCIsIk90aGVyIiwiYXNzZXJ0VW5yZWFjaGFibGUiLCJ4IiwiZ2V0QnJvd3NlciIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImluZGV4T2YiLCJnZXREZXRlY3Rpb25Qcm9taXNlIiwiY2xlYW51cCIsImNsZWFyVGltZW91dCIsInRpbWVvdXRJZCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJoYW5kbGVCbHVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInNldFRpbWVvdXQiLCJfZnJhbWUiLCJsYXVuY2hVcmxUaHJvdWdoSGlkZGVuRnJhbWUiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJzdHlsZSIsImRpc3BsYXkiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJjb250ZW50V2luZG93IiwiaHJlZiIsImxhdW5jaEFzc29jaWF0aW9uIiwiYXNzb2NpYXRpb25VcmwiLCJicm93c2VyIiwiZGV0ZWN0aW9uUHJvbWlzZSIsInN0YXJ0U2Vzc2lvbiIsInJhbmRvbUFzc29jaWF0aW9uUG9ydCIsImdldFJlbW90ZVNlc3Npb25VcmwiLCJyYW5kb21SZWZsZWN0b3JJZCIsIldFQlNPQ0tFVF9DT05ORUNUSU9OX0NPTkZJRyIsInJldHJ5RGVsYXlTY2hlZHVsZU1zIiwidGltZW91dE1zIiwiV0VCU09DS0VUX1BST1RPQ09MIiwiYXNzZXJ0U2VjdXJlQ29udGV4dCIsImlzU2VjdXJlQ29udGV4dCIsImFzc2VydFNlY3VyZUVuZHBvaW50U3BlY2lmaWNVUkkiLCJ3YWxsZXRVcmlCYXNlIiwiZ2V0U2VxdWVuY2VOdW1iZXJGcm9tQnl0ZUFycmF5IiwiZ2V0VWludDMyIiwidHJhbnNhY3QiLCJjYWxsYmFjayIsImNvbmZpZyIsImFzc29jaWF0aW9uS2V5cGFpciIsInNlc3Npb25Qb3J0IiwicHVibGljS2V5IiwiYmFzZVVyaSIsIndlYnNvY2tldFVSTCIsImNvbm5lY3Rpb25TdGFydFRpbWUiLCJnZXROZXh0UmV0cnlEZWxheU1zIiwic2NoZWR1bGUiLCJzaGlmdCIsIm5leHRKc29uUnBjTWVzc2FnZUlkIiwibGFzdEtub3duSW5ib3VuZFNlcXVlbmNlTnVtYmVyIiwic3RhdGUiLCJfX3R5cGUiLCJzb2NrZXQiLCJqc29uUnBjUmVzcG9uc2VQcm9taXNlcyIsImhhbmRsZU9wZW4iLCJjb25zb2xlIiwid2FybiIsImVjZGhLZXlwYWlyIiwic2VuZCIsInByaXZhdGVLZXkiLCJoYW5kbGVDbG9zZSIsImV2dCIsIndhc0NsZWFuIiwicmVhc29uIiwiY2xvc2VFdmVudCIsImRpc3Bvc2VTb2NrZXQiLCJoYW5kbGVFcnJvciIsIl9ldnQiLCJEYXRlIiwibm93IiwicmV0cnlEZWxheU1zIiwicmV0cnlXYWl0VGltZW91dElkIiwiYXR0ZW1wdFNvY2tldENvbm5lY3Rpb24iLCJoYW5kbGVNZXNzYWdlIiwicmVzcG9uc2VCdWZmZXIiLCJhcnJheUJ1ZmZlciIsInJlc3BvbnNlUHJvbWlzZSIsInNlc3Npb25Qcm9wZXJ0aWVzQnVmZmVyIiwic2Vzc2lvblByb3BlcnRpZXMiLCJ3YWxsZXQiLCJqc29ucnBjIiwid2FsbGV0X3VyaV9iYXNlIiwiY2xvc2UiLCJXZWJTb2NrZXQiLCJ0cmFuc2FjdFJlbW90ZSIsInJlbW90ZUhvc3RBdXRob3JpdHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana-mobile/mobile-wallet-adapter-protocol/lib/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana-mobile/wallet-adapter-mobile/lib/esm/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@solana-mobile/wallet-adapter-mobile/lib/esm/index.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolanaMobileWalletAdapter: () => (/* binding */ SolanaMobileWalletAdapter),\n/* harmony export */   SolanaMobileWalletAdapterRemote: () => (/* binding */ SolanaMobileWalletAdapterRemote),\n/* harmony export */   SolanaMobileWalletAdapterRemoteWalletName: () => (/* binding */ SolanaMobileWalletAdapterRemoteWalletName),\n/* harmony export */   SolanaMobileWalletAdapterWalletName: () => (/* binding */ SolanaMobileWalletAdapterWalletName),\n/* harmony export */   createDefaultAddressSelector: () => (/* binding */ createDefaultAddressSelector),\n/* harmony export */   createDefaultAuthorizationResultCache: () => (/* binding */ createDefaultAuthorizationResultCache),\n/* harmony export */   createDefaultWalletNotFoundHandler: () => (/* binding */ createDefaultWalletNotFoundHandler)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/signer.js\");\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js\");\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/errors.js\");\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/transaction.js\");\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/./node_modules/@solana/web3.js/lib/index.esm.js\");\n/* harmony import */ var _solana_mobile_mobile_wallet_adapter_protocol_web3js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana-mobile/mobile-wallet-adapter-protocol-web3js */ \"(ssr)/./node_modules/@solana-mobile/mobile-wallet-adapter-protocol-web3js/lib/esm/index.js\");\n/* harmony import */ var qrcode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! qrcode */ \"(ssr)/./node_modules/qrcode/lib/index.js\");\n/* harmony import */ var js_base64__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! js-base64 */ \"(ssr)/./node_modules/js-base64/base64.mjs\");\n\n\n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ function __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction toUint8Array(base64EncodedByteArray) {\n    return new Uint8Array(window.atob(base64EncodedByteArray).split(\"\").map((c)=>c.charCodeAt(0)));\n}\nfunction getIsSupported$1() {\n    return  false && 0;\n}\nconst SolanaMobileWalletAdapterWalletName = \"Mobile Wallet Adapter\";\nconst SIGNATURE_LENGTH_IN_BYTES$1 = 64;\nfunction getPublicKeyFromAddress$1(address) {\n    const publicKeyByteArray = toUint8Array(address);\n    return new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(publicKeyByteArray);\n}\nfunction isVersionedTransaction(transaction) {\n    return \"version\" in transaction;\n}\nfunction clusterToChainId(cluster) {\n    switch(cluster){\n        case \"mainnet-beta\":\n            return \"solana:mainnet\";\n        case \"testnet\":\n            return \"solana:testnet\";\n        case \"devnet\":\n            return \"solana:devnet\";\n    }\n}\nclass SolanaMobileWalletAdapter extends _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.BaseSignInMessageSignerWalletAdapter {\n    constructor(config){\n        var _a;\n        super();\n        this.supportedTransactionVersions = new Set(// FIXME(#244): We can't actually know what versions are supported until we know which wallet we're talking to.\n        [\n            \"legacy\",\n            0\n        ]);\n        this.name = SolanaMobileWalletAdapterWalletName;\n        this.url = \"https://solanamobile.com/wallets\";\n        this.icon = \"data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjI4IiB3aWR0aD0iMjgiIHZpZXdCb3g9Ii0zIDAgMjggMjgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI0RDQjhGRiI+PHBhdGggZD0iTTE3LjQgMTcuNEgxNXYyLjRoMi40di0yLjRabTEuMi05LjZoLTIuNHYyLjRoMi40VjcuOFoiLz48cGF0aCBkPSJNMjEuNiAzVjBoLTIuNHYzaC0zLjZWMGgtMi40djNoLTIuNHY2LjZINC41YTIuMSAyLjEgMCAxIDEgMC00LjJoMi43VjNINC41QTQuNSA0LjUgMCAwIDAgMCA3LjVWMjRoMjEuNnYtNi42aC0yLjR2NC4ySDIuNFYxMS41Yy41LjMgMS4yLjQgMS44LjVoNy41QTYuNiA2LjYgMCAwIDAgMjQgOVYzaC0yLjRabTAgNS43YTQuMiA0LjIgMCAxIDEtOC40IDBWNS40aDguNHYzLjNaIi8+PC9nPjwvc3ZnPg==\";\n        this._connecting = false;\n        /**\n         * Every time the connection is recycled in some way (eg. `disconnect()` is called)\n         * increment this and use it to make sure that `transact` calls from the previous\n         * 'generation' don't continue to do work and throw exceptions.\n         */ this._connectionGeneration = 0;\n        this._readyState = getIsSupported$1() ? _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Loadable : _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Unsupported;\n        this._authorizationResultCache = config.authorizationResultCache;\n        this._addressSelector = config.addressSelector;\n        this._appIdentity = config.appIdentity;\n        this._chain = (_a = config.chain) !== null && _a !== void 0 ? _a : clusterToChainId(config.cluster);\n        this._hostAuthority = config.remoteHostAuthority;\n        this._onWalletNotFound = config.onWalletNotFound;\n        if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Unsupported) {\n            this._authorizationResultCache.get().then((authorizationResult)=>{\n                if (authorizationResult) {\n                    // Having a prior authorization result is, right now, the best\n                    // indication that a mobile wallet is installed. There is no API\n                    // we can use to test for whether the association URI is supported.\n                    this.declareWalletAsInstalled();\n                }\n            });\n        }\n    }\n    get publicKey() {\n        if (this._publicKey == null && this._selectedAddress != null) {\n            try {\n                this._publicKey = getPublicKeyFromAddress$1(this._selectedAddress);\n            } catch (e) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletPublicKeyError(e instanceof Error && (e === null || e === void 0 ? void 0 : e.message) || \"Unknown error\", e);\n            }\n        }\n        return this._publicKey ? this._publicKey : null;\n    }\n    get connected() {\n        return !!this._authorizationResult;\n    }\n    get connecting() {\n        return this._connecting;\n    }\n    get readyState() {\n        return this._readyState;\n    }\n    declareWalletAsInstalled() {\n        if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Installed) {\n            this.emit(\"readyStateChange\", this._readyState = _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Installed);\n        }\n    }\n    runWithGuard(callback) {\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                return yield callback();\n            } catch (e) {\n                this.emit(\"error\", e);\n                throw e;\n            }\n        });\n    }\n    /** @deprecated Use `autoConnect()` instead. */ autoConnect_DO_NOT_USE_OR_YOU_WILL_BE_FIRED() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return yield this.autoConnect();\n        });\n    }\n    autoConnect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.connecting || this.connected) {\n                return;\n            }\n            return yield this.runWithGuard(()=>__awaiter(this, void 0, void 0, function*() {\n                    if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Installed && this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Loadable) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletNotReadyError();\n                    }\n                    this._connecting = true;\n                    try {\n                        const cachedAuthorizationResult = yield this._authorizationResultCache.get();\n                        if (cachedAuthorizationResult) {\n                            // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                            this.handleAuthorizationResult(cachedAuthorizationResult);\n                        }\n                    } catch (e) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletConnectionError(e instanceof Error && e.message || \"Unknown error\", e);\n                    } finally{\n                        this._connecting = false;\n                    }\n                }));\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.connecting || this.connected) {\n                return;\n            }\n            return yield this.runWithGuard(()=>__awaiter(this, void 0, void 0, function*() {\n                    if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Installed && this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Loadable) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletNotReadyError();\n                    }\n                    this._connecting = true;\n                    try {\n                        yield this.performAuthorization();\n                    } catch (e) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletConnectionError(e instanceof Error && e.message || \"Unknown error\", e);\n                    } finally{\n                        this._connecting = false;\n                    }\n                }));\n        });\n    }\n    performAuthorization(signInPayload) {\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                const cachedAuthorizationResult = yield this._authorizationResultCache.get();\n                if (cachedAuthorizationResult) {\n                    // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                    this.handleAuthorizationResult(cachedAuthorizationResult);\n                    return cachedAuthorizationResult;\n                }\n                return yield this.transact((wallet)=>__awaiter(this, void 0, void 0, function*() {\n                        const authorizationResult = yield wallet.authorize({\n                            chain: this._chain,\n                            identity: this._appIdentity,\n                            sign_in_payload: signInPayload\n                        });\n                        // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                        Promise.all([\n                            this._authorizationResultCache.set(authorizationResult),\n                            this.handleAuthorizationResult(authorizationResult)\n                        ]);\n                        return authorizationResult;\n                    }));\n            } catch (e) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletConnectionError(e instanceof Error && e.message || \"Unknown error\", e);\n            }\n        });\n    }\n    handleAuthorizationResult(authorizationResult) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const didPublicKeysChange = // Case 1: We started from having no authorization.\n            this._authorizationResult == null || // Case 2: The number of authorized accounts changed.\n            ((_a = this._authorizationResult) === null || _a === void 0 ? void 0 : _a.accounts.length) !== authorizationResult.accounts.length || // Case 3: The new list of addresses isn't exactly the same as the old list, in the same order.\n            this._authorizationResult.accounts.some((account, ii)=>account.address !== authorizationResult.accounts[ii].address);\n            this._authorizationResult = authorizationResult;\n            this.declareWalletAsInstalled();\n            if (didPublicKeysChange) {\n                const nextSelectedAddress = yield this._addressSelector.select(authorizationResult.accounts.map(({ address })=>address));\n                if (nextSelectedAddress !== this._selectedAddress) {\n                    this._selectedAddress = nextSelectedAddress;\n                    delete this._publicKey;\n                    this.emit(\"connect\", // Having just set `this._selectedAddress`, `this.publicKey` is definitely non-null\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    this.publicKey);\n                }\n            }\n        });\n    }\n    performReauthorization(wallet, authToken) {\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                const authorizationResult = yield wallet.authorize({\n                    auth_token: authToken,\n                    identity: this._appIdentity\n                });\n                // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                Promise.all([\n                    this._authorizationResultCache.set(authorizationResult),\n                    this.handleAuthorizationResult(authorizationResult)\n                ]);\n            } catch (e) {\n                this.disconnect();\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletDisconnectedError(e instanceof Error && (e === null || e === void 0 ? void 0 : e.message) || \"Unknown error\", e);\n            }\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this._authorizationResultCache.clear(); // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n            this._connecting = false;\n            this._connectionGeneration++;\n            delete this._authorizationResult;\n            delete this._publicKey;\n            delete this._selectedAddress;\n            this.emit(\"disconnect\");\n        });\n    }\n    transact(callback) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const walletUriBase = (_a = this._authorizationResult) === null || _a === void 0 ? void 0 : _a.wallet_uri_base;\n            const config = walletUriBase ? {\n                baseUri: walletUriBase\n            } : undefined;\n            const remoteConfig = this._hostAuthority ? {\n                remoteHostAuthority: this._hostAuthority\n            } : undefined;\n            const currentConnectionGeneration = this._connectionGeneration;\n            try {\n                return yield (0,_solana_mobile_mobile_wallet_adapter_protocol_web3js__WEBPACK_IMPORTED_MODULE_1__.transact)(callback, Object.assign(Object.assign({}, config), remoteConfig));\n            } catch (e) {\n                if (this._connectionGeneration !== currentConnectionGeneration) {\n                    yield new Promise(()=>{}); // Never resolve.\n                }\n                if (e instanceof Error && e.name === \"SolanaMobileWalletAdapterError\" && e.code === \"ERROR_WALLET_NOT_FOUND\") {\n                    yield this._onWalletNotFound(this);\n                }\n                throw e;\n            }\n        });\n    }\n    assertIsAuthorized() {\n        if (!this._authorizationResult || !this._selectedAddress) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletNotConnectedError();\n        return {\n            authToken: this._authorizationResult.auth_token,\n            selectedAddress: this._selectedAddress\n        };\n    }\n    performSignTransactions(transactions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { authToken } = this.assertIsAuthorized();\n            try {\n                return yield this.transact((wallet)=>__awaiter(this, void 0, void 0, function*() {\n                        yield this.performReauthorization(wallet, authToken);\n                        const signedTransactions = yield wallet.signTransactions({\n                            transactions\n                        });\n                        return signedTransactions;\n                    }));\n            } catch (error) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n            }\n        });\n    }\n    sendTransaction(transaction, connection, options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return yield this.runWithGuard(()=>__awaiter(this, void 0, void 0, function*() {\n                    const { authToken } = this.assertIsAuthorized();\n                    const minContextSlot = options === null || options === void 0 ? void 0 : options.minContextSlot;\n                    try {\n                        return yield this.transact((wallet)=>__awaiter(this, void 0, void 0, function*() {\n                                function getTargetCommitment() {\n                                    let targetCommitment;\n                                    switch(connection.commitment){\n                                        case \"confirmed\":\n                                        case \"finalized\":\n                                        case \"processed\":\n                                            targetCommitment = connection.commitment;\n                                            break;\n                                        default:\n                                            targetCommitment = \"finalized\";\n                                    }\n                                    let targetPreflightCommitment;\n                                    switch(options === null || options === void 0 ? void 0 : options.preflightCommitment){\n                                        case \"confirmed\":\n                                        case \"finalized\":\n                                        case \"processed\":\n                                            targetPreflightCommitment = options.preflightCommitment;\n                                            break;\n                                        case undefined:\n                                            targetPreflightCommitment = targetCommitment;\n                                            break;\n                                        default:\n                                            targetPreflightCommitment = \"finalized\";\n                                    }\n                                    const preflightCommitmentScore = targetPreflightCommitment === \"finalized\" ? 2 : targetPreflightCommitment === \"confirmed\" ? 1 : 0;\n                                    const targetCommitmentScore = targetCommitment === \"finalized\" ? 2 : targetCommitment === \"confirmed\" ? 1 : 0;\n                                    return preflightCommitmentScore < targetCommitmentScore ? targetPreflightCommitment : targetCommitment;\n                                }\n                                const [capabilities, _1, _2] = yield Promise.all([\n                                    wallet.getCapabilities(),\n                                    this.performReauthorization(wallet, authToken),\n                                    isVersionedTransaction(transaction) ? null : /**\n                                   * Unlike versioned transactions, legacy `Transaction` objects\n                                   * may not have an associated `feePayer` or `recentBlockhash`.\n                                   * This code exists to patch them up in case they are missing.\n                                   */ (()=>__awaiter(this, void 0, void 0, function*() {\n                                            var _a;\n                                            transaction.feePayer || (transaction.feePayer = (_a = this.publicKey) !== null && _a !== void 0 ? _a : undefined);\n                                            if (transaction.recentBlockhash == null) {\n                                                const { blockhash } = yield connection.getLatestBlockhash({\n                                                    commitment: getTargetCommitment()\n                                                });\n                                                transaction.recentBlockhash = blockhash;\n                                            }\n                                        }))()\n                                ]);\n                                if (capabilities.supports_sign_and_send_transactions) {\n                                    const signatures = yield wallet.signAndSendTransactions({\n                                        minContextSlot,\n                                        transactions: [\n                                            transaction\n                                        ]\n                                    });\n                                    return signatures[0];\n                                } else {\n                                    const [signedTransaction] = yield wallet.signTransactions({\n                                        transactions: [\n                                            transaction\n                                        ]\n                                    });\n                                    if (isVersionedTransaction(signedTransaction)) {\n                                        return yield connection.sendTransaction(signedTransaction);\n                                    } else {\n                                        const serializedTransaction = signedTransaction.serialize();\n                                        return yield connection.sendRawTransaction(serializedTransaction, Object.assign(Object.assign({}, options), {\n                                            preflightCommitment: getTargetCommitment()\n                                        }));\n                                    }\n                                }\n                            }));\n                    } catch (error) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletSendTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n                    }\n                }));\n        });\n    }\n    signTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return yield this.runWithGuard(()=>__awaiter(this, void 0, void 0, function*() {\n                    const [signedTransaction] = yield this.performSignTransactions([\n                        transaction\n                    ]);\n                    return signedTransaction;\n                }));\n        });\n    }\n    signAllTransactions(transactions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return yield this.runWithGuard(()=>__awaiter(this, void 0, void 0, function*() {\n                    const signedTransactions = yield this.performSignTransactions(transactions);\n                    return signedTransactions;\n                }));\n        });\n    }\n    signMessage(message) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return yield this.runWithGuard(()=>__awaiter(this, void 0, void 0, function*() {\n                    const { authToken, selectedAddress } = this.assertIsAuthorized();\n                    try {\n                        return yield this.transact((wallet)=>__awaiter(this, void 0, void 0, function*() {\n                                yield this.performReauthorization(wallet, authToken);\n                                const [signedMessage] = yield wallet.signMessages({\n                                    addresses: [\n                                        selectedAddress\n                                    ],\n                                    payloads: [\n                                        message\n                                    ]\n                                });\n                                const signature = signedMessage.slice(-SIGNATURE_LENGTH_IN_BYTES$1);\n                                return signature;\n                            }));\n                    } catch (error) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletSignMessageError(error === null || error === void 0 ? void 0 : error.message, error);\n                    }\n                }));\n        });\n    }\n    signIn(input) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return yield this.runWithGuard(()=>__awaiter(this, void 0, void 0, function*() {\n                    var _a, _b;\n                    if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Installed && this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Loadable) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletNotReadyError();\n                    }\n                    this._connecting = true;\n                    try {\n                        const authorizationResult = yield this.performAuthorization(Object.assign(Object.assign({}, input), {\n                            domain: (_a = input === null || input === void 0 ? void 0 : input.domain) !== null && _a !== void 0 ? _a : window.location.host\n                        }));\n                        if (!authorizationResult.sign_in_result) {\n                            throw new Error(\"Sign in failed, no sign in result returned by wallet\");\n                        }\n                        const signedInAddress = authorizationResult.sign_in_result.address;\n                        const signedInAccount = Object.assign(Object.assign({}, (_b = authorizationResult.accounts.find((acc)=>acc.address == signedInAddress)) !== null && _b !== void 0 ? _b : {\n                            address: signedInAddress\n                        }), {\n                            publicKey: toUint8Array(signedInAddress)\n                        });\n                        return {\n                            account: signedInAccount,\n                            signedMessage: toUint8Array(authorizationResult.sign_in_result.signed_message),\n                            signature: toUint8Array(authorizationResult.sign_in_result.signature)\n                        };\n                    } catch (e) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletConnectionError(e instanceof Error && e.message || \"Unknown error\", e);\n                    } finally{\n                        this._connecting = false;\n                    }\n                }));\n        });\n    }\n}\nconst BluetoothHtml = `\r\n    <div class=\"mobile-wallet-adapter-embedded-modal-content\">\r\n    <button id=\"mobile-wallet-adapter-embedded-modal-close\" class=\"mobile-wallet-adapter-embedded-modal-close\">\r\n        <svg width=\"14\" height=\"14\">\r\n        <path d=\"M14 12.461 8.3 6.772l5.234-5.233L12.006 0 6.772 5.234 1.54 0 0 1.539l5.234 5.233L0 12.006l1.539 1.528L6.772 8.3l5.69 5.7L14 12.461z\" />\r\n        </svg>\r\n    </button>\r\n    <h1><b>Jupiter</b> wants to connect</h1>\r\n    <p class=\"mobile-wallet-adapter-embedded-modal-subtitle\">Connect to your mobile wallet app through Bluetooth.</p>\r\n    <div class=\"mobile-wallet-adapter-embedded-modal-connection-status-container\">\r\n        <div id=\"status-not-connected\" class=\"connection-status\">\r\n        <svg class=\"bluetooth-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\r\n            <path fill=\"#a0a0a0\" d=\"M14.24 12.01l2.32 2.32c.28-.72.44-1.51.44-2.33 0-.82-.16-1.59-.43-2.31l-2.33 2.32zm5.29-5.3l-1.26 1.26c.63 1.21.98 2.57.98 4.02s-.36 2.82-.98 4.02l1.2 1.2c.97-1.54 1.54-3.36 1.54-5.31-.01-1.89-.55-3.67-1.48-5.19zm-3.82 1L10 2H9v7.59L4.41 5 3 6.41 8.59 12 3 17.59 4.41 19 9 14.41V22h1l5.71-5.71-4.3-4.29 4.3-4.29zM11 5.83l1.88 1.88L11 9.59V5.83zm1.88 10.46L11 18.17v-3.76l1.88 1.88z\"/>\r\n        </svg>\r\n        <p>Not connected</p>\r\n        </div>\r\n        <div id=\"status-connecting\" class=\"connection-status\" style=\"display:none;\">\r\n        <div class=\"spinner\"></div>\r\n        <p>Connecting...</p>\r\n        </div>\r\n        <div id=\"status-connected\" class=\"connection-status\" style=\"display:none;\">\r\n        <svg class=\"checkmark-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\r\n            <path fill=\"#4CAF50\" d=\"M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z\"/>\r\n        </svg>\r\n        <p>Connected</p>\r\n        </div>\r\n    </div>\r\n    <div class=\"button-group\">\r\n        <button id=\"cancel-btn\" class=\"cancel-btn\">Cancel</button>\r\n        <button id=\"connect-btn\" class=\"connect-btn\">Connect</button>\r\n    </div>\r\n    </div>\r\n`;\nconst QRCodeHtml = `\r\n<div class=\"mobile-wallet-adapter-embedded-modal-content\">\r\n  <button id=\"mobile-wallet-adapter-embedded-modal-close\" class=\"mobile-wallet-adapter-embedded-modal-close\">\r\n    <svg width=\"14\" height=\"14\">\r\n      <path d=\"M14 12.461 8.3 6.772l5.234-5.233L12.006 0 6.772 5.234 1.54 0 0 1.539l5.234 5.233L0 12.006l1.539 1.528L6.772 8.3l5.69 5.7L14 12.461z\" />\r\n    </svg>\r\n  </button>\r\n  <h1>Scan to connect</h1>\r\n  <p class=\"mobile-wallet-adapter-embedded-modal-subtitle\">Use your wallet app to scan the QR Code and connect.</p>\r\n  <div id=\"mobile-wallet-adapter-embedded-modal-qr-code-container\" />\r\n</div>\r\n`;\nconst css = `\r\n.mobile-wallet-adapter-embedded-modal {\r\n    display: flex; /* Use flexbox to center content */\r\n    flex-direction: column;\r\n    justify-content: center; /* Center horizontally */\r\n    align-items: center; /* Center vertically */\r\n    position: fixed; /* Stay in place */\r\n    z-index: 1; /* Sit on top */\r\n    left: 0;\r\n    top: 0;\r\n    width: 100%; /* Full width */\r\n    height: 100%; /* Full height */\r\n    background-color: rgba(0,0,0,0.4); /* Black w/ opacity */\r\n}\r\n\r\n.mobile-wallet-adapter-embedded-modal-content {\r\n    background: #10141f;\r\n    padding: 20px;\r\n    border-radius: 10px;\r\n    width: 80%;\r\n    max-width: 500px;\r\n    text-align: center;\r\n    position: relative;\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: center; /* Center children horizontally */\r\n}\r\n\r\n.mobile-wallet-adapter-embedded-modal-subtitle {\r\n    color: #D8D8D8;\r\n}\r\n\r\n.mobile-wallet-adapter-embedded-modal-close {\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    position: absolute;\r\n    top: 18px;\r\n    right: 18px;\r\n    padding: 12px;\r\n    cursor: pointer;\r\n    background: #1a1f2e;\r\n    border: none;\r\n    border-radius: 50%;\r\n}\r\n\r\n.mobile-wallet-adapter-embedded-modal-close:focus-visible {\r\n    outline-color: white;\r\n}\r\n\r\n.mobile-wallet-adapter-embedded-modal-close svg {\r\n    fill: #777;\r\n    transition: fill 200ms ease 0s;\r\n}\r\n\r\n.mobile-wallet-adapter-embedded-modal-close:hover svg {\r\n    fill: #fff;\r\n}\r\n\r\n.icon-container {\r\n    display: flex;\r\n    justify-content: center;\r\n    margin-bottom: 20px;\r\n}\r\n\r\n.icon {\r\n    width: 80px;\r\n    height: 80px;\r\n    border-radius: 50%;\r\n    background-color: #ddd; /* Placeholder for icon background */\r\n}\r\n\r\n/* Modal Title */\r\n.mobile-wallet-adapter-embedded-modal-content h1 {\r\n    color: white;\r\n    font-size: 24px;   \r\n}\r\n\r\n.button-group {\r\n    display: flex;\r\n    width: 100%;\r\n    gap: 10px;\r\n}\r\n\r\n.connect-btn, .cancel-btn {\r\n    flex: 1;\r\n    padding: 12px 20px;\r\n    font-size: 16px;\r\n    cursor: pointer;\r\n    border-radius: 10px;\r\n    transition: all 0.3s ease;\r\n}\r\n\r\n.connect-btn {\r\n    background-color: #007bff;\r\n    color: white;\r\n    border: none;\r\n}\r\n\r\n.connect-btn:hover {\r\n    background-color: #0056b3;\r\n}\r\n\r\n.cancel-btn {\r\n    background-color: transparent;\r\n    color: #a0a0a0;\r\n    border: 1px solid #a0a0a0;\r\n}\r\n\r\n.cancel-btn:hover {\r\n    background-color: rgba(160, 160, 160, 0.1);\r\n}\r\n\r\n/* BT Connection Status */\r\n\r\n.mobile-wallet-adapter-embedded-modal-connection-status-container {\r\n    margin: 20px 0px 20px 0px;\r\n}\r\n\r\n.connection-status {\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: center;\r\n    justify-content: center;\r\n    margin: 20px 0;\r\n}\r\n  \r\n.connection-status p {\r\n    margin-top: 10px;\r\n    color: #a0a0a0;\r\n}\r\n  \r\n.bluetooth-icon, .checkmark-icon {\r\n    width: 48px;\r\n    height: 48px;\r\n}\r\n  \r\n.spinner {\r\n    border: 4px solid #f3f3f3;\r\n    border-top: 4px solid #3498db;\r\n    border-radius: 50%;\r\n    width: 40px;\r\n    height: 40px;\r\n    animation: spin 1s linear infinite;\r\n}\r\n  \r\n@keyframes spin {\r\n    0% { transform: rotate(0deg); }\r\n    100% { transform: rotate(360deg); }\r\n}\r\n\r\n/* QR Code */\r\n\r\n#mobile-wallet-adapter-embedded-modal-qr-code-container {\r\n    width: 500px;\r\n    height: 500px;\r\n    align-content: center;\r\n}\r\n`;\nclass EmbeddedModal {\n    constructor(title){\n        this._root = null;\n        this._title = title;\n        // Bind methods to ensure `this` context is correct\n        this.init = this.init.bind(this);\n        this.injectQRCodeHTML = this.injectQRCodeHTML.bind(this);\n        this.injectBluetoothHTML = this.injectBluetoothHTML.bind(this);\n        this.open = this.open.bind(this);\n        this.close = this.close.bind(this);\n        this.connect = this.connect.bind(this);\n        this._root = document.getElementById(\"mobile-wallet-adapter-embedded-root-ui\");\n    }\n    init(qrCode) {\n        return __awaiter(this, void 0, void 0, function*() {\n            console.log(\"Injecting modal\");\n            this.injectStyles();\n            this.injectQRCodeHTML(qrCode);\n        });\n    }\n    setConnectionStatus(status) {\n        if (!this._root) return;\n        const statuses = [\n            \"not-connected\",\n            \"connecting\",\n            \"connected\"\n        ];\n        statuses.forEach((s)=>{\n            const el = this._root.querySelector(`#status-${s}`);\n            if (el instanceof HTMLElement) {\n                el.style.display = s === status ? \"flex\" : \"none\";\n            }\n        });\n    }\n    injectStyles() {\n        // Check if the styles have already been injected\n        if (document.getElementById(\"mobile-wallet-adapter-styles\")) {\n            return;\n        }\n        const styleElement = document.createElement(\"style\");\n        styleElement.id = \"mobile-wallet-adapter-styles\";\n        styleElement.textContent = css;\n        document.head.appendChild(styleElement);\n    }\n    populateQRCode(qrUrl) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const qrcodeContainer = document.getElementById(\"mobile-wallet-adapter-embedded-modal-qr-code-container\");\n            if (qrcodeContainer) {\n                const qrCodeElement = yield qrcode__WEBPACK_IMPORTED_MODULE_2__.toCanvas(qrUrl, {\n                    width: 400\n                });\n                if (qrcodeContainer.firstElementChild !== null) {\n                    qrcodeContainer.replaceChild(qrCodeElement, qrcodeContainer.firstElementChild);\n                } else qrcodeContainer.appendChild(qrCodeElement);\n            } else {\n                console.error(\"QRCode Container not found\");\n            }\n        });\n    }\n    injectQRCodeHTML(qrCode) {\n        // Check if the HTML has already been injected\n        if (document.getElementById(\"mobile-wallet-adapter-embedded-root-ui\")) {\n            if (!this._root) this._root = document.getElementById(\"mobile-wallet-adapter-embedded-root-ui\");\n            this.populateQRCode(qrCode);\n            return;\n        }\n        // Create a container for the modal\n        this._root = document.createElement(\"div\");\n        this._root.id = \"mobile-wallet-adapter-embedded-root-ui\";\n        this._root.className = \"mobile-wallet-adapter-embedded-modal\";\n        this._root.innerHTML = QRCodeHtml;\n        this._root.style.display = \"none\";\n        // Append the modal to the body\n        document.body.appendChild(this._root);\n        // Render the QRCode\n        this.populateQRCode(qrCode);\n        this.attachEventListeners();\n    }\n    injectBluetoothHTML() {\n        // Check if the HTML has already been injected\n        if (document.getElementById(\"mobile-wallet-adapter-embedded-root-ui\")) {\n            return;\n        }\n        this._root = document.createElement(\"div\");\n        this._root.id = \"mobile-wallet-adapter-embedded-root-ui\";\n        this._root.className = \"mobile-wallet-adapter-embedded-modal\";\n        this._root.innerHTML = BluetoothHtml;\n        document.body.appendChild(this._root);\n        this.attachEventListeners();\n    }\n    attachEventListeners() {\n        if (!this._root) return;\n        const closeBtn = this._root.querySelector(\"#mobile-wallet-adapter-embedded-modal-close\");\n        const cancelBtn = this._root.querySelector(\"#cancel-btn\");\n        const connectBtn = this._root.querySelector(\"#connect-btn\");\n        closeBtn === null || closeBtn === void 0 ? void 0 : closeBtn.addEventListener(\"click\", ()=>this.close());\n        cancelBtn === null || cancelBtn === void 0 ? void 0 : cancelBtn.addEventListener(\"click\", ()=>this.close());\n        connectBtn === null || connectBtn === void 0 ? void 0 : connectBtn.addEventListener(\"click\", ()=>this.connect());\n    }\n    open() {\n        console.debug(\"Modal open\");\n        if (this._root) {\n            this._root.style.display = \"flex\";\n            this.setConnectionStatus(\"not-connected\"); // Reset status when opening\n        }\n    }\n    close() {\n        console.debug(\"Modal close\");\n        if (this._root) {\n            this._root.style.display = \"none\";\n            this.setConnectionStatus(\"not-connected\"); // Reset status when closing\n        }\n    }\n    connect() {\n        console.log(\"Connecting...\");\n        // Mock connection\n        this.setConnectionStatus(\"connecting\");\n        // Simulate connection process\n        setTimeout(()=>{\n            this.setConnectionStatus(\"connected\");\n            console.log(\"Connected!\");\n        }, 5000); // 5 seconds delay\n    }\n}\nconst SolanaMobileWalletAdapterRemoteWalletName = \"MWA (Remote)\";\nconst SIGNATURE_LENGTH_IN_BYTES = 64;\nfunction getPublicKeyFromAddress(address) {\n    const publicKeyByteArray = (0,js_base64__WEBPACK_IMPORTED_MODULE_6__.toUint8Array)(address);\n    return new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(publicKeyByteArray);\n}\n/**\n * Determine the mobile operating system.\n * Returns true if running on a mobile operating system, or false otherwise.\n *\n * @returns {boolean}\n */ function isMobileOperatingSystem() {\n    var userAgent = navigator.userAgent;\n    // Windows Phone must come first because its UA also contains \"Android\"\n    if (/windows phone/i.test(userAgent)) {\n        return true;\n    }\n    if (/android/i.test(userAgent)) {\n        return true;\n    }\n    // iOS detection from: http://stackoverflow.com/a/9039885/177710\n    if (/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream) {\n        return true;\n    }\n    return false;\n}\nfunction getIsSupported() {\n    return  false && 0;\n}\n/**\n * This burner wallet adapter is unsafe to use and is only included to provide an easy way for applications to test\n * Wallet Adapter without using a third-party wallet.\n */ class SolanaMobileWalletAdapterRemote extends _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.BaseSignInMessageSignerWalletAdapter {\n    constructor(config){\n        super();\n        this.supportedTransactionVersions = new Set(// FIXME(#244): We can't actually know what versions are supported until we know which wallet we're talking to.\n        [\n            \"legacy\",\n            0\n        ]);\n        this.name = SolanaMobileWalletAdapterRemoteWalletName;\n        this.url = \"https://solanamobile.com/wallets\";\n        this.icon = \"data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjI4IiB3aWR0aD0iMjgiIHZpZXdCb3g9Ii0zIDAgMjggMjgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI0RDQjhGRiI+PHBhdGggZD0iTTE3LjQgMTcuNEgxNXYyLjRoMi40di0yLjRabTEuMi05LjZoLTIuNHYyLjRoMi40VjcuOFoiLz48cGF0aCBkPSJNMjEuNiAzVjBoLTIuNHYzaC0zLjZWMGgtMi40djNoLTIuNHY2LjZINC41YTIuMSAyLjEgMCAxIDEgMC00LjJoMi43VjNINC41QTQuNSA0LjUgMCAwIDAgMCA3LjVWMjRoMjEuNnYtNi42aC0yLjR2NC4ySDIuNFYxMS41Yy41LjMgMS4yLjQgMS44LjVoNy41QTYuNiA2LjYgMCAwIDAgMjQgOVYzaC0yLjRabTAgNS43YTQuMiA0LjIgMCAxIDEtOC40IDBWNS40aDguNHYzLjNaIi8+PC9nPjwvc3ZnPg==\";\n        this._connecting = false;\n        /**\n         * Every time the connection is recycled in some way (eg. `disconnect()` is called)\n         * increment this and use it to make sure that `transact` calls from the previous\n         * 'generation' don't continue to do work and throw exceptions.\n         */ this._connectionGeneration = 0;\n        this._readyState = getIsSupported() ? _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Loadable : _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Unsupported;\n        this._authorizationResultCache = config.authorizationResultCache;\n        this._addressSelector = config.addressSelector;\n        this._appIdentity = config.appIdentity;\n        this._chain = config.chain;\n        this._hostAuthority = config.remoteHostAuthority;\n        this._onWalletNotFound = config.onWalletNotFound;\n        if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Unsupported) {\n            this._authorizationResultCache.get().then((authorizationResult)=>{\n                if (authorizationResult) {\n                    // Having a prior authorization result is, right now, the best\n                    // indication that a mobile wallet is installed. There is no API\n                    // we can use to test for whether the association URI is supported.\n                    this.declareWalletAsInstalled();\n                }\n            });\n        }\n    }\n    get publicKey() {\n        if (this._publicKey == null && this._selectedAddress != null) {\n            try {\n                this._publicKey = getPublicKeyFromAddress(this._selectedAddress);\n            } catch (e) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletPublicKeyError(e instanceof Error && (e === null || e === void 0 ? void 0 : e.message) || \"Unknown error\", e);\n            }\n        }\n        return this._publicKey ? this._publicKey : null;\n    }\n    get connected() {\n        return !!this._authorizationResult;\n    }\n    get connecting() {\n        return this._connecting;\n    }\n    get readyState() {\n        return this._readyState;\n    }\n    declareWalletAsInstalled() {\n        if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Installed) {\n            this.emit(\"readyStateChange\", this._readyState = _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Installed);\n        }\n    }\n    runWithGuard(callback) {\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                return yield callback();\n            } catch (e) {\n                this.emit(\"error\", e);\n                throw e;\n            }\n        });\n    }\n    autoConnect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.connecting || this.connected) {\n                return;\n            }\n            return yield this.runWithGuard(()=>__awaiter(this, void 0, void 0, function*() {\n                    if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Installed && this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Loadable) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletNotReadyError();\n                    }\n                    this._connecting = true;\n                    try {\n                        const cachedAuthorizationResult = yield this._authorizationResultCache.get();\n                        if (cachedAuthorizationResult) {\n                            // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                            this.handleAuthorizationResult(cachedAuthorizationResult);\n                        }\n                    } catch (e) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletConnectionError(e instanceof Error && e.message || \"Unknown error\", e);\n                    } finally{\n                        this._connecting = false;\n                    }\n                }));\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.connecting || this.connected) {\n                return;\n            }\n            return yield this.runWithGuard(()=>__awaiter(this, void 0, void 0, function*() {\n                    if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Installed && this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Loadable) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletNotReadyError();\n                    }\n                    this._connecting = true;\n                    try {\n                        yield this.performAuthorization();\n                    } catch (e) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletConnectionError(e instanceof Error && e.message || \"Unknown error\", e);\n                    } finally{\n                        this._connecting = false;\n                    }\n                }));\n        });\n    }\n    performAuthorization(signInPayload) {\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                const cachedAuthorizationResult = yield this._authorizationResultCache.get();\n                if (cachedAuthorizationResult) {\n                    // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                    this.handleAuthorizationResult(cachedAuthorizationResult);\n                    return cachedAuthorizationResult;\n                }\n                if (this._wallet) delete this._wallet;\n                return yield this.transact((wallet)=>__awaiter(this, void 0, void 0, function*() {\n                        this._wallet = wallet;\n                        const authorizationResult = yield wallet.authorize({\n                            chain: this._chain,\n                            identity: this._appIdentity,\n                            sign_in_payload: signInPayload\n                        });\n                        // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                        Promise.all([\n                            this._authorizationResultCache.set(authorizationResult),\n                            this.handleAuthorizationResult(authorizationResult)\n                        ]);\n                        return authorizationResult;\n                    }));\n            } catch (e) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletConnectionError(e instanceof Error && e.message || \"Unknown error\", e);\n            }\n        });\n    }\n    handleAuthorizationResult(authorizationResult) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const didPublicKeysChange = // Case 1: We started from having no authorization.\n            this._authorizationResult == null || // Case 2: The number of authorized accounts changed.\n            ((_a = this._authorizationResult) === null || _a === void 0 ? void 0 : _a.accounts.length) !== authorizationResult.accounts.length || // Case 3: The new list of addresses isn't exactly the same as the old list, in the same order.\n            this._authorizationResult.accounts.some((account, ii)=>account.address !== authorizationResult.accounts[ii].address);\n            this._authorizationResult = authorizationResult;\n            this.declareWalletAsInstalled();\n            if (didPublicKeysChange) {\n                const nextSelectedAddress = yield this._addressSelector.select(authorizationResult.accounts.map(({ address })=>address));\n                if (nextSelectedAddress !== this._selectedAddress) {\n                    this._selectedAddress = nextSelectedAddress;\n                    delete this._publicKey;\n                    this.emit(\"connect\", // Having just set `this._selectedAddress`, `this.publicKey` is definitely non-null\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    this.publicKey);\n                }\n            }\n        });\n    }\n    performReauthorization(wallet, authToken) {\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                const authorizationResult = yield wallet.authorize({\n                    auth_token: authToken,\n                    identity: this._appIdentity\n                });\n                // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                Promise.all([\n                    this._authorizationResultCache.set(authorizationResult),\n                    this.handleAuthorizationResult(authorizationResult)\n                ]);\n            } catch (e) {\n                this.disconnect();\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletDisconnectedError(e instanceof Error && (e === null || e === void 0 ? void 0 : e.message) || \"Unknown error\", e);\n            }\n        });\n    }\n    disconnect() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            // TODO: figure out why this call throws \"TypeError: _a.terminateSession is not a function\"\n            //  even though the session termination is actually executed (websocket closes). \n            try {\n                (_a = this._wallet) === null || _a === void 0 ? void 0 : _a.terminateSession();\n            } catch (e) {}\n            this._authorizationResultCache.clear(); // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n            this._connecting = false;\n            this._connectionGeneration++;\n            delete this._authorizationResult;\n            delete this._publicKey;\n            delete this._selectedAddress;\n            delete this._wallet;\n            this.emit(\"disconnect\");\n        });\n    }\n    transact(callback) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const walletUriBase = (_a = this._authorizationResult) === null || _a === void 0 ? void 0 : _a.wallet_uri_base;\n            const baseConfig = walletUriBase ? {\n                baseUri: walletUriBase\n            } : undefined;\n            const remoteConfig = Object.assign(Object.assign({}, baseConfig), {\n                remoteHostAuthority: this._hostAuthority\n            });\n            const currentConnectionGeneration = this._connectionGeneration;\n            const modal = new EmbeddedModal(\"MWA QR\");\n            if (this._wallet) {\n                return callback(this._wallet);\n            }\n            try {\n                const { associationUrl, result: promise } = yield (0,_solana_mobile_mobile_wallet_adapter_protocol_web3js__WEBPACK_IMPORTED_MODULE_1__.transactRemote)((wallet)=>__awaiter(this, void 0, void 0, function*() {\n                        const result = yield callback(wallet);\n                        modal.close();\n                        return result;\n                    }), remoteConfig);\n                modal.init(associationUrl.toString());\n                modal.open();\n                return yield promise;\n            } catch (e) {\n                modal.close();\n                if (this._connectionGeneration !== currentConnectionGeneration) {\n                    yield new Promise(()=>{}); // Never resolve.\n                }\n                if (e instanceof Error && e.name === \"SolanaMobileWalletAdapterError\" && e.code === \"ERROR_WALLET_NOT_FOUND\") {\n                    yield this._onWalletNotFound(this);\n                }\n                throw e;\n            }\n        });\n    }\n    assertIsAuthorized() {\n        if (!this._authorizationResult || !this._selectedAddress) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletNotConnectedError();\n        return {\n            authToken: this._authorizationResult.auth_token,\n            selectedAddress: this._selectedAddress\n        };\n    }\n    performSignTransactions(transactions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { authToken } = this.assertIsAuthorized();\n            try {\n                return yield this.transact((wallet)=>__awaiter(this, void 0, void 0, function*() {\n                        yield this.performReauthorization(wallet, authToken);\n                        const signedTransactions = yield wallet.signTransactions({\n                            transactions\n                        });\n                        return signedTransactions;\n                    }));\n            } catch (error) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n            }\n        });\n    }\n    sendTransaction(transaction, connection, options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return yield this.runWithGuard(()=>__awaiter(this, void 0, void 0, function*() {\n                    const { authToken } = this.assertIsAuthorized();\n                    const minContextSlot = options === null || options === void 0 ? void 0 : options.minContextSlot;\n                    try {\n                        return yield this.transact((wallet)=>__awaiter(this, void 0, void 0, function*() {\n                                function getTargetCommitment() {\n                                    let targetCommitment;\n                                    switch(connection.commitment){\n                                        case \"confirmed\":\n                                        case \"finalized\":\n                                        case \"processed\":\n                                            targetCommitment = connection.commitment;\n                                            break;\n                                        default:\n                                            targetCommitment = \"finalized\";\n                                    }\n                                    let targetPreflightCommitment;\n                                    switch(options === null || options === void 0 ? void 0 : options.preflightCommitment){\n                                        case \"confirmed\":\n                                        case \"finalized\":\n                                        case \"processed\":\n                                            targetPreflightCommitment = options.preflightCommitment;\n                                            break;\n                                        case undefined:\n                                            targetPreflightCommitment = targetCommitment;\n                                            break;\n                                        default:\n                                            targetPreflightCommitment = \"finalized\";\n                                    }\n                                    const preflightCommitmentScore = targetPreflightCommitment === \"finalized\" ? 2 : targetPreflightCommitment === \"confirmed\" ? 1 : 0;\n                                    const targetCommitmentScore = targetCommitment === \"finalized\" ? 2 : targetCommitment === \"confirmed\" ? 1 : 0;\n                                    return preflightCommitmentScore < targetCommitmentScore ? targetPreflightCommitment : targetCommitment;\n                                }\n                                const [capabilities, _1, _2] = yield Promise.all([\n                                    wallet.getCapabilities(),\n                                    this.performReauthorization(wallet, authToken),\n                                    (0,_solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_7__.isVersionedTransaction)(transaction) ? null : /**\n                                   * Unlike versioned transactions, legacy `Transaction` objects\n                                   * may not have an associated `feePayer` or `recentBlockhash`.\n                                   * This code exists to patch them up in case they are missing.\n                                   */ (()=>__awaiter(this, void 0, void 0, function*() {\n                                            var _a;\n                                            transaction.feePayer || (transaction.feePayer = (_a = this.publicKey) !== null && _a !== void 0 ? _a : undefined);\n                                            if (transaction.recentBlockhash == null) {\n                                                const { blockhash } = yield connection.getLatestBlockhash({\n                                                    commitment: getTargetCommitment()\n                                                });\n                                                transaction.recentBlockhash = blockhash;\n                                            }\n                                        }))()\n                                ]);\n                                if (capabilities.supports_sign_and_send_transactions) {\n                                    const signatures = yield wallet.signAndSendTransactions({\n                                        minContextSlot,\n                                        transactions: [\n                                            transaction\n                                        ]\n                                    });\n                                    return signatures[0];\n                                } else {\n                                    const [signedTransaction] = yield wallet.signTransactions({\n                                        transactions: [\n                                            transaction\n                                        ]\n                                    });\n                                    if ((0,_solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_7__.isVersionedTransaction)(signedTransaction)) {\n                                        return yield connection.sendTransaction(signedTransaction);\n                                    } else {\n                                        const serializedTransaction = signedTransaction.serialize();\n                                        return yield connection.sendRawTransaction(serializedTransaction, Object.assign(Object.assign({}, options), {\n                                            preflightCommitment: getTargetCommitment()\n                                        }));\n                                    }\n                                }\n                            }));\n                    } catch (error) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletSendTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n                    }\n                }));\n        });\n    }\n    signTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return yield this.runWithGuard(()=>__awaiter(this, void 0, void 0, function*() {\n                    const [signedTransaction] = yield this.performSignTransactions([\n                        transaction\n                    ]);\n                    return signedTransaction;\n                }));\n        });\n    }\n    signAllTransactions(transactions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return yield this.runWithGuard(()=>__awaiter(this, void 0, void 0, function*() {\n                    const signedTransactions = yield this.performSignTransactions(transactions);\n                    return signedTransactions;\n                }));\n        });\n    }\n    signMessage(message) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return yield this.runWithGuard(()=>__awaiter(this, void 0, void 0, function*() {\n                    const { authToken, selectedAddress } = this.assertIsAuthorized();\n                    try {\n                        return yield this.transact((wallet)=>__awaiter(this, void 0, void 0, function*() {\n                                yield this.performReauthorization(wallet, authToken);\n                                const [signedMessage] = yield wallet.signMessages({\n                                    addresses: [\n                                        selectedAddress\n                                    ],\n                                    payloads: [\n                                        message\n                                    ]\n                                });\n                                const signature = signedMessage.slice(-SIGNATURE_LENGTH_IN_BYTES);\n                                return signature;\n                            }));\n                    } catch (error) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletSignMessageError(error === null || error === void 0 ? void 0 : error.message, error);\n                    }\n                }));\n        });\n    }\n    signIn(input) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return yield this.runWithGuard(()=>__awaiter(this, void 0, void 0, function*() {\n                    var _a, _b;\n                    if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Installed && this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Loadable) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletNotReadyError();\n                    }\n                    this._connecting = true;\n                    try {\n                        const authorizationResult = yield this.performAuthorization(Object.assign(Object.assign({}, input), {\n                            domain: (_a = input === null || input === void 0 ? void 0 : input.domain) !== null && _a !== void 0 ? _a : window.location.host\n                        }));\n                        if (!authorizationResult.sign_in_result) {\n                            throw new Error(\"Sign in failed, no sign in result returned by wallet\");\n                        }\n                        const signedInAddress = authorizationResult.sign_in_result.address;\n                        const signedInAccount = Object.assign(Object.assign({}, (_b = authorizationResult.accounts.find((acc)=>acc.address == signedInAddress)) !== null && _b !== void 0 ? _b : {\n                            address: signedInAddress\n                        }), {\n                            publicKey: (0,js_base64__WEBPACK_IMPORTED_MODULE_6__.toUint8Array)(signedInAddress)\n                        });\n                        return {\n                            account: signedInAccount,\n                            signedMessage: (0,js_base64__WEBPACK_IMPORTED_MODULE_6__.toUint8Array)(authorizationResult.sign_in_result.signed_message),\n                            signature: (0,js_base64__WEBPACK_IMPORTED_MODULE_6__.toUint8Array)(authorizationResult.sign_in_result.signature)\n                        };\n                    } catch (e) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletConnectionError(e instanceof Error && e.message || \"Unknown error\", e);\n                    } finally{\n                        this._connecting = false;\n                    }\n                }));\n        });\n    }\n}\nfunction createDefaultAddressSelector() {\n    return {\n        select (addresses) {\n            return __awaiter(this, void 0, void 0, function*() {\n                return addresses[0];\n            });\n        }\n    };\n}\nconst CACHE_KEY = \"SolanaMobileWalletAdapterDefaultAuthorizationCache\";\nfunction createDefaultAuthorizationResultCache() {\n    let storage;\n    try {\n        storage = window.localStorage;\n    // eslint-disable-next-line no-empty\n    } catch (_a) {}\n    return {\n        clear () {\n            return __awaiter(this, void 0, void 0, function*() {\n                if (!storage) {\n                    return;\n                }\n                try {\n                    storage.removeItem(CACHE_KEY);\n                // eslint-disable-next-line no-empty\n                } catch (_a) {}\n            });\n        },\n        get () {\n            return __awaiter(this, void 0, void 0, function*() {\n                if (!storage) {\n                    return;\n                }\n                try {\n                    return JSON.parse(storage.getItem(CACHE_KEY)) || undefined;\n                // eslint-disable-next-line no-empty\n                } catch (_a) {}\n            });\n        },\n        set (authorizationResult) {\n            return __awaiter(this, void 0, void 0, function*() {\n                if (!storage) {\n                    return;\n                }\n                try {\n                    storage.setItem(CACHE_KEY, JSON.stringify(authorizationResult));\n                // eslint-disable-next-line no-empty\n                } catch (_a) {}\n            });\n        }\n    };\n}\nfunction defaultWalletNotFoundHandler(mobileWalletAdapter) {\n    return __awaiter(this, void 0, void 0, function*() {\n        if (false) {}\n    });\n}\nfunction createDefaultWalletNotFoundHandler() {\n    return defaultWalletNotFoundHandler;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS1tb2JpbGUvd2FsbGV0LWFkYXB0ZXItbW9iaWxlL2xpYi9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZWO0FBQ2pUO0FBQ29EO0FBQ3BFO0FBQytCO0FBRTNEOzs7Ozs7Ozs7Ozs7OzhFQWE4RSxHQUU5RSxTQUFTa0IsVUFBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNoRCxTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxRQUFRLElBQUlILEVBQUUsU0FBVUksT0FBTztZQUFJQSxRQUFRRDtRQUFRO0lBQUk7SUFDM0csT0FBTyxJQUFLSCxDQUFBQSxLQUFNQSxDQUFBQSxJQUFJSyxPQUFNLENBQUMsRUFBRyxTQUFVRCxPQUFPLEVBQUVFLE1BQU07UUFDckQsU0FBU0MsVUFBVUosS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFVBQVVRLElBQUksQ0FBQ047WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUMxRixTQUFTQyxTQUFTUixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsU0FBUyxDQUFDLFFBQVEsQ0FBQ0U7WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUM3RixTQUFTRixLQUFLSSxNQUFNO1lBQUlBLE9BQU9DLElBQUksR0FBR1QsUUFBUVEsT0FBT1QsS0FBSyxJQUFJRCxNQUFNVSxPQUFPVCxLQUFLLEVBQUVXLElBQUksQ0FBQ1AsV0FBV0k7UUFBVztRQUM3R0gsS0FBSyxDQUFDUCxZQUFZQSxVQUFVYyxLQUFLLENBQUNqQixTQUFTQyxjQUFjLEVBQUUsR0FBR1UsSUFBSTtJQUN0RTtBQUNKO0FBRUEsU0FBU2QsYUFBYXFCLHNCQUFzQjtJQUN4QyxPQUFPLElBQUlDLFdBQVdDLE9BQ2pCQyxJQUFJLENBQUNILHdCQUNMSSxL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Z0JBQ0o7Z0JBQ0EsSUFBSTtvQkFDQUEsUUFBUUUsVUFBVSxDQUFDSjtnQkFDbkIsb0NBQW9DO2dCQUN4QyxFQUNBLE9BQU9uTSxJQUFJLENBQUU7WUFDakI7UUFDSjtRQUNBdUI7WUFDSSxPQUFPbkUsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztnQkFDbkMsSUFBSSxDQUFDaVAsU0FBUztvQkFDVjtnQkFDSjtnQkFDQSxJQUFJO29CQUNBLE9BQU9HLEtBQUtDLEtBQUssQ0FBQ0osUUFBUUssT0FBTyxDQUFDUCxlQUFlL0g7Z0JBQ2pELG9DQUFvQztnQkFDeEMsRUFDQSxPQUFPcEUsSUFBSSxDQUFFO1lBQ2pCO1FBQ0o7UUFDQW1ELEtBQUkzQixtQkFBbUI7WUFDbkIsT0FBT3BFLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7Z0JBQ25DLElBQUksQ0FBQ2lQLFNBQVM7b0JBQ1Y7Z0JBQ0o7Z0JBQ0EsSUFBSTtvQkFDQUEsUUFBUU0sT0FBTyxDQUFDUixXQUFXSyxLQUFLSSxTQUFTLENBQUNwTDtnQkFDMUMsb0NBQW9DO2dCQUN4QyxFQUNBLE9BQU94QixJQUFJLENBQUU7WUFDakI7UUFDSjtJQUNKO0FBQ0o7QUFFQSxTQUFTNk0sNkJBQTZCQyxtQkFBbUI7SUFDckQsT0FBTzFQLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7UUFDbkMsSUFBSSxLQUFrQixFQUFhLEVBRWxDO0lBQ0w7QUFDSjtBQUNBLFNBQVMyUDtJQUNMLE9BQU9GO0FBQ1g7QUFFK1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zb2xhbmEtbGlxdWlkaXR5LXBvb2wvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS1tb2JpbGUvd2FsbGV0LWFkYXB0ZXItbW9iaWxlL2xpYi9lc20vaW5kZXguanM/M2YxOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlU2lnbkluTWVzc2FnZVNpZ25lcldhbGxldEFkYXB0ZXIsIFdhbGxldFJlYWR5U3RhdGUsIFdhbGxldFB1YmxpY0tleUVycm9yLCBXYWxsZXROb3RSZWFkeUVycm9yLCBXYWxsZXRDb25uZWN0aW9uRXJyb3IsIFdhbGxldERpc2Nvbm5lY3RlZEVycm9yLCBXYWxsZXROb3RDb25uZWN0ZWRFcnJvciwgV2FsbGV0U2lnblRyYW5zYWN0aW9uRXJyb3IsIFdhbGxldFNlbmRUcmFuc2FjdGlvbkVycm9yLCBXYWxsZXRTaWduTWVzc2FnZUVycm9yLCBpc1ZlcnNpb25lZFRyYW5zYWN0aW9uIGFzIGlzVmVyc2lvbmVkVHJhbnNhY3Rpb24kMSB9IGZyb20gJ0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItYmFzZSc7XG5pbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdAc29sYW5hL3dlYjMuanMnO1xuaW1wb3J0IHsgdHJhbnNhY3QsIHRyYW5zYWN0UmVtb3RlIH0gZnJvbSAnQHNvbGFuYS1tb2JpbGUvbW9iaWxlLXdhbGxldC1hZGFwdGVyLXByb3RvY29sLXdlYjNqcyc7XG5pbXBvcnQgUVJDb2RlIGZyb20gJ3FyY29kZSc7XG5pbXBvcnQgeyB0b1VpbnQ4QXJyYXkgYXMgdG9VaW50OEFycmF5JDEgfSBmcm9tICdqcy1iYXNlNjQnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cblxuZnVuY3Rpb24gdG9VaW50OEFycmF5KGJhc2U2NEVuY29kZWRCeXRlQXJyYXkpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkod2luZG93XG4gICAgICAgIC5hdG9iKGJhc2U2NEVuY29kZWRCeXRlQXJyYXkpXG4gICAgICAgIC5zcGxpdCgnJylcbiAgICAgICAgLm1hcCgoYykgPT4gYy5jaGFyQ29kZUF0KDApKSk7XG59XG5cbmZ1bmN0aW9uIGdldElzU3VwcG9ydGVkJDEoKSB7XG4gICAgcmV0dXJuICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB3aW5kb3cuaXNTZWN1cmVDb250ZXh0ICYmXG4gICAgICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgL2FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKTtcbn1cblxuY29uc3QgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldE5hbWUgPSAnTW9iaWxlIFdhbGxldCBBZGFwdGVyJztcbmNvbnN0IFNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMkMSA9IDY0O1xuZnVuY3Rpb24gZ2V0UHVibGljS2V5RnJvbUFkZHJlc3MkMShhZGRyZXNzKSB7XG4gICAgY29uc3QgcHVibGljS2V5Qnl0ZUFycmF5ID0gdG9VaW50OEFycmF5KGFkZHJlc3MpO1xuICAgIHJldHVybiBuZXcgUHVibGljS2V5KHB1YmxpY0tleUJ5dGVBcnJheSk7XG59XG5mdW5jdGlvbiBpc1ZlcnNpb25lZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgcmV0dXJuICd2ZXJzaW9uJyBpbiB0cmFuc2FjdGlvbjtcbn1cbmZ1bmN0aW9uIGNsdXN0ZXJUb0NoYWluSWQoY2x1c3Rlcikge1xuICAgIHN3aXRjaCAoY2x1c3Rlcikge1xuICAgICAgICBjYXNlICdtYWlubmV0LWJldGEnOlxuICAgICAgICAgICAgcmV0dXJuICdzb2xhbmE6bWFpbm5ldCc7XG4gICAgICAgIGNhc2UgJ3Rlc3RuZXQnOlxuICAgICAgICAgICAgcmV0dXJuICdzb2xhbmE6dGVzdG5ldCc7XG4gICAgICAgIGNhc2UgJ2Rldm5ldCc6XG4gICAgICAgICAgICByZXR1cm4gJ3NvbGFuYTpkZXZuZXQnO1xuICAgIH1cbn1cbmNsYXNzIFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXIgZXh0ZW5kcyBCYXNlU2lnbkluTWVzc2FnZVNpZ25lcldhbGxldEFkYXB0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9ucyA9IG5ldyBTZXQoXG4gICAgICAgIC8vIEZJWE1FKCMyNDQpOiBXZSBjYW4ndCBhY3R1YWxseSBrbm93IHdoYXQgdmVyc2lvbnMgYXJlIHN1cHBvcnRlZCB1bnRpbCB3ZSBrbm93IHdoaWNoIHdhbGxldCB3ZSdyZSB0YWxraW5nIHRvLlxuICAgICAgICBbJ2xlZ2FjeScsIDBdKTtcbiAgICAgICAgdGhpcy5uYW1lID0gU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldE5hbWU7XG4gICAgICAgIHRoaXMudXJsID0gJ2h0dHBzOi8vc29sYW5hbW9iaWxlLmNvbS93YWxsZXRzJztcbiAgICAgICAgdGhpcy5pY29uID0gJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5Qm1hV3hzUFNKdWIyNWxJaUJvWldsbmFIUTlJakk0SWlCM2FXUjBhRDBpTWpnaUlIWnBaWGRDYjNnOUlpMHpJREFnTWpnZ01qZ2lJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStQR2NnWm1sc2JEMGlJMFJEUWpoR1JpSStQSEJoZEdnZ1pEMGlUVEUzTGpRZ01UY3VORWd4TlhZeUxqUm9NaTQwZGkweUxqUmFiVEV1TWkwNUxqWm9MVEl1TkhZeUxqUm9NaTQwVmpjdU9Gb2lMejQ4Y0dGMGFDQmtQU0pOTWpFdU5pQXpWakJvTFRJdU5IWXphQzB6TGpaV01HZ3RNaTQwZGpOb0xUSXVOSFkyTGpaSU5DNDFZVEl1TVNBeUxqRWdNQ0F4SURFZ01DMDBMakpvTWk0M1ZqTklOQzQxUVRRdU5TQTBMalVnTUNBd0lEQWdNQ0EzTGpWV01qUm9NakV1Tm5ZdE5pNDJhQzB5TGpSMk5DNHlTREl1TkZZeE1TNDFZeTQxTGpNZ01TNHlMalFnTVM0NExqVm9OeTQxUVRZdU5pQTJMallnTUNBd0lEQWdNalFnT1ZZemFDMHlMalJhYlRBZ05TNDNZVFF1TWlBMExqSWdNQ0F4SURFdE9DNDBJREJXTlM0MGFEZ3VOSFl6TGpOYUlpOCtQQzluUGp3dmMzWm5QZz09JztcbiAgICAgICAgdGhpcy5fY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZlcnkgdGltZSB0aGUgY29ubmVjdGlvbiBpcyByZWN5Y2xlZCBpbiBzb21lIHdheSAoZWcuIGBkaXNjb25uZWN0KClgIGlzIGNhbGxlZClcbiAgICAgICAgICogaW5jcmVtZW50IHRoaXMgYW5kIHVzZSBpdCB0byBtYWtlIHN1cmUgdGhhdCBgdHJhbnNhY3RgIGNhbGxzIGZyb20gdGhlIHByZXZpb3VzXG4gICAgICAgICAqICdnZW5lcmF0aW9uJyBkb24ndCBjb250aW51ZSB0byBkbyB3b3JrIGFuZCB0aHJvdyBleGNlcHRpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbkdlbmVyYXRpb24gPSAwO1xuICAgICAgICB0aGlzLl9yZWFkeVN0YXRlID0gZ2V0SXNTdXBwb3J0ZWQkMSgpID8gV2FsbGV0UmVhZHlTdGF0ZS5Mb2FkYWJsZSA6IFdhbGxldFJlYWR5U3RhdGUuVW5zdXBwb3J0ZWQ7XG4gICAgICAgIHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHRDYWNoZSA9IGNvbmZpZy5hdXRob3JpemF0aW9uUmVzdWx0Q2FjaGU7XG4gICAgICAgIHRoaXMuX2FkZHJlc3NTZWxlY3RvciA9IGNvbmZpZy5hZGRyZXNzU2VsZWN0b3I7XG4gICAgICAgIHRoaXMuX2FwcElkZW50aXR5ID0gY29uZmlnLmFwcElkZW50aXR5O1xuICAgICAgICB0aGlzLl9jaGFpbiA9IChfYSA9IGNvbmZpZy5jaGFpbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2x1c3RlclRvQ2hhaW5JZChjb25maWcuY2x1c3Rlcik7XG4gICAgICAgIHRoaXMuX2hvc3RBdXRob3JpdHkgPSBjb25maWcucmVtb3RlSG9zdEF1dGhvcml0eTtcbiAgICAgICAgdGhpcy5fb25XYWxsZXROb3RGb3VuZCA9IGNvbmZpZy5vbldhbGxldE5vdEZvdW5kO1xuICAgICAgICBpZiAodGhpcy5fcmVhZHlTdGF0ZSAhPT0gV2FsbGV0UmVhZHlTdGF0ZS5VbnN1cHBvcnRlZCkge1xuICAgICAgICAgICAgdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdENhY2hlLmdldCgpLnRoZW4oKGF1dGhvcml6YXRpb25SZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXV0aG9yaXphdGlvblJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBIYXZpbmcgYSBwcmlvciBhdXRob3JpemF0aW9uIHJlc3VsdCBpcywgcmlnaHQgbm93LCB0aGUgYmVzdFxuICAgICAgICAgICAgICAgICAgICAvLyBpbmRpY2F0aW9uIHRoYXQgYSBtb2JpbGUgd2FsbGV0IGlzIGluc3RhbGxlZC4gVGhlcmUgaXMgbm8gQVBJXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGNhbiB1c2UgdG8gdGVzdCBmb3Igd2hldGhlciB0aGUgYXNzb2NpYXRpb24gVVJJIGlzIHN1cHBvcnRlZC5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWNsYXJlV2FsbGV0QXNJbnN0YWxsZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgcHVibGljS2V5KCkge1xuICAgICAgICBpZiAodGhpcy5fcHVibGljS2V5ID09IG51bGwgJiYgdGhpcy5fc2VsZWN0ZWRBZGRyZXNzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHVibGljS2V5ID0gZ2V0UHVibGljS2V5RnJvbUFkZHJlc3MkMSh0aGlzLl9zZWxlY3RlZEFkZHJlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0UHVibGljS2V5RXJyb3IoKGUgaW5zdGFuY2VvZiBFcnJvciAmJiAoZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLm1lc3NhZ2UpKSB8fCAnVW5rbm93biBlcnJvcicsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wdWJsaWNLZXkgPyB0aGlzLl9wdWJsaWNLZXkgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgY29ubmVjdGVkKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0O1xuICAgIH1cbiAgICBnZXQgY29ubmVjdGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpbmc7XG4gICAgfVxuICAgIGdldCByZWFkeVN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZHlTdGF0ZTtcbiAgICB9XG4gICAgZGVjbGFyZVdhbGxldEFzSW5zdGFsbGVkKCkge1xuICAgICAgICBpZiAodGhpcy5fcmVhZHlTdGF0ZSAhPT0gV2FsbGV0UmVhZHlTdGF0ZS5JbnN0YWxsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVhZHlTdGF0ZUNoYW5nZScsICh0aGlzLl9yZWFkeVN0YXRlID0gV2FsbGV0UmVhZHlTdGF0ZS5JbnN0YWxsZWQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBydW5XaXRoR3VhcmQoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkIFVzZSBgYXV0b0Nvbm5lY3QoKWAgaW5zdGVhZC4gKi9cbiAgICBhdXRvQ29ubmVjdF9ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuYXV0b0Nvbm5lY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGF1dG9Db25uZWN0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGluZyB8fCB0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnJ1bldpdGhHdWFyZCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JlYWR5U3RhdGUgIT09IFdhbGxldFJlYWR5U3RhdGUuSW5zdGFsbGVkICYmIHRoaXMuX3JlYWR5U3RhdGUgIT09IFdhbGxldFJlYWR5U3RhdGUuTG9hZGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdFJlYWR5RXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FjaGVkQXV0aG9yaXphdGlvblJlc3VsdCA9IHlpZWxkIHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHRDYWNoZS5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlZEF1dGhvcml6YXRpb25SZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IEV2YWx1YXRlIHdoZXRoZXIgdGhlcmUncyBhbnkgdGhyZWF0IHRvIG5vdCBgYXdhaXRpbmdgIHRoaXMgZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVBdXRob3JpemF0aW9uUmVzdWx0KGNhY2hlZEF1dGhvcml6YXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRDb25uZWN0aW9uRXJyb3IoKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UpIHx8ICdVbmtub3duIGVycm9yJywgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RpbmcgfHwgdGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5ydW5XaXRoR3VhcmQoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZWFkeVN0YXRlICE9PSBXYWxsZXRSZWFkeVN0YXRlLkluc3RhbGxlZCAmJiB0aGlzLl9yZWFkeVN0YXRlICE9PSBXYWxsZXRSZWFkeVN0YXRlLkxvYWRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXROb3RSZWFkeUVycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucGVyZm9ybUF1dGhvcml6YXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldENvbm5lY3Rpb25FcnJvcigoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZSkgfHwgJ1Vua25vd24gZXJyb3InLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwZXJmb3JtQXV0aG9yaXphdGlvbihzaWduSW5QYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlZEF1dGhvcml6YXRpb25SZXN1bHQgPSB5aWVsZCB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUuZ2V0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZEF1dGhvcml6YXRpb25SZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogRXZhbHVhdGUgd2hldGhlciB0aGVyZSdzIGFueSB0aHJlYXQgdG8gbm90IGBhd2FpdGluZ2AgdGhpcyBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQXV0aG9yaXphdGlvblJlc3VsdChjYWNoZWRBdXRob3JpemF0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZEF1dGhvcml6YXRpb25SZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnRyYW5zYWN0KCh3YWxsZXQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXV0aG9yaXphdGlvblJlc3VsdCA9IHlpZWxkIHdhbGxldC5hdXRob3JpemUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW46IHRoaXMuX2NoYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpdHk6IHRoaXMuX2FwcElkZW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbl9pbl9wYXlsb2FkOiBzaWduSW5QYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogRXZhbHVhdGUgd2hldGhlciB0aGVyZSdzIGFueSB0aHJlYXQgdG8gbm90IGBhd2FpdGluZ2AgdGhpcyBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHRDYWNoZS5zZXQoYXV0aG9yaXphdGlvblJlc3VsdCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUF1dGhvcml6YXRpb25SZXN1bHQoYXV0aG9yaXphdGlvblJlc3VsdCksXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXV0aG9yaXphdGlvblJlc3VsdDtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRDb25uZWN0aW9uRXJyb3IoKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UpIHx8ICdVbmtub3duIGVycm9yJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVBdXRob3JpemF0aW9uUmVzdWx0KGF1dGhvcml6YXRpb25SZXN1bHQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZGlkUHVibGljS2V5c0NoYW5nZSA9IFxuICAgICAgICAgICAgLy8gQ2FzZSAxOiBXZSBzdGFydGVkIGZyb20gaGF2aW5nIG5vIGF1dGhvcml6YXRpb24uXG4gICAgICAgICAgICB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0ID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAvLyBDYXNlIDI6IFRoZSBudW1iZXIgb2YgYXV0aG9yaXplZCBhY2NvdW50cyBjaGFuZ2VkLlxuICAgICAgICAgICAgICAgICgoX2EgPSB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjb3VudHMubGVuZ3RoKSAhPT0gYXV0aG9yaXphdGlvblJlc3VsdC5hY2NvdW50cy5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICAvLyBDYXNlIDM6IFRoZSBuZXcgbGlzdCBvZiBhZGRyZXNzZXMgaXNuJ3QgZXhhY3RseSB0aGUgc2FtZSBhcyB0aGUgb2xkIGxpc3QsIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgICAgICAgICAgICAgIHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHQuYWNjb3VudHMuc29tZSgoYWNjb3VudCwgaWkpID0+IGFjY291bnQuYWRkcmVzcyAhPT0gYXV0aG9yaXphdGlvblJlc3VsdC5hY2NvdW50c1tpaV0uYWRkcmVzcyk7XG4gICAgICAgICAgICB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0ID0gYXV0aG9yaXphdGlvblJlc3VsdDtcbiAgICAgICAgICAgIHRoaXMuZGVjbGFyZVdhbGxldEFzSW5zdGFsbGVkKCk7XG4gICAgICAgICAgICBpZiAoZGlkUHVibGljS2V5c0NoYW5nZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRTZWxlY3RlZEFkZHJlc3MgPSB5aWVsZCB0aGlzLl9hZGRyZXNzU2VsZWN0b3Iuc2VsZWN0KGF1dGhvcml6YXRpb25SZXN1bHQuYWNjb3VudHMubWFwKCh7IGFkZHJlc3MgfSkgPT4gYWRkcmVzcykpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0U2VsZWN0ZWRBZGRyZXNzICE9PSB0aGlzLl9zZWxlY3RlZEFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRBZGRyZXNzID0gbmV4dFNlbGVjdGVkQWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3B1YmxpY0tleTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdjb25uZWN0JywgXG4gICAgICAgICAgICAgICAgICAgIC8vIEhhdmluZyBqdXN0IHNldCBgdGhpcy5fc2VsZWN0ZWRBZGRyZXNzYCwgYHRoaXMucHVibGljS2V5YCBpcyBkZWZpbml0ZWx5IG5vbi1udWxsXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVibGljS2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwZXJmb3JtUmVhdXRob3JpemF0aW9uKHdhbGxldCwgYXV0aFRva2VuKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF1dGhvcml6YXRpb25SZXN1bHQgPSB5aWVsZCB3YWxsZXQuYXV0aG9yaXplKHtcbiAgICAgICAgICAgICAgICAgICAgYXV0aF90b2tlbjogYXV0aFRva2VuLFxuICAgICAgICAgICAgICAgICAgICBpZGVudGl0eTogdGhpcy5fYXBwSWRlbnRpdHksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogRXZhbHVhdGUgd2hldGhlciB0aGVyZSdzIGFueSB0aHJlYXQgdG8gbm90IGBhd2FpdGluZ2AgdGhpcyBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUuc2V0KGF1dGhvcml6YXRpb25SZXN1bHQpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUF1dGhvcml6YXRpb25SZXN1bHQoYXV0aG9yaXphdGlvblJlc3VsdCksXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXREaXNjb25uZWN0ZWRFcnJvcigoZSBpbnN0YW5jZW9mIEVycm9yICYmIChlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUubWVzc2FnZSkpIHx8ICdVbmtub3duIGVycm9yJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdENhY2hlLmNsZWFyKCk7IC8vIFRPRE86IEV2YWx1YXRlIHdoZXRoZXIgdGhlcmUncyBhbnkgdGhyZWF0IHRvIG5vdCBgYXdhaXRpbmdgIHRoaXMgZXhwcmVzc2lvblxuICAgICAgICAgICAgdGhpcy5fY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvbkdlbmVyYXRpb24rKztcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0O1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3B1YmxpY0tleTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zZWxlY3RlZEFkZHJlc3M7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3QnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRyYW5zYWN0KGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHdhbGxldFVyaUJhc2UgPSAoX2EgPSB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eud2FsbGV0X3VyaV9iYXNlO1xuICAgICAgICAgICAgY29uc3QgY29uZmlnID0gd2FsbGV0VXJpQmFzZSA/IHsgYmFzZVVyaTogd2FsbGV0VXJpQmFzZSB9IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgcmVtb3RlQ29uZmlnID0gdGhpcy5faG9zdEF1dGhvcml0eSA/IHsgcmVtb3RlSG9zdEF1dGhvcml0eTogdGhpcy5faG9zdEF1dGhvcml0eSB9IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudENvbm5lY3Rpb25HZW5lcmF0aW9uID0gdGhpcy5fY29ubmVjdGlvbkdlbmVyYXRpb247XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0cmFuc2FjdChjYWxsYmFjaywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb25maWcpLCByZW1vdGVDb25maWcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Nvbm5lY3Rpb25HZW5lcmF0aW9uICE9PSBjdXJyZW50Q29ubmVjdGlvbkdlbmVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgbmV3IFByb21pc2UoKCkgPT4geyB9KTsgLy8gTmV2ZXIgcmVzb2x2ZS5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgICAgICAgICAgICAgICBlLm5hbWUgPT09ICdTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3InICYmXG4gICAgICAgICAgICAgICAgICAgIGUuY29kZSA9PT0gJ0VSUk9SX1dBTExFVF9OT1RfRk9VTkQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuX29uV2FsbGV0Tm90Rm91bmQodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3NlcnRJc0F1dGhvcml6ZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdCB8fCAhdGhpcy5fc2VsZWN0ZWRBZGRyZXNzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdENvbm5lY3RlZEVycm9yKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhdXRoVG9rZW46IHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHQuYXV0aF90b2tlbixcbiAgICAgICAgICAgIHNlbGVjdGVkQWRkcmVzczogdGhpcy5fc2VsZWN0ZWRBZGRyZXNzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBwZXJmb3JtU2lnblRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYXV0aFRva2VuIH0gPSB0aGlzLmFzc2VydElzQXV0aG9yaXplZCgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy50cmFuc2FjdCgod2FsbGV0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucGVyZm9ybVJlYXV0aG9yaXphdGlvbih3YWxsZXQsIGF1dGhUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9ucyA9IHlpZWxkIHdhbGxldC5zaWduVHJhbnNhY3Rpb25zKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWduZWRUcmFuc2FjdGlvbnM7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFNpZ25UcmFuc2FjdGlvbkVycm9yKGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5tZXNzYWdlLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIGNvbm5lY3Rpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnJ1bldpdGhHdWFyZCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBhdXRoVG9rZW4gfSA9IHRoaXMuYXNzZXJ0SXNBdXRob3JpemVkKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWluQ29udGV4dFNsb3QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWluQ29udGV4dFNsb3Q7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMudHJhbnNhY3QoKHdhbGxldCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0VGFyZ2V0Q29tbWl0bWVudCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0Q29tbWl0bWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvbm5lY3Rpb24uY29tbWl0bWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb25maXJtZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmaW5hbGl6ZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdwcm9jZXNzZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q29tbWl0bWVudCA9IGNvbm5lY3Rpb24uY29tbWl0bWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q29tbWl0bWVudCA9ICdmaW5hbGl6ZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0UHJlZmxpZ2h0Q29tbWl0bWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmVmbGlnaHRDb21taXRtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NvbmZpcm1lZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbmFsaXplZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Byb2Nlc3NlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRQcmVmbGlnaHRDb21taXRtZW50ID0gb3B0aW9ucy5wcmVmbGlnaHRDb21taXRtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0UHJlZmxpZ2h0Q29tbWl0bWVudCA9IHRhcmdldENvbW1pdG1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFByZWZsaWdodENvbW1pdG1lbnQgPSAnZmluYWxpemVkJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlZmxpZ2h0Q29tbWl0bWVudFNjb3JlID0gdGFyZ2V0UHJlZmxpZ2h0Q29tbWl0bWVudCA9PT0gJ2ZpbmFsaXplZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGFyZ2V0UHJlZmxpZ2h0Q29tbWl0bWVudCA9PT0gJ2NvbmZpcm1lZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldENvbW1pdG1lbnRTY29yZSA9IHRhcmdldENvbW1pdG1lbnQgPT09ICdmaW5hbGl6ZWQnID8gMiA6IHRhcmdldENvbW1pdG1lbnQgPT09ICdjb25maXJtZWQnID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZWZsaWdodENvbW1pdG1lbnRTY29yZSA8IHRhcmdldENvbW1pdG1lbnRTY29yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRhcmdldFByZWZsaWdodENvbW1pdG1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0YXJnZXRDb21taXRtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW2NhcGFiaWxpdGllcywgXzEsIF8yXSA9IHlpZWxkIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YWxsZXQuZ2V0Q2FwYWJpbGl0aWVzKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmb3JtUmVhdXRob3JpemF0aW9uKHdhbGxldCwgYXV0aFRva2VuKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ZlcnNpb25lZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBVbmxpa2UgdmVyc2lvbmVkIHRyYW5zYWN0aW9ucywgbGVnYWN5IGBUcmFuc2FjdGlvbmAgb2JqZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIG1heSBub3QgaGF2ZSBhbiBhc3NvY2lhdGVkIGBmZWVQYXllcmAgb3IgYHJlY2VudEJsb2NraGFzaGAuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogVGhpcyBjb2RlIGV4aXN0cyB0byBwYXRjaCB0aGVtIHVwIGluIGNhc2UgdGhleSBhcmUgbWlzc2luZy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmZlZVBheWVyIHx8ICh0cmFuc2FjdGlvbi5mZWVQYXllciA9IChfYSA9IHRoaXMucHVibGljS2V5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGJsb2NraGFzaCB9ID0geWllbGQgY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWl0bWVudDogZ2V0VGFyZ2V0Q29tbWl0bWVudCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gYmxvY2toYXNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FwYWJpbGl0aWVzLnN1cHBvcnRzX3NpZ25fYW5kX3NlbmRfdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlcyA9IHlpZWxkIHdhbGxldC5zaWduQW5kU2VuZFRyYW5zYWN0aW9ucyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbkNvbnRleHRTbG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnM6IFt0cmFuc2FjdGlvbl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25hdHVyZXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbc2lnbmVkVHJhbnNhY3Rpb25dID0geWllbGQgd2FsbGV0LnNpZ25UcmFuc2FjdGlvbnMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnM6IFt0cmFuc2FjdGlvbl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmVyc2lvbmVkVHJhbnNhY3Rpb24oc2lnbmVkVHJhbnNhY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCBjb25uZWN0aW9uLnNlbmRUcmFuc2FjdGlvbihzaWduZWRUcmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkVHJhbnNhY3Rpb24gPSBzaWduZWRUcmFuc2FjdGlvbi5zZXJpYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGNvbm5lY3Rpb24uc2VuZFJhd1RyYW5zYWN0aW9uKHNlcmlhbGl6ZWRUcmFuc2FjdGlvbiwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBwcmVmbGlnaHRDb21taXRtZW50OiBnZXRUYXJnZXRDb21taXRtZW50KCkgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFNlbmRUcmFuc2FjdGlvbkVycm9yKGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5tZXNzYWdlLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5ydW5XaXRoR3VhcmQoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtzaWduZWRUcmFuc2FjdGlvbl0gPSB5aWVsZCB0aGlzLnBlcmZvcm1TaWduVHJhbnNhY3Rpb25zKFt0cmFuc2FjdGlvbl0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaWduZWRUcmFuc2FjdGlvbjtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25BbGxUcmFuc2FjdGlvbnModHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5ydW5XaXRoR3VhcmQoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9ucyA9IHlpZWxkIHRoaXMucGVyZm9ybVNpZ25UcmFuc2FjdGlvbnModHJhbnNhY3Rpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmVkVHJhbnNhY3Rpb25zO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnbk1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucnVuV2l0aEd1YXJkKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGF1dGhUb2tlbiwgc2VsZWN0ZWRBZGRyZXNzIH0gPSB0aGlzLmFzc2VydElzQXV0aG9yaXplZCgpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnRyYW5zYWN0KCh3YWxsZXQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucGVyZm9ybVJlYXV0aG9yaXphdGlvbih3YWxsZXQsIGF1dGhUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbc2lnbmVkTWVzc2FnZV0gPSB5aWVsZCB3YWxsZXQuc2lnbk1lc3NhZ2VzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXM6IFtzZWxlY3RlZEFkZHJlc3NdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWRzOiBbbWVzc2FnZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHNpZ25lZE1lc3NhZ2Uuc2xpY2UoLVNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMkMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmF0dXJlO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0U2lnbk1lc3NhZ2VFcnJvcihlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IubWVzc2FnZSwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25JbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucnVuV2l0aEd1YXJkKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZWFkeVN0YXRlICE9PSBXYWxsZXRSZWFkeVN0YXRlLkluc3RhbGxlZCAmJiB0aGlzLl9yZWFkeVN0YXRlICE9PSBXYWxsZXRSZWFkeVN0YXRlLkxvYWRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXROb3RSZWFkeUVycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF1dGhvcml6YXRpb25SZXN1bHQgPSB5aWVsZCB0aGlzLnBlcmZvcm1BdXRob3JpemF0aW9uKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaW5wdXQpLCB7IGRvbWFpbjogKF9hID0gaW5wdXQgPT09IG51bGwgfHwgaW5wdXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlucHV0LmRvbWFpbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogd2luZG93LmxvY2F0aW9uLmhvc3QgfSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWF1dGhvcml6YXRpb25SZXN1bHQuc2lnbl9pbl9yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNpZ24gaW4gZmFpbGVkLCBubyBzaWduIGluIHJlc3VsdCByZXR1cm5lZCBieSB3YWxsZXRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2lnbmVkSW5BZGRyZXNzID0gYXV0aG9yaXphdGlvblJlc3VsdC5zaWduX2luX3Jlc3VsdC5hZGRyZXNzO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWduZWRJbkFjY291bnQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChfYiA9IGF1dGhvcml6YXRpb25SZXN1bHQuYWNjb3VudHMuZmluZChhY2MgPT4gYWNjLmFkZHJlc3MgPT0gc2lnbmVkSW5BZGRyZXNzKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogc2lnbmVkSW5BZGRyZXNzXG4gICAgICAgICAgICAgICAgICAgIH0pLCB7IHB1YmxpY0tleTogdG9VaW50OEFycmF5KHNpZ25lZEluQWRkcmVzcykgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50OiBzaWduZWRJbkFjY291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduZWRNZXNzYWdlOiB0b1VpbnQ4QXJyYXkoYXV0aG9yaXphdGlvblJlc3VsdC5zaWduX2luX3Jlc3VsdC5zaWduZWRfbWVzc2FnZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IHRvVWludDhBcnJheShhdXRob3JpemF0aW9uUmVzdWx0LnNpZ25faW5fcmVzdWx0LnNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldENvbm5lY3Rpb25FcnJvcigoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZSkgfHwgJ1Vua25vd24gZXJyb3InLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY29uc3QgQmx1ZXRvb3RoSHRtbCA9IGBcclxuICAgIDxkaXYgY2xhc3M9XCJtb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtY29udGVudFwiPlxyXG4gICAgPGJ1dHRvbiBpZD1cIm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1jbG9zZVwiIGNsYXNzPVwibW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLWNsb3NlXCI+XHJcbiAgICAgICAgPHN2ZyB3aWR0aD1cIjE0XCIgaGVpZ2h0PVwiMTRcIj5cclxuICAgICAgICA8cGF0aCBkPVwiTTE0IDEyLjQ2MSA4LjMgNi43NzJsNS4yMzQtNS4yMzNMMTIuMDA2IDAgNi43NzIgNS4yMzQgMS41NCAwIDAgMS41MzlsNS4yMzQgNS4yMzNMMCAxMi4wMDZsMS41MzkgMS41MjhMNi43NzIgOC4zbDUuNjkgNS43TDE0IDEyLjQ2MXpcIiAvPlxyXG4gICAgICAgIDwvc3ZnPlxyXG4gICAgPC9idXR0b24+XHJcbiAgICA8aDE+PGI+SnVwaXRlcjwvYj4gd2FudHMgdG8gY29ubmVjdDwvaDE+XHJcbiAgICA8cCBjbGFzcz1cIm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1zdWJ0aXRsZVwiPkNvbm5lY3QgdG8geW91ciBtb2JpbGUgd2FsbGV0IGFwcCB0aHJvdWdoIEJsdWV0b290aC48L3A+XHJcbiAgICA8ZGl2IGNsYXNzPVwibW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLWNvbm5lY3Rpb24tc3RhdHVzLWNvbnRhaW5lclwiPlxyXG4gICAgICAgIDxkaXYgaWQ9XCJzdGF0dXMtbm90LWNvbm5lY3RlZFwiIGNsYXNzPVwiY29ubmVjdGlvbi1zdGF0dXNcIj5cclxuICAgICAgICA8c3ZnIGNsYXNzPVwiYmx1ZXRvb3RoLWljb25cIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XHJcbiAgICAgICAgICAgIDxwYXRoIGZpbGw9XCIjYTBhMGEwXCIgZD1cIk0xNC4yNCAxMi4wMWwyLjMyIDIuMzJjLjI4LS43Mi40NC0xLjUxLjQ0LTIuMzMgMC0uODItLjE2LTEuNTktLjQzLTIuMzFsLTIuMzMgMi4zMnptNS4yOS01LjNsLTEuMjYgMS4yNmMuNjMgMS4yMS45OCAyLjU3Ljk4IDQuMDJzLS4zNiAyLjgyLS45OCA0LjAybDEuMiAxLjJjLjk3LTEuNTQgMS41NC0zLjM2IDEuNTQtNS4zMS0uMDEtMS44OS0uNTUtMy42Ny0xLjQ4LTUuMTl6bS0zLjgyIDFMMTAgMkg5djcuNTlMNC40MSA1IDMgNi40MSA4LjU5IDEyIDMgMTcuNTkgNC40MSAxOSA5IDE0LjQxVjIyaDFsNS43MS01LjcxLTQuMy00LjI5IDQuMy00LjI5ek0xMSA1LjgzbDEuODggMS44OEwxMSA5LjU5VjUuODN6bTEuODggMTAuNDZMMTEgMTguMTd2LTMuNzZsMS44OCAxLjg4elwiLz5cclxuICAgICAgICA8L3N2Zz5cclxuICAgICAgICA8cD5Ob3QgY29ubmVjdGVkPC9wPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxkaXYgaWQ9XCJzdGF0dXMtY29ubmVjdGluZ1wiIGNsYXNzPVwiY29ubmVjdGlvbi1zdGF0dXNcIiBzdHlsZT1cImRpc3BsYXk6bm9uZTtcIj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwic3Bpbm5lclwiPjwvZGl2PlxyXG4gICAgICAgIDxwPkNvbm5lY3RpbmcuLi48L3A+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGRpdiBpZD1cInN0YXR1cy1jb25uZWN0ZWRcIiBjbGFzcz1cImNvbm5lY3Rpb24tc3RhdHVzXCIgc3R5bGU9XCJkaXNwbGF5Om5vbmU7XCI+XHJcbiAgICAgICAgPHN2ZyBjbGFzcz1cImNoZWNrbWFyay1pY29uXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPlxyXG4gICAgICAgICAgICA8cGF0aCBmaWxsPVwiIzRDQUY1MFwiIGQ9XCJNOSAxNi4xN0w0LjgzIDEybC0xLjQyIDEuNDFMOSAxOSAyMSA3bC0xLjQxLTEuNDF6XCIvPlxyXG4gICAgICAgIDwvc3ZnPlxyXG4gICAgICAgIDxwPkNvbm5lY3RlZDwvcD5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gICAgPGRpdiBjbGFzcz1cImJ1dHRvbi1ncm91cFwiPlxyXG4gICAgICAgIDxidXR0b24gaWQ9XCJjYW5jZWwtYnRuXCIgY2xhc3M9XCJjYW5jZWwtYnRuXCI+Q2FuY2VsPC9idXR0b24+XHJcbiAgICAgICAgPGJ1dHRvbiBpZD1cImNvbm5lY3QtYnRuXCIgY2xhc3M9XCJjb25uZWN0LWJ0blwiPkNvbm5lY3Q8L2J1dHRvbj5cclxuICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbmA7XG5cbmNvbnN0IFFSQ29kZUh0bWwgPSBgXHJcbjxkaXYgY2xhc3M9XCJtb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtY29udGVudFwiPlxyXG4gIDxidXR0b24gaWQ9XCJtb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtY2xvc2VcIiBjbGFzcz1cIm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1jbG9zZVwiPlxyXG4gICAgPHN2ZyB3aWR0aD1cIjE0XCIgaGVpZ2h0PVwiMTRcIj5cclxuICAgICAgPHBhdGggZD1cIk0xNCAxMi40NjEgOC4zIDYuNzcybDUuMjM0LTUuMjMzTDEyLjAwNiAwIDYuNzcyIDUuMjM0IDEuNTQgMCAwIDEuNTM5bDUuMjM0IDUuMjMzTDAgMTIuMDA2bDEuNTM5IDEuNTI4TDYuNzcyIDguM2w1LjY5IDUuN0wxNCAxMi40NjF6XCIgLz5cclxuICAgIDwvc3ZnPlxyXG4gIDwvYnV0dG9uPlxyXG4gIDxoMT5TY2FuIHRvIGNvbm5lY3Q8L2gxPlxyXG4gIDxwIGNsYXNzPVwibW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLXN1YnRpdGxlXCI+VXNlIHlvdXIgd2FsbGV0IGFwcCB0byBzY2FuIHRoZSBRUiBDb2RlIGFuZCBjb25uZWN0LjwvcD5cclxuICA8ZGl2IGlkPVwibW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLXFyLWNvZGUtY29udGFpbmVyXCIgLz5cclxuPC9kaXY+XHJcbmA7XG5cbmNvbnN0IGNzcyA9IGBcclxuLm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbCB7XHJcbiAgICBkaXNwbGF5OiBmbGV4OyAvKiBVc2UgZmxleGJveCB0byBjZW50ZXIgY29udGVudCAqL1xyXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcclxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyOyAvKiBDZW50ZXIgaG9yaXpvbnRhbGx5ICovXHJcbiAgICBhbGlnbi1pdGVtczogY2VudGVyOyAvKiBDZW50ZXIgdmVydGljYWxseSAqL1xyXG4gICAgcG9zaXRpb246IGZpeGVkOyAvKiBTdGF5IGluIHBsYWNlICovXHJcbiAgICB6LWluZGV4OiAxOyAvKiBTaXQgb24gdG9wICovXHJcbiAgICBsZWZ0OiAwO1xyXG4gICAgdG9wOiAwO1xyXG4gICAgd2lkdGg6IDEwMCU7IC8qIEZ1bGwgd2lkdGggKi9cclxuICAgIGhlaWdodDogMTAwJTsgLyogRnVsbCBoZWlnaHQgKi9cclxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwwLDAsMC40KTsgLyogQmxhY2sgdy8gb3BhY2l0eSAqL1xyXG59XHJcblxyXG4ubW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLWNvbnRlbnQge1xyXG4gICAgYmFja2dyb3VuZDogIzEwMTQxZjtcclxuICAgIHBhZGRpbmc6IDIwcHg7XHJcbiAgICBib3JkZXItcmFkaXVzOiAxMHB4O1xyXG4gICAgd2lkdGg6IDgwJTtcclxuICAgIG1heC13aWR0aDogNTAwcHg7XHJcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XHJcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcclxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7IC8qIENlbnRlciBjaGlsZHJlbiBob3Jpem9udGFsbHkgKi9cclxufVxyXG5cclxuLm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1zdWJ0aXRsZSB7XHJcbiAgICBjb2xvcjogI0Q4RDhEODtcclxufVxyXG5cclxuLm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1jbG9zZSB7XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcclxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgdG9wOiAxOHB4O1xyXG4gICAgcmlnaHQ6IDE4cHg7XHJcbiAgICBwYWRkaW5nOiAxMnB4O1xyXG4gICAgY3Vyc29yOiBwb2ludGVyO1xyXG4gICAgYmFja2dyb3VuZDogIzFhMWYyZTtcclxuICAgIGJvcmRlcjogbm9uZTtcclxuICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcclxufVxyXG5cclxuLm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1jbG9zZTpmb2N1cy12aXNpYmxlIHtcclxuICAgIG91dGxpbmUtY29sb3I6IHdoaXRlO1xyXG59XHJcblxyXG4ubW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLWNsb3NlIHN2ZyB7XHJcbiAgICBmaWxsOiAjNzc3O1xyXG4gICAgdHJhbnNpdGlvbjogZmlsbCAyMDBtcyBlYXNlIDBzO1xyXG59XHJcblxyXG4ubW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLWNsb3NlOmhvdmVyIHN2ZyB7XHJcbiAgICBmaWxsOiAjZmZmO1xyXG59XHJcblxyXG4uaWNvbi1jb250YWluZXIge1xyXG4gICAgZGlzcGxheTogZmxleDtcclxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xyXG4gICAgbWFyZ2luLWJvdHRvbTogMjBweDtcclxufVxyXG5cclxuLmljb24ge1xyXG4gICAgd2lkdGg6IDgwcHg7XHJcbiAgICBoZWlnaHQ6IDgwcHg7XHJcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XHJcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZGRkOyAvKiBQbGFjZWhvbGRlciBmb3IgaWNvbiBiYWNrZ3JvdW5kICovXHJcbn1cclxuXHJcbi8qIE1vZGFsIFRpdGxlICovXHJcbi5tb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtY29udGVudCBoMSB7XHJcbiAgICBjb2xvcjogd2hpdGU7XHJcbiAgICBmb250LXNpemU6IDI0cHg7ICAgXHJcbn1cclxuXHJcbi5idXR0b24tZ3JvdXAge1xyXG4gICAgZGlzcGxheTogZmxleDtcclxuICAgIHdpZHRoOiAxMDAlO1xyXG4gICAgZ2FwOiAxMHB4O1xyXG59XHJcblxyXG4uY29ubmVjdC1idG4sIC5jYW5jZWwtYnRuIHtcclxuICAgIGZsZXg6IDE7XHJcbiAgICBwYWRkaW5nOiAxMnB4IDIwcHg7XHJcbiAgICBmb250LXNpemU6IDE2cHg7XHJcbiAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICBib3JkZXItcmFkaXVzOiAxMHB4O1xyXG4gICAgdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZTtcclxufVxyXG5cclxuLmNvbm5lY3QtYnRuIHtcclxuICAgIGJhY2tncm91bmQtY29sb3I6ICMwMDdiZmY7XHJcbiAgICBjb2xvcjogd2hpdGU7XHJcbiAgICBib3JkZXI6IG5vbmU7XHJcbn1cclxuXHJcbi5jb25uZWN0LWJ0bjpob3ZlciB7XHJcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDA1NmIzO1xyXG59XHJcblxyXG4uY2FuY2VsLWJ0biB7XHJcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcclxuICAgIGNvbG9yOiAjYTBhMGEwO1xyXG4gICAgYm9yZGVyOiAxcHggc29saWQgI2EwYTBhMDtcclxufVxyXG5cclxuLmNhbmNlbC1idG46aG92ZXIge1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxNjAsIDE2MCwgMTYwLCAwLjEpO1xyXG59XHJcblxyXG4vKiBCVCBDb25uZWN0aW9uIFN0YXR1cyAqL1xyXG5cclxuLm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1jb25uZWN0aW9uLXN0YXR1cy1jb250YWluZXIge1xyXG4gICAgbWFyZ2luOiAyMHB4IDBweCAyMHB4IDBweDtcclxufVxyXG5cclxuLmNvbm5lY3Rpb24tc3RhdHVzIHtcclxuICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xyXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcclxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xyXG4gICAgbWFyZ2luOiAyMHB4IDA7XHJcbn1cclxuICBcclxuLmNvbm5lY3Rpb24tc3RhdHVzIHAge1xyXG4gICAgbWFyZ2luLXRvcDogMTBweDtcclxuICAgIGNvbG9yOiAjYTBhMGEwO1xyXG59XHJcbiAgXHJcbi5ibHVldG9vdGgtaWNvbiwgLmNoZWNrbWFyay1pY29uIHtcclxuICAgIHdpZHRoOiA0OHB4O1xyXG4gICAgaGVpZ2h0OiA0OHB4O1xyXG59XHJcbiAgXHJcbi5zcGlubmVyIHtcclxuICAgIGJvcmRlcjogNHB4IHNvbGlkICNmM2YzZjM7XHJcbiAgICBib3JkZXItdG9wOiA0cHggc29saWQgIzM0OThkYjtcclxuICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcclxuICAgIHdpZHRoOiA0MHB4O1xyXG4gICAgaGVpZ2h0OiA0MHB4O1xyXG4gICAgYW5pbWF0aW9uOiBzcGluIDFzIGxpbmVhciBpbmZpbml0ZTtcclxufVxyXG4gIFxyXG5Aa2V5ZnJhbWVzIHNwaW4ge1xyXG4gICAgMCUgeyB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTsgfVxyXG4gICAgMTAwJSB7IHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7IH1cclxufVxyXG5cclxuLyogUVIgQ29kZSAqL1xyXG5cclxuI21vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1xci1jb2RlLWNvbnRhaW5lciB7XHJcbiAgICB3aWR0aDogNTAwcHg7XHJcbiAgICBoZWlnaHQ6IDUwMHB4O1xyXG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xyXG59XHJcbmA7XG5cbmNsYXNzIEVtYmVkZGVkTW9kYWwge1xuICAgIGNvbnN0cnVjdG9yKHRpdGxlKSB7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgICAgICB0aGlzLl90aXRsZSA9IHRpdGxlO1xuICAgICAgICAvLyBCaW5kIG1ldGhvZHMgdG8gZW5zdXJlIGB0aGlzYCBjb250ZXh0IGlzIGNvcnJlY3RcbiAgICAgICAgdGhpcy5pbml0ID0gdGhpcy5pbml0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaW5qZWN0UVJDb2RlSFRNTCA9IHRoaXMuaW5qZWN0UVJDb2RlSFRNTC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmluamVjdEJsdWV0b290aEhUTUwgPSB0aGlzLmluamVjdEJsdWV0b290aEhUTUwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vcGVuID0gdGhpcy5vcGVuLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2xvc2UgPSB0aGlzLmNsb3NlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY29ubmVjdCA9IHRoaXMuY29ubmVjdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9yb290ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1yb290LXVpJyk7XG4gICAgfVxuICAgIGluaXQocXJDb2RlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnSW5qZWN0aW5nIG1vZGFsJyk7XG4gICAgICAgICAgICB0aGlzLmluamVjdFN0eWxlcygpO1xuICAgICAgICAgICAgdGhpcy5pbmplY3RRUkNvZGVIVE1MKHFyQ29kZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXRDb25uZWN0aW9uU3RhdHVzKHN0YXR1cykge1xuICAgICAgICBpZiAoIXRoaXMuX3Jvb3QpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHN0YXR1c2VzID0gWydub3QtY29ubmVjdGVkJywgJ2Nvbm5lY3RpbmcnLCAnY29ubmVjdGVkJ107XG4gICAgICAgIHN0YXR1c2VzLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsID0gdGhpcy5fcm9vdC5xdWVyeVNlbGVjdG9yKGAjc3RhdHVzLSR7c31gKTtcbiAgICAgICAgICAgIGlmIChlbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHMgPT09IHN0YXR1cyA/ICdmbGV4JyA6ICdub25lJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGluamVjdFN0eWxlcygpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHN0eWxlcyBoYXZlIGFscmVhZHkgYmVlbiBpbmplY3RlZFxuICAgICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vYmlsZS13YWxsZXQtYWRhcHRlci1zdHlsZXMnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgIHN0eWxlRWxlbWVudC5pZCA9ICdtb2JpbGUtd2FsbGV0LWFkYXB0ZXItc3R5bGVzJztcbiAgICAgICAgc3R5bGVFbGVtZW50LnRleHRDb250ZW50ID0gY3NzO1xuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG4gICAgfVxuICAgIHBvcHVsYXRlUVJDb2RlKHFyVXJsKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxcmNvZGVDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLXFyLWNvZGUtY29udGFpbmVyJyk7XG4gICAgICAgICAgICBpZiAocXJjb2RlQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcXJDb2RlRWxlbWVudCA9IHlpZWxkIFFSQ29kZS50b0NhbnZhcyhxclVybCwgeyB3aWR0aDogNDAwIH0pO1xuICAgICAgICAgICAgICAgIGlmIChxcmNvZGVDb250YWluZXIuZmlyc3RFbGVtZW50Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcXJjb2RlQ29udGFpbmVyLnJlcGxhY2VDaGlsZChxckNvZGVFbGVtZW50LCBxcmNvZGVDb250YWluZXIuZmlyc3RFbGVtZW50Q2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHFyY29kZUNvbnRhaW5lci5hcHBlbmRDaGlsZChxckNvZGVFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1FSQ29kZSBDb250YWluZXIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbmplY3RRUkNvZGVIVE1MKHFyQ29kZSkge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgSFRNTCBoYXMgYWxyZWFkeSBiZWVuIGluamVjdGVkXG4gICAgICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLXJvb3QtdWknKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9yb290KVxuICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLXJvb3QtdWknKTtcbiAgICAgICAgICAgIHRoaXMucG9wdWxhdGVRUkNvZGUocXJDb2RlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYSBjb250YWluZXIgZm9yIHRoZSBtb2RhbFxuICAgICAgICB0aGlzLl9yb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuX3Jvb3QuaWQgPSAnbW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLXJvb3QtdWknO1xuICAgICAgICB0aGlzLl9yb290LmNsYXNzTmFtZSA9ICdtb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwnO1xuICAgICAgICB0aGlzLl9yb290LmlubmVySFRNTCA9IFFSQ29kZUh0bWw7XG4gICAgICAgIHRoaXMuX3Jvb3Quc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgLy8gQXBwZW5kIHRoZSBtb2RhbCB0byB0aGUgYm9keVxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX3Jvb3QpO1xuICAgICAgICAvLyBSZW5kZXIgdGhlIFFSQ29kZVxuICAgICAgICB0aGlzLnBvcHVsYXRlUVJDb2RlKHFyQ29kZSk7XG4gICAgICAgIHRoaXMuYXR0YWNoRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgaW5qZWN0Qmx1ZXRvb3RoSFRNTCgpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIEhUTUwgaGFzIGFscmVhZHkgYmVlbiBpbmplY3RlZFxuICAgICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1yb290LXVpJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuX3Jvb3QuaWQgPSAnbW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLXJvb3QtdWknO1xuICAgICAgICB0aGlzLl9yb290LmNsYXNzTmFtZSA9ICdtb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwnO1xuICAgICAgICB0aGlzLl9yb290LmlubmVySFRNTCA9IEJsdWV0b290aEh0bWw7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5fcm9vdCk7XG4gICAgICAgIHRoaXMuYXR0YWNoRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgYXR0YWNoRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcm9vdClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgY2xvc2VCdG4gPSB0aGlzLl9yb290LnF1ZXJ5U2VsZWN0b3IoJyNtb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtY2xvc2UnKTtcbiAgICAgICAgY29uc3QgY2FuY2VsQnRuID0gdGhpcy5fcm9vdC5xdWVyeVNlbGVjdG9yKCcjY2FuY2VsLWJ0bicpO1xuICAgICAgICBjb25zdCBjb25uZWN0QnRuID0gdGhpcy5fcm9vdC5xdWVyeVNlbGVjdG9yKCcjY29ubmVjdC1idG4nKTtcbiAgICAgICAgY2xvc2VCdG4gPT09IG51bGwgfHwgY2xvc2VCdG4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsb3NlQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy5jbG9zZSgpKTtcbiAgICAgICAgY2FuY2VsQnRuID09PSBudWxsIHx8IGNhbmNlbEJ0biA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FuY2VsQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy5jbG9zZSgpKTtcbiAgICAgICAgY29ubmVjdEJ0biA9PT0gbnVsbCB8fCBjb25uZWN0QnRuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25uZWN0QnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy5jb25uZWN0KCkpO1xuICAgIH1cbiAgICBvcGVuKCkge1xuICAgICAgICBjb25zb2xlLmRlYnVnKCdNb2RhbCBvcGVuJyk7XG4gICAgICAgIGlmICh0aGlzLl9yb290KSB7XG4gICAgICAgICAgICB0aGlzLl9yb290LnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7XG4gICAgICAgICAgICB0aGlzLnNldENvbm5lY3Rpb25TdGF0dXMoJ25vdC1jb25uZWN0ZWQnKTsgLy8gUmVzZXQgc3RhdHVzIHdoZW4gb3BlbmluZ1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBjb25zb2xlLmRlYnVnKCdNb2RhbCBjbG9zZScpO1xuICAgICAgICBpZiAodGhpcy5fcm9vdCkge1xuICAgICAgICAgICAgdGhpcy5fcm9vdC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgdGhpcy5zZXRDb25uZWN0aW9uU3RhdHVzKCdub3QtY29ubmVjdGVkJyk7IC8vIFJlc2V0IHN0YXR1cyB3aGVuIGNsb3NpbmdcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25uZWN0KCkge1xuICAgICAgICBjb25zb2xlLmxvZygnQ29ubmVjdGluZy4uLicpO1xuICAgICAgICAvLyBNb2NrIGNvbm5lY3Rpb25cbiAgICAgICAgdGhpcy5zZXRDb25uZWN0aW9uU3RhdHVzKCdjb25uZWN0aW5nJyk7XG4gICAgICAgIC8vIFNpbXVsYXRlIGNvbm5lY3Rpb24gcHJvY2Vzc1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29ubmVjdGlvblN0YXR1cygnY29ubmVjdGVkJyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQ29ubmVjdGVkIScpO1xuICAgICAgICB9LCA1MDAwKTsgLy8gNSBzZWNvbmRzIGRlbGF5XG4gICAgfVxufVxuXG5jb25zdCBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyUmVtb3RlV2FsbGV0TmFtZSA9ICdNV0EgKFJlbW90ZSknO1xuY29uc3QgU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUyA9IDY0O1xuZnVuY3Rpb24gZ2V0UHVibGljS2V5RnJvbUFkZHJlc3MoYWRkcmVzcykge1xuICAgIGNvbnN0IHB1YmxpY0tleUJ5dGVBcnJheSA9IHRvVWludDhBcnJheSQxKGFkZHJlc3MpO1xuICAgIHJldHVybiBuZXcgUHVibGljS2V5KHB1YmxpY0tleUJ5dGVBcnJheSk7XG59XG4vKipcbiAqIERldGVybWluZSB0aGUgbW9iaWxlIG9wZXJhdGluZyBzeXN0ZW0uXG4gKiBSZXR1cm5zIHRydWUgaWYgcnVubmluZyBvbiBhIG1vYmlsZSBvcGVyYXRpbmcgc3lzdGVtLCBvciBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTW9iaWxlT3BlcmF0aW5nU3lzdGVtKCkge1xuICAgIHZhciB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICAgIC8vIFdpbmRvd3MgUGhvbmUgbXVzdCBjb21lIGZpcnN0IGJlY2F1c2UgaXRzIFVBIGFsc28gY29udGFpbnMgXCJBbmRyb2lkXCJcbiAgICBpZiAoL3dpbmRvd3MgcGhvbmUvaS50ZXN0KHVzZXJBZ2VudCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICgvYW5kcm9pZC9pLnRlc3QodXNlckFnZW50KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gaU9TIGRldGVjdGlvbiBmcm9tOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS85MDM5ODg1LzE3NzcxMFxuICAgIGlmICgvaVBhZHxpUGhvbmV8aVBvZC8udGVzdCh1c2VyQWdlbnQpICYmICF3aW5kb3cuTVNTdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldElzU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgd2luZG93LmlzU2VjdXJlQ29udGV4dCAmJlxuICAgICAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICFpc01vYmlsZU9wZXJhdGluZ1N5c3RlbSgpKTtcbn1cbi8qKlxuICogVGhpcyBidXJuZXIgd2FsbGV0IGFkYXB0ZXIgaXMgdW5zYWZlIHRvIHVzZSBhbmQgaXMgb25seSBpbmNsdWRlZCB0byBwcm92aWRlIGFuIGVhc3kgd2F5IGZvciBhcHBsaWNhdGlvbnMgdG8gdGVzdFxuICogV2FsbGV0IEFkYXB0ZXIgd2l0aG91dCB1c2luZyBhIHRoaXJkLXBhcnR5IHdhbGxldC5cbiAqL1xuY2xhc3MgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlclJlbW90ZSBleHRlbmRzIEJhc2VTaWduSW5NZXNzYWdlU2lnbmVyV2FsbGV0QWRhcHRlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9ucyA9IG5ldyBTZXQoXG4gICAgICAgIC8vIEZJWE1FKCMyNDQpOiBXZSBjYW4ndCBhY3R1YWxseSBrbm93IHdoYXQgdmVyc2lvbnMgYXJlIHN1cHBvcnRlZCB1bnRpbCB3ZSBrbm93IHdoaWNoIHdhbGxldCB3ZSdyZSB0YWxraW5nIHRvLlxuICAgICAgICBbJ2xlZ2FjeScsIDBdKTtcbiAgICAgICAgdGhpcy5uYW1lID0gU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlclJlbW90ZVdhbGxldE5hbWU7XG4gICAgICAgIHRoaXMudXJsID0gJ2h0dHBzOi8vc29sYW5hbW9iaWxlLmNvbS93YWxsZXRzJztcbiAgICAgICAgdGhpcy5pY29uID0gJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5Qm1hV3hzUFNKdWIyNWxJaUJvWldsbmFIUTlJakk0SWlCM2FXUjBhRDBpTWpnaUlIWnBaWGRDYjNnOUlpMHpJREFnTWpnZ01qZ2lJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStQR2NnWm1sc2JEMGlJMFJEUWpoR1JpSStQSEJoZEdnZ1pEMGlUVEUzTGpRZ01UY3VORWd4TlhZeUxqUm9NaTQwZGkweUxqUmFiVEV1TWkwNUxqWm9MVEl1TkhZeUxqUm9NaTQwVmpjdU9Gb2lMejQ4Y0dGMGFDQmtQU0pOTWpFdU5pQXpWakJvTFRJdU5IWXphQzB6TGpaV01HZ3RNaTQwZGpOb0xUSXVOSFkyTGpaSU5DNDFZVEl1TVNBeUxqRWdNQ0F4SURFZ01DMDBMakpvTWk0M1ZqTklOQzQxUVRRdU5TQTBMalVnTUNBd0lEQWdNQ0EzTGpWV01qUm9NakV1Tm5ZdE5pNDJhQzB5TGpSMk5DNHlTREl1TkZZeE1TNDFZeTQxTGpNZ01TNHlMalFnTVM0NExqVm9OeTQxUVRZdU5pQTJMallnTUNBd0lEQWdNalFnT1ZZemFDMHlMalJhYlRBZ05TNDNZVFF1TWlBMExqSWdNQ0F4SURFdE9DNDBJREJXTlM0MGFEZ3VOSFl6TGpOYUlpOCtQQzluUGp3dmMzWm5QZz09JztcbiAgICAgICAgdGhpcy5fY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZlcnkgdGltZSB0aGUgY29ubmVjdGlvbiBpcyByZWN5Y2xlZCBpbiBzb21lIHdheSAoZWcuIGBkaXNjb25uZWN0KClgIGlzIGNhbGxlZClcbiAgICAgICAgICogaW5jcmVtZW50IHRoaXMgYW5kIHVzZSBpdCB0byBtYWtlIHN1cmUgdGhhdCBgdHJhbnNhY3RgIGNhbGxzIGZyb20gdGhlIHByZXZpb3VzXG4gICAgICAgICAqICdnZW5lcmF0aW9uJyBkb24ndCBjb250aW51ZSB0byBkbyB3b3JrIGFuZCB0aHJvdyBleGNlcHRpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbkdlbmVyYXRpb24gPSAwO1xuICAgICAgICB0aGlzLl9yZWFkeVN0YXRlID0gZ2V0SXNTdXBwb3J0ZWQoKSA/IFdhbGxldFJlYWR5U3RhdGUuTG9hZGFibGUgOiBXYWxsZXRSZWFkeVN0YXRlLlVuc3VwcG9ydGVkO1xuICAgICAgICB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUgPSBjb25maWcuYXV0aG9yaXphdGlvblJlc3VsdENhY2hlO1xuICAgICAgICB0aGlzLl9hZGRyZXNzU2VsZWN0b3IgPSBjb25maWcuYWRkcmVzc1NlbGVjdG9yO1xuICAgICAgICB0aGlzLl9hcHBJZGVudGl0eSA9IGNvbmZpZy5hcHBJZGVudGl0eTtcbiAgICAgICAgdGhpcy5fY2hhaW4gPSBjb25maWcuY2hhaW47XG4gICAgICAgIHRoaXMuX2hvc3RBdXRob3JpdHkgPSBjb25maWcucmVtb3RlSG9zdEF1dGhvcml0eTtcbiAgICAgICAgdGhpcy5fb25XYWxsZXROb3RGb3VuZCA9IGNvbmZpZy5vbldhbGxldE5vdEZvdW5kO1xuICAgICAgICBpZiAodGhpcy5fcmVhZHlTdGF0ZSAhPT0gV2FsbGV0UmVhZHlTdGF0ZS5VbnN1cHBvcnRlZCkge1xuICAgICAgICAgICAgdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdENhY2hlLmdldCgpLnRoZW4oKGF1dGhvcml6YXRpb25SZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXV0aG9yaXphdGlvblJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBIYXZpbmcgYSBwcmlvciBhdXRob3JpemF0aW9uIHJlc3VsdCBpcywgcmlnaHQgbm93LCB0aGUgYmVzdFxuICAgICAgICAgICAgICAgICAgICAvLyBpbmRpY2F0aW9uIHRoYXQgYSBtb2JpbGUgd2FsbGV0IGlzIGluc3RhbGxlZC4gVGhlcmUgaXMgbm8gQVBJXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGNhbiB1c2UgdG8gdGVzdCBmb3Igd2hldGhlciB0aGUgYXNzb2NpYXRpb24gVVJJIGlzIHN1cHBvcnRlZC5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWNsYXJlV2FsbGV0QXNJbnN0YWxsZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgcHVibGljS2V5KCkge1xuICAgICAgICBpZiAodGhpcy5fcHVibGljS2V5ID09IG51bGwgJiYgdGhpcy5fc2VsZWN0ZWRBZGRyZXNzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHVibGljS2V5ID0gZ2V0UHVibGljS2V5RnJvbUFkZHJlc3ModGhpcy5fc2VsZWN0ZWRBZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFB1YmxpY0tleUVycm9yKChlIGluc3RhbmNlb2YgRXJyb3IgJiYgKGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5tZXNzYWdlKSkgfHwgJ1Vua25vd24gZXJyb3InLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHVibGljS2V5ID8gdGhpcy5fcHVibGljS2V5IDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IGNvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdDtcbiAgICB9XG4gICAgZ2V0IGNvbm5lY3RpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW5nO1xuICAgIH1cbiAgICBnZXQgcmVhZHlTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWR5U3RhdGU7XG4gICAgfVxuICAgIGRlY2xhcmVXYWxsZXRBc0luc3RhbGxlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlYWR5U3RhdGUgIT09IFdhbGxldFJlYWR5U3RhdGUuSW5zdGFsbGVkKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlYWR5U3RhdGVDaGFuZ2UnLCAodGhpcy5fcmVhZHlTdGF0ZSA9IFdhbGxldFJlYWR5U3RhdGUuSW5zdGFsbGVkKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcnVuV2l0aEd1YXJkKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGF1dG9Db25uZWN0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGluZyB8fCB0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnJ1bldpdGhHdWFyZCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JlYWR5U3RhdGUgIT09IFdhbGxldFJlYWR5U3RhdGUuSW5zdGFsbGVkICYmIHRoaXMuX3JlYWR5U3RhdGUgIT09IFdhbGxldFJlYWR5U3RhdGUuTG9hZGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdFJlYWR5RXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FjaGVkQXV0aG9yaXphdGlvblJlc3VsdCA9IHlpZWxkIHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHRDYWNoZS5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlZEF1dGhvcml6YXRpb25SZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IEV2YWx1YXRlIHdoZXRoZXIgdGhlcmUncyBhbnkgdGhyZWF0IHRvIG5vdCBgYXdhaXRpbmdgIHRoaXMgZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVBdXRob3JpemF0aW9uUmVzdWx0KGNhY2hlZEF1dGhvcml6YXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRDb25uZWN0aW9uRXJyb3IoKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UpIHx8ICdVbmtub3duIGVycm9yJywgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RpbmcgfHwgdGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5ydW5XaXRoR3VhcmQoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZWFkeVN0YXRlICE9PSBXYWxsZXRSZWFkeVN0YXRlLkluc3RhbGxlZCAmJiB0aGlzLl9yZWFkeVN0YXRlICE9PSBXYWxsZXRSZWFkeVN0YXRlLkxvYWRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXROb3RSZWFkeUVycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucGVyZm9ybUF1dGhvcml6YXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldENvbm5lY3Rpb25FcnJvcigoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZSkgfHwgJ1Vua25vd24gZXJyb3InLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwZXJmb3JtQXV0aG9yaXphdGlvbihzaWduSW5QYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlZEF1dGhvcml6YXRpb25SZXN1bHQgPSB5aWVsZCB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUuZ2V0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZEF1dGhvcml6YXRpb25SZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogRXZhbHVhdGUgd2hldGhlciB0aGVyZSdzIGFueSB0aHJlYXQgdG8gbm90IGBhd2FpdGluZ2AgdGhpcyBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQXV0aG9yaXphdGlvblJlc3VsdChjYWNoZWRBdXRob3JpemF0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZEF1dGhvcml6YXRpb25SZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl93YWxsZXQpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl93YWxsZXQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMudHJhbnNhY3QoKHdhbGxldCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl93YWxsZXQgPSB3YWxsZXQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF1dGhvcml6YXRpb25SZXN1bHQgPSB5aWVsZCB3YWxsZXQuYXV0aG9yaXplKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluOiB0aGlzLl9jaGFpbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aXR5OiB0aGlzLl9hcHBJZGVudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25faW5fcGF5bG9hZDogc2lnbkluUGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IEV2YWx1YXRlIHdoZXRoZXIgdGhlcmUncyBhbnkgdGhyZWF0IHRvIG5vdCBgYXdhaXRpbmdgIHRoaXMgZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUuc2V0KGF1dGhvcml6YXRpb25SZXN1bHQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVBdXRob3JpemF0aW9uUmVzdWx0KGF1dGhvcml6YXRpb25SZXN1bHQpLFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF1dGhvcml6YXRpb25SZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Q29ubmVjdGlvbkVycm9yKChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlKSB8fCAnVW5rbm93biBlcnJvcicsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlQXV0aG9yaXphdGlvblJlc3VsdChhdXRob3JpemF0aW9uUmVzdWx0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZFB1YmxpY0tleXNDaGFuZ2UgPSBcbiAgICAgICAgICAgIC8vIENhc2UgMTogV2Ugc3RhcnRlZCBmcm9tIGhhdmluZyBubyBhdXRob3JpemF0aW9uLlxuICAgICAgICAgICAgdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdCA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgLy8gQ2FzZSAyOiBUaGUgbnVtYmVyIG9mIGF1dGhvcml6ZWQgYWNjb3VudHMgY2hhbmdlZC5cbiAgICAgICAgICAgICAgICAoKF9hID0gdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY291bnRzLmxlbmd0aCkgIT09IGF1dGhvcml6YXRpb25SZXN1bHQuYWNjb3VudHMubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgLy8gQ2FzZSAzOiBUaGUgbmV3IGxpc3Qgb2YgYWRkcmVzc2VzIGlzbid0IGV4YWN0bHkgdGhlIHNhbWUgYXMgdGhlIG9sZCBsaXN0LCBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICAgICAgICAgICAgICB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0LmFjY291bnRzLnNvbWUoKGFjY291bnQsIGlpKSA9PiBhY2NvdW50LmFkZHJlc3MgIT09IGF1dGhvcml6YXRpb25SZXN1bHQuYWNjb3VudHNbaWldLmFkZHJlc3MpO1xuICAgICAgICAgICAgdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdCA9IGF1dGhvcml6YXRpb25SZXN1bHQ7XG4gICAgICAgICAgICB0aGlzLmRlY2xhcmVXYWxsZXRBc0luc3RhbGxlZCgpO1xuICAgICAgICAgICAgaWYgKGRpZFB1YmxpY0tleXNDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0U2VsZWN0ZWRBZGRyZXNzID0geWllbGQgdGhpcy5fYWRkcmVzc1NlbGVjdG9yLnNlbGVjdChhdXRob3JpemF0aW9uUmVzdWx0LmFjY291bnRzLm1hcCgoeyBhZGRyZXNzIH0pID0+IGFkZHJlc3MpKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dFNlbGVjdGVkQWRkcmVzcyAhPT0gdGhpcy5fc2VsZWN0ZWRBZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkQWRkcmVzcyA9IG5leHRTZWxlY3RlZEFkZHJlc3M7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wdWJsaWNLZXk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY29ubmVjdCcsIFxuICAgICAgICAgICAgICAgICAgICAvLyBIYXZpbmcganVzdCBzZXQgYHRoaXMuX3NlbGVjdGVkQWRkcmVzc2AsIGB0aGlzLnB1YmxpY0tleWAgaXMgZGVmaW5pdGVseSBub24tbnVsbFxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1YmxpY0tleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGVyZm9ybVJlYXV0aG9yaXphdGlvbih3YWxsZXQsIGF1dGhUb2tlbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhdXRob3JpemF0aW9uUmVzdWx0ID0geWllbGQgd2FsbGV0LmF1dGhvcml6ZSh7XG4gICAgICAgICAgICAgICAgICAgIGF1dGhfdG9rZW46IGF1dGhUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgaWRlbnRpdHk6IHRoaXMuX2FwcElkZW50aXR5LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IEV2YWx1YXRlIHdoZXRoZXIgdGhlcmUncyBhbnkgdGhyZWF0IHRvIG5vdCBgYXdhaXRpbmdgIHRoaXMgZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdENhY2hlLnNldChhdXRob3JpemF0aW9uUmVzdWx0KSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVBdXRob3JpemF0aW9uUmVzdWx0KGF1dGhvcml6YXRpb25SZXN1bHQpLFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0RGlzY29ubmVjdGVkRXJyb3IoKGUgaW5zdGFuY2VvZiBFcnJvciAmJiAoZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLm1lc3NhZ2UpKSB8fCAnVW5rbm93biBlcnJvcicsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gVE9ETzogZmlndXJlIG91dCB3aHkgdGhpcyBjYWxsIHRocm93cyBcIlR5cGVFcnJvcjogX2EudGVybWluYXRlU2Vzc2lvbiBpcyBub3QgYSBmdW5jdGlvblwiXG4gICAgICAgICAgICAvLyAgZXZlbiB0aG91Z2ggdGhlIHNlc3Npb24gdGVybWluYXRpb24gaXMgYWN0dWFsbHkgZXhlY3V0ZWQgKHdlYnNvY2tldCBjbG9zZXMpLiBcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5fd2FsbGV0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudGVybWluYXRlU2Vzc2lvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdENhY2hlLmNsZWFyKCk7IC8vIFRPRE86IEV2YWx1YXRlIHdoZXRoZXIgdGhlcmUncyBhbnkgdGhyZWF0IHRvIG5vdCBgYXdhaXRpbmdgIHRoaXMgZXhwcmVzc2lvblxuICAgICAgICAgICAgdGhpcy5fY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvbkdlbmVyYXRpb24rKztcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0O1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3B1YmxpY0tleTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zZWxlY3RlZEFkZHJlc3M7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fd2FsbGV0O1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdkaXNjb25uZWN0Jyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0cmFuc2FjdChjYWxsYmFjaykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB3YWxsZXRVcmlCYXNlID0gKF9hID0gdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLndhbGxldF91cmlfYmFzZTtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VDb25maWcgPSB3YWxsZXRVcmlCYXNlID8geyBiYXNlVXJpOiB3YWxsZXRVcmlCYXNlIH0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCByZW1vdGVDb25maWcgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJhc2VDb25maWcpLCB7IHJlbW90ZUhvc3RBdXRob3JpdHk6IHRoaXMuX2hvc3RBdXRob3JpdHkgfSk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Q29ubmVjdGlvbkdlbmVyYXRpb24gPSB0aGlzLl9jb25uZWN0aW9uR2VuZXJhdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IG1vZGFsID0gbmV3IEVtYmVkZGVkTW9kYWwoJ01XQSBRUicpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3dhbGxldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLl93YWxsZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGFzc29jaWF0aW9uVXJsLCByZXN1bHQ6IHByb21pc2UgfSA9IHlpZWxkIHRyYW5zYWN0UmVtb3RlKCh3YWxsZXQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgY2FsbGJhY2sod2FsbGV0KTtcbiAgICAgICAgICAgICAgICAgICAgbW9kYWwuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9KSwgcmVtb3RlQ29uZmlnKTtcbiAgICAgICAgICAgICAgICBtb2RhbC5pbml0KGFzc29jaWF0aW9uVXJsLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIG1vZGFsLm9wZW4oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgcHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgbW9kYWwuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29ubmVjdGlvbkdlbmVyYXRpb24gIT09IGN1cnJlbnRDb25uZWN0aW9uR2VuZXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBuZXcgUHJvbWlzZSgoKSA9PiB7IH0pOyAvLyBOZXZlciByZXNvbHZlLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgIGUubmFtZSA9PT0gJ1NvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcicgJiZcbiAgICAgICAgICAgICAgICAgICAgZS5jb2RlID09PSAnRVJST1JfV0FMTEVUX05PVF9GT1VORCcpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5fb25XYWxsZXROb3RGb3VuZCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzc2VydElzQXV0aG9yaXplZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0IHx8ICF0aGlzLl9zZWxlY3RlZEFkZHJlc3MpXG4gICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGF1dGhUb2tlbjogdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdC5hdXRoX3Rva2VuLFxuICAgICAgICAgICAgc2VsZWN0ZWRBZGRyZXNzOiB0aGlzLl9zZWxlY3RlZEFkZHJlc3MsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHBlcmZvcm1TaWduVHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBhdXRoVG9rZW4gfSA9IHRoaXMuYXNzZXJ0SXNBdXRob3JpemVkKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnRyYW5zYWN0KCh3YWxsZXQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5wZXJmb3JtUmVhdXRob3JpemF0aW9uKHdhbGxldCwgYXV0aFRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2lnbmVkVHJhbnNhY3Rpb25zID0geWllbGQgd2FsbGV0LnNpZ25UcmFuc2FjdGlvbnMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25zLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25lZFRyYW5zYWN0aW9ucztcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0U2lnblRyYW5zYWN0aW9uRXJyb3IoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2UsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgY29ubmVjdGlvbiwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucnVuV2l0aEd1YXJkKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGF1dGhUb2tlbiB9ID0gdGhpcy5hc3NlcnRJc0F1dGhvcml6ZWQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtaW5Db250ZXh0U2xvdCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5taW5Db250ZXh0U2xvdDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy50cmFuc2FjdCgod2FsbGV0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRUYXJnZXRDb21taXRtZW50KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0YXJnZXRDb21taXRtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29ubmVjdGlvbi5jb21taXRtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NvbmZpcm1lZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbmFsaXplZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Byb2Nlc3NlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRDb21taXRtZW50ID0gY29ubmVjdGlvbi5jb21taXRtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRDb21taXRtZW50ID0gJ2ZpbmFsaXplZCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0YXJnZXRQcmVmbGlnaHRDb21taXRtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZWZsaWdodENvbW1pdG1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29uZmlybWVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZmluYWxpemVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncHJvY2Vzc2VkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFByZWZsaWdodENvbW1pdG1lbnQgPSBvcHRpb25zLnByZWZsaWdodENvbW1pdG1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRQcmVmbGlnaHRDb21taXRtZW50ID0gdGFyZ2V0Q29tbWl0bWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0UHJlZmxpZ2h0Q29tbWl0bWVudCA9ICdmaW5hbGl6ZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVmbGlnaHRDb21taXRtZW50U2NvcmUgPSB0YXJnZXRQcmVmbGlnaHRDb21taXRtZW50ID09PSAnZmluYWxpemVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0YXJnZXRQcmVmbGlnaHRDb21taXRtZW50ID09PSAnY29uZmlybWVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0Q29tbWl0bWVudFNjb3JlID0gdGFyZ2V0Q29tbWl0bWVudCA9PT0gJ2ZpbmFsaXplZCcgPyAyIDogdGFyZ2V0Q29tbWl0bWVudCA9PT0gJ2NvbmZpcm1lZCcgPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlZmxpZ2h0Q29tbWl0bWVudFNjb3JlIDwgdGFyZ2V0Q29tbWl0bWVudFNjb3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGFyZ2V0UHJlZmxpZ2h0Q29tbWl0bWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRhcmdldENvbW1pdG1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbY2FwYWJpbGl0aWVzLCBfMSwgXzJdID0geWllbGQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhbGxldC5nZXRDYXBhYmlsaXRpZXMoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmZvcm1SZWF1dGhvcml6YXRpb24od2FsbGV0LCBhdXRoVG9rZW4pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVmVyc2lvbmVkVHJhbnNhY3Rpb24kMSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogVW5saWtlIHZlcnNpb25lZCB0cmFuc2FjdGlvbnMsIGxlZ2FjeSBgVHJhbnNhY3Rpb25gIG9iamVjdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBtYXkgbm90IGhhdmUgYW4gYXNzb2NpYXRlZCBgZmVlUGF5ZXJgIG9yIGByZWNlbnRCbG9ja2hhc2hgLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFRoaXMgY29kZSBleGlzdHMgdG8gcGF0Y2ggdGhlbSB1cCBpbiBjYXNlIHRoZXkgYXJlIG1pc3NpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5mZWVQYXllciB8fCAodHJhbnNhY3Rpb24uZmVlUGF5ZXIgPSAoX2EgPSB0aGlzLnB1YmxpY0tleSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBibG9ja2hhc2ggfSA9IHlpZWxkIGNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2toYXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1pdG1lbnQ6IGdldFRhcmdldENvbW1pdG1lbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCA9IGJsb2NraGFzaDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhcGFiaWxpdGllcy5zdXBwb3J0c19zaWduX2FuZF9zZW5kX3RyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZXMgPSB5aWVsZCB3YWxsZXQuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbnMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5Db250ZXh0U2xvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25zOiBbdHJhbnNhY3Rpb25dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWduYXR1cmVzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW3NpZ25lZFRyYW5zYWN0aW9uXSA9IHlpZWxkIHdhbGxldC5zaWduVHJhbnNhY3Rpb25zKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25zOiBbdHJhbnNhY3Rpb25dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1ZlcnNpb25lZFRyYW5zYWN0aW9uJDEoc2lnbmVkVHJhbnNhY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCBjb25uZWN0aW9uLnNlbmRUcmFuc2FjdGlvbihzaWduZWRUcmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkVHJhbnNhY3Rpb24gPSBzaWduZWRUcmFuc2FjdGlvbi5zZXJpYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGNvbm5lY3Rpb24uc2VuZFJhd1RyYW5zYWN0aW9uKHNlcmlhbGl6ZWRUcmFuc2FjdGlvbiwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBwcmVmbGlnaHRDb21taXRtZW50OiBnZXRUYXJnZXRDb21taXRtZW50KCkgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFNlbmRUcmFuc2FjdGlvbkVycm9yKGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5tZXNzYWdlLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5ydW5XaXRoR3VhcmQoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtzaWduZWRUcmFuc2FjdGlvbl0gPSB5aWVsZCB0aGlzLnBlcmZvcm1TaWduVHJhbnNhY3Rpb25zKFt0cmFuc2FjdGlvbl0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaWduZWRUcmFuc2FjdGlvbjtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25BbGxUcmFuc2FjdGlvbnModHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5ydW5XaXRoR3VhcmQoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9ucyA9IHlpZWxkIHRoaXMucGVyZm9ybVNpZ25UcmFuc2FjdGlvbnModHJhbnNhY3Rpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmVkVHJhbnNhY3Rpb25zO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnbk1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucnVuV2l0aEd1YXJkKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGF1dGhUb2tlbiwgc2VsZWN0ZWRBZGRyZXNzIH0gPSB0aGlzLmFzc2VydElzQXV0aG9yaXplZCgpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnRyYW5zYWN0KCh3YWxsZXQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucGVyZm9ybVJlYXV0aG9yaXphdGlvbih3YWxsZXQsIGF1dGhUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbc2lnbmVkTWVzc2FnZV0gPSB5aWVsZCB3YWxsZXQuc2lnbk1lc3NhZ2VzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXM6IFtzZWxlY3RlZEFkZHJlc3NdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWRzOiBbbWVzc2FnZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHNpZ25lZE1lc3NhZ2Uuc2xpY2UoLVNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25hdHVyZTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFNpZ25NZXNzYWdlRXJyb3IoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2UsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaWduSW4oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnJ1bldpdGhHdWFyZCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVhZHlTdGF0ZSAhPT0gV2FsbGV0UmVhZHlTdGF0ZS5JbnN0YWxsZWQgJiYgdGhpcy5fcmVhZHlTdGF0ZSAhPT0gV2FsbGV0UmVhZHlTdGF0ZS5Mb2FkYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Tm90UmVhZHlFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdXRob3JpemF0aW9uUmVzdWx0ID0geWllbGQgdGhpcy5wZXJmb3JtQXV0aG9yaXphdGlvbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGlucHV0KSwgeyBkb21haW46IChfYSA9IGlucHV0ID09PSBudWxsIHx8IGlucHV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnB1dC5kb21haW4pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHdpbmRvdy5sb2NhdGlvbi5ob3N0IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhdXRob3JpemF0aW9uUmVzdWx0LnNpZ25faW5fcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaWduIGluIGZhaWxlZCwgbm8gc2lnbiBpbiByZXN1bHQgcmV0dXJuZWQgYnkgd2FsbGV0XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25lZEluQWRkcmVzcyA9IGF1dGhvcml6YXRpb25SZXN1bHQuc2lnbl9pbl9yZXN1bHQuYWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2lnbmVkSW5BY2NvdW50ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoX2IgPSBhdXRob3JpemF0aW9uUmVzdWx0LmFjY291bnRzLmZpbmQoYWNjID0+IGFjYy5hZGRyZXNzID09IHNpZ25lZEluQWRkcmVzcykpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHNpZ25lZEluQWRkcmVzc1xuICAgICAgICAgICAgICAgICAgICB9KSwgeyBwdWJsaWNLZXk6IHRvVWludDhBcnJheSQxKHNpZ25lZEluQWRkcmVzcykgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50OiBzaWduZWRJbkFjY291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduZWRNZXNzYWdlOiB0b1VpbnQ4QXJyYXkkMShhdXRob3JpemF0aW9uUmVzdWx0LnNpZ25faW5fcmVzdWx0LnNpZ25lZF9tZXNzYWdlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogdG9VaW50OEFycmF5JDEoYXV0aG9yaXphdGlvblJlc3VsdC5zaWduX2luX3Jlc3VsdC5zaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRDb25uZWN0aW9uRXJyb3IoKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UpIHx8ICdVbmtub3duIGVycm9yJywgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRBZGRyZXNzU2VsZWN0b3IoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2VsZWN0KGFkZHJlc3Nlcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkcmVzc2VzWzBdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cblxuY29uc3QgQ0FDSEVfS0VZID0gJ1NvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJEZWZhdWx0QXV0aG9yaXphdGlvbkNhY2hlJztcbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRBdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUoKSB7XG4gICAgbGV0IHN0b3JhZ2U7XG4gICAgdHJ5IHtcbiAgICAgICAgc3RvcmFnZSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgIH1cbiAgICBjYXRjaCAoX2EpIHsgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNsZWFyKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oQ0FDSEVfS0VZKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShzdG9yYWdlLmdldEl0ZW0oQ0FDSEVfS0VZKSkgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBzZXQoYXV0aG9yaXphdGlvblJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlLnNldEl0ZW0oQ0FDSEVfS0VZLCBKU09OLnN0cmluZ2lmeShhdXRob3JpemF0aW9uUmVzdWx0KSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHsgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFdhbGxldE5vdEZvdW5kSGFuZGxlcihtb2JpbGVXYWxsZXRBZGFwdGVyKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKG1vYmlsZVdhbGxldEFkYXB0ZXIudXJsKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlRGVmYXVsdFdhbGxldE5vdEZvdW5kSGFuZGxlcigpIHtcbiAgICByZXR1cm4gZGVmYXVsdFdhbGxldE5vdEZvdW5kSGFuZGxlcjtcbn1cblxuZXhwb3J0IHsgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlciwgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlclJlbW90ZSwgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlclJlbW90ZVdhbGxldE5hbWUsIFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXROYW1lLCBjcmVhdGVEZWZhdWx0QWRkcmVzc1NlbGVjdG9yLCBjcmVhdGVEZWZhdWx0QXV0aG9yaXphdGlvblJlc3VsdENhY2hlLCBjcmVhdGVEZWZhdWx0V2FsbGV0Tm90Rm91bmRIYW5kbGVyIH07XG4iXSwibmFtZXMiOlsiQmFzZVNpZ25Jbk1lc3NhZ2VTaWduZXJXYWxsZXRBZGFwdGVyIiwiV2FsbGV0UmVhZHlTdGF0ZSIsIldhbGxldFB1YmxpY0tleUVycm9yIiwiV2FsbGV0Tm90UmVhZHlFcnJvciIsIldhbGxldENvbm5lY3Rpb25FcnJvciIsIldhbGxldERpc2Nvbm5lY3RlZEVycm9yIiwiV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IiLCJXYWxsZXRTaWduVHJhbnNhY3Rpb25FcnJvciIsIldhbGxldFNlbmRUcmFuc2FjdGlvbkVycm9yIiwiV2FsbGV0U2lnbk1lc3NhZ2VFcnJvciIsImlzVmVyc2lvbmVkVHJhbnNhY3Rpb24iLCJpc1ZlcnNpb25lZFRyYW5zYWN0aW9uJDEiLCJQdWJsaWNLZXkiLCJ0cmFuc2FjdCIsInRyYW5zYWN0UmVtb3RlIiwiUVJDb2RlIiwidG9VaW50OEFycmF5IiwidG9VaW50OEFycmF5JDEiLCJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJiYXNlNjRFbmNvZGVkQnl0ZUFycmF5IiwiVWludDhBcnJheSIsIndpbmRvdyIsImF0b2IiLCJzcGxpdCIsIm1hcCIsImMiLCJjaGFyQ29kZUF0IiwiZ2V0SXNTdXBwb3J0ZWQkMSIsImlzU2VjdXJlQ29udGV4dCIsImRvY3VtZW50IiwidGVzdCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsIlNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXROYW1lIiwiU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUyQxIiwiZ2V0UHVibGljS2V5RnJvbUFkZHJlc3MkMSIsImFkZHJlc3MiLCJwdWJsaWNLZXlCeXRlQXJyYXkiLCJ0cmFuc2FjdGlvbiIsImNsdXN0ZXJUb0NoYWluSWQiLCJjbHVzdGVyIiwiU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlciIsImNvbnN0cnVjdG9yIiwiY29uZmlnIiwiX2EiLCJzdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25zIiwiU2V0IiwibmFtZSIsInVybCIsImljb24iLCJfY29ubmVjdGluZyIsIl9jb25uZWN0aW9uR2VuZXJhdGlvbiIsIl9yZWFkeVN0YXRlIiwiTG9hZGFibGUiLCJVbnN1cHBvcnRlZCIsIl9hdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUiLCJhdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUiLCJfYWRkcmVzc1NlbGVjdG9yIiwiYWRkcmVzc1NlbGVjdG9yIiwiX2FwcElkZW50aXR5IiwiYXBwSWRlbnRpdHkiLCJfY2hhaW4iLCJjaGFpbiIsIl9ob3N0QXV0aG9yaXR5IiwicmVtb3RlSG9zdEF1dGhvcml0eSIsIl9vbldhbGxldE5vdEZvdW5kIiwib25XYWxsZXROb3RGb3VuZCIsImdldCIsImF1dGhvcml6YXRpb25SZXN1bHQiLCJkZWNsYXJlV2FsbGV0QXNJbnN0YWxsZWQiLCJwdWJsaWNLZXkiLCJfcHVibGljS2V5IiwiX3NlbGVjdGVkQWRkcmVzcyIsIkVycm9yIiwibWVzc2FnZSIsImNvbm5lY3RlZCIsIl9hdXRob3JpemF0aW9uUmVzdWx0IiwiY29ubmVjdGluZyIsInJlYWR5U3RhdGUiLCJJbnN0YWxsZWQiLCJlbWl0IiwicnVuV2l0aEd1YXJkIiwiY2FsbGJhY2siLCJhdXRvQ29ubmVjdF9ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiYXV0b0Nvbm5lY3QiLCJjYWNoZWRBdXRob3JpemF0aW9uUmVzdWx0IiwiaGFuZGxlQXV0aG9yaXphdGlvblJlc3VsdCIsImNvbm5lY3QiLCJwZXJmb3JtQXV0aG9yaXphdGlvbiIsInNpZ25JblBheWxvYWQiLCJ3YWxsZXQiLCJhdXRob3JpemUiLCJpZGVudGl0eSIsInNpZ25faW5fcGF5bG9hZCIsImFsbCIsInNldCIsImRpZFB1YmxpY0tleXNDaGFuZ2UiLCJhY2NvdW50cyIsImxlbmd0aCIsInNvbWUiLCJhY2NvdW50IiwiaWkiLCJuZXh0U2VsZWN0ZWRBZGRyZXNzIiwic2VsZWN0IiwicGVyZm9ybVJlYXV0aG9yaXphdGlvbiIsImF1dGhUb2tlbiIsImF1dGhfdG9rZW4iLCJkaXNjb25uZWN0IiwiY2xlYXIiLCJ3YWxsZXRVcmlCYXNlIiwid2FsbGV0X3VyaV9iYXNlIiwiYmFzZVVyaSIsInVuZGVmaW5lZCIsInJlbW90ZUNvbmZpZyIsImN1cnJlbnRDb25uZWN0aW9uR2VuZXJhdGlvbiIsIk9iamVjdCIsImFzc2lnbiIsImNvZGUiLCJhc3NlcnRJc0F1dGhvcml6ZWQiLCJzZWxlY3RlZEFkZHJlc3MiLCJwZXJmb3JtU2lnblRyYW5zYWN0aW9ucyIsInRyYW5zYWN0aW9ucyIsInNpZ25lZFRyYW5zYWN0aW9ucyIsInNpZ25UcmFuc2FjdGlvbnMiLCJlcnJvciIsInNlbmRUcmFuc2FjdGlvbiIsImNvbm5lY3Rpb24iLCJvcHRpb25zIiwibWluQ29udGV4dFNsb3QiLCJnZXRUYXJnZXRDb21taXRtZW50IiwidGFyZ2V0Q29tbWl0bWVudCIsImNvbW1pdG1lbnQiLCJ0YXJnZXRQcmVmbGlnaHRDb21taXRtZW50IiwicHJlZmxpZ2h0Q29tbWl0bWVudCIsInByZWZsaWdodENvbW1pdG1lbnRTY29yZSIsInRhcmdldENvbW1pdG1lbnRTY29yZSIsImNhcGFiaWxpdGllcyIsIl8xIiwiXzIiLCJnZXRDYXBhYmlsaXRpZXMiLCJmZWVQYXllciIsInJlY2VudEJsb2NraGFzaCIsImJsb2NraGFzaCIsImdldExhdGVzdEJsb2NraGFzaCIsInN1cHBvcnRzX3NpZ25fYW5kX3NlbmRfdHJhbnNhY3Rpb25zIiwic2lnbmF0dXJlcyIsInNpZ25BbmRTZW5kVHJhbnNhY3Rpb25zIiwic2lnbmVkVHJhbnNhY3Rpb24iLCJzZXJpYWxpemVkVHJhbnNhY3Rpb24iLCJzZXJpYWxpemUiLCJzZW5kUmF3VHJhbnNhY3Rpb24iLCJzaWduVHJhbnNhY3Rpb24iLCJzaWduQWxsVHJhbnNhY3Rpb25zIiwic2lnbk1lc3NhZ2UiLCJzaWduZWRNZXNzYWdlIiwic2lnbk1lc3NhZ2VzIiwiYWRkcmVzc2VzIiwicGF5bG9hZHMiLCJzaWduYXR1cmUiLCJzbGljZSIsInNpZ25JbiIsImlucHV0IiwiX2IiLCJkb21haW4iLCJsb2NhdGlvbiIsImhvc3QiLCJzaWduX2luX3Jlc3VsdCIsInNpZ25lZEluQWRkcmVzcyIsInNpZ25lZEluQWNjb3VudCIsImZpbmQiLCJhY2MiLCJzaWduZWRfbWVzc2FnZSIsIkJsdWV0b290aEh0bWwiLCJRUkNvZGVIdG1sIiwiY3NzIiwiRW1iZWRkZWRNb2RhbCIsInRpdGxlIiwiX3Jvb3QiLCJfdGl0bGUiLCJpbml0IiwiYmluZCIsImluamVjdFFSQ29kZUhUTUwiLCJpbmplY3RCbHVldG9vdGhIVE1MIiwib3BlbiIsImNsb3NlIiwiZ2V0RWxlbWVudEJ5SWQiLCJxckNvZGUiLCJjb25zb2xlIiwibG9nIiwiaW5qZWN0U3R5bGVzIiwic2V0Q29ubmVjdGlvblN0YXR1cyIsInN0YXR1cyIsInN0YXR1c2VzIiwiZm9yRWFjaCIsInMiLCJlbCIsInF1ZXJ5U2VsZWN0b3IiLCJIVE1MRWxlbWVudCIsInN0eWxlIiwiZGlzcGxheSIsInN0eWxlRWxlbWVudCIsImNyZWF0ZUVsZW1lbnQiLCJpZCIsInRleHRDb250ZW50IiwiaGVhZCIsImFwcGVuZENoaWxkIiwicG9wdWxhdGVRUkNvZGUiLCJxclVybCIsInFyY29kZUNvbnRhaW5lciIsInFyQ29kZUVsZW1lbnQiLCJ0b0NhbnZhcyIsIndpZHRoIiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJyZXBsYWNlQ2hpbGQiLCJjbGFzc05hbWUiLCJpbm5lckhUTUwiLCJib2R5IiwiYXR0YWNoRXZlbnRMaXN0ZW5lcnMiLCJjbG9zZUJ0biIsImNhbmNlbEJ0biIsImNvbm5lY3RCdG4iLCJhZGRFdmVudExpc3RlbmVyIiwiZGVidWciLCJzZXRUaW1lb3V0IiwiU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlclJlbW90ZVdhbGxldE5hbWUiLCJTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTIiwiZ2V0UHVibGljS2V5RnJvbUFkZHJlc3MiLCJpc01vYmlsZU9wZXJhdGluZ1N5c3RlbSIsIk1TU3RyZWFtIiwiZ2V0SXNTdXBwb3J0ZWQiLCJTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyUmVtb3RlIiwiX3dhbGxldCIsInRlcm1pbmF0ZVNlc3Npb24iLCJiYXNlQ29uZmlnIiwibW9kYWwiLCJhc3NvY2lhdGlvblVybCIsInByb21pc2UiLCJ0b1N0cmluZyIsImNyZWF0ZURlZmF1bHRBZGRyZXNzU2VsZWN0b3IiLCJDQUNIRV9LRVkiLCJjcmVhdGVEZWZhdWx0QXV0aG9yaXphdGlvblJlc3VsdENhY2hlIiwic3RvcmFnZSIsImxvY2FsU3RvcmFnZSIsInJlbW92ZUl0ZW0iLCJKU09OIiwicGFyc2UiLCJnZXRJdGVtIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsImRlZmF1bHRXYWxsZXROb3RGb3VuZEhhbmRsZXIiLCJtb2JpbGVXYWxsZXRBZGFwdGVyIiwiY3JlYXRlRGVmYXVsdFdhbGxldE5vdEZvdW5kSGFuZGxlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana-mobile/wallet-adapter-mobile/lib/esm/index.js\n");

/***/ })

};
;